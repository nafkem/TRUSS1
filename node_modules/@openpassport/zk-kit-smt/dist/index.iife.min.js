/**
 * @module @openpassport/zk-kit-smt
 * @version 0.0.1
 * @file Sparse Merkle tree implementation in TypeScript.
 * @copyright Cedoor 2024
 * @license MIT
 * @see [Github]{@link https://www.openpassport.app/}
*/
var openpassportZkKitSmt=function(t){"use strict";function e(t){let e=Number(`0x${t[0]}`).toString(2);for(let r=1;r<t.length;r+=1)e+=Number(`0x${t[r]}`).toString(2).padStart(4,"0");return e}function r(t){return("bigint"==typeof t?t.toString(2):e(t)).padStart(256,"0").split("").reverse().map(Number)}function s(t){for(let e=t.length-1;e>=0;e-=1)if(0!==Number(`0x${t[e]}`))return e;return-1}function i(t,e){const r=t.length<e.length?t:e;for(let s=0;s<r.length;s+=1)if(t[s]!==e[s])return r.slice(0,s);return r.slice()}function n(t){return"string"==typeof t&&/^[0-9A-Fa-f]{1,64}$/.test(t)}return t.SMT=class{constructor(t,e=!1){if(e){if("function"!=typeof BigInt)throw new Error("Big numbers are not supported");if("bigint"!=typeof t([BigInt(1),BigInt(1)]))throw new Error("The hash function must return a big number")}else if(!n(t(["1","1"])))throw new Error("The hash function must return a hexadecimal");this.hash=t,this.bigNumbers=e,this.zeroNode=e?BigInt(0):"0",this.entryMark=e?BigInt(1):"1",this.nodes=new Map,this.root=this.zeroNode}get(t){this.checkParameterType(t);const{entry:e}=this.retrieveEntry(t);return e[1]}add(t,e){this.checkParameterType(t),this.checkParameterType(e);const{entry:s,matchingEntry:i,siblings:n}=this.retrieveEntry(t);if(void 0!==s[1])throw new Error(`Key "${t}" already exists`);const o=r(t),h=i?this.hash(i):this.zeroNode;if(n.length>0&&this.deleteOldNodes(h,o,n),i){const t=r(i[0]);for(let e=n.length;t[e]===o[e];e+=1)n.push(this.zeroNode);n.push(h)}const a=this.hash([t,e,this.entryMark]);this.nodes.set(a,[t,e,this.entryMark]),this.root=this.addNewNodes(a,o,n)}update(t,e){this.checkParameterType(t),this.checkParameterType(e);const{entry:s,siblings:i}=this.retrieveEntry(t);if(void 0===s[1])throw new Error(`Key "${t}" does not exist`);const n=r(t),o=this.hash(s);this.nodes.delete(o),this.deleteOldNodes(o,n,i);const h=this.hash([t,e,this.entryMark]);this.nodes.set(h,[t,e,this.entryMark]),this.root=this.addNewNodes(h,n,i)}delete(t){this.checkParameterType(t);const{entry:e,siblings:i}=this.retrieveEntry(t);if(void 0===e[1])throw new Error(`Key "${t}" does not exist`);const n=r(t),o=this.hash(e);if(this.nodes.delete(o),this.root=this.zeroNode,i.length>0)if(this.deleteOldNodes(o,n,i),this.isLeaf(i[i.length-1])){const t=i.pop(),e=s(i);this.root=this.addNewNodes(t,n,i,e)}else this.root=this.addNewNodes(this.zeroNode,n,i)}createProof(t){this.checkParameterType(t);const{entry:e,matchingEntry:r,siblings:s}=this.retrieveEntry(t);return{entry:e,matchingEntry:r,siblings:s,root:this.root,membership:!!e[1]}}verifyProof(t){if(!t.matchingEntry){const e=r(t.entry[0]),s=void 0!==t.entry[1]?this.hash(t.entry):this.zeroNode;return this.calculateRoot(s,e,t.siblings)===t.root}const e=r(t.matchingEntry[0]),s=this.hash(t.matchingEntry);if(this.calculateRoot(s,e,t.siblings)===t.root){const s=i(r(t.entry[0]),e);return t.siblings.length<=s.length}return!1}export(){const t={};return t.root=[this.root.toString()],this.nodes.forEach(((e,r)=>{t[r.toString()]=e.map((t=>t.toString()))})),JSON.stringify(t,null,2)}import(t){const e=JSON.parse(t),r=new Map;for(const[t,s]of Object.entries(e))if("root"===t)this.root=this.bigNumbers?BigInt(s[0]):s[0];else{const e=this.bigNumbers?BigInt(t):t;if(this.bigNumbers){const t=s.map((t=>BigInt(t)));r.set(e,t)}else r.set(e,s)}this.nodes=r}retrieveEntry(t){const e=r(t),s=[];for(let r=0,i=this.root;i!==this.zeroNode;r+=1){const n=this.nodes.get(i),o=e[r];if(n[2])return n[0]===t?{entry:n,siblings:s}:{entry:[t],matchingEntry:n,siblings:s};i=n[o],s.push(n[Number(!o)])}return{entry:[t],siblings:s}}calculateRoot(t,e,r){for(let s=r.length-1;s>=0;s-=1){const i=e[s]?[r[s],t]:[t,r[s]];t=this.hash(i)}return t}addNewNodes(t,e,r,s=r.length-1){for(;s>=0;s-=1){const i=e[s]?[r[s],t]:[t,r[s]];t=this.hash(i),this.nodes.set(t,i)}return t}deleteOldNodes(t,e,r){for(let s=r.length-1;s>=0;s-=1){const i=e[s]?[r[s],t]:[t,r[s]];t=this.hash(i),this.nodes.delete(t)}}isLeaf(t){const e=this.nodes.get(t);return!(!e||!e[2])}checkParameterType(t){if(this.bigNumbers&&"bigint"!=typeof t)throw new Error(`Parameter ${t} must be a big number`);if(!this.bigNumbers&&!n(t))throw new Error(`Parameter ${t} must be a hexadecimal`)}},t.checkHex=n,t.getFirstCommonElements=i,t.getIndexOfLastNonZeroElement=s,t.hexToBin=e,t.keyToPath=r,t}({});

import "./chunk-N4W5OTIS.js";
import {
  require_crypto_browserify
} from "./chunk-ST37V2NI.js";
import "./chunk-MUOHFX6U.js";
import {
  require_buffer
} from "./chunk-4MRMGVXR.js";
import {
  require_react
} from "./chunk-DRWLMN53.js";
import {
  __commonJS,
  __export,
  __toESM
} from "./chunk-G3PMV62Z.js";

// node_modules/lottie-web/build/player/lottie.js
var require_lottie = __commonJS({
  "node_modules/lottie-web/build/player/lottie.js"(exports, module) {
    typeof document !== "undefined" && typeof navigator !== "undefined" && function(global2, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2.lottie = factory());
    }(exports, function() {
      "use strict";
      var svgNS = "http://www.w3.org/2000/svg";
      var locationHref = "";
      var _useWebWorker = false;
      var initialDefaultFrame = -999999;
      var setWebWorker = function setWebWorker2(flag) {
        _useWebWorker = !!flag;
      };
      var getWebWorker = function getWebWorker2() {
        return _useWebWorker;
      };
      var setLocationHref = function setLocationHref2(value3) {
        locationHref = value3;
      };
      var getLocationHref = function getLocationHref2() {
        return locationHref;
      };
      function createTag(type) {
        return document.createElement(type);
      }
      function extendPrototype(sources, destination) {
        var i;
        var len = sources.length;
        var sourcePrototype;
        for (i = 0; i < len; i += 1) {
          sourcePrototype = sources[i].prototype;
          for (var attr in sourcePrototype) {
            if (Object.prototype.hasOwnProperty.call(sourcePrototype, attr)) destination.prototype[attr] = sourcePrototype[attr];
          }
        }
      }
      function getDescriptor(object, prop) {
        return Object.getOwnPropertyDescriptor(object, prop);
      }
      function createProxyFunction(prototype) {
        function ProxyFunction() {
        }
        ProxyFunction.prototype = prototype;
        return ProxyFunction;
      }
      var audioControllerFactory = function() {
        function AudioController(audioFactory) {
          this.audios = [];
          this.audioFactory = audioFactory;
          this._volume = 1;
          this._isMuted = false;
        }
        AudioController.prototype = {
          addAudio: function addAudio(audio) {
            this.audios.push(audio);
          },
          pause: function pause() {
            var i;
            var len = this.audios.length;
            for (i = 0; i < len; i += 1) {
              this.audios[i].pause();
            }
          },
          resume: function resume() {
            var i;
            var len = this.audios.length;
            for (i = 0; i < len; i += 1) {
              this.audios[i].resume();
            }
          },
          setRate: function setRate(rateValue) {
            var i;
            var len = this.audios.length;
            for (i = 0; i < len; i += 1) {
              this.audios[i].setRate(rateValue);
            }
          },
          createAudio: function createAudio(assetPath) {
            if (this.audioFactory) {
              return this.audioFactory(assetPath);
            }
            if (window.Howl) {
              return new window.Howl({
                src: [assetPath]
              });
            }
            return {
              isPlaying: false,
              play: function play() {
                this.isPlaying = true;
              },
              seek: function seek() {
                this.isPlaying = false;
              },
              playing: function playing() {
              },
              rate: function rate() {
              },
              setVolume: function setVolume() {
              }
            };
          },
          setAudioFactory: function setAudioFactory(audioFactory) {
            this.audioFactory = audioFactory;
          },
          setVolume: function setVolume(value3) {
            this._volume = value3;
            this._updateVolume();
          },
          mute: function mute() {
            this._isMuted = true;
            this._updateVolume();
          },
          unmute: function unmute() {
            this._isMuted = false;
            this._updateVolume();
          },
          getVolume: function getVolume() {
            return this._volume;
          },
          _updateVolume: function _updateVolume() {
            var i;
            var len = this.audios.length;
            for (i = 0; i < len; i += 1) {
              this.audios[i].volume(this._volume * (this._isMuted ? 0 : 1));
            }
          }
        };
        return function() {
          return new AudioController();
        };
      }();
      var createTypedArray = function() {
        function createRegularArray(type, len) {
          var i = 0;
          var arr = [];
          var value3;
          switch (type) {
            case "int16":
            case "uint8c":
              value3 = 1;
              break;
            default:
              value3 = 1.1;
              break;
          }
          for (i = 0; i < len; i += 1) {
            arr.push(value3);
          }
          return arr;
        }
        function createTypedArrayFactory(type, len) {
          if (type === "float32") {
            return new Float32Array(len);
          }
          if (type === "int16") {
            return new Int16Array(len);
          }
          if (type === "uint8c") {
            return new Uint8ClampedArray(len);
          }
          return createRegularArray(type, len);
        }
        if (typeof Uint8ClampedArray === "function" && typeof Float32Array === "function") {
          return createTypedArrayFactory;
        }
        return createRegularArray;
      }();
      function createSizedArray(len) {
        return Array.apply(null, {
          length: len
        });
      }
      function _typeof$6(o) {
        "@babel/helpers - typeof";
        return _typeof$6 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
          return typeof o2;
        } : function(o2) {
          return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
        }, _typeof$6(o);
      }
      var subframeEnabled = true;
      var expressionsPlugin = null;
      var expressionsInterfaces = null;
      var idPrefix$1 = "";
      var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
      var _shouldRoundValues = false;
      var bmPow = Math.pow;
      var bmSqrt = Math.sqrt;
      var bmFloor = Math.floor;
      var bmMax = Math.max;
      var bmMin = Math.min;
      var BMMath = {};
      (function() {
        var propertyNames = ["abs", "acos", "acosh", "asin", "asinh", "atan", "atanh", "atan2", "ceil", "cbrt", "expm1", "clz32", "cos", "cosh", "exp", "floor", "fround", "hypot", "imul", "log", "log1p", "log2", "log10", "max", "min", "pow", "random", "round", "sign", "sin", "sinh", "sqrt", "tan", "tanh", "trunc", "E", "LN10", "LN2", "LOG10E", "LOG2E", "PI", "SQRT1_2", "SQRT2"];
        var i;
        var len = propertyNames.length;
        for (i = 0; i < len; i += 1) {
          BMMath[propertyNames[i]] = Math[propertyNames[i]];
        }
      })();
      function ProjectInterface$1() {
        return {};
      }
      BMMath.random = Math.random;
      BMMath.abs = function(val2) {
        var tOfVal = _typeof$6(val2);
        if (tOfVal === "object" && val2.length) {
          var absArr = createSizedArray(val2.length);
          var i;
          var len = val2.length;
          for (i = 0; i < len; i += 1) {
            absArr[i] = Math.abs(val2[i]);
          }
          return absArr;
        }
        return Math.abs(val2);
      };
      var defaultCurveSegments = 150;
      var degToRads = Math.PI / 180;
      var roundCorner = 0.5519;
      function roundValues(flag) {
        _shouldRoundValues = !!flag;
      }
      function bmRnd(value3) {
        if (_shouldRoundValues) {
          return Math.round(value3);
        }
        return value3;
      }
      function styleDiv(element) {
        element.style.position = "absolute";
        element.style.top = 0;
        element.style.left = 0;
        element.style.display = "block";
        element.style.transformOrigin = "0 0";
        element.style.webkitTransformOrigin = "0 0";
        element.style.backfaceVisibility = "visible";
        element.style.webkitBackfaceVisibility = "visible";
        element.style.transformStyle = "preserve-3d";
        element.style.webkitTransformStyle = "preserve-3d";
        element.style.mozTransformStyle = "preserve-3d";
      }
      function BMEnterFrameEvent(type, currentTime, totalTime, frameMultiplier) {
        this.type = type;
        this.currentTime = currentTime;
        this.totalTime = totalTime;
        this.direction = frameMultiplier < 0 ? -1 : 1;
      }
      function BMCompleteEvent(type, frameMultiplier) {
        this.type = type;
        this.direction = frameMultiplier < 0 ? -1 : 1;
      }
      function BMCompleteLoopEvent(type, totalLoops, currentLoop, frameMultiplier) {
        this.type = type;
        this.currentLoop = currentLoop;
        this.totalLoops = totalLoops;
        this.direction = frameMultiplier < 0 ? -1 : 1;
      }
      function BMSegmentStartEvent(type, firstFrame, totalFrames) {
        this.type = type;
        this.firstFrame = firstFrame;
        this.totalFrames = totalFrames;
      }
      function BMDestroyEvent(type, target) {
        this.type = type;
        this.target = target;
      }
      function BMRenderFrameErrorEvent(nativeError, currentTime) {
        this.type = "renderFrameError";
        this.nativeError = nativeError;
        this.currentTime = currentTime;
      }
      function BMConfigErrorEvent(nativeError) {
        this.type = "configError";
        this.nativeError = nativeError;
      }
      function BMAnimationConfigErrorEvent(type, nativeError) {
        this.type = type;
        this.nativeError = nativeError;
      }
      var createElementID = /* @__PURE__ */ function() {
        var _count = 0;
        return function createID() {
          _count += 1;
          return idPrefix$1 + "__lottie_element_" + _count;
        };
      }();
      function HSVtoRGB(h, s, v) {
        var r;
        var g;
        var b;
        var i;
        var f3;
        var p;
        var q;
        var t;
        i = Math.floor(h * 6);
        f3 = h * 6 - i;
        p = v * (1 - s);
        q = v * (1 - f3 * s);
        t = v * (1 - (1 - f3) * s);
        switch (i % 6) {
          case 0:
            r = v;
            g = t;
            b = p;
            break;
          case 1:
            r = q;
            g = v;
            b = p;
            break;
          case 2:
            r = p;
            g = v;
            b = t;
            break;
          case 3:
            r = p;
            g = q;
            b = v;
            break;
          case 4:
            r = t;
            g = p;
            b = v;
            break;
          case 5:
            r = v;
            g = p;
            b = q;
            break;
          default:
            break;
        }
        return [r, g, b];
      }
      function RGBtoHSV(r, g, b) {
        var max = Math.max(r, g, b);
        var min = Math.min(r, g, b);
        var d = max - min;
        var h;
        var s = max === 0 ? 0 : d / max;
        var v = max / 255;
        switch (max) {
          case min:
            h = 0;
            break;
          case r:
            h = g - b + d * (g < b ? 6 : 0);
            h /= 6 * d;
            break;
          case g:
            h = b - r + d * 2;
            h /= 6 * d;
            break;
          case b:
            h = r - g + d * 4;
            h /= 6 * d;
            break;
          default:
            break;
        }
        return [h, s, v];
      }
      function addSaturationToRGB(color, offset) {
        var hsv = RGBtoHSV(color[0] * 255, color[1] * 255, color[2] * 255);
        hsv[1] += offset;
        if (hsv[1] > 1) {
          hsv[1] = 1;
        } else if (hsv[1] <= 0) {
          hsv[1] = 0;
        }
        return HSVtoRGB(hsv[0], hsv[1], hsv[2]);
      }
      function addBrightnessToRGB(color, offset) {
        var hsv = RGBtoHSV(color[0] * 255, color[1] * 255, color[2] * 255);
        hsv[2] += offset;
        if (hsv[2] > 1) {
          hsv[2] = 1;
        } else if (hsv[2] < 0) {
          hsv[2] = 0;
        }
        return HSVtoRGB(hsv[0], hsv[1], hsv[2]);
      }
      function addHueToRGB(color, offset) {
        var hsv = RGBtoHSV(color[0] * 255, color[1] * 255, color[2] * 255);
        hsv[0] += offset / 360;
        if (hsv[0] > 1) {
          hsv[0] -= 1;
        } else if (hsv[0] < 0) {
          hsv[0] += 1;
        }
        return HSVtoRGB(hsv[0], hsv[1], hsv[2]);
      }
      var rgbToHex = function() {
        var colorMap = [];
        var i;
        var hex;
        for (i = 0; i < 256; i += 1) {
          hex = i.toString(16);
          colorMap[i] = hex.length === 1 ? "0" + hex : hex;
        }
        return function(r, g, b) {
          if (r < 0) {
            r = 0;
          }
          if (g < 0) {
            g = 0;
          }
          if (b < 0) {
            b = 0;
          }
          return "#" + colorMap[r] + colorMap[g] + colorMap[b];
        };
      }();
      var setSubframeEnabled = function setSubframeEnabled2(flag) {
        subframeEnabled = !!flag;
      };
      var getSubframeEnabled = function getSubframeEnabled2() {
        return subframeEnabled;
      };
      var setExpressionsPlugin = function setExpressionsPlugin2(value3) {
        expressionsPlugin = value3;
      };
      var getExpressionsPlugin = function getExpressionsPlugin2() {
        return expressionsPlugin;
      };
      var setExpressionInterfaces = function setExpressionInterfaces2(value3) {
        expressionsInterfaces = value3;
      };
      var getExpressionInterfaces = function getExpressionInterfaces2() {
        return expressionsInterfaces;
      };
      var setDefaultCurveSegments = function setDefaultCurveSegments2(value3) {
        defaultCurveSegments = value3;
      };
      var getDefaultCurveSegments = function getDefaultCurveSegments2() {
        return defaultCurveSegments;
      };
      var setIdPrefix = function setIdPrefix2(value3) {
        idPrefix$1 = value3;
      };
      var getIdPrefix = function getIdPrefix2() {
        return idPrefix$1;
      };
      function createNS(type) {
        return document.createElementNS(svgNS, type);
      }
      function _typeof$5(o) {
        "@babel/helpers - typeof";
        return _typeof$5 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
          return typeof o2;
        } : function(o2) {
          return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
        }, _typeof$5(o);
      }
      var dataManager = /* @__PURE__ */ function() {
        var _counterId = 1;
        var processes = [];
        var workerFn;
        var workerInstance;
        var workerProxy = {
          onmessage: function onmessage() {
          },
          postMessage: function postMessage(path) {
            workerFn({
              data: path
            });
          }
        };
        var _workerSelf = {
          postMessage: function postMessage(data2) {
            workerProxy.onmessage({
              data: data2
            });
          }
        };
        function createWorker(fn) {
          if (window.Worker && window.Blob && getWebWorker()) {
            var blob = new Blob(["var _workerSelf = self; self.onmessage = ", fn.toString()], {
              type: "text/javascript"
            });
            var url2 = URL.createObjectURL(blob);
            return new Worker(url2);
          }
          workerFn = fn;
          return workerProxy;
        }
        function setupWorker() {
          if (!workerInstance) {
            workerInstance = createWorker(function workerStart(e) {
              function dataFunctionManager() {
                function completeLayers(layers, comps) {
                  var layerData;
                  var i;
                  var len = layers.length;
                  var j;
                  var jLen;
                  var k;
                  var kLen;
                  for (i = 0; i < len; i += 1) {
                    layerData = layers[i];
                    if ("ks" in layerData && !layerData.completed) {
                      layerData.completed = true;
                      if (layerData.hasMask) {
                        var maskProps = layerData.masksProperties;
                        jLen = maskProps.length;
                        for (j = 0; j < jLen; j += 1) {
                          if (maskProps[j].pt.k.i) {
                            convertPathsToAbsoluteValues(maskProps[j].pt.k);
                          } else {
                            kLen = maskProps[j].pt.k.length;
                            for (k = 0; k < kLen; k += 1) {
                              if (maskProps[j].pt.k[k].s) {
                                convertPathsToAbsoluteValues(maskProps[j].pt.k[k].s[0]);
                              }
                              if (maskProps[j].pt.k[k].e) {
                                convertPathsToAbsoluteValues(maskProps[j].pt.k[k].e[0]);
                              }
                            }
                          }
                        }
                      }
                      if (layerData.ty === 0) {
                        layerData.layers = findCompLayers(layerData.refId, comps);
                        completeLayers(layerData.layers, comps);
                      } else if (layerData.ty === 4) {
                        completeShapes(layerData.shapes);
                      } else if (layerData.ty === 5) {
                        completeText(layerData);
                      }
                    }
                  }
                }
                function completeChars(chars2, assets) {
                  if (chars2) {
                    var i = 0;
                    var len = chars2.length;
                    for (i = 0; i < len; i += 1) {
                      if (chars2[i].t === 1) {
                        chars2[i].data.layers = findCompLayers(chars2[i].data.refId, assets);
                        completeLayers(chars2[i].data.layers, assets);
                      }
                    }
                  }
                }
                function findComp(id, comps) {
                  var i = 0;
                  var len = comps.length;
                  while (i < len) {
                    if (comps[i].id === id) {
                      return comps[i];
                    }
                    i += 1;
                  }
                  return null;
                }
                function findCompLayers(id, comps) {
                  var comp2 = findComp(id, comps);
                  if (comp2) {
                    if (!comp2.layers.__used) {
                      comp2.layers.__used = true;
                      return comp2.layers;
                    }
                    return JSON.parse(JSON.stringify(comp2.layers));
                  }
                  return null;
                }
                function completeShapes(arr) {
                  var i;
                  var len = arr.length;
                  var j;
                  var jLen;
                  for (i = len - 1; i >= 0; i -= 1) {
                    if (arr[i].ty === "sh") {
                      if (arr[i].ks.k.i) {
                        convertPathsToAbsoluteValues(arr[i].ks.k);
                      } else {
                        jLen = arr[i].ks.k.length;
                        for (j = 0; j < jLen; j += 1) {
                          if (arr[i].ks.k[j].s) {
                            convertPathsToAbsoluteValues(arr[i].ks.k[j].s[0]);
                          }
                          if (arr[i].ks.k[j].e) {
                            convertPathsToAbsoluteValues(arr[i].ks.k[j].e[0]);
                          }
                        }
                      }
                    } else if (arr[i].ty === "gr") {
                      completeShapes(arr[i].it);
                    }
                  }
                }
                function convertPathsToAbsoluteValues(path) {
                  var i;
                  var len = path.i.length;
                  for (i = 0; i < len; i += 1) {
                    path.i[i][0] += path.v[i][0];
                    path.i[i][1] += path.v[i][1];
                    path.o[i][0] += path.v[i][0];
                    path.o[i][1] += path.v[i][1];
                  }
                }
                function checkVersion(minimum, animVersionString) {
                  var animVersion = animVersionString ? animVersionString.split(".") : [100, 100, 100];
                  if (minimum[0] > animVersion[0]) {
                    return true;
                  }
                  if (animVersion[0] > minimum[0]) {
                    return false;
                  }
                  if (minimum[1] > animVersion[1]) {
                    return true;
                  }
                  if (animVersion[1] > minimum[1]) {
                    return false;
                  }
                  if (minimum[2] > animVersion[2]) {
                    return true;
                  }
                  if (animVersion[2] > minimum[2]) {
                    return false;
                  }
                  return null;
                }
                var checkText = /* @__PURE__ */ function() {
                  var minimumVersion = [4, 4, 14];
                  function updateTextLayer(textLayer) {
                    var documentData = textLayer.t.d;
                    textLayer.t.d = {
                      k: [{
                        s: documentData,
                        t: 0
                      }]
                    };
                  }
                  function iterateLayers(layers) {
                    var i;
                    var len = layers.length;
                    for (i = 0; i < len; i += 1) {
                      if (layers[i].ty === 5) {
                        updateTextLayer(layers[i]);
                      }
                    }
                  }
                  return function(animationData2) {
                    if (checkVersion(minimumVersion, animationData2.v)) {
                      iterateLayers(animationData2.layers);
                      if (animationData2.assets) {
                        var i;
                        var len = animationData2.assets.length;
                        for (i = 0; i < len; i += 1) {
                          if (animationData2.assets[i].layers) {
                            iterateLayers(animationData2.assets[i].layers);
                          }
                        }
                      }
                    }
                  };
                }();
                var checkChars = /* @__PURE__ */ function() {
                  var minimumVersion = [4, 7, 99];
                  return function(animationData2) {
                    if (animationData2.chars && !checkVersion(minimumVersion, animationData2.v)) {
                      var i;
                      var len = animationData2.chars.length;
                      for (i = 0; i < len; i += 1) {
                        var charData = animationData2.chars[i];
                        if (charData.data && charData.data.shapes) {
                          completeShapes(charData.data.shapes);
                          charData.data.ip = 0;
                          charData.data.op = 99999;
                          charData.data.st = 0;
                          charData.data.sr = 1;
                          charData.data.ks = {
                            p: {
                              k: [0, 0],
                              a: 0
                            },
                            s: {
                              k: [100, 100],
                              a: 0
                            },
                            a: {
                              k: [0, 0],
                              a: 0
                            },
                            r: {
                              k: 0,
                              a: 0
                            },
                            o: {
                              k: 100,
                              a: 0
                            }
                          };
                          if (!animationData2.chars[i].t) {
                            charData.data.shapes.push({
                              ty: "no"
                            });
                            charData.data.shapes[0].it.push({
                              p: {
                                k: [0, 0],
                                a: 0
                              },
                              s: {
                                k: [100, 100],
                                a: 0
                              },
                              a: {
                                k: [0, 0],
                                a: 0
                              },
                              r: {
                                k: 0,
                                a: 0
                              },
                              o: {
                                k: 100,
                                a: 0
                              },
                              sk: {
                                k: 0,
                                a: 0
                              },
                              sa: {
                                k: 0,
                                a: 0
                              },
                              ty: "tr"
                            });
                          }
                        }
                      }
                    }
                  };
                }();
                var checkPathProperties = /* @__PURE__ */ function() {
                  var minimumVersion = [5, 7, 15];
                  function updateTextLayer(textLayer) {
                    var pathData = textLayer.t.p;
                    if (typeof pathData.a === "number") {
                      pathData.a = {
                        a: 0,
                        k: pathData.a
                      };
                    }
                    if (typeof pathData.p === "number") {
                      pathData.p = {
                        a: 0,
                        k: pathData.p
                      };
                    }
                    if (typeof pathData.r === "number") {
                      pathData.r = {
                        a: 0,
                        k: pathData.r
                      };
                    }
                  }
                  function iterateLayers(layers) {
                    var i;
                    var len = layers.length;
                    for (i = 0; i < len; i += 1) {
                      if (layers[i].ty === 5) {
                        updateTextLayer(layers[i]);
                      }
                    }
                  }
                  return function(animationData2) {
                    if (checkVersion(minimumVersion, animationData2.v)) {
                      iterateLayers(animationData2.layers);
                      if (animationData2.assets) {
                        var i;
                        var len = animationData2.assets.length;
                        for (i = 0; i < len; i += 1) {
                          if (animationData2.assets[i].layers) {
                            iterateLayers(animationData2.assets[i].layers);
                          }
                        }
                      }
                    }
                  };
                }();
                var checkColors = /* @__PURE__ */ function() {
                  var minimumVersion = [4, 1, 9];
                  function iterateShapes(shapes) {
                    var i;
                    var len = shapes.length;
                    var j;
                    var jLen;
                    for (i = 0; i < len; i += 1) {
                      if (shapes[i].ty === "gr") {
                        iterateShapes(shapes[i].it);
                      } else if (shapes[i].ty === "fl" || shapes[i].ty === "st") {
                        if (shapes[i].c.k && shapes[i].c.k[0].i) {
                          jLen = shapes[i].c.k.length;
                          for (j = 0; j < jLen; j += 1) {
                            if (shapes[i].c.k[j].s) {
                              shapes[i].c.k[j].s[0] /= 255;
                              shapes[i].c.k[j].s[1] /= 255;
                              shapes[i].c.k[j].s[2] /= 255;
                              shapes[i].c.k[j].s[3] /= 255;
                            }
                            if (shapes[i].c.k[j].e) {
                              shapes[i].c.k[j].e[0] /= 255;
                              shapes[i].c.k[j].e[1] /= 255;
                              shapes[i].c.k[j].e[2] /= 255;
                              shapes[i].c.k[j].e[3] /= 255;
                            }
                          }
                        } else {
                          shapes[i].c.k[0] /= 255;
                          shapes[i].c.k[1] /= 255;
                          shapes[i].c.k[2] /= 255;
                          shapes[i].c.k[3] /= 255;
                        }
                      }
                    }
                  }
                  function iterateLayers(layers) {
                    var i;
                    var len = layers.length;
                    for (i = 0; i < len; i += 1) {
                      if (layers[i].ty === 4) {
                        iterateShapes(layers[i].shapes);
                      }
                    }
                  }
                  return function(animationData2) {
                    if (checkVersion(minimumVersion, animationData2.v)) {
                      iterateLayers(animationData2.layers);
                      if (animationData2.assets) {
                        var i;
                        var len = animationData2.assets.length;
                        for (i = 0; i < len; i += 1) {
                          if (animationData2.assets[i].layers) {
                            iterateLayers(animationData2.assets[i].layers);
                          }
                        }
                      }
                    }
                  };
                }();
                var checkShapes = /* @__PURE__ */ function() {
                  var minimumVersion = [4, 4, 18];
                  function completeClosingShapes(arr) {
                    var i;
                    var len = arr.length;
                    var j;
                    var jLen;
                    for (i = len - 1; i >= 0; i -= 1) {
                      if (arr[i].ty === "sh") {
                        if (arr[i].ks.k.i) {
                          arr[i].ks.k.c = arr[i].closed;
                        } else {
                          jLen = arr[i].ks.k.length;
                          for (j = 0; j < jLen; j += 1) {
                            if (arr[i].ks.k[j].s) {
                              arr[i].ks.k[j].s[0].c = arr[i].closed;
                            }
                            if (arr[i].ks.k[j].e) {
                              arr[i].ks.k[j].e[0].c = arr[i].closed;
                            }
                          }
                        }
                      } else if (arr[i].ty === "gr") {
                        completeClosingShapes(arr[i].it);
                      }
                    }
                  }
                  function iterateLayers(layers) {
                    var layerData;
                    var i;
                    var len = layers.length;
                    var j;
                    var jLen;
                    var k;
                    var kLen;
                    for (i = 0; i < len; i += 1) {
                      layerData = layers[i];
                      if (layerData.hasMask) {
                        var maskProps = layerData.masksProperties;
                        jLen = maskProps.length;
                        for (j = 0; j < jLen; j += 1) {
                          if (maskProps[j].pt.k.i) {
                            maskProps[j].pt.k.c = maskProps[j].cl;
                          } else {
                            kLen = maskProps[j].pt.k.length;
                            for (k = 0; k < kLen; k += 1) {
                              if (maskProps[j].pt.k[k].s) {
                                maskProps[j].pt.k[k].s[0].c = maskProps[j].cl;
                              }
                              if (maskProps[j].pt.k[k].e) {
                                maskProps[j].pt.k[k].e[0].c = maskProps[j].cl;
                              }
                            }
                          }
                        }
                      }
                      if (layerData.ty === 4) {
                        completeClosingShapes(layerData.shapes);
                      }
                    }
                  }
                  return function(animationData2) {
                    if (checkVersion(minimumVersion, animationData2.v)) {
                      iterateLayers(animationData2.layers);
                      if (animationData2.assets) {
                        var i;
                        var len = animationData2.assets.length;
                        for (i = 0; i < len; i += 1) {
                          if (animationData2.assets[i].layers) {
                            iterateLayers(animationData2.assets[i].layers);
                          }
                        }
                      }
                    }
                  };
                }();
                function completeData(animationData2) {
                  if (animationData2.__complete) {
                    return;
                  }
                  checkColors(animationData2);
                  checkText(animationData2);
                  checkChars(animationData2);
                  checkPathProperties(animationData2);
                  checkShapes(animationData2);
                  completeLayers(animationData2.layers, animationData2.assets);
                  completeChars(animationData2.chars, animationData2.assets);
                  animationData2.__complete = true;
                }
                function completeText(data2) {
                  if (data2.t.a.length === 0 && !("m" in data2.t.p)) {
                  }
                }
                var moduleOb = {};
                moduleOb.completeData = completeData;
                moduleOb.checkColors = checkColors;
                moduleOb.checkChars = checkChars;
                moduleOb.checkPathProperties = checkPathProperties;
                moduleOb.checkShapes = checkShapes;
                moduleOb.completeLayers = completeLayers;
                return moduleOb;
              }
              if (!_workerSelf.dataManager) {
                _workerSelf.dataManager = dataFunctionManager();
              }
              if (!_workerSelf.assetLoader) {
                _workerSelf.assetLoader = /* @__PURE__ */ function() {
                  function formatResponse(xhr) {
                    var contentTypeHeader = xhr.getResponseHeader("content-type");
                    if (contentTypeHeader && xhr.responseType === "json" && contentTypeHeader.indexOf("json") !== -1) {
                      return xhr.response;
                    }
                    if (xhr.response && _typeof$5(xhr.response) === "object") {
                      return xhr.response;
                    }
                    if (xhr.response && typeof xhr.response === "string") {
                      return JSON.parse(xhr.response);
                    }
                    if (xhr.responseText) {
                      return JSON.parse(xhr.responseText);
                    }
                    return null;
                  }
                  function loadAsset(path, fullPath, callback, errorCallback) {
                    var response;
                    var xhr = new XMLHttpRequest();
                    try {
                      xhr.responseType = "json";
                    } catch (err) {
                    }
                    xhr.onreadystatechange = function() {
                      if (xhr.readyState === 4) {
                        if (xhr.status === 200) {
                          response = formatResponse(xhr);
                          callback(response);
                        } else {
                          try {
                            response = formatResponse(xhr);
                            callback(response);
                          } catch (err) {
                            if (errorCallback) {
                              errorCallback(err);
                            }
                          }
                        }
                      }
                    };
                    try {
                      xhr.open(["G", "E", "T"].join(""), path, true);
                    } catch (error) {
                      xhr.open(["G", "E", "T"].join(""), fullPath + "/" + path, true);
                    }
                    xhr.send();
                  }
                  return {
                    load: loadAsset
                  };
                }();
              }
              if (e.data.type === "loadAnimation") {
                _workerSelf.assetLoader.load(e.data.path, e.data.fullPath, function(data2) {
                  _workerSelf.dataManager.completeData(data2);
                  _workerSelf.postMessage({
                    id: e.data.id,
                    payload: data2,
                    status: "success"
                  });
                }, function() {
                  _workerSelf.postMessage({
                    id: e.data.id,
                    status: "error"
                  });
                });
              } else if (e.data.type === "complete") {
                var animation = e.data.animation;
                _workerSelf.dataManager.completeData(animation);
                _workerSelf.postMessage({
                  id: e.data.id,
                  payload: animation,
                  status: "success"
                });
              } else if (e.data.type === "loadData") {
                _workerSelf.assetLoader.load(e.data.path, e.data.fullPath, function(data2) {
                  _workerSelf.postMessage({
                    id: e.data.id,
                    payload: data2,
                    status: "success"
                  });
                }, function() {
                  _workerSelf.postMessage({
                    id: e.data.id,
                    status: "error"
                  });
                });
              }
            });
            workerInstance.onmessage = function(event) {
              var data2 = event.data;
              var id = data2.id;
              var process2 = processes[id];
              processes[id] = null;
              if (data2.status === "success") {
                process2.onComplete(data2.payload);
              } else if (process2.onError) {
                process2.onError();
              }
            };
          }
        }
        function createProcess(onComplete, onError) {
          _counterId += 1;
          var id = "processId_" + _counterId;
          processes[id] = {
            onComplete,
            onError
          };
          return id;
        }
        function loadAnimation2(path, onComplete, onError) {
          setupWorker();
          var processId = createProcess(onComplete, onError);
          workerInstance.postMessage({
            type: "loadAnimation",
            path,
            fullPath: window.location.origin + window.location.pathname,
            id: processId
          });
        }
        function loadData(path, onComplete, onError) {
          setupWorker();
          var processId = createProcess(onComplete, onError);
          workerInstance.postMessage({
            type: "loadData",
            path,
            fullPath: window.location.origin + window.location.pathname,
            id: processId
          });
        }
        function completeAnimation(anim, onComplete, onError) {
          setupWorker();
          var processId = createProcess(onComplete, onError);
          workerInstance.postMessage({
            type: "complete",
            animation: anim,
            id: processId
          });
        }
        return {
          loadAnimation: loadAnimation2,
          loadData,
          completeAnimation
        };
      }();
      var ImagePreloader = function() {
        var proxyImage = function() {
          var canvas = createTag("canvas");
          canvas.width = 1;
          canvas.height = 1;
          var ctx = canvas.getContext("2d");
          ctx.fillStyle = "rgba(0,0,0,0)";
          ctx.fillRect(0, 0, 1, 1);
          return canvas;
        }();
        function imageLoaded() {
          this.loadedAssets += 1;
          if (this.loadedAssets === this.totalImages && this.loadedFootagesCount === this.totalFootages) {
            if (this.imagesLoadedCb) {
              this.imagesLoadedCb(null);
            }
          }
        }
        function footageLoaded() {
          this.loadedFootagesCount += 1;
          if (this.loadedAssets === this.totalImages && this.loadedFootagesCount === this.totalFootages) {
            if (this.imagesLoadedCb) {
              this.imagesLoadedCb(null);
            }
          }
        }
        function getAssetsPath(assetData, assetsPath, originalPath) {
          var path = "";
          if (assetData.e) {
            path = assetData.p;
          } else if (assetsPath) {
            var imagePath = assetData.p;
            if (imagePath.indexOf("images/") !== -1) {
              imagePath = imagePath.split("/")[1];
            }
            path = assetsPath + imagePath;
          } else {
            path = originalPath;
            path += assetData.u ? assetData.u : "";
            path += assetData.p;
          }
          return path;
        }
        function testImageLoaded(img) {
          var _count = 0;
          var intervalId = setInterval((function() {
            var box = img.getBBox();
            if (box.width || _count > 500) {
              this._imageLoaded();
              clearInterval(intervalId);
            }
            _count += 1;
          }).bind(this), 50);
        }
        function createImageData(assetData) {
          var path = getAssetsPath(assetData, this.assetsPath, this.path);
          var img = createNS("image");
          if (isSafari) {
            this.testImageLoaded(img);
          } else {
            img.addEventListener("load", this._imageLoaded, false);
          }
          img.addEventListener("error", (function() {
            ob2.img = proxyImage;
            this._imageLoaded();
          }).bind(this), false);
          img.setAttributeNS("http://www.w3.org/1999/xlink", "href", path);
          if (this._elementHelper.append) {
            this._elementHelper.append(img);
          } else {
            this._elementHelper.appendChild(img);
          }
          var ob2 = {
            img,
            assetData
          };
          return ob2;
        }
        function createImgData(assetData) {
          var path = getAssetsPath(assetData, this.assetsPath, this.path);
          var img = createTag("img");
          img.crossOrigin = "anonymous";
          img.addEventListener("load", this._imageLoaded, false);
          img.addEventListener("error", (function() {
            ob2.img = proxyImage;
            this._imageLoaded();
          }).bind(this), false);
          img.src = path;
          var ob2 = {
            img,
            assetData
          };
          return ob2;
        }
        function createFootageData(data2) {
          var ob2 = {
            assetData: data2
          };
          var path = getAssetsPath(data2, this.assetsPath, this.path);
          dataManager.loadData(path, (function(footageData) {
            ob2.img = footageData;
            this._footageLoaded();
          }).bind(this), (function() {
            ob2.img = {};
            this._footageLoaded();
          }).bind(this));
          return ob2;
        }
        function loadAssets(assets, cb) {
          this.imagesLoadedCb = cb;
          var i;
          var len = assets.length;
          for (i = 0; i < len; i += 1) {
            if (!assets[i].layers) {
              if (!assets[i].t || assets[i].t === "seq") {
                this.totalImages += 1;
                this.images.push(this._createImageData(assets[i]));
              } else if (assets[i].t === 3) {
                this.totalFootages += 1;
                this.images.push(this.createFootageData(assets[i]));
              }
            }
          }
        }
        function setPath(path) {
          this.path = path || "";
        }
        function setAssetsPath(path) {
          this.assetsPath = path || "";
        }
        function getAsset(assetData) {
          var i = 0;
          var len = this.images.length;
          while (i < len) {
            if (this.images[i].assetData === assetData) {
              return this.images[i].img;
            }
            i += 1;
          }
          return null;
        }
        function destroy() {
          this.imagesLoadedCb = null;
          this.images.length = 0;
        }
        function loadedImages() {
          return this.totalImages === this.loadedAssets;
        }
        function loadedFootages() {
          return this.totalFootages === this.loadedFootagesCount;
        }
        function setCacheType(type, elementHelper) {
          if (type === "svg") {
            this._elementHelper = elementHelper;
            this._createImageData = this.createImageData.bind(this);
          } else {
            this._createImageData = this.createImgData.bind(this);
          }
        }
        function ImagePreloaderFactory() {
          this._imageLoaded = imageLoaded.bind(this);
          this._footageLoaded = footageLoaded.bind(this);
          this.testImageLoaded = testImageLoaded.bind(this);
          this.createFootageData = createFootageData.bind(this);
          this.assetsPath = "";
          this.path = "";
          this.totalImages = 0;
          this.totalFootages = 0;
          this.loadedAssets = 0;
          this.loadedFootagesCount = 0;
          this.imagesLoadedCb = null;
          this.images = [];
        }
        ImagePreloaderFactory.prototype = {
          loadAssets,
          setAssetsPath,
          setPath,
          loadedImages,
          loadedFootages,
          destroy,
          getAsset,
          createImgData,
          createImageData,
          imageLoaded,
          footageLoaded,
          setCacheType
        };
        return ImagePreloaderFactory;
      }();
      function BaseEvent() {
      }
      BaseEvent.prototype = {
        triggerEvent: function triggerEvent(eventName, args) {
          if (this._cbs[eventName]) {
            var callbacks = this._cbs[eventName];
            for (var i = 0; i < callbacks.length; i += 1) {
              callbacks[i](args);
            }
          }
        },
        addEventListener: function addEventListener2(eventName, callback) {
          if (!this._cbs[eventName]) {
            this._cbs[eventName] = [];
          }
          this._cbs[eventName].push(callback);
          return (function() {
            this.removeEventListener(eventName, callback);
          }).bind(this);
        },
        removeEventListener: function removeEventListener2(eventName, callback) {
          if (!callback) {
            this._cbs[eventName] = null;
          } else if (this._cbs[eventName]) {
            var i = 0;
            var len = this._cbs[eventName].length;
            while (i < len) {
              if (this._cbs[eventName][i] === callback) {
                this._cbs[eventName].splice(i, 1);
                i -= 1;
                len -= 1;
              }
              i += 1;
            }
            if (!this._cbs[eventName].length) {
              this._cbs[eventName] = null;
            }
          }
        }
      };
      var markerParser = /* @__PURE__ */ function() {
        function parsePayloadLines(payload) {
          var lines = payload.split("\r\n");
          var keys = {};
          var line;
          var keysCount = 0;
          for (var i = 0; i < lines.length; i += 1) {
            line = lines[i].split(":");
            if (line.length === 2) {
              keys[line[0]] = line[1].trim();
              keysCount += 1;
            }
          }
          if (keysCount === 0) {
            throw new Error();
          }
          return keys;
        }
        return function(_markers) {
          var markers = [];
          for (var i = 0; i < _markers.length; i += 1) {
            var _marker = _markers[i];
            var markerData = {
              time: _marker.tm,
              duration: _marker.dr
            };
            try {
              markerData.payload = JSON.parse(_markers[i].cm);
            } catch (_) {
              try {
                markerData.payload = parsePayloadLines(_markers[i].cm);
              } catch (__) {
                markerData.payload = {
                  name: _markers[i].cm
                };
              }
            }
            markers.push(markerData);
          }
          return markers;
        };
      }();
      var ProjectInterface = /* @__PURE__ */ function() {
        function registerComposition(comp2) {
          this.compositions.push(comp2);
        }
        return function() {
          function _thisProjectFunction(name2) {
            var i = 0;
            var len = this.compositions.length;
            while (i < len) {
              if (this.compositions[i].data && this.compositions[i].data.nm === name2) {
                if (this.compositions[i].prepareFrame && this.compositions[i].data.xt) {
                  this.compositions[i].prepareFrame(this.currentFrame);
                }
                return this.compositions[i].compInterface;
              }
              i += 1;
            }
            return null;
          }
          _thisProjectFunction.compositions = [];
          _thisProjectFunction.currentFrame = 0;
          _thisProjectFunction.registerComposition = registerComposition;
          return _thisProjectFunction;
        };
      }();
      var renderers = {};
      var registerRenderer = function registerRenderer2(key2, value3) {
        renderers[key2] = value3;
      };
      function getRenderer(key2) {
        return renderers[key2];
      }
      function getRegisteredRenderer() {
        if (renderers.canvas) {
          return "canvas";
        }
        for (var key2 in renderers) {
          if (renderers[key2]) {
            return key2;
          }
        }
        return "";
      }
      function _typeof$4(o) {
        "@babel/helpers - typeof";
        return _typeof$4 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
          return typeof o2;
        } : function(o2) {
          return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
        }, _typeof$4(o);
      }
      var AnimationItem = function AnimationItem2() {
        this._cbs = [];
        this.name = "";
        this.path = "";
        this.isLoaded = false;
        this.currentFrame = 0;
        this.currentRawFrame = 0;
        this.firstFrame = 0;
        this.totalFrames = 0;
        this.frameRate = 0;
        this.frameMult = 0;
        this.playSpeed = 1;
        this.playDirection = 1;
        this.playCount = 0;
        this.animationData = {};
        this.assets = [];
        this.isPaused = true;
        this.autoplay = false;
        this.loop = true;
        this.renderer = null;
        this.animationID = createElementID();
        this.assetsPath = "";
        this.timeCompleted = 0;
        this.segmentPos = 0;
        this.isSubframeEnabled = getSubframeEnabled();
        this.segments = [];
        this._idle = true;
        this._completedLoop = false;
        this.projectInterface = ProjectInterface();
        this.imagePreloader = new ImagePreloader();
        this.audioController = audioControllerFactory();
        this.markers = [];
        this.configAnimation = this.configAnimation.bind(this);
        this.onSetupError = this.onSetupError.bind(this);
        this.onSegmentComplete = this.onSegmentComplete.bind(this);
        this.drawnFrameEvent = new BMEnterFrameEvent("drawnFrame", 0, 0, 0);
        this.expressionsPlugin = getExpressionsPlugin();
      };
      extendPrototype([BaseEvent], AnimationItem);
      AnimationItem.prototype.setParams = function(params) {
        if (params.wrapper || params.container) {
          this.wrapper = params.wrapper || params.container;
        }
        var animType = "svg";
        if (params.animType) {
          animType = params.animType;
        } else if (params.renderer) {
          animType = params.renderer;
        }
        var RendererClass = getRenderer(animType);
        this.renderer = new RendererClass(this, params.rendererSettings);
        this.imagePreloader.setCacheType(animType, this.renderer.globalData.defs);
        this.renderer.setProjectInterface(this.projectInterface);
        this.animType = animType;
        if (params.loop === "" || params.loop === null || params.loop === void 0 || params.loop === true) {
          this.loop = true;
        } else if (params.loop === false) {
          this.loop = false;
        } else {
          this.loop = parseInt(params.loop, 10);
        }
        this.autoplay = "autoplay" in params ? params.autoplay : true;
        this.name = params.name ? params.name : "";
        this.autoloadSegments = Object.prototype.hasOwnProperty.call(params, "autoloadSegments") ? params.autoloadSegments : true;
        this.assetsPath = params.assetsPath;
        this.initialSegment = params.initialSegment;
        if (params.audioFactory) {
          this.audioController.setAudioFactory(params.audioFactory);
        }
        if (params.animationData) {
          this.setupAnimation(params.animationData);
        } else if (params.path) {
          if (params.path.lastIndexOf("\\") !== -1) {
            this.path = params.path.substr(0, params.path.lastIndexOf("\\") + 1);
          } else {
            this.path = params.path.substr(0, params.path.lastIndexOf("/") + 1);
          }
          this.fileName = params.path.substr(params.path.lastIndexOf("/") + 1);
          this.fileName = this.fileName.substr(0, this.fileName.lastIndexOf(".json"));
          dataManager.loadAnimation(params.path, this.configAnimation, this.onSetupError);
        }
      };
      AnimationItem.prototype.onSetupError = function() {
        this.trigger("data_failed");
      };
      AnimationItem.prototype.setupAnimation = function(data2) {
        dataManager.completeAnimation(data2, this.configAnimation);
      };
      AnimationItem.prototype.setData = function(wrapper, animationData2) {
        if (animationData2) {
          if (_typeof$4(animationData2) !== "object") {
            animationData2 = JSON.parse(animationData2);
          }
        }
        var params = {
          wrapper,
          animationData: animationData2
        };
        var wrapperAttributes = wrapper.attributes;
        params.path = wrapperAttributes.getNamedItem("data-animation-path") ? wrapperAttributes.getNamedItem("data-animation-path").value : wrapperAttributes.getNamedItem("data-bm-path") ? wrapperAttributes.getNamedItem("data-bm-path").value : wrapperAttributes.getNamedItem("bm-path") ? wrapperAttributes.getNamedItem("bm-path").value : "";
        params.animType = wrapperAttributes.getNamedItem("data-anim-type") ? wrapperAttributes.getNamedItem("data-anim-type").value : wrapperAttributes.getNamedItem("data-bm-type") ? wrapperAttributes.getNamedItem("data-bm-type").value : wrapperAttributes.getNamedItem("bm-type") ? wrapperAttributes.getNamedItem("bm-type").value : wrapperAttributes.getNamedItem("data-bm-renderer") ? wrapperAttributes.getNamedItem("data-bm-renderer").value : wrapperAttributes.getNamedItem("bm-renderer") ? wrapperAttributes.getNamedItem("bm-renderer").value : getRegisteredRenderer() || "canvas";
        var loop = wrapperAttributes.getNamedItem("data-anim-loop") ? wrapperAttributes.getNamedItem("data-anim-loop").value : wrapperAttributes.getNamedItem("data-bm-loop") ? wrapperAttributes.getNamedItem("data-bm-loop").value : wrapperAttributes.getNamedItem("bm-loop") ? wrapperAttributes.getNamedItem("bm-loop").value : "";
        if (loop === "false") {
          params.loop = false;
        } else if (loop === "true") {
          params.loop = true;
        } else if (loop !== "") {
          params.loop = parseInt(loop, 10);
        }
        var autoplay = wrapperAttributes.getNamedItem("data-anim-autoplay") ? wrapperAttributes.getNamedItem("data-anim-autoplay").value : wrapperAttributes.getNamedItem("data-bm-autoplay") ? wrapperAttributes.getNamedItem("data-bm-autoplay").value : wrapperAttributes.getNamedItem("bm-autoplay") ? wrapperAttributes.getNamedItem("bm-autoplay").value : true;
        params.autoplay = autoplay !== "false";
        params.name = wrapperAttributes.getNamedItem("data-name") ? wrapperAttributes.getNamedItem("data-name").value : wrapperAttributes.getNamedItem("data-bm-name") ? wrapperAttributes.getNamedItem("data-bm-name").value : wrapperAttributes.getNamedItem("bm-name") ? wrapperAttributes.getNamedItem("bm-name").value : "";
        var prerender = wrapperAttributes.getNamedItem("data-anim-prerender") ? wrapperAttributes.getNamedItem("data-anim-prerender").value : wrapperAttributes.getNamedItem("data-bm-prerender") ? wrapperAttributes.getNamedItem("data-bm-prerender").value : wrapperAttributes.getNamedItem("bm-prerender") ? wrapperAttributes.getNamedItem("bm-prerender").value : "";
        if (prerender === "false") {
          params.prerender = false;
        }
        if (!params.path) {
          this.trigger("destroy");
        } else {
          this.setParams(params);
        }
      };
      AnimationItem.prototype.includeLayers = function(data2) {
        if (data2.op > this.animationData.op) {
          this.animationData.op = data2.op;
          this.totalFrames = Math.floor(data2.op - this.animationData.ip);
        }
        var layers = this.animationData.layers;
        var i;
        var len = layers.length;
        var newLayers = data2.layers;
        var j;
        var jLen = newLayers.length;
        for (j = 0; j < jLen; j += 1) {
          i = 0;
          while (i < len) {
            if (layers[i].id === newLayers[j].id) {
              layers[i] = newLayers[j];
              break;
            }
            i += 1;
          }
        }
        if (data2.chars || data2.fonts) {
          this.renderer.globalData.fontManager.addChars(data2.chars);
          this.renderer.globalData.fontManager.addFonts(data2.fonts, this.renderer.globalData.defs);
        }
        if (data2.assets) {
          len = data2.assets.length;
          for (i = 0; i < len; i += 1) {
            this.animationData.assets.push(data2.assets[i]);
          }
        }
        this.animationData.__complete = false;
        dataManager.completeAnimation(this.animationData, this.onSegmentComplete);
      };
      AnimationItem.prototype.onSegmentComplete = function(data2) {
        this.animationData = data2;
        var expressionsPlugin2 = getExpressionsPlugin();
        if (expressionsPlugin2) {
          expressionsPlugin2.initExpressions(this);
        }
        this.loadNextSegment();
      };
      AnimationItem.prototype.loadNextSegment = function() {
        var segments = this.animationData.segments;
        if (!segments || segments.length === 0 || !this.autoloadSegments) {
          this.trigger("data_ready");
          this.timeCompleted = this.totalFrames;
          return;
        }
        var segment = segments.shift();
        this.timeCompleted = segment.time * this.frameRate;
        var segmentPath = this.path + this.fileName + "_" + this.segmentPos + ".json";
        this.segmentPos += 1;
        dataManager.loadData(segmentPath, this.includeLayers.bind(this), (function() {
          this.trigger("data_failed");
        }).bind(this));
      };
      AnimationItem.prototype.loadSegments = function() {
        var segments = this.animationData.segments;
        if (!segments) {
          this.timeCompleted = this.totalFrames;
        }
        this.loadNextSegment();
      };
      AnimationItem.prototype.imagesLoaded = function() {
        this.trigger("loaded_images");
        this.checkLoaded();
      };
      AnimationItem.prototype.preloadImages = function() {
        this.imagePreloader.setAssetsPath(this.assetsPath);
        this.imagePreloader.setPath(this.path);
        this.imagePreloader.loadAssets(this.animationData.assets, this.imagesLoaded.bind(this));
      };
      AnimationItem.prototype.configAnimation = function(animData) {
        if (!this.renderer) {
          return;
        }
        try {
          this.animationData = animData;
          if (this.initialSegment) {
            this.totalFrames = Math.floor(this.initialSegment[1] - this.initialSegment[0]);
            this.firstFrame = Math.round(this.initialSegment[0]);
          } else {
            this.totalFrames = Math.floor(this.animationData.op - this.animationData.ip);
            this.firstFrame = Math.round(this.animationData.ip);
          }
          this.renderer.configAnimation(animData);
          if (!animData.assets) {
            animData.assets = [];
          }
          this.assets = this.animationData.assets;
          this.frameRate = this.animationData.fr;
          this.frameMult = this.animationData.fr / 1e3;
          this.renderer.searchExtraCompositions(animData.assets);
          this.markers = markerParser(animData.markers || []);
          this.trigger("config_ready");
          this.preloadImages();
          this.loadSegments();
          this.updaFrameModifier();
          this.waitForFontsLoaded();
          if (this.isPaused) {
            this.audioController.pause();
          }
        } catch (error) {
          this.triggerConfigError(error);
        }
      };
      AnimationItem.prototype.waitForFontsLoaded = function() {
        if (!this.renderer) {
          return;
        }
        if (this.renderer.globalData.fontManager.isLoaded) {
          this.checkLoaded();
        } else {
          setTimeout(this.waitForFontsLoaded.bind(this), 20);
        }
      };
      AnimationItem.prototype.checkLoaded = function() {
        if (!this.isLoaded && this.renderer.globalData.fontManager.isLoaded && (this.imagePreloader.loadedImages() || this.renderer.rendererType !== "canvas") && this.imagePreloader.loadedFootages()) {
          this.isLoaded = true;
          var expressionsPlugin2 = getExpressionsPlugin();
          if (expressionsPlugin2) {
            expressionsPlugin2.initExpressions(this);
          }
          this.renderer.initItems();
          setTimeout((function() {
            this.trigger("DOMLoaded");
          }).bind(this), 0);
          this.gotoFrame();
          if (this.autoplay) {
            this.play();
          }
        }
      };
      AnimationItem.prototype.resize = function(width2, height2) {
        var _width = typeof width2 === "number" ? width2 : void 0;
        var _height = typeof height2 === "number" ? height2 : void 0;
        this.renderer.updateContainerSize(_width, _height);
      };
      AnimationItem.prototype.setSubframe = function(flag) {
        this.isSubframeEnabled = !!flag;
      };
      AnimationItem.prototype.gotoFrame = function() {
        this.currentFrame = this.isSubframeEnabled ? this.currentRawFrame : ~~this.currentRawFrame;
        if (this.timeCompleted !== this.totalFrames && this.currentFrame > this.timeCompleted) {
          this.currentFrame = this.timeCompleted;
        }
        this.trigger("enterFrame");
        this.renderFrame();
        this.trigger("drawnFrame");
      };
      AnimationItem.prototype.renderFrame = function() {
        if (this.isLoaded === false || !this.renderer) {
          return;
        }
        try {
          if (this.expressionsPlugin) {
            this.expressionsPlugin.resetFrame();
          }
          this.renderer.renderFrame(this.currentFrame + this.firstFrame);
        } catch (error) {
          this.triggerRenderFrameError(error);
        }
      };
      AnimationItem.prototype.play = function(name2) {
        if (name2 && this.name !== name2) {
          return;
        }
        if (this.isPaused === true) {
          this.isPaused = false;
          this.trigger("_play");
          this.audioController.resume();
          if (this._idle) {
            this._idle = false;
            this.trigger("_active");
          }
        }
      };
      AnimationItem.prototype.pause = function(name2) {
        if (name2 && this.name !== name2) {
          return;
        }
        if (this.isPaused === false) {
          this.isPaused = true;
          this.trigger("_pause");
          this._idle = true;
          this.trigger("_idle");
          this.audioController.pause();
        }
      };
      AnimationItem.prototype.togglePause = function(name2) {
        if (name2 && this.name !== name2) {
          return;
        }
        if (this.isPaused === true) {
          this.play();
        } else {
          this.pause();
        }
      };
      AnimationItem.prototype.stop = function(name2) {
        if (name2 && this.name !== name2) {
          return;
        }
        this.pause();
        this.playCount = 0;
        this._completedLoop = false;
        this.setCurrentRawFrameValue(0);
      };
      AnimationItem.prototype.getMarkerData = function(markerName) {
        var marker;
        for (var i = 0; i < this.markers.length; i += 1) {
          marker = this.markers[i];
          if (marker.payload && marker.payload.name === markerName) {
            return marker;
          }
        }
        return null;
      };
      AnimationItem.prototype.goToAndStop = function(value3, isFrame, name2) {
        if (name2 && this.name !== name2) {
          return;
        }
        var numValue = Number(value3);
        if (isNaN(numValue)) {
          var marker = this.getMarkerData(value3);
          if (marker) {
            this.goToAndStop(marker.time, true);
          }
        } else if (isFrame) {
          this.setCurrentRawFrameValue(value3);
        } else {
          this.setCurrentRawFrameValue(value3 * this.frameModifier);
        }
        this.pause();
      };
      AnimationItem.prototype.goToAndPlay = function(value3, isFrame, name2) {
        if (name2 && this.name !== name2) {
          return;
        }
        var numValue = Number(value3);
        if (isNaN(numValue)) {
          var marker = this.getMarkerData(value3);
          if (marker) {
            if (!marker.duration) {
              this.goToAndStop(marker.time, true);
            } else {
              this.playSegments([marker.time, marker.time + marker.duration], true);
            }
          }
        } else {
          this.goToAndStop(numValue, isFrame, name2);
        }
        this.play();
      };
      AnimationItem.prototype.advanceTime = function(value3) {
        if (this.isPaused === true || this.isLoaded === false) {
          return;
        }
        var nextValue = this.currentRawFrame + value3 * this.frameModifier;
        var _isComplete = false;
        if (nextValue >= this.totalFrames - 1 && this.frameModifier > 0) {
          if (!this.loop || this.playCount === this.loop) {
            if (!this.checkSegments(nextValue > this.totalFrames ? nextValue % this.totalFrames : 0)) {
              _isComplete = true;
              nextValue = this.totalFrames - 1;
            }
          } else if (nextValue >= this.totalFrames) {
            this.playCount += 1;
            if (!this.checkSegments(nextValue % this.totalFrames)) {
              this.setCurrentRawFrameValue(nextValue % this.totalFrames);
              this._completedLoop = true;
              this.trigger("loopComplete");
            }
          } else {
            this.setCurrentRawFrameValue(nextValue);
          }
        } else if (nextValue < 0) {
          if (!this.checkSegments(nextValue % this.totalFrames)) {
            if (this.loop && !(this.playCount-- <= 0 && this.loop !== true)) {
              this.setCurrentRawFrameValue(this.totalFrames + nextValue % this.totalFrames);
              if (!this._completedLoop) {
                this._completedLoop = true;
              } else {
                this.trigger("loopComplete");
              }
            } else {
              _isComplete = true;
              nextValue = 0;
            }
          }
        } else {
          this.setCurrentRawFrameValue(nextValue);
        }
        if (_isComplete) {
          this.setCurrentRawFrameValue(nextValue);
          this.pause();
          this.trigger("complete");
        }
      };
      AnimationItem.prototype.adjustSegment = function(arr, offset) {
        this.playCount = 0;
        if (arr[1] < arr[0]) {
          if (this.frameModifier > 0) {
            if (this.playSpeed < 0) {
              this.setSpeed(-this.playSpeed);
            } else {
              this.setDirection(-1);
            }
          }
          this.totalFrames = arr[0] - arr[1];
          this.timeCompleted = this.totalFrames;
          this.firstFrame = arr[1];
          this.setCurrentRawFrameValue(this.totalFrames - 1e-3 - offset);
        } else if (arr[1] > arr[0]) {
          if (this.frameModifier < 0) {
            if (this.playSpeed < 0) {
              this.setSpeed(-this.playSpeed);
            } else {
              this.setDirection(1);
            }
          }
          this.totalFrames = arr[1] - arr[0];
          this.timeCompleted = this.totalFrames;
          this.firstFrame = arr[0];
          this.setCurrentRawFrameValue(1e-3 + offset);
        }
        this.trigger("segmentStart");
      };
      AnimationItem.prototype.setSegment = function(init, end) {
        var pendingFrame = -1;
        if (this.isPaused) {
          if (this.currentRawFrame + this.firstFrame < init) {
            pendingFrame = init;
          } else if (this.currentRawFrame + this.firstFrame > end) {
            pendingFrame = end - init;
          }
        }
        this.firstFrame = init;
        this.totalFrames = end - init;
        this.timeCompleted = this.totalFrames;
        if (pendingFrame !== -1) {
          this.goToAndStop(pendingFrame, true);
        }
      };
      AnimationItem.prototype.playSegments = function(arr, forceFlag) {
        if (forceFlag) {
          this.segments.length = 0;
        }
        if (_typeof$4(arr[0]) === "object") {
          var i;
          var len = arr.length;
          for (i = 0; i < len; i += 1) {
            this.segments.push(arr[i]);
          }
        } else {
          this.segments.push(arr);
        }
        if (this.segments.length && forceFlag) {
          this.adjustSegment(this.segments.shift(), 0);
        }
        if (this.isPaused) {
          this.play();
        }
      };
      AnimationItem.prototype.resetSegments = function(forceFlag) {
        this.segments.length = 0;
        this.segments.push([this.animationData.ip, this.animationData.op]);
        if (forceFlag) {
          this.checkSegments(0);
        }
      };
      AnimationItem.prototype.checkSegments = function(offset) {
        if (this.segments.length) {
          this.adjustSegment(this.segments.shift(), offset);
          return true;
        }
        return false;
      };
      AnimationItem.prototype.destroy = function(name2) {
        if (name2 && this.name !== name2 || !this.renderer) {
          return;
        }
        this.renderer.destroy();
        this.imagePreloader.destroy();
        this.trigger("destroy");
        this._cbs = null;
        this.onEnterFrame = null;
        this.onLoopComplete = null;
        this.onComplete = null;
        this.onSegmentStart = null;
        this.onDestroy = null;
        this.renderer = null;
        this.expressionsPlugin = null;
        this.imagePreloader = null;
        this.projectInterface = null;
      };
      AnimationItem.prototype.setCurrentRawFrameValue = function(value3) {
        this.currentRawFrame = value3;
        this.gotoFrame();
      };
      AnimationItem.prototype.setSpeed = function(val2) {
        this.playSpeed = val2;
        this.updaFrameModifier();
      };
      AnimationItem.prototype.setDirection = function(val2) {
        this.playDirection = val2 < 0 ? -1 : 1;
        this.updaFrameModifier();
      };
      AnimationItem.prototype.setLoop = function(isLooping) {
        this.loop = isLooping;
      };
      AnimationItem.prototype.setVolume = function(val2, name2) {
        if (name2 && this.name !== name2) {
          return;
        }
        this.audioController.setVolume(val2);
      };
      AnimationItem.prototype.getVolume = function() {
        return this.audioController.getVolume();
      };
      AnimationItem.prototype.mute = function(name2) {
        if (name2 && this.name !== name2) {
          return;
        }
        this.audioController.mute();
      };
      AnimationItem.prototype.unmute = function(name2) {
        if (name2 && this.name !== name2) {
          return;
        }
        this.audioController.unmute();
      };
      AnimationItem.prototype.updaFrameModifier = function() {
        this.frameModifier = this.frameMult * this.playSpeed * this.playDirection;
        this.audioController.setRate(this.playSpeed * this.playDirection);
      };
      AnimationItem.prototype.getPath = function() {
        return this.path;
      };
      AnimationItem.prototype.getAssetsPath = function(assetData) {
        var path = "";
        if (assetData.e) {
          path = assetData.p;
        } else if (this.assetsPath) {
          var imagePath = assetData.p;
          if (imagePath.indexOf("images/") !== -1) {
            imagePath = imagePath.split("/")[1];
          }
          path = this.assetsPath + imagePath;
        } else {
          path = this.path;
          path += assetData.u ? assetData.u : "";
          path += assetData.p;
        }
        return path;
      };
      AnimationItem.prototype.getAssetData = function(id) {
        var i = 0;
        var len = this.assets.length;
        while (i < len) {
          if (id === this.assets[i].id) {
            return this.assets[i];
          }
          i += 1;
        }
        return null;
      };
      AnimationItem.prototype.hide = function() {
        this.renderer.hide();
      };
      AnimationItem.prototype.show = function() {
        this.renderer.show();
      };
      AnimationItem.prototype.getDuration = function(isFrame) {
        return isFrame ? this.totalFrames : this.totalFrames / this.frameRate;
      };
      AnimationItem.prototype.updateDocumentData = function(path, documentData, index2) {
        try {
          var element = this.renderer.getElementByPath(path);
          element.updateDocumentData(documentData, index2);
        } catch (error) {
        }
      };
      AnimationItem.prototype.trigger = function(name2) {
        if (this._cbs && this._cbs[name2]) {
          switch (name2) {
            case "enterFrame":
              this.triggerEvent(name2, new BMEnterFrameEvent(name2, this.currentFrame, this.totalFrames, this.frameModifier));
              break;
            case "drawnFrame":
              this.drawnFrameEvent.currentTime = this.currentFrame;
              this.drawnFrameEvent.totalTime = this.totalFrames;
              this.drawnFrameEvent.direction = this.frameModifier;
              this.triggerEvent(name2, this.drawnFrameEvent);
              break;
            case "loopComplete":
              this.triggerEvent(name2, new BMCompleteLoopEvent(name2, this.loop, this.playCount, this.frameMult));
              break;
            case "complete":
              this.triggerEvent(name2, new BMCompleteEvent(name2, this.frameMult));
              break;
            case "segmentStart":
              this.triggerEvent(name2, new BMSegmentStartEvent(name2, this.firstFrame, this.totalFrames));
              break;
            case "destroy":
              this.triggerEvent(name2, new BMDestroyEvent(name2, this));
              break;
            default:
              this.triggerEvent(name2);
          }
        }
        if (name2 === "enterFrame" && this.onEnterFrame) {
          this.onEnterFrame.call(this, new BMEnterFrameEvent(name2, this.currentFrame, this.totalFrames, this.frameMult));
        }
        if (name2 === "loopComplete" && this.onLoopComplete) {
          this.onLoopComplete.call(this, new BMCompleteLoopEvent(name2, this.loop, this.playCount, this.frameMult));
        }
        if (name2 === "complete" && this.onComplete) {
          this.onComplete.call(this, new BMCompleteEvent(name2, this.frameMult));
        }
        if (name2 === "segmentStart" && this.onSegmentStart) {
          this.onSegmentStart.call(this, new BMSegmentStartEvent(name2, this.firstFrame, this.totalFrames));
        }
        if (name2 === "destroy" && this.onDestroy) {
          this.onDestroy.call(this, new BMDestroyEvent(name2, this));
        }
      };
      AnimationItem.prototype.triggerRenderFrameError = function(nativeError) {
        var error = new BMRenderFrameErrorEvent(nativeError, this.currentFrame);
        this.triggerEvent("error", error);
        if (this.onError) {
          this.onError.call(this, error);
        }
      };
      AnimationItem.prototype.triggerConfigError = function(nativeError) {
        var error = new BMConfigErrorEvent(nativeError, this.currentFrame);
        this.triggerEvent("error", error);
        if (this.onError) {
          this.onError.call(this, error);
        }
      };
      var animationManager = function() {
        var moduleOb = {};
        var registeredAnimations = [];
        var initTime = 0;
        var len = 0;
        var playingAnimationsNum = 0;
        var _stopped = true;
        var _isFrozen = false;
        function removeElement(ev) {
          var i = 0;
          var animItem = ev.target;
          while (i < len) {
            if (registeredAnimations[i].animation === animItem) {
              registeredAnimations.splice(i, 1);
              i -= 1;
              len -= 1;
              if (!animItem.isPaused) {
                subtractPlayingCount();
              }
            }
            i += 1;
          }
        }
        function registerAnimation(element, animationData2) {
          if (!element) {
            return null;
          }
          var i = 0;
          while (i < len) {
            if (registeredAnimations[i].elem === element && registeredAnimations[i].elem !== null) {
              return registeredAnimations[i].animation;
            }
            i += 1;
          }
          var animItem = new AnimationItem();
          setupAnimation(animItem, element);
          animItem.setData(element, animationData2);
          return animItem;
        }
        function getRegisteredAnimations() {
          var i;
          var lenAnims = registeredAnimations.length;
          var animations = [];
          for (i = 0; i < lenAnims; i += 1) {
            animations.push(registeredAnimations[i].animation);
          }
          return animations;
        }
        function addPlayingCount() {
          playingAnimationsNum += 1;
          activate();
        }
        function subtractPlayingCount() {
          playingAnimationsNum -= 1;
        }
        function setupAnimation(animItem, element) {
          animItem.addEventListener("destroy", removeElement);
          animItem.addEventListener("_active", addPlayingCount);
          animItem.addEventListener("_idle", subtractPlayingCount);
          registeredAnimations.push({
            elem: element,
            animation: animItem
          });
          len += 1;
        }
        function loadAnimation2(params) {
          var animItem = new AnimationItem();
          setupAnimation(animItem, null);
          animItem.setParams(params);
          return animItem;
        }
        function setSpeed(val2, animation) {
          var i;
          for (i = 0; i < len; i += 1) {
            registeredAnimations[i].animation.setSpeed(val2, animation);
          }
        }
        function setDirection(val2, animation) {
          var i;
          for (i = 0; i < len; i += 1) {
            registeredAnimations[i].animation.setDirection(val2, animation);
          }
        }
        function play(animation) {
          var i;
          for (i = 0; i < len; i += 1) {
            registeredAnimations[i].animation.play(animation);
          }
        }
        function resume(nowTime) {
          var elapsedTime = nowTime - initTime;
          var i;
          for (i = 0; i < len; i += 1) {
            registeredAnimations[i].animation.advanceTime(elapsedTime);
          }
          initTime = nowTime;
          if (playingAnimationsNum && !_isFrozen) {
            window.requestAnimationFrame(resume);
          } else {
            _stopped = true;
          }
        }
        function first(nowTime) {
          initTime = nowTime;
          window.requestAnimationFrame(resume);
        }
        function pause(animation) {
          var i;
          for (i = 0; i < len; i += 1) {
            registeredAnimations[i].animation.pause(animation);
          }
        }
        function goToAndStop(value3, isFrame, animation) {
          var i;
          for (i = 0; i < len; i += 1) {
            registeredAnimations[i].animation.goToAndStop(value3, isFrame, animation);
          }
        }
        function stop(animation) {
          var i;
          for (i = 0; i < len; i += 1) {
            registeredAnimations[i].animation.stop(animation);
          }
        }
        function togglePause(animation) {
          var i;
          for (i = 0; i < len; i += 1) {
            registeredAnimations[i].animation.togglePause(animation);
          }
        }
        function destroy(animation) {
          var i;
          for (i = len - 1; i >= 0; i -= 1) {
            registeredAnimations[i].animation.destroy(animation);
          }
        }
        function searchAnimations2(animationData2, standalone2, renderer2) {
          var animElements = [].concat([].slice.call(document.getElementsByClassName("lottie")), [].slice.call(document.getElementsByClassName("bodymovin")));
          var i;
          var lenAnims = animElements.length;
          for (i = 0; i < lenAnims; i += 1) {
            if (renderer2) {
              animElements[i].setAttribute("data-bm-type", renderer2);
            }
            registerAnimation(animElements[i], animationData2);
          }
          if (standalone2 && lenAnims === 0) {
            if (!renderer2) {
              renderer2 = "svg";
            }
            var body = document.getElementsByTagName("body")[0];
            body.innerText = "";
            var div2 = createTag("div");
            div2.style.width = "100%";
            div2.style.height = "100%";
            div2.setAttribute("data-bm-type", renderer2);
            body.appendChild(div2);
            registerAnimation(div2, animationData2);
          }
        }
        function resize() {
          var i;
          for (i = 0; i < len; i += 1) {
            registeredAnimations[i].animation.resize();
          }
        }
        function activate() {
          if (!_isFrozen && playingAnimationsNum) {
            if (_stopped) {
              window.requestAnimationFrame(first);
              _stopped = false;
            }
          }
        }
        function freeze() {
          _isFrozen = true;
        }
        function unfreeze() {
          _isFrozen = false;
          activate();
        }
        function setVolume(val2, animation) {
          var i;
          for (i = 0; i < len; i += 1) {
            registeredAnimations[i].animation.setVolume(val2, animation);
          }
        }
        function mute(animation) {
          var i;
          for (i = 0; i < len; i += 1) {
            registeredAnimations[i].animation.mute(animation);
          }
        }
        function unmute(animation) {
          var i;
          for (i = 0; i < len; i += 1) {
            registeredAnimations[i].animation.unmute(animation);
          }
        }
        moduleOb.registerAnimation = registerAnimation;
        moduleOb.loadAnimation = loadAnimation2;
        moduleOb.setSpeed = setSpeed;
        moduleOb.setDirection = setDirection;
        moduleOb.play = play;
        moduleOb.pause = pause;
        moduleOb.stop = stop;
        moduleOb.togglePause = togglePause;
        moduleOb.searchAnimations = searchAnimations2;
        moduleOb.resize = resize;
        moduleOb.goToAndStop = goToAndStop;
        moduleOb.destroy = destroy;
        moduleOb.freeze = freeze;
        moduleOb.unfreeze = unfreeze;
        moduleOb.setVolume = setVolume;
        moduleOb.mute = mute;
        moduleOb.unmute = unmute;
        moduleOb.getRegisteredAnimations = getRegisteredAnimations;
        return moduleOb;
      }();
      var BezierFactory = function() {
        var ob2 = {};
        ob2.getBezierEasing = getBezierEasing;
        var beziers = {};
        function getBezierEasing(a, b, c, d, nm) {
          var str = nm || ("bez_" + a + "_" + b + "_" + c + "_" + d).replace(/\./g, "p");
          if (beziers[str]) {
            return beziers[str];
          }
          var bezEasing = new BezierEasing([a, b, c, d]);
          beziers[str] = bezEasing;
          return bezEasing;
        }
        var NEWTON_ITERATIONS = 4;
        var NEWTON_MIN_SLOPE = 1e-3;
        var SUBDIVISION_PRECISION = 1e-7;
        var SUBDIVISION_MAX_ITERATIONS = 10;
        var kSplineTableSize = 11;
        var kSampleStepSize = 1 / (kSplineTableSize - 1);
        var float32ArraySupported = typeof Float32Array === "function";
        function A(aA1, aA2) {
          return 1 - 3 * aA2 + 3 * aA1;
        }
        function B(aA1, aA2) {
          return 3 * aA2 - 6 * aA1;
        }
        function C(aA1) {
          return 3 * aA1;
        }
        function calcBezier(aT, aA1, aA2) {
          return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;
        }
        function getSlope(aT, aA1, aA2) {
          return 3 * A(aA1, aA2) * aT * aT + 2 * B(aA1, aA2) * aT + C(aA1);
        }
        function binarySubdivide(aX, aA, aB, mX1, mX2) {
          var currentX, currentT, i = 0;
          do {
            currentT = aA + (aB - aA) / 2;
            currentX = calcBezier(currentT, mX1, mX2) - aX;
            if (currentX > 0) {
              aB = currentT;
            } else {
              aA = currentT;
            }
          } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);
          return currentT;
        }
        function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {
          for (var i = 0; i < NEWTON_ITERATIONS; ++i) {
            var currentSlope = getSlope(aGuessT, mX1, mX2);
            if (currentSlope === 0) return aGuessT;
            var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
            aGuessT -= currentX / currentSlope;
          }
          return aGuessT;
        }
        function BezierEasing(points) {
          this._p = points;
          this._mSampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);
          this._precomputed = false;
          this.get = this.get.bind(this);
        }
        BezierEasing.prototype = {
          get: function get(x) {
            var mX1 = this._p[0], mY1 = this._p[1], mX2 = this._p[2], mY2 = this._p[3];
            if (!this._precomputed) this._precompute();
            if (mX1 === mY1 && mX2 === mY2) return x;
            if (x === 0) return 0;
            if (x === 1) return 1;
            return calcBezier(this._getTForX(x), mY1, mY2);
          },
          // Private part
          _precompute: function _precompute() {
            var mX1 = this._p[0], mY1 = this._p[1], mX2 = this._p[2], mY2 = this._p[3];
            this._precomputed = true;
            if (mX1 !== mY1 || mX2 !== mY2) {
              this._calcSampleValues();
            }
          },
          _calcSampleValues: function _calcSampleValues() {
            var mX1 = this._p[0], mX2 = this._p[2];
            for (var i = 0; i < kSplineTableSize; ++i) {
              this._mSampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
            }
          },
          /**
               * getTForX chose the fastest heuristic to determine the percentage value precisely from a given X projection.
               */
          _getTForX: function _getTForX(aX) {
            var mX1 = this._p[0], mX2 = this._p[2], mSampleValues = this._mSampleValues;
            var intervalStart = 0;
            var currentSample = 1;
            var lastSample = kSplineTableSize - 1;
            for (; currentSample !== lastSample && mSampleValues[currentSample] <= aX; ++currentSample) {
              intervalStart += kSampleStepSize;
            }
            --currentSample;
            var dist = (aX - mSampleValues[currentSample]) / (mSampleValues[currentSample + 1] - mSampleValues[currentSample]);
            var guessForT = intervalStart + dist * kSampleStepSize;
            var initialSlope = getSlope(guessForT, mX1, mX2);
            if (initialSlope >= NEWTON_MIN_SLOPE) {
              return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
            }
            if (initialSlope === 0) {
              return guessForT;
            }
            return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
          }
        };
        return ob2;
      }();
      var pooling = /* @__PURE__ */ function() {
        function _double(arr) {
          return arr.concat(createSizedArray(arr.length));
        }
        return {
          "double": _double
        };
      }();
      var poolFactory = /* @__PURE__ */ function() {
        return function(initialLength, _create, _release) {
          var _length = 0;
          var _maxLength = initialLength;
          var pool = createSizedArray(_maxLength);
          var ob2 = {
            newElement,
            release
          };
          function newElement() {
            var element;
            if (_length) {
              _length -= 1;
              element = pool[_length];
            } else {
              element = _create();
            }
            return element;
          }
          function release(element) {
            if (_length === _maxLength) {
              pool = pooling["double"](pool);
              _maxLength *= 2;
            }
            if (_release) {
              _release(element);
            }
            pool[_length] = element;
            _length += 1;
          }
          return ob2;
        };
      }();
      var bezierLengthPool = function() {
        function create() {
          return {
            addedLength: 0,
            percents: createTypedArray("float32", getDefaultCurveSegments()),
            lengths: createTypedArray("float32", getDefaultCurveSegments())
          };
        }
        return poolFactory(8, create);
      }();
      var segmentsLengthPool = function() {
        function create() {
          return {
            lengths: [],
            totalLength: 0
          };
        }
        function release(element) {
          var i;
          var len = element.lengths.length;
          for (i = 0; i < len; i += 1) {
            bezierLengthPool.release(element.lengths[i]);
          }
          element.lengths.length = 0;
        }
        return poolFactory(8, create, release);
      }();
      function bezFunction() {
        var math = Math;
        function pointOnLine2D(x1, y1, x2, y2, x3, y3) {
          var det1 = x1 * y2 + y1 * x3 + x2 * y3 - x3 * y2 - y3 * x1 - x2 * y1;
          return det1 > -1e-3 && det1 < 1e-3;
        }
        function pointOnLine3D(x1, y1, z1, x2, y2, z2, x3, y3, z3) {
          if (z1 === 0 && z2 === 0 && z3 === 0) {
            return pointOnLine2D(x1, y1, x2, y2, x3, y3);
          }
          var dist1 = math.sqrt(math.pow(x2 - x1, 2) + math.pow(y2 - y1, 2) + math.pow(z2 - z1, 2));
          var dist2 = math.sqrt(math.pow(x3 - x1, 2) + math.pow(y3 - y1, 2) + math.pow(z3 - z1, 2));
          var dist3 = math.sqrt(math.pow(x3 - x2, 2) + math.pow(y3 - y2, 2) + math.pow(z3 - z2, 2));
          var diffDist;
          if (dist1 > dist2) {
            if (dist1 > dist3) {
              diffDist = dist1 - dist2 - dist3;
            } else {
              diffDist = dist3 - dist2 - dist1;
            }
          } else if (dist3 > dist2) {
            diffDist = dist3 - dist2 - dist1;
          } else {
            diffDist = dist2 - dist1 - dist3;
          }
          return diffDist > -1e-4 && diffDist < 1e-4;
        }
        var getBezierLength = /* @__PURE__ */ function() {
          return function(pt1, pt2, pt3, pt4) {
            var curveSegments = getDefaultCurveSegments();
            var k;
            var i;
            var len;
            var ptCoord;
            var perc;
            var addedLength = 0;
            var ptDistance;
            var point = [];
            var lastPoint = [];
            var lengthData = bezierLengthPool.newElement();
            len = pt3.length;
            for (k = 0; k < curveSegments; k += 1) {
              perc = k / (curveSegments - 1);
              ptDistance = 0;
              for (i = 0; i < len; i += 1) {
                ptCoord = bmPow(1 - perc, 3) * pt1[i] + 3 * bmPow(1 - perc, 2) * perc * pt3[i] + 3 * (1 - perc) * bmPow(perc, 2) * pt4[i] + bmPow(perc, 3) * pt2[i];
                point[i] = ptCoord;
                if (lastPoint[i] !== null) {
                  ptDistance += bmPow(point[i] - lastPoint[i], 2);
                }
                lastPoint[i] = point[i];
              }
              if (ptDistance) {
                ptDistance = bmSqrt(ptDistance);
                addedLength += ptDistance;
              }
              lengthData.percents[k] = perc;
              lengthData.lengths[k] = addedLength;
            }
            lengthData.addedLength = addedLength;
            return lengthData;
          };
        }();
        function getSegmentsLength(shapeData) {
          var segmentsLength = segmentsLengthPool.newElement();
          var closed = shapeData.c;
          var pathV = shapeData.v;
          var pathO = shapeData.o;
          var pathI = shapeData.i;
          var i;
          var len = shapeData._length;
          var lengths = segmentsLength.lengths;
          var totalLength2 = 0;
          for (i = 0; i < len - 1; i += 1) {
            lengths[i] = getBezierLength(pathV[i], pathV[i + 1], pathO[i], pathI[i + 1]);
            totalLength2 += lengths[i].addedLength;
          }
          if (closed && len) {
            lengths[i] = getBezierLength(pathV[i], pathV[0], pathO[i], pathI[0]);
            totalLength2 += lengths[i].addedLength;
          }
          segmentsLength.totalLength = totalLength2;
          return segmentsLength;
        }
        function BezierData(length2) {
          this.segmentLength = 0;
          this.points = new Array(length2);
        }
        function PointData(partial, point) {
          this.partialLength = partial;
          this.point = point;
        }
        var buildBezierData = /* @__PURE__ */ function() {
          var storedData = {};
          return function(pt1, pt2, pt3, pt4) {
            var bezierName = (pt1[0] + "_" + pt1[1] + "_" + pt2[0] + "_" + pt2[1] + "_" + pt3[0] + "_" + pt3[1] + "_" + pt4[0] + "_" + pt4[1]).replace(/\./g, "p");
            if (!storedData[bezierName]) {
              var curveSegments = getDefaultCurveSegments();
              var k;
              var i;
              var len;
              var ptCoord;
              var perc;
              var addedLength = 0;
              var ptDistance;
              var point;
              var lastPoint = null;
              if (pt1.length === 2 && (pt1[0] !== pt2[0] || pt1[1] !== pt2[1]) && pointOnLine2D(pt1[0], pt1[1], pt2[0], pt2[1], pt1[0] + pt3[0], pt1[1] + pt3[1]) && pointOnLine2D(pt1[0], pt1[1], pt2[0], pt2[1], pt2[0] + pt4[0], pt2[1] + pt4[1])) {
                curveSegments = 2;
              }
              var bezierData = new BezierData(curveSegments);
              len = pt3.length;
              for (k = 0; k < curveSegments; k += 1) {
                point = createSizedArray(len);
                perc = k / (curveSegments - 1);
                ptDistance = 0;
                for (i = 0; i < len; i += 1) {
                  ptCoord = bmPow(1 - perc, 3) * pt1[i] + 3 * bmPow(1 - perc, 2) * perc * (pt1[i] + pt3[i]) + 3 * (1 - perc) * bmPow(perc, 2) * (pt2[i] + pt4[i]) + bmPow(perc, 3) * pt2[i];
                  point[i] = ptCoord;
                  if (lastPoint !== null) {
                    ptDistance += bmPow(point[i] - lastPoint[i], 2);
                  }
                }
                ptDistance = bmSqrt(ptDistance);
                addedLength += ptDistance;
                bezierData.points[k] = new PointData(ptDistance, point);
                lastPoint = point;
              }
              bezierData.segmentLength = addedLength;
              storedData[bezierName] = bezierData;
            }
            return storedData[bezierName];
          };
        }();
        function getDistancePerc(perc, bezierData) {
          var percents = bezierData.percents;
          var lengths = bezierData.lengths;
          var len = percents.length;
          var initPos = bmFloor((len - 1) * perc);
          var lengthPos = perc * bezierData.addedLength;
          var lPerc = 0;
          if (initPos === len - 1 || initPos === 0 || lengthPos === lengths[initPos]) {
            return percents[initPos];
          }
          var dir = lengths[initPos] > lengthPos ? -1 : 1;
          var flag = true;
          while (flag) {
            if (lengths[initPos] <= lengthPos && lengths[initPos + 1] > lengthPos) {
              lPerc = (lengthPos - lengths[initPos]) / (lengths[initPos + 1] - lengths[initPos]);
              flag = false;
            } else {
              initPos += dir;
            }
            if (initPos < 0 || initPos >= len - 1) {
              if (initPos === len - 1) {
                return percents[initPos];
              }
              flag = false;
            }
          }
          return percents[initPos] + (percents[initPos + 1] - percents[initPos]) * lPerc;
        }
        function getPointInSegment(pt1, pt2, pt3, pt4, percent, bezierData) {
          var t1 = getDistancePerc(percent, bezierData);
          var u1 = 1 - t1;
          var ptX = math.round((u1 * u1 * u1 * pt1[0] + (t1 * u1 * u1 + u1 * t1 * u1 + u1 * u1 * t1) * pt3[0] + (t1 * t1 * u1 + u1 * t1 * t1 + t1 * u1 * t1) * pt4[0] + t1 * t1 * t1 * pt2[0]) * 1e3) / 1e3;
          var ptY = math.round((u1 * u1 * u1 * pt1[1] + (t1 * u1 * u1 + u1 * t1 * u1 + u1 * u1 * t1) * pt3[1] + (t1 * t1 * u1 + u1 * t1 * t1 + t1 * u1 * t1) * pt4[1] + t1 * t1 * t1 * pt2[1]) * 1e3) / 1e3;
          return [ptX, ptY];
        }
        var bezierSegmentPoints = createTypedArray("float32", 8);
        function getNewSegment(pt1, pt2, pt3, pt4, startPerc, endPerc, bezierData) {
          if (startPerc < 0) {
            startPerc = 0;
          } else if (startPerc > 1) {
            startPerc = 1;
          }
          var t0 = getDistancePerc(startPerc, bezierData);
          endPerc = endPerc > 1 ? 1 : endPerc;
          var t1 = getDistancePerc(endPerc, bezierData);
          var i;
          var len = pt1.length;
          var u0 = 1 - t0;
          var u1 = 1 - t1;
          var u0u0u0 = u0 * u0 * u0;
          var t0u0u0_3 = t0 * u0 * u0 * 3;
          var t0t0u0_3 = t0 * t0 * u0 * 3;
          var t0t0t0 = t0 * t0 * t0;
          var u0u0u1 = u0 * u0 * u1;
          var t0u0u1_3 = t0 * u0 * u1 + u0 * t0 * u1 + u0 * u0 * t1;
          var t0t0u1_3 = t0 * t0 * u1 + u0 * t0 * t1 + t0 * u0 * t1;
          var t0t0t1 = t0 * t0 * t1;
          var u0u1u1 = u0 * u1 * u1;
          var t0u1u1_3 = t0 * u1 * u1 + u0 * t1 * u1 + u0 * u1 * t1;
          var t0t1u1_3 = t0 * t1 * u1 + u0 * t1 * t1 + t0 * u1 * t1;
          var t0t1t1 = t0 * t1 * t1;
          var u1u1u1 = u1 * u1 * u1;
          var t1u1u1_3 = t1 * u1 * u1 + u1 * t1 * u1 + u1 * u1 * t1;
          var t1t1u1_3 = t1 * t1 * u1 + u1 * t1 * t1 + t1 * u1 * t1;
          var t1t1t1 = t1 * t1 * t1;
          for (i = 0; i < len; i += 1) {
            bezierSegmentPoints[i * 4] = math.round((u0u0u0 * pt1[i] + t0u0u0_3 * pt3[i] + t0t0u0_3 * pt4[i] + t0t0t0 * pt2[i]) * 1e3) / 1e3;
            bezierSegmentPoints[i * 4 + 1] = math.round((u0u0u1 * pt1[i] + t0u0u1_3 * pt3[i] + t0t0u1_3 * pt4[i] + t0t0t1 * pt2[i]) * 1e3) / 1e3;
            bezierSegmentPoints[i * 4 + 2] = math.round((u0u1u1 * pt1[i] + t0u1u1_3 * pt3[i] + t0t1u1_3 * pt4[i] + t0t1t1 * pt2[i]) * 1e3) / 1e3;
            bezierSegmentPoints[i * 4 + 3] = math.round((u1u1u1 * pt1[i] + t1u1u1_3 * pt3[i] + t1t1u1_3 * pt4[i] + t1t1t1 * pt2[i]) * 1e3) / 1e3;
          }
          return bezierSegmentPoints;
        }
        return {
          getSegmentsLength,
          getNewSegment,
          getPointInSegment,
          buildBezierData,
          pointOnLine2D,
          pointOnLine3D
        };
      }
      var bez = bezFunction();
      var initFrame = initialDefaultFrame;
      var mathAbs = Math.abs;
      function interpolateValue(frameNum, caching) {
        var offsetTime = this.offsetTime;
        var newValue;
        if (this.propType === "multidimensional") {
          newValue = createTypedArray("float32", this.pv.length);
        }
        var iterationIndex = caching.lastIndex;
        var i = iterationIndex;
        var len = this.keyframes.length - 1;
        var flag = true;
        var keyData;
        var nextKeyData;
        var keyframeMetadata;
        while (flag) {
          keyData = this.keyframes[i];
          nextKeyData = this.keyframes[i + 1];
          if (i === len - 1 && frameNum >= nextKeyData.t - offsetTime) {
            if (keyData.h) {
              keyData = nextKeyData;
            }
            iterationIndex = 0;
            break;
          }
          if (nextKeyData.t - offsetTime > frameNum) {
            iterationIndex = i;
            break;
          }
          if (i < len - 1) {
            i += 1;
          } else {
            iterationIndex = 0;
            flag = false;
          }
        }
        keyframeMetadata = this.keyframesMetadata[i] || {};
        var k;
        var kLen;
        var perc;
        var jLen;
        var j;
        var fnc;
        var nextKeyTime = nextKeyData.t - offsetTime;
        var keyTime = keyData.t - offsetTime;
        var endValue;
        if (keyData.to) {
          if (!keyframeMetadata.bezierData) {
            keyframeMetadata.bezierData = bez.buildBezierData(keyData.s, nextKeyData.s || keyData.e, keyData.to, keyData.ti);
          }
          var bezierData = keyframeMetadata.bezierData;
          if (frameNum >= nextKeyTime || frameNum < keyTime) {
            var ind = frameNum >= nextKeyTime ? bezierData.points.length - 1 : 0;
            kLen = bezierData.points[ind].point.length;
            for (k = 0; k < kLen; k += 1) {
              newValue[k] = bezierData.points[ind].point[k];
            }
          } else {
            if (keyframeMetadata.__fnct) {
              fnc = keyframeMetadata.__fnct;
            } else {
              fnc = BezierFactory.getBezierEasing(keyData.o.x, keyData.o.y, keyData.i.x, keyData.i.y, keyData.n).get;
              keyframeMetadata.__fnct = fnc;
            }
            perc = fnc((frameNum - keyTime) / (nextKeyTime - keyTime));
            var distanceInLine = bezierData.segmentLength * perc;
            var segmentPerc;
            var addedLength = caching.lastFrame < frameNum && caching._lastKeyframeIndex === i ? caching._lastAddedLength : 0;
            j = caching.lastFrame < frameNum && caching._lastKeyframeIndex === i ? caching._lastPoint : 0;
            flag = true;
            jLen = bezierData.points.length;
            while (flag) {
              addedLength += bezierData.points[j].partialLength;
              if (distanceInLine === 0 || perc === 0 || j === bezierData.points.length - 1) {
                kLen = bezierData.points[j].point.length;
                for (k = 0; k < kLen; k += 1) {
                  newValue[k] = bezierData.points[j].point[k];
                }
                break;
              } else if (distanceInLine >= addedLength && distanceInLine < addedLength + bezierData.points[j + 1].partialLength) {
                segmentPerc = (distanceInLine - addedLength) / bezierData.points[j + 1].partialLength;
                kLen = bezierData.points[j].point.length;
                for (k = 0; k < kLen; k += 1) {
                  newValue[k] = bezierData.points[j].point[k] + (bezierData.points[j + 1].point[k] - bezierData.points[j].point[k]) * segmentPerc;
                }
                break;
              }
              if (j < jLen - 1) {
                j += 1;
              } else {
                flag = false;
              }
            }
            caching._lastPoint = j;
            caching._lastAddedLength = addedLength - bezierData.points[j].partialLength;
            caching._lastKeyframeIndex = i;
          }
        } else {
          var outX;
          var outY;
          var inX;
          var inY;
          var keyValue;
          len = keyData.s.length;
          endValue = nextKeyData.s || keyData.e;
          if (this.sh && keyData.h !== 1) {
            if (frameNum >= nextKeyTime) {
              newValue[0] = endValue[0];
              newValue[1] = endValue[1];
              newValue[2] = endValue[2];
            } else if (frameNum <= keyTime) {
              newValue[0] = keyData.s[0];
              newValue[1] = keyData.s[1];
              newValue[2] = keyData.s[2];
            } else {
              var quatStart = createQuaternion(keyData.s);
              var quatEnd = createQuaternion(endValue);
              var time2 = (frameNum - keyTime) / (nextKeyTime - keyTime);
              quaternionToEuler(newValue, slerp(quatStart, quatEnd, time2));
            }
          } else {
            for (i = 0; i < len; i += 1) {
              if (keyData.h !== 1) {
                if (frameNum >= nextKeyTime) {
                  perc = 1;
                } else if (frameNum < keyTime) {
                  perc = 0;
                } else {
                  if (keyData.o.x.constructor === Array) {
                    if (!keyframeMetadata.__fnct) {
                      keyframeMetadata.__fnct = [];
                    }
                    if (!keyframeMetadata.__fnct[i]) {
                      outX = keyData.o.x[i] === void 0 ? keyData.o.x[0] : keyData.o.x[i];
                      outY = keyData.o.y[i] === void 0 ? keyData.o.y[0] : keyData.o.y[i];
                      inX = keyData.i.x[i] === void 0 ? keyData.i.x[0] : keyData.i.x[i];
                      inY = keyData.i.y[i] === void 0 ? keyData.i.y[0] : keyData.i.y[i];
                      fnc = BezierFactory.getBezierEasing(outX, outY, inX, inY).get;
                      keyframeMetadata.__fnct[i] = fnc;
                    } else {
                      fnc = keyframeMetadata.__fnct[i];
                    }
                  } else if (!keyframeMetadata.__fnct) {
                    outX = keyData.o.x;
                    outY = keyData.o.y;
                    inX = keyData.i.x;
                    inY = keyData.i.y;
                    fnc = BezierFactory.getBezierEasing(outX, outY, inX, inY).get;
                    keyData.keyframeMetadata = fnc;
                  } else {
                    fnc = keyframeMetadata.__fnct;
                  }
                  perc = fnc((frameNum - keyTime) / (nextKeyTime - keyTime));
                }
              }
              endValue = nextKeyData.s || keyData.e;
              keyValue = keyData.h === 1 ? keyData.s[i] : keyData.s[i] + (endValue[i] - keyData.s[i]) * perc;
              if (this.propType === "multidimensional") {
                newValue[i] = keyValue;
              } else {
                newValue = keyValue;
              }
            }
          }
        }
        caching.lastIndex = iterationIndex;
        return newValue;
      }
      function slerp(a, b, t) {
        var out = [];
        var ax = a[0];
        var ay = a[1];
        var az = a[2];
        var aw = a[3];
        var bx = b[0];
        var by = b[1];
        var bz = b[2];
        var bw = b[3];
        var omega;
        var cosom;
        var sinom;
        var scale0;
        var scale1;
        cosom = ax * bx + ay * by + az * bz + aw * bw;
        if (cosom < 0) {
          cosom = -cosom;
          bx = -bx;
          by = -by;
          bz = -bz;
          bw = -bw;
        }
        if (1 - cosom > 1e-6) {
          omega = Math.acos(cosom);
          sinom = Math.sin(omega);
          scale0 = Math.sin((1 - t) * omega) / sinom;
          scale1 = Math.sin(t * omega) / sinom;
        } else {
          scale0 = 1 - t;
          scale1 = t;
        }
        out[0] = scale0 * ax + scale1 * bx;
        out[1] = scale0 * ay + scale1 * by;
        out[2] = scale0 * az + scale1 * bz;
        out[3] = scale0 * aw + scale1 * bw;
        return out;
      }
      function quaternionToEuler(out, quat) {
        var qx = quat[0];
        var qy = quat[1];
        var qz = quat[2];
        var qw = quat[3];
        var heading = Math.atan2(2 * qy * qw - 2 * qx * qz, 1 - 2 * qy * qy - 2 * qz * qz);
        var attitude = Math.asin(2 * qx * qy + 2 * qz * qw);
        var bank = Math.atan2(2 * qx * qw - 2 * qy * qz, 1 - 2 * qx * qx - 2 * qz * qz);
        out[0] = heading / degToRads;
        out[1] = attitude / degToRads;
        out[2] = bank / degToRads;
      }
      function createQuaternion(values) {
        var heading = values[0] * degToRads;
        var attitude = values[1] * degToRads;
        var bank = values[2] * degToRads;
        var c1 = Math.cos(heading / 2);
        var c2 = Math.cos(attitude / 2);
        var c3 = Math.cos(bank / 2);
        var s1 = Math.sin(heading / 2);
        var s2 = Math.sin(attitude / 2);
        var s3 = Math.sin(bank / 2);
        var w = c1 * c2 * c3 - s1 * s2 * s3;
        var x = s1 * s2 * c3 + c1 * c2 * s3;
        var y = s1 * c2 * c3 + c1 * s2 * s3;
        var z = c1 * s2 * c3 - s1 * c2 * s3;
        return [x, y, z, w];
      }
      function getValueAtCurrentTime() {
        var frameNum = this.comp.renderedFrame - this.offsetTime;
        var initTime = this.keyframes[0].t - this.offsetTime;
        var endTime = this.keyframes[this.keyframes.length - 1].t - this.offsetTime;
        if (!(frameNum === this._caching.lastFrame || this._caching.lastFrame !== initFrame && (this._caching.lastFrame >= endTime && frameNum >= endTime || this._caching.lastFrame < initTime && frameNum < initTime))) {
          if (this._caching.lastFrame >= frameNum) {
            this._caching._lastKeyframeIndex = -1;
            this._caching.lastIndex = 0;
          }
          var renderResult = this.interpolateValue(frameNum, this._caching);
          this.pv = renderResult;
        }
        this._caching.lastFrame = frameNum;
        return this.pv;
      }
      function setVValue(val2) {
        var multipliedValue;
        if (this.propType === "unidimensional") {
          multipliedValue = val2 * this.mult;
          if (mathAbs(this.v - multipliedValue) > 1e-5) {
            this.v = multipliedValue;
            this._mdf = true;
          }
        } else {
          var i = 0;
          var len = this.v.length;
          while (i < len) {
            multipliedValue = val2[i] * this.mult;
            if (mathAbs(this.v[i] - multipliedValue) > 1e-5) {
              this.v[i] = multipliedValue;
              this._mdf = true;
            }
            i += 1;
          }
        }
      }
      function processEffectsSequence() {
        if (this.elem.globalData.frameId === this.frameId || !this.effectsSequence.length) {
          return;
        }
        if (this.lock) {
          this.setVValue(this.pv);
          return;
        }
        this.lock = true;
        this._mdf = this._isFirstFrame;
        var i;
        var len = this.effectsSequence.length;
        var finalValue = this.kf ? this.pv : this.data.k;
        for (i = 0; i < len; i += 1) {
          finalValue = this.effectsSequence[i](finalValue);
        }
        this.setVValue(finalValue);
        this._isFirstFrame = false;
        this.lock = false;
        this.frameId = this.elem.globalData.frameId;
      }
      function addEffect(effectFunction) {
        this.effectsSequence.push(effectFunction);
        this.container.addDynamicProperty(this);
      }
      function ValueProperty(elem2, data2, mult, container) {
        this.propType = "unidimensional";
        this.mult = mult || 1;
        this.data = data2;
        this.v = mult ? data2.k * mult : data2.k;
        this.pv = data2.k;
        this._mdf = false;
        this.elem = elem2;
        this.container = container;
        this.comp = elem2.comp;
        this.k = false;
        this.kf = false;
        this.vel = 0;
        this.effectsSequence = [];
        this._isFirstFrame = true;
        this.getValue = processEffectsSequence;
        this.setVValue = setVValue;
        this.addEffect = addEffect;
      }
      function MultiDimensionalProperty(elem2, data2, mult, container) {
        this.propType = "multidimensional";
        this.mult = mult || 1;
        this.data = data2;
        this._mdf = false;
        this.elem = elem2;
        this.container = container;
        this.comp = elem2.comp;
        this.k = false;
        this.kf = false;
        this.frameId = -1;
        var i;
        var len = data2.k.length;
        this.v = createTypedArray("float32", len);
        this.pv = createTypedArray("float32", len);
        this.vel = createTypedArray("float32", len);
        for (i = 0; i < len; i += 1) {
          this.v[i] = data2.k[i] * this.mult;
          this.pv[i] = data2.k[i];
        }
        this._isFirstFrame = true;
        this.effectsSequence = [];
        this.getValue = processEffectsSequence;
        this.setVValue = setVValue;
        this.addEffect = addEffect;
      }
      function KeyframedValueProperty(elem2, data2, mult, container) {
        this.propType = "unidimensional";
        this.keyframes = data2.k;
        this.keyframesMetadata = [];
        this.offsetTime = elem2.data.st;
        this.frameId = -1;
        this._caching = {
          lastFrame: initFrame,
          lastIndex: 0,
          value: 0,
          _lastKeyframeIndex: -1
        };
        this.k = true;
        this.kf = true;
        this.data = data2;
        this.mult = mult || 1;
        this.elem = elem2;
        this.container = container;
        this.comp = elem2.comp;
        this.v = initFrame;
        this.pv = initFrame;
        this._isFirstFrame = true;
        this.getValue = processEffectsSequence;
        this.setVValue = setVValue;
        this.interpolateValue = interpolateValue;
        this.effectsSequence = [getValueAtCurrentTime.bind(this)];
        this.addEffect = addEffect;
      }
      function KeyframedMultidimensionalProperty(elem2, data2, mult, container) {
        this.propType = "multidimensional";
        var i;
        var len = data2.k.length;
        var s;
        var e;
        var to;
        var ti;
        for (i = 0; i < len - 1; i += 1) {
          if (data2.k[i].to && data2.k[i].s && data2.k[i + 1] && data2.k[i + 1].s) {
            s = data2.k[i].s;
            e = data2.k[i + 1].s;
            to = data2.k[i].to;
            ti = data2.k[i].ti;
            if (s.length === 2 && !(s[0] === e[0] && s[1] === e[1]) && bez.pointOnLine2D(s[0], s[1], e[0], e[1], s[0] + to[0], s[1] + to[1]) && bez.pointOnLine2D(s[0], s[1], e[0], e[1], e[0] + ti[0], e[1] + ti[1]) || s.length === 3 && !(s[0] === e[0] && s[1] === e[1] && s[2] === e[2]) && bez.pointOnLine3D(s[0], s[1], s[2], e[0], e[1], e[2], s[0] + to[0], s[1] + to[1], s[2] + to[2]) && bez.pointOnLine3D(s[0], s[1], s[2], e[0], e[1], e[2], e[0] + ti[0], e[1] + ti[1], e[2] + ti[2])) {
              data2.k[i].to = null;
              data2.k[i].ti = null;
            }
            if (s[0] === e[0] && s[1] === e[1] && to[0] === 0 && to[1] === 0 && ti[0] === 0 && ti[1] === 0) {
              if (s.length === 2 || s[2] === e[2] && to[2] === 0 && ti[2] === 0) {
                data2.k[i].to = null;
                data2.k[i].ti = null;
              }
            }
          }
        }
        this.effectsSequence = [getValueAtCurrentTime.bind(this)];
        this.data = data2;
        this.keyframes = data2.k;
        this.keyframesMetadata = [];
        this.offsetTime = elem2.data.st;
        this.k = true;
        this.kf = true;
        this._isFirstFrame = true;
        this.mult = mult || 1;
        this.elem = elem2;
        this.container = container;
        this.comp = elem2.comp;
        this.getValue = processEffectsSequence;
        this.setVValue = setVValue;
        this.interpolateValue = interpolateValue;
        this.frameId = -1;
        var arrLen = data2.k[0].s.length;
        this.v = createTypedArray("float32", arrLen);
        this.pv = createTypedArray("float32", arrLen);
        for (i = 0; i < arrLen; i += 1) {
          this.v[i] = initFrame;
          this.pv[i] = initFrame;
        }
        this._caching = {
          lastFrame: initFrame,
          lastIndex: 0,
          value: createTypedArray("float32", arrLen)
        };
        this.addEffect = addEffect;
      }
      var PropertyFactory = /* @__PURE__ */ function() {
        function getProp(elem2, data2, type, mult, container) {
          if (data2.sid) {
            data2 = elem2.globalData.slotManager.getProp(data2);
          }
          var p;
          if (!data2.k.length) {
            p = new ValueProperty(elem2, data2, mult, container);
          } else if (typeof data2.k[0] === "number") {
            p = new MultiDimensionalProperty(elem2, data2, mult, container);
          } else {
            switch (type) {
              case 0:
                p = new KeyframedValueProperty(elem2, data2, mult, container);
                break;
              case 1:
                p = new KeyframedMultidimensionalProperty(elem2, data2, mult, container);
                break;
              default:
                break;
            }
          }
          if (p.effectsSequence.length) {
            container.addDynamicProperty(p);
          }
          return p;
        }
        var ob2 = {
          getProp
        };
        return ob2;
      }();
      function DynamicPropertyContainer() {
      }
      DynamicPropertyContainer.prototype = {
        addDynamicProperty: function addDynamicProperty(prop) {
          if (this.dynamicProperties.indexOf(prop) === -1) {
            this.dynamicProperties.push(prop);
            this.container.addDynamicProperty(this);
            this._isAnimated = true;
          }
        },
        iterateDynamicProperties: function iterateDynamicProperties() {
          this._mdf = false;
          var i;
          var len = this.dynamicProperties.length;
          for (i = 0; i < len; i += 1) {
            this.dynamicProperties[i].getValue();
            if (this.dynamicProperties[i]._mdf) {
              this._mdf = true;
            }
          }
        },
        initDynamicPropertyContainer: function initDynamicPropertyContainer(container) {
          this.container = container;
          this.dynamicProperties = [];
          this._mdf = false;
          this._isAnimated = false;
        }
      };
      var pointPool = function() {
        function create() {
          return createTypedArray("float32", 2);
        }
        return poolFactory(8, create);
      }();
      function ShapePath() {
        this.c = false;
        this._length = 0;
        this._maxLength = 8;
        this.v = createSizedArray(this._maxLength);
        this.o = createSizedArray(this._maxLength);
        this.i = createSizedArray(this._maxLength);
      }
      ShapePath.prototype.setPathData = function(closed, len) {
        this.c = closed;
        this.setLength(len);
        var i = 0;
        while (i < len) {
          this.v[i] = pointPool.newElement();
          this.o[i] = pointPool.newElement();
          this.i[i] = pointPool.newElement();
          i += 1;
        }
      };
      ShapePath.prototype.setLength = function(len) {
        while (this._maxLength < len) {
          this.doubleArrayLength();
        }
        this._length = len;
      };
      ShapePath.prototype.doubleArrayLength = function() {
        this.v = this.v.concat(createSizedArray(this._maxLength));
        this.i = this.i.concat(createSizedArray(this._maxLength));
        this.o = this.o.concat(createSizedArray(this._maxLength));
        this._maxLength *= 2;
      };
      ShapePath.prototype.setXYAt = function(x, y, type, pos, replace) {
        var arr;
        this._length = Math.max(this._length, pos + 1);
        if (this._length >= this._maxLength) {
          this.doubleArrayLength();
        }
        switch (type) {
          case "v":
            arr = this.v;
            break;
          case "i":
            arr = this.i;
            break;
          case "o":
            arr = this.o;
            break;
          default:
            arr = [];
            break;
        }
        if (!arr[pos] || arr[pos] && !replace) {
          arr[pos] = pointPool.newElement();
        }
        arr[pos][0] = x;
        arr[pos][1] = y;
      };
      ShapePath.prototype.setTripleAt = function(vX, vY, oX, oY, iX, iY, pos, replace) {
        this.setXYAt(vX, vY, "v", pos, replace);
        this.setXYAt(oX, oY, "o", pos, replace);
        this.setXYAt(iX, iY, "i", pos, replace);
      };
      ShapePath.prototype.reverse = function() {
        var newPath = new ShapePath();
        newPath.setPathData(this.c, this._length);
        var vertices = this.v;
        var outPoints = this.o;
        var inPoints = this.i;
        var init = 0;
        if (this.c) {
          newPath.setTripleAt(vertices[0][0], vertices[0][1], inPoints[0][0], inPoints[0][1], outPoints[0][0], outPoints[0][1], 0, false);
          init = 1;
        }
        var cnt = this._length - 1;
        var len = this._length;
        var i;
        for (i = init; i < len; i += 1) {
          newPath.setTripleAt(vertices[cnt][0], vertices[cnt][1], inPoints[cnt][0], inPoints[cnt][1], outPoints[cnt][0], outPoints[cnt][1], i, false);
          cnt -= 1;
        }
        return newPath;
      };
      ShapePath.prototype.length = function() {
        return this._length;
      };
      var shapePool = function() {
        function create() {
          return new ShapePath();
        }
        function release(shapePath) {
          var len = shapePath._length;
          var i;
          for (i = 0; i < len; i += 1) {
            pointPool.release(shapePath.v[i]);
            pointPool.release(shapePath.i[i]);
            pointPool.release(shapePath.o[i]);
            shapePath.v[i] = null;
            shapePath.i[i] = null;
            shapePath.o[i] = null;
          }
          shapePath._length = 0;
          shapePath.c = false;
        }
        function clone(shape) {
          var cloned = factory.newElement();
          var i;
          var len = shape._length === void 0 ? shape.v.length : shape._length;
          cloned.setLength(len);
          cloned.c = shape.c;
          for (i = 0; i < len; i += 1) {
            cloned.setTripleAt(shape.v[i][0], shape.v[i][1], shape.o[i][0], shape.o[i][1], shape.i[i][0], shape.i[i][1], i);
          }
          return cloned;
        }
        var factory = poolFactory(4, create, release);
        factory.clone = clone;
        return factory;
      }();
      function ShapeCollection() {
        this._length = 0;
        this._maxLength = 4;
        this.shapes = createSizedArray(this._maxLength);
      }
      ShapeCollection.prototype.addShape = function(shapeData) {
        if (this._length === this._maxLength) {
          this.shapes = this.shapes.concat(createSizedArray(this._maxLength));
          this._maxLength *= 2;
        }
        this.shapes[this._length] = shapeData;
        this._length += 1;
      };
      ShapeCollection.prototype.releaseShapes = function() {
        var i;
        for (i = 0; i < this._length; i += 1) {
          shapePool.release(this.shapes[i]);
        }
        this._length = 0;
      };
      var shapeCollectionPool = function() {
        var ob2 = {
          newShapeCollection,
          release
        };
        var _length = 0;
        var _maxLength = 4;
        var pool = createSizedArray(_maxLength);
        function newShapeCollection() {
          var shapeCollection;
          if (_length) {
            _length -= 1;
            shapeCollection = pool[_length];
          } else {
            shapeCollection = new ShapeCollection();
          }
          return shapeCollection;
        }
        function release(shapeCollection) {
          var i;
          var len = shapeCollection._length;
          for (i = 0; i < len; i += 1) {
            shapePool.release(shapeCollection.shapes[i]);
          }
          shapeCollection._length = 0;
          if (_length === _maxLength) {
            pool = pooling["double"](pool);
            _maxLength *= 2;
          }
          pool[_length] = shapeCollection;
          _length += 1;
        }
        return ob2;
      }();
      var ShapePropertyFactory = function() {
        var initFrame2 = -999999;
        function interpolateShape(frameNum, previousValue, caching) {
          var iterationIndex = caching.lastIndex;
          var keyPropS;
          var keyPropE;
          var isHold;
          var j;
          var k;
          var jLen;
          var kLen;
          var perc;
          var vertexValue;
          var kf = this.keyframes;
          if (frameNum < kf[0].t - this.offsetTime) {
            keyPropS = kf[0].s[0];
            isHold = true;
            iterationIndex = 0;
          } else if (frameNum >= kf[kf.length - 1].t - this.offsetTime) {
            keyPropS = kf[kf.length - 1].s ? kf[kf.length - 1].s[0] : kf[kf.length - 2].e[0];
            isHold = true;
          } else {
            var i = iterationIndex;
            var len = kf.length - 1;
            var flag = true;
            var keyData;
            var nextKeyData;
            var keyframeMetadata;
            while (flag) {
              keyData = kf[i];
              nextKeyData = kf[i + 1];
              if (nextKeyData.t - this.offsetTime > frameNum) {
                break;
              }
              if (i < len - 1) {
                i += 1;
              } else {
                flag = false;
              }
            }
            keyframeMetadata = this.keyframesMetadata[i] || {};
            isHold = keyData.h === 1;
            iterationIndex = i;
            if (!isHold) {
              if (frameNum >= nextKeyData.t - this.offsetTime) {
                perc = 1;
              } else if (frameNum < keyData.t - this.offsetTime) {
                perc = 0;
              } else {
                var fnc;
                if (keyframeMetadata.__fnct) {
                  fnc = keyframeMetadata.__fnct;
                } else {
                  fnc = BezierFactory.getBezierEasing(keyData.o.x, keyData.o.y, keyData.i.x, keyData.i.y).get;
                  keyframeMetadata.__fnct = fnc;
                }
                perc = fnc((frameNum - (keyData.t - this.offsetTime)) / (nextKeyData.t - this.offsetTime - (keyData.t - this.offsetTime)));
              }
              keyPropE = nextKeyData.s ? nextKeyData.s[0] : keyData.e[0];
            }
            keyPropS = keyData.s[0];
          }
          jLen = previousValue._length;
          kLen = keyPropS.i[0].length;
          caching.lastIndex = iterationIndex;
          for (j = 0; j < jLen; j += 1) {
            for (k = 0; k < kLen; k += 1) {
              vertexValue = isHold ? keyPropS.i[j][k] : keyPropS.i[j][k] + (keyPropE.i[j][k] - keyPropS.i[j][k]) * perc;
              previousValue.i[j][k] = vertexValue;
              vertexValue = isHold ? keyPropS.o[j][k] : keyPropS.o[j][k] + (keyPropE.o[j][k] - keyPropS.o[j][k]) * perc;
              previousValue.o[j][k] = vertexValue;
              vertexValue = isHold ? keyPropS.v[j][k] : keyPropS.v[j][k] + (keyPropE.v[j][k] - keyPropS.v[j][k]) * perc;
              previousValue.v[j][k] = vertexValue;
            }
          }
        }
        function interpolateShapeCurrentTime() {
          var frameNum = this.comp.renderedFrame - this.offsetTime;
          var initTime = this.keyframes[0].t - this.offsetTime;
          var endTime = this.keyframes[this.keyframes.length - 1].t - this.offsetTime;
          var lastFrame = this._caching.lastFrame;
          if (!(lastFrame !== initFrame2 && (lastFrame < initTime && frameNum < initTime || lastFrame > endTime && frameNum > endTime))) {
            this._caching.lastIndex = lastFrame < frameNum ? this._caching.lastIndex : 0;
            this.interpolateShape(frameNum, this.pv, this._caching);
          }
          this._caching.lastFrame = frameNum;
          return this.pv;
        }
        function resetShape() {
          this.paths = this.localShapeCollection;
        }
        function shapesEqual(shape1, shape2) {
          if (shape1._length !== shape2._length || shape1.c !== shape2.c) {
            return false;
          }
          var i;
          var len = shape1._length;
          for (i = 0; i < len; i += 1) {
            if (shape1.v[i][0] !== shape2.v[i][0] || shape1.v[i][1] !== shape2.v[i][1] || shape1.o[i][0] !== shape2.o[i][0] || shape1.o[i][1] !== shape2.o[i][1] || shape1.i[i][0] !== shape2.i[i][0] || shape1.i[i][1] !== shape2.i[i][1]) {
              return false;
            }
          }
          return true;
        }
        function setVValue2(newPath) {
          if (!shapesEqual(this.v, newPath)) {
            this.v = shapePool.clone(newPath);
            this.localShapeCollection.releaseShapes();
            this.localShapeCollection.addShape(this.v);
            this._mdf = true;
            this.paths = this.localShapeCollection;
          }
        }
        function processEffectsSequence2() {
          if (this.elem.globalData.frameId === this.frameId) {
            return;
          }
          if (!this.effectsSequence.length) {
            this._mdf = false;
            return;
          }
          if (this.lock) {
            this.setVValue(this.pv);
            return;
          }
          this.lock = true;
          this._mdf = false;
          var finalValue;
          if (this.kf) {
            finalValue = this.pv;
          } else if (this.data.ks) {
            finalValue = this.data.ks.k;
          } else {
            finalValue = this.data.pt.k;
          }
          var i;
          var len = this.effectsSequence.length;
          for (i = 0; i < len; i += 1) {
            finalValue = this.effectsSequence[i](finalValue);
          }
          this.setVValue(finalValue);
          this.lock = false;
          this.frameId = this.elem.globalData.frameId;
        }
        function ShapeProperty(elem2, data2, type) {
          this.propType = "shape";
          this.comp = elem2.comp;
          this.container = elem2;
          this.elem = elem2;
          this.data = data2;
          this.k = false;
          this.kf = false;
          this._mdf = false;
          var pathData = type === 3 ? data2.pt.k : data2.ks.k;
          this.v = shapePool.clone(pathData);
          this.pv = shapePool.clone(this.v);
          this.localShapeCollection = shapeCollectionPool.newShapeCollection();
          this.paths = this.localShapeCollection;
          this.paths.addShape(this.v);
          this.reset = resetShape;
          this.effectsSequence = [];
        }
        function addEffect2(effectFunction) {
          this.effectsSequence.push(effectFunction);
          this.container.addDynamicProperty(this);
        }
        ShapeProperty.prototype.interpolateShape = interpolateShape;
        ShapeProperty.prototype.getValue = processEffectsSequence2;
        ShapeProperty.prototype.setVValue = setVValue2;
        ShapeProperty.prototype.addEffect = addEffect2;
        function KeyframedShapeProperty(elem2, data2, type) {
          this.propType = "shape";
          this.comp = elem2.comp;
          this.elem = elem2;
          this.container = elem2;
          this.offsetTime = elem2.data.st;
          this.keyframes = type === 3 ? data2.pt.k : data2.ks.k;
          this.keyframesMetadata = [];
          this.k = true;
          this.kf = true;
          var len = this.keyframes[0].s[0].i.length;
          this.v = shapePool.newElement();
          this.v.setPathData(this.keyframes[0].s[0].c, len);
          this.pv = shapePool.clone(this.v);
          this.localShapeCollection = shapeCollectionPool.newShapeCollection();
          this.paths = this.localShapeCollection;
          this.paths.addShape(this.v);
          this.lastFrame = initFrame2;
          this.reset = resetShape;
          this._caching = {
            lastFrame: initFrame2,
            lastIndex: 0
          };
          this.effectsSequence = [interpolateShapeCurrentTime.bind(this)];
        }
        KeyframedShapeProperty.prototype.getValue = processEffectsSequence2;
        KeyframedShapeProperty.prototype.interpolateShape = interpolateShape;
        KeyframedShapeProperty.prototype.setVValue = setVValue2;
        KeyframedShapeProperty.prototype.addEffect = addEffect2;
        var EllShapeProperty = function() {
          var cPoint = roundCorner;
          function EllShapePropertyFactory(elem2, data2) {
            this.v = shapePool.newElement();
            this.v.setPathData(true, 4);
            this.localShapeCollection = shapeCollectionPool.newShapeCollection();
            this.paths = this.localShapeCollection;
            this.localShapeCollection.addShape(this.v);
            this.d = data2.d;
            this.elem = elem2;
            this.comp = elem2.comp;
            this.frameId = -1;
            this.initDynamicPropertyContainer(elem2);
            this.p = PropertyFactory.getProp(elem2, data2.p, 1, 0, this);
            this.s = PropertyFactory.getProp(elem2, data2.s, 1, 0, this);
            if (this.dynamicProperties.length) {
              this.k = true;
            } else {
              this.k = false;
              this.convertEllToPath();
            }
          }
          EllShapePropertyFactory.prototype = {
            reset: resetShape,
            getValue: function getValue() {
              if (this.elem.globalData.frameId === this.frameId) {
                return;
              }
              this.frameId = this.elem.globalData.frameId;
              this.iterateDynamicProperties();
              if (this._mdf) {
                this.convertEllToPath();
              }
            },
            convertEllToPath: function convertEllToPath() {
              var p0 = this.p.v[0];
              var p1 = this.p.v[1];
              var s0 = this.s.v[0] / 2;
              var s1 = this.s.v[1] / 2;
              var _cw = this.d !== 3;
              var _v = this.v;
              _v.v[0][0] = p0;
              _v.v[0][1] = p1 - s1;
              _v.v[1][0] = _cw ? p0 + s0 : p0 - s0;
              _v.v[1][1] = p1;
              _v.v[2][0] = p0;
              _v.v[2][1] = p1 + s1;
              _v.v[3][0] = _cw ? p0 - s0 : p0 + s0;
              _v.v[3][1] = p1;
              _v.i[0][0] = _cw ? p0 - s0 * cPoint : p0 + s0 * cPoint;
              _v.i[0][1] = p1 - s1;
              _v.i[1][0] = _cw ? p0 + s0 : p0 - s0;
              _v.i[1][1] = p1 - s1 * cPoint;
              _v.i[2][0] = _cw ? p0 + s0 * cPoint : p0 - s0 * cPoint;
              _v.i[2][1] = p1 + s1;
              _v.i[3][0] = _cw ? p0 - s0 : p0 + s0;
              _v.i[3][1] = p1 + s1 * cPoint;
              _v.o[0][0] = _cw ? p0 + s0 * cPoint : p0 - s0 * cPoint;
              _v.o[0][1] = p1 - s1;
              _v.o[1][0] = _cw ? p0 + s0 : p0 - s0;
              _v.o[1][1] = p1 + s1 * cPoint;
              _v.o[2][0] = _cw ? p0 - s0 * cPoint : p0 + s0 * cPoint;
              _v.o[2][1] = p1 + s1;
              _v.o[3][0] = _cw ? p0 - s0 : p0 + s0;
              _v.o[3][1] = p1 - s1 * cPoint;
            }
          };
          extendPrototype([DynamicPropertyContainer], EllShapePropertyFactory);
          return EllShapePropertyFactory;
        }();
        var StarShapeProperty = function() {
          function StarShapePropertyFactory(elem2, data2) {
            this.v = shapePool.newElement();
            this.v.setPathData(true, 0);
            this.elem = elem2;
            this.comp = elem2.comp;
            this.data = data2;
            this.frameId = -1;
            this.d = data2.d;
            this.initDynamicPropertyContainer(elem2);
            if (data2.sy === 1) {
              this.ir = PropertyFactory.getProp(elem2, data2.ir, 0, 0, this);
              this.is = PropertyFactory.getProp(elem2, data2.is, 0, 0.01, this);
              this.convertToPath = this.convertStarToPath;
            } else {
              this.convertToPath = this.convertPolygonToPath;
            }
            this.pt = PropertyFactory.getProp(elem2, data2.pt, 0, 0, this);
            this.p = PropertyFactory.getProp(elem2, data2.p, 1, 0, this);
            this.r = PropertyFactory.getProp(elem2, data2.r, 0, degToRads, this);
            this.or = PropertyFactory.getProp(elem2, data2.or, 0, 0, this);
            this.os = PropertyFactory.getProp(elem2, data2.os, 0, 0.01, this);
            this.localShapeCollection = shapeCollectionPool.newShapeCollection();
            this.localShapeCollection.addShape(this.v);
            this.paths = this.localShapeCollection;
            if (this.dynamicProperties.length) {
              this.k = true;
            } else {
              this.k = false;
              this.convertToPath();
            }
          }
          StarShapePropertyFactory.prototype = {
            reset: resetShape,
            getValue: function getValue() {
              if (this.elem.globalData.frameId === this.frameId) {
                return;
              }
              this.frameId = this.elem.globalData.frameId;
              this.iterateDynamicProperties();
              if (this._mdf) {
                this.convertToPath();
              }
            },
            convertStarToPath: function convertStarToPath() {
              var numPts = Math.floor(this.pt.v) * 2;
              var angle = Math.PI * 2 / numPts;
              var longFlag = true;
              var longRad = this.or.v;
              var shortRad = this.ir.v;
              var longRound = this.os.v;
              var shortRound = this.is.v;
              var longPerimSegment = 2 * Math.PI * longRad / (numPts * 2);
              var shortPerimSegment = 2 * Math.PI * shortRad / (numPts * 2);
              var i;
              var rad;
              var roundness;
              var perimSegment;
              var currentAng = -Math.PI / 2;
              currentAng += this.r.v;
              var dir = this.data.d === 3 ? -1 : 1;
              this.v._length = 0;
              for (i = 0; i < numPts; i += 1) {
                rad = longFlag ? longRad : shortRad;
                roundness = longFlag ? longRound : shortRound;
                perimSegment = longFlag ? longPerimSegment : shortPerimSegment;
                var x = rad * Math.cos(currentAng);
                var y = rad * Math.sin(currentAng);
                var ox = x === 0 && y === 0 ? 0 : y / Math.sqrt(x * x + y * y);
                var oy = x === 0 && y === 0 ? 0 : -x / Math.sqrt(x * x + y * y);
                x += +this.p.v[0];
                y += +this.p.v[1];
                this.v.setTripleAt(x, y, x - ox * perimSegment * roundness * dir, y - oy * perimSegment * roundness * dir, x + ox * perimSegment * roundness * dir, y + oy * perimSegment * roundness * dir, i, true);
                longFlag = !longFlag;
                currentAng += angle * dir;
              }
            },
            convertPolygonToPath: function convertPolygonToPath() {
              var numPts = Math.floor(this.pt.v);
              var angle = Math.PI * 2 / numPts;
              var rad = this.or.v;
              var roundness = this.os.v;
              var perimSegment = 2 * Math.PI * rad / (numPts * 4);
              var i;
              var currentAng = -Math.PI * 0.5;
              var dir = this.data.d === 3 ? -1 : 1;
              currentAng += this.r.v;
              this.v._length = 0;
              for (i = 0; i < numPts; i += 1) {
                var x = rad * Math.cos(currentAng);
                var y = rad * Math.sin(currentAng);
                var ox = x === 0 && y === 0 ? 0 : y / Math.sqrt(x * x + y * y);
                var oy = x === 0 && y === 0 ? 0 : -x / Math.sqrt(x * x + y * y);
                x += +this.p.v[0];
                y += +this.p.v[1];
                this.v.setTripleAt(x, y, x - ox * perimSegment * roundness * dir, y - oy * perimSegment * roundness * dir, x + ox * perimSegment * roundness * dir, y + oy * perimSegment * roundness * dir, i, true);
                currentAng += angle * dir;
              }
              this.paths.length = 0;
              this.paths[0] = this.v;
            }
          };
          extendPrototype([DynamicPropertyContainer], StarShapePropertyFactory);
          return StarShapePropertyFactory;
        }();
        var RectShapeProperty = function() {
          function RectShapePropertyFactory(elem2, data2) {
            this.v = shapePool.newElement();
            this.v.c = true;
            this.localShapeCollection = shapeCollectionPool.newShapeCollection();
            this.localShapeCollection.addShape(this.v);
            this.paths = this.localShapeCollection;
            this.elem = elem2;
            this.comp = elem2.comp;
            this.frameId = -1;
            this.d = data2.d;
            this.initDynamicPropertyContainer(elem2);
            this.p = PropertyFactory.getProp(elem2, data2.p, 1, 0, this);
            this.s = PropertyFactory.getProp(elem2, data2.s, 1, 0, this);
            this.r = PropertyFactory.getProp(elem2, data2.r, 0, 0, this);
            if (this.dynamicProperties.length) {
              this.k = true;
            } else {
              this.k = false;
              this.convertRectToPath();
            }
          }
          RectShapePropertyFactory.prototype = {
            convertRectToPath: function convertRectToPath() {
              var p0 = this.p.v[0];
              var p1 = this.p.v[1];
              var v0 = this.s.v[0] / 2;
              var v1 = this.s.v[1] / 2;
              var round = bmMin(v0, v1, this.r.v);
              var cPoint = round * (1 - roundCorner);
              this.v._length = 0;
              if (this.d === 2 || this.d === 1) {
                this.v.setTripleAt(p0 + v0, p1 - v1 + round, p0 + v0, p1 - v1 + round, p0 + v0, p1 - v1 + cPoint, 0, true);
                this.v.setTripleAt(p0 + v0, p1 + v1 - round, p0 + v0, p1 + v1 - cPoint, p0 + v0, p1 + v1 - round, 1, true);
                if (round !== 0) {
                  this.v.setTripleAt(p0 + v0 - round, p1 + v1, p0 + v0 - round, p1 + v1, p0 + v0 - cPoint, p1 + v1, 2, true);
                  this.v.setTripleAt(p0 - v0 + round, p1 + v1, p0 - v0 + cPoint, p1 + v1, p0 - v0 + round, p1 + v1, 3, true);
                  this.v.setTripleAt(p0 - v0, p1 + v1 - round, p0 - v0, p1 + v1 - round, p0 - v0, p1 + v1 - cPoint, 4, true);
                  this.v.setTripleAt(p0 - v0, p1 - v1 + round, p0 - v0, p1 - v1 + cPoint, p0 - v0, p1 - v1 + round, 5, true);
                  this.v.setTripleAt(p0 - v0 + round, p1 - v1, p0 - v0 + round, p1 - v1, p0 - v0 + cPoint, p1 - v1, 6, true);
                  this.v.setTripleAt(p0 + v0 - round, p1 - v1, p0 + v0 - cPoint, p1 - v1, p0 + v0 - round, p1 - v1, 7, true);
                } else {
                  this.v.setTripleAt(p0 - v0, p1 + v1, p0 - v0 + cPoint, p1 + v1, p0 - v0, p1 + v1, 2);
                  this.v.setTripleAt(p0 - v0, p1 - v1, p0 - v0, p1 - v1 + cPoint, p0 - v0, p1 - v1, 3);
                }
              } else {
                this.v.setTripleAt(p0 + v0, p1 - v1 + round, p0 + v0, p1 - v1 + cPoint, p0 + v0, p1 - v1 + round, 0, true);
                if (round !== 0) {
                  this.v.setTripleAt(p0 + v0 - round, p1 - v1, p0 + v0 - round, p1 - v1, p0 + v0 - cPoint, p1 - v1, 1, true);
                  this.v.setTripleAt(p0 - v0 + round, p1 - v1, p0 - v0 + cPoint, p1 - v1, p0 - v0 + round, p1 - v1, 2, true);
                  this.v.setTripleAt(p0 - v0, p1 - v1 + round, p0 - v0, p1 - v1 + round, p0 - v0, p1 - v1 + cPoint, 3, true);
                  this.v.setTripleAt(p0 - v0, p1 + v1 - round, p0 - v0, p1 + v1 - cPoint, p0 - v0, p1 + v1 - round, 4, true);
                  this.v.setTripleAt(p0 - v0 + round, p1 + v1, p0 - v0 + round, p1 + v1, p0 - v0 + cPoint, p1 + v1, 5, true);
                  this.v.setTripleAt(p0 + v0 - round, p1 + v1, p0 + v0 - cPoint, p1 + v1, p0 + v0 - round, p1 + v1, 6, true);
                  this.v.setTripleAt(p0 + v0, p1 + v1 - round, p0 + v0, p1 + v1 - round, p0 + v0, p1 + v1 - cPoint, 7, true);
                } else {
                  this.v.setTripleAt(p0 - v0, p1 - v1, p0 - v0 + cPoint, p1 - v1, p0 - v0, p1 - v1, 1, true);
                  this.v.setTripleAt(p0 - v0, p1 + v1, p0 - v0, p1 + v1 - cPoint, p0 - v0, p1 + v1, 2, true);
                  this.v.setTripleAt(p0 + v0, p1 + v1, p0 + v0 - cPoint, p1 + v1, p0 + v0, p1 + v1, 3, true);
                }
              }
            },
            getValue: function getValue() {
              if (this.elem.globalData.frameId === this.frameId) {
                return;
              }
              this.frameId = this.elem.globalData.frameId;
              this.iterateDynamicProperties();
              if (this._mdf) {
                this.convertRectToPath();
              }
            },
            reset: resetShape
          };
          extendPrototype([DynamicPropertyContainer], RectShapePropertyFactory);
          return RectShapePropertyFactory;
        }();
        function getShapeProp(elem2, data2, type) {
          var prop;
          if (type === 3 || type === 4) {
            var dataProp = type === 3 ? data2.pt : data2.ks;
            var keys = dataProp.k;
            if (keys.length) {
              prop = new KeyframedShapeProperty(elem2, data2, type);
            } else {
              prop = new ShapeProperty(elem2, data2, type);
            }
          } else if (type === 5) {
            prop = new RectShapeProperty(elem2, data2);
          } else if (type === 6) {
            prop = new EllShapeProperty(elem2, data2);
          } else if (type === 7) {
            prop = new StarShapeProperty(elem2, data2);
          }
          if (prop.k) {
            elem2.addDynamicProperty(prop);
          }
          return prop;
        }
        function getConstructorFunction() {
          return ShapeProperty;
        }
        function getKeyframedConstructorFunction() {
          return KeyframedShapeProperty;
        }
        var ob2 = {};
        ob2.getShapeProp = getShapeProp;
        ob2.getConstructorFunction = getConstructorFunction;
        ob2.getKeyframedConstructorFunction = getKeyframedConstructorFunction;
        return ob2;
      }();
      var Matrix = /* @__PURE__ */ function() {
        var _cos = Math.cos;
        var _sin = Math.sin;
        var _tan = Math.tan;
        var _rnd = Math.round;
        function reset() {
          this.props[0] = 1;
          this.props[1] = 0;
          this.props[2] = 0;
          this.props[3] = 0;
          this.props[4] = 0;
          this.props[5] = 1;
          this.props[6] = 0;
          this.props[7] = 0;
          this.props[8] = 0;
          this.props[9] = 0;
          this.props[10] = 1;
          this.props[11] = 0;
          this.props[12] = 0;
          this.props[13] = 0;
          this.props[14] = 0;
          this.props[15] = 1;
          return this;
        }
        function rotate4(angle) {
          if (angle === 0) {
            return this;
          }
          var mCos = _cos(angle);
          var mSin = _sin(angle);
          return this._t(mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        }
        function rotateX(angle) {
          if (angle === 0) {
            return this;
          }
          var mCos = _cos(angle);
          var mSin = _sin(angle);
          return this._t(1, 0, 0, 0, 0, mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1);
        }
        function rotateY(angle) {
          if (angle === 0) {
            return this;
          }
          var mCos = _cos(angle);
          var mSin = _sin(angle);
          return this._t(mCos, 0, mSin, 0, 0, 1, 0, 0, -mSin, 0, mCos, 0, 0, 0, 0, 1);
        }
        function rotateZ(angle) {
          if (angle === 0) {
            return this;
          }
          var mCos = _cos(angle);
          var mSin = _sin(angle);
          return this._t(mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        }
        function shear(sx, sy) {
          return this._t(1, sy, sx, 1, 0, 0);
        }
        function skew2(ax, ay) {
          return this.shear(_tan(ax), _tan(ay));
        }
        function skewFromAxis(ax, angle) {
          var mCos = _cos(angle);
          var mSin = _sin(angle);
          return this._t(mCos, mSin, 0, 0, -mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)._t(1, 0, 0, 0, _tan(ax), 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)._t(mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        }
        function scale3(sx, sy, sz) {
          if (!sz && sz !== 0) {
            sz = 1;
          }
          if (sx === 1 && sy === 1 && sz === 1) {
            return this;
          }
          return this._t(sx, 0, 0, 0, 0, sy, 0, 0, 0, 0, sz, 0, 0, 0, 0, 1);
        }
        function setTransform(a, b, c, d, e, f3, g, h, i, j, k, l, m, n, o, p) {
          this.props[0] = a;
          this.props[1] = b;
          this.props[2] = c;
          this.props[3] = d;
          this.props[4] = e;
          this.props[5] = f3;
          this.props[6] = g;
          this.props[7] = h;
          this.props[8] = i;
          this.props[9] = j;
          this.props[10] = k;
          this.props[11] = l;
          this.props[12] = m;
          this.props[13] = n;
          this.props[14] = o;
          this.props[15] = p;
          return this;
        }
        function translate(tx, ty, tz) {
          tz = tz || 0;
          if (tx !== 0 || ty !== 0 || tz !== 0) {
            return this._t(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, tx, ty, tz, 1);
          }
          return this;
        }
        function transform2(a2, b2, c2, d2, e2, f22, g2, h2, i2, j2, k2, l2, m2, n2, o2, p2) {
          var _p = this.props;
          if (a2 === 1 && b2 === 0 && c2 === 0 && d2 === 0 && e2 === 0 && f22 === 1 && g2 === 0 && h2 === 0 && i2 === 0 && j2 === 0 && k2 === 1 && l2 === 0) {
            _p[12] = _p[12] * a2 + _p[15] * m2;
            _p[13] = _p[13] * f22 + _p[15] * n2;
            _p[14] = _p[14] * k2 + _p[15] * o2;
            _p[15] *= p2;
            this._identityCalculated = false;
            return this;
          }
          var a1 = _p[0];
          var b1 = _p[1];
          var c1 = _p[2];
          var d1 = _p[3];
          var e1 = _p[4];
          var f1 = _p[5];
          var g1 = _p[6];
          var h1 = _p[7];
          var i1 = _p[8];
          var j1 = _p[9];
          var k1 = _p[10];
          var l1 = _p[11];
          var m1 = _p[12];
          var n1 = _p[13];
          var o1 = _p[14];
          var p1 = _p[15];
          _p[0] = a1 * a2 + b1 * e2 + c1 * i2 + d1 * m2;
          _p[1] = a1 * b2 + b1 * f22 + c1 * j2 + d1 * n2;
          _p[2] = a1 * c2 + b1 * g2 + c1 * k2 + d1 * o2;
          _p[3] = a1 * d2 + b1 * h2 + c1 * l2 + d1 * p2;
          _p[4] = e1 * a2 + f1 * e2 + g1 * i2 + h1 * m2;
          _p[5] = e1 * b2 + f1 * f22 + g1 * j2 + h1 * n2;
          _p[6] = e1 * c2 + f1 * g2 + g1 * k2 + h1 * o2;
          _p[7] = e1 * d2 + f1 * h2 + g1 * l2 + h1 * p2;
          _p[8] = i1 * a2 + j1 * e2 + k1 * i2 + l1 * m2;
          _p[9] = i1 * b2 + j1 * f22 + k1 * j2 + l1 * n2;
          _p[10] = i1 * c2 + j1 * g2 + k1 * k2 + l1 * o2;
          _p[11] = i1 * d2 + j1 * h2 + k1 * l2 + l1 * p2;
          _p[12] = m1 * a2 + n1 * e2 + o1 * i2 + p1 * m2;
          _p[13] = m1 * b2 + n1 * f22 + o1 * j2 + p1 * n2;
          _p[14] = m1 * c2 + n1 * g2 + o1 * k2 + p1 * o2;
          _p[15] = m1 * d2 + n1 * h2 + o1 * l2 + p1 * p2;
          this._identityCalculated = false;
          return this;
        }
        function multiply(matrix) {
          var matrixProps = matrix.props;
          return this.transform(matrixProps[0], matrixProps[1], matrixProps[2], matrixProps[3], matrixProps[4], matrixProps[5], matrixProps[6], matrixProps[7], matrixProps[8], matrixProps[9], matrixProps[10], matrixProps[11], matrixProps[12], matrixProps[13], matrixProps[14], matrixProps[15]);
        }
        function isIdentity() {
          if (!this._identityCalculated) {
            this._identity = !(this.props[0] !== 1 || this.props[1] !== 0 || this.props[2] !== 0 || this.props[3] !== 0 || this.props[4] !== 0 || this.props[5] !== 1 || this.props[6] !== 0 || this.props[7] !== 0 || this.props[8] !== 0 || this.props[9] !== 0 || this.props[10] !== 1 || this.props[11] !== 0 || this.props[12] !== 0 || this.props[13] !== 0 || this.props[14] !== 0 || this.props[15] !== 1);
            this._identityCalculated = true;
          }
          return this._identity;
        }
        function equals(matr) {
          var i = 0;
          while (i < 16) {
            if (matr.props[i] !== this.props[i]) {
              return false;
            }
            i += 1;
          }
          return true;
        }
        function clone(matr) {
          var i;
          for (i = 0; i < 16; i += 1) {
            matr.props[i] = this.props[i];
          }
          return matr;
        }
        function cloneFromProps(props) {
          var i;
          for (i = 0; i < 16; i += 1) {
            this.props[i] = props[i];
          }
        }
        function applyToPoint(x, y, z) {
          return {
            x: x * this.props[0] + y * this.props[4] + z * this.props[8] + this.props[12],
            y: x * this.props[1] + y * this.props[5] + z * this.props[9] + this.props[13],
            z: x * this.props[2] + y * this.props[6] + z * this.props[10] + this.props[14]
          };
        }
        function applyToX(x, y, z) {
          return x * this.props[0] + y * this.props[4] + z * this.props[8] + this.props[12];
        }
        function applyToY(x, y, z) {
          return x * this.props[1] + y * this.props[5] + z * this.props[9] + this.props[13];
        }
        function applyToZ(x, y, z) {
          return x * this.props[2] + y * this.props[6] + z * this.props[10] + this.props[14];
        }
        function getInverseMatrix() {
          var determinant = this.props[0] * this.props[5] - this.props[1] * this.props[4];
          var a = this.props[5] / determinant;
          var b = -this.props[1] / determinant;
          var c = -this.props[4] / determinant;
          var d = this.props[0] / determinant;
          var e = (this.props[4] * this.props[13] - this.props[5] * this.props[12]) / determinant;
          var f3 = -(this.props[0] * this.props[13] - this.props[1] * this.props[12]) / determinant;
          var inverseMatrix = new Matrix();
          inverseMatrix.props[0] = a;
          inverseMatrix.props[1] = b;
          inverseMatrix.props[4] = c;
          inverseMatrix.props[5] = d;
          inverseMatrix.props[12] = e;
          inverseMatrix.props[13] = f3;
          return inverseMatrix;
        }
        function inversePoint(pt) {
          var inverseMatrix = this.getInverseMatrix();
          return inverseMatrix.applyToPointArray(pt[0], pt[1], pt[2] || 0);
        }
        function inversePoints(pts) {
          var i;
          var len = pts.length;
          var retPts = [];
          for (i = 0; i < len; i += 1) {
            retPts[i] = inversePoint(pts[i]);
          }
          return retPts;
        }
        function applyToTriplePoints(pt1, pt2, pt3) {
          var arr = createTypedArray("float32", 6);
          if (this.isIdentity()) {
            arr[0] = pt1[0];
            arr[1] = pt1[1];
            arr[2] = pt2[0];
            arr[3] = pt2[1];
            arr[4] = pt3[0];
            arr[5] = pt3[1];
          } else {
            var p0 = this.props[0];
            var p1 = this.props[1];
            var p4 = this.props[4];
            var p5 = this.props[5];
            var p12 = this.props[12];
            var p13 = this.props[13];
            arr[0] = pt1[0] * p0 + pt1[1] * p4 + p12;
            arr[1] = pt1[0] * p1 + pt1[1] * p5 + p13;
            arr[2] = pt2[0] * p0 + pt2[1] * p4 + p12;
            arr[3] = pt2[0] * p1 + pt2[1] * p5 + p13;
            arr[4] = pt3[0] * p0 + pt3[1] * p4 + p12;
            arr[5] = pt3[0] * p1 + pt3[1] * p5 + p13;
          }
          return arr;
        }
        function applyToPointArray(x, y, z) {
          var arr;
          if (this.isIdentity()) {
            arr = [x, y, z];
          } else {
            arr = [x * this.props[0] + y * this.props[4] + z * this.props[8] + this.props[12], x * this.props[1] + y * this.props[5] + z * this.props[9] + this.props[13], x * this.props[2] + y * this.props[6] + z * this.props[10] + this.props[14]];
          }
          return arr;
        }
        function applyToPointStringified(x, y) {
          if (this.isIdentity()) {
            return x + "," + y;
          }
          var _p = this.props;
          return Math.round((x * _p[0] + y * _p[4] + _p[12]) * 100) / 100 + "," + Math.round((x * _p[1] + y * _p[5] + _p[13]) * 100) / 100;
        }
        function toCSS() {
          var i = 0;
          var props = this.props;
          var cssValue2 = "matrix3d(";
          var v = 1e4;
          while (i < 16) {
            cssValue2 += _rnd(props[i] * v) / v;
            cssValue2 += i === 15 ? ")" : ",";
            i += 1;
          }
          return cssValue2;
        }
        function roundMatrixProperty(val2) {
          var v = 1e4;
          if (val2 < 1e-6 && val2 > 0 || val2 > -1e-6 && val2 < 0) {
            return _rnd(val2 * v) / v;
          }
          return val2;
        }
        function to2dCSS() {
          var props = this.props;
          var _a = roundMatrixProperty(props[0]);
          var _b = roundMatrixProperty(props[1]);
          var _c = roundMatrixProperty(props[4]);
          var _d = roundMatrixProperty(props[5]);
          var _e = roundMatrixProperty(props[12]);
          var _f = roundMatrixProperty(props[13]);
          return "matrix(" + _a + "," + _b + "," + _c + "," + _d + "," + _e + "," + _f + ")";
        }
        return function() {
          this.reset = reset;
          this.rotate = rotate4;
          this.rotateX = rotateX;
          this.rotateY = rotateY;
          this.rotateZ = rotateZ;
          this.skew = skew2;
          this.skewFromAxis = skewFromAxis;
          this.shear = shear;
          this.scale = scale3;
          this.setTransform = setTransform;
          this.translate = translate;
          this.transform = transform2;
          this.multiply = multiply;
          this.applyToPoint = applyToPoint;
          this.applyToX = applyToX;
          this.applyToY = applyToY;
          this.applyToZ = applyToZ;
          this.applyToPointArray = applyToPointArray;
          this.applyToTriplePoints = applyToTriplePoints;
          this.applyToPointStringified = applyToPointStringified;
          this.toCSS = toCSS;
          this.to2dCSS = to2dCSS;
          this.clone = clone;
          this.cloneFromProps = cloneFromProps;
          this.equals = equals;
          this.inversePoints = inversePoints;
          this.inversePoint = inversePoint;
          this.getInverseMatrix = getInverseMatrix;
          this._t = this.transform;
          this.isIdentity = isIdentity;
          this._identity = true;
          this._identityCalculated = false;
          this.props = createTypedArray("float32", 16);
          this.reset();
        };
      }();
      function _typeof$3(o) {
        "@babel/helpers - typeof";
        return _typeof$3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
          return typeof o2;
        } : function(o2) {
          return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
        }, _typeof$3(o);
      }
      var lottie = {};
      var standalone = "__[STANDALONE]__";
      var animationData = "__[ANIMATIONDATA]__";
      var renderer = "";
      function setLocation(href) {
        setLocationHref(href);
      }
      function searchAnimations() {
        if (standalone === true) {
          animationManager.searchAnimations(animationData, standalone, renderer);
        } else {
          animationManager.searchAnimations();
        }
      }
      function setSubframeRendering(flag) {
        setSubframeEnabled(flag);
      }
      function setPrefix(prefix) {
        setIdPrefix(prefix);
      }
      function loadAnimation(params) {
        if (standalone === true) {
          params.animationData = JSON.parse(animationData);
        }
        return animationManager.loadAnimation(params);
      }
      function setQuality(value3) {
        if (typeof value3 === "string") {
          switch (value3) {
            case "high":
              setDefaultCurveSegments(200);
              break;
            default:
            case "medium":
              setDefaultCurveSegments(50);
              break;
            case "low":
              setDefaultCurveSegments(10);
              break;
          }
        } else if (!isNaN(value3) && value3 > 1) {
          setDefaultCurveSegments(value3);
        }
        if (getDefaultCurveSegments() >= 50) {
          roundValues(false);
        } else {
          roundValues(true);
        }
      }
      function inBrowser() {
        return typeof navigator !== "undefined";
      }
      function installPlugin(type, plugin) {
        if (type === "expressions") {
          setExpressionsPlugin(plugin);
        }
      }
      function getFactory(name2) {
        switch (name2) {
          case "propertyFactory":
            return PropertyFactory;
          case "shapePropertyFactory":
            return ShapePropertyFactory;
          case "matrix":
            return Matrix;
          default:
            return null;
        }
      }
      lottie.play = animationManager.play;
      lottie.pause = animationManager.pause;
      lottie.setLocationHref = setLocation;
      lottie.togglePause = animationManager.togglePause;
      lottie.setSpeed = animationManager.setSpeed;
      lottie.setDirection = animationManager.setDirection;
      lottie.stop = animationManager.stop;
      lottie.searchAnimations = searchAnimations;
      lottie.registerAnimation = animationManager.registerAnimation;
      lottie.loadAnimation = loadAnimation;
      lottie.setSubframeRendering = setSubframeRendering;
      lottie.resize = animationManager.resize;
      lottie.goToAndStop = animationManager.goToAndStop;
      lottie.destroy = animationManager.destroy;
      lottie.setQuality = setQuality;
      lottie.inBrowser = inBrowser;
      lottie.installPlugin = installPlugin;
      lottie.freeze = animationManager.freeze;
      lottie.unfreeze = animationManager.unfreeze;
      lottie.setVolume = animationManager.setVolume;
      lottie.mute = animationManager.mute;
      lottie.unmute = animationManager.unmute;
      lottie.getRegisteredAnimations = animationManager.getRegisteredAnimations;
      lottie.useWebWorker = setWebWorker;
      lottie.setIDPrefix = setPrefix;
      lottie.__getFactory = getFactory;
      lottie.version = "5.13.0";
      function checkReady() {
        if (document.readyState === "complete") {
          clearInterval(readyStateCheckInterval);
          searchAnimations();
        }
      }
      function getQueryVariable(variable) {
        var vars = queryString.split("&");
        for (var i = 0; i < vars.length; i += 1) {
          var pair = vars[i].split("=");
          if (decodeURIComponent(pair[0]) == variable) {
            return decodeURIComponent(pair[1]);
          }
        }
        return null;
      }
      var queryString = "";
      if (standalone) {
        var scripts = document.getElementsByTagName("script");
        var index = scripts.length - 1;
        var myScript = scripts[index] || {
          src: ""
        };
        queryString = myScript.src ? myScript.src.replace(/^[^\?]+\??/, "") : "";
        renderer = getQueryVariable("renderer");
      }
      var readyStateCheckInterval = setInterval(checkReady, 100);
      try {
        if (!((typeof exports === "undefined" ? "undefined" : _typeof$3(exports)) === "object" && typeof module !== "undefined") && !(typeof define === "function" && define.amd)) {
          window.bodymovin = lottie;
        }
      } catch (err) {
      }
      var ShapeModifiers = function() {
        var ob2 = {};
        var modifiers = {};
        ob2.registerModifier = registerModifier;
        ob2.getModifier = getModifier;
        function registerModifier(nm, factory) {
          if (!modifiers[nm]) {
            modifiers[nm] = factory;
          }
        }
        function getModifier(nm, elem2, data2) {
          return new modifiers[nm](elem2, data2);
        }
        return ob2;
      }();
      function ShapeModifier() {
      }
      ShapeModifier.prototype.initModifierProperties = function() {
      };
      ShapeModifier.prototype.addShapeToModifier = function() {
      };
      ShapeModifier.prototype.addShape = function(data2) {
        if (!this.closed) {
          data2.sh.container.addDynamicProperty(data2.sh);
          var shapeData = {
            shape: data2.sh,
            data: data2,
            localShapeCollection: shapeCollectionPool.newShapeCollection()
          };
          this.shapes.push(shapeData);
          this.addShapeToModifier(shapeData);
          if (this._isAnimated) {
            data2.setAsAnimated();
          }
        }
      };
      ShapeModifier.prototype.init = function(elem2, data2) {
        this.shapes = [];
        this.elem = elem2;
        this.initDynamicPropertyContainer(elem2);
        this.initModifierProperties(elem2, data2);
        this.frameId = initialDefaultFrame;
        this.closed = false;
        this.k = false;
        if (this.dynamicProperties.length) {
          this.k = true;
        } else {
          this.getValue(true);
        }
      };
      ShapeModifier.prototype.processKeys = function() {
        if (this.elem.globalData.frameId === this.frameId) {
          return;
        }
        this.frameId = this.elem.globalData.frameId;
        this.iterateDynamicProperties();
      };
      extendPrototype([DynamicPropertyContainer], ShapeModifier);
      function TrimModifier() {
      }
      extendPrototype([ShapeModifier], TrimModifier);
      TrimModifier.prototype.initModifierProperties = function(elem2, data2) {
        this.s = PropertyFactory.getProp(elem2, data2.s, 0, 0.01, this);
        this.e = PropertyFactory.getProp(elem2, data2.e, 0, 0.01, this);
        this.o = PropertyFactory.getProp(elem2, data2.o, 0, 0, this);
        this.sValue = 0;
        this.eValue = 0;
        this.getValue = this.processKeys;
        this.m = data2.m;
        this._isAnimated = !!this.s.effectsSequence.length || !!this.e.effectsSequence.length || !!this.o.effectsSequence.length;
      };
      TrimModifier.prototype.addShapeToModifier = function(shapeData) {
        shapeData.pathsData = [];
      };
      TrimModifier.prototype.calculateShapeEdges = function(s, e, shapeLength, addedLength, totalModifierLength) {
        var segments = [];
        if (e <= 1) {
          segments.push({
            s,
            e
          });
        } else if (s >= 1) {
          segments.push({
            s: s - 1,
            e: e - 1
          });
        } else {
          segments.push({
            s,
            e: 1
          });
          segments.push({
            s: 0,
            e: e - 1
          });
        }
        var shapeSegments = [];
        var i;
        var len = segments.length;
        var segmentOb;
        for (i = 0; i < len; i += 1) {
          segmentOb = segments[i];
          if (!(segmentOb.e * totalModifierLength < addedLength || segmentOb.s * totalModifierLength > addedLength + shapeLength)) {
            var shapeS;
            var shapeE;
            if (segmentOb.s * totalModifierLength <= addedLength) {
              shapeS = 0;
            } else {
              shapeS = (segmentOb.s * totalModifierLength - addedLength) / shapeLength;
            }
            if (segmentOb.e * totalModifierLength >= addedLength + shapeLength) {
              shapeE = 1;
            } else {
              shapeE = (segmentOb.e * totalModifierLength - addedLength) / shapeLength;
            }
            shapeSegments.push([shapeS, shapeE]);
          }
        }
        if (!shapeSegments.length) {
          shapeSegments.push([0, 0]);
        }
        return shapeSegments;
      };
      TrimModifier.prototype.releasePathsData = function(pathsData) {
        var i;
        var len = pathsData.length;
        for (i = 0; i < len; i += 1) {
          segmentsLengthPool.release(pathsData[i]);
        }
        pathsData.length = 0;
        return pathsData;
      };
      TrimModifier.prototype.processShapes = function(_isFirstFrame) {
        var s;
        var e;
        if (this._mdf || _isFirstFrame) {
          var o = this.o.v % 360 / 360;
          if (o < 0) {
            o += 1;
          }
          if (this.s.v > 1) {
            s = 1 + o;
          } else if (this.s.v < 0) {
            s = 0 + o;
          } else {
            s = this.s.v + o;
          }
          if (this.e.v > 1) {
            e = 1 + o;
          } else if (this.e.v < 0) {
            e = 0 + o;
          } else {
            e = this.e.v + o;
          }
          if (s > e) {
            var _s = s;
            s = e;
            e = _s;
          }
          s = Math.round(s * 1e4) * 1e-4;
          e = Math.round(e * 1e4) * 1e-4;
          this.sValue = s;
          this.eValue = e;
        } else {
          s = this.sValue;
          e = this.eValue;
        }
        var shapePaths;
        var i;
        var len = this.shapes.length;
        var j;
        var jLen;
        var pathsData;
        var pathData;
        var totalShapeLength;
        var totalModifierLength = 0;
        if (e === s) {
          for (i = 0; i < len; i += 1) {
            this.shapes[i].localShapeCollection.releaseShapes();
            this.shapes[i].shape._mdf = true;
            this.shapes[i].shape.paths = this.shapes[i].localShapeCollection;
            if (this._mdf) {
              this.shapes[i].pathsData.length = 0;
            }
          }
        } else if (!(e === 1 && s === 0 || e === 0 && s === 1)) {
          var segments = [];
          var shapeData;
          var localShapeCollection;
          for (i = 0; i < len; i += 1) {
            shapeData = this.shapes[i];
            if (!shapeData.shape._mdf && !this._mdf && !_isFirstFrame && this.m !== 2) {
              shapeData.shape.paths = shapeData.localShapeCollection;
            } else {
              shapePaths = shapeData.shape.paths;
              jLen = shapePaths._length;
              totalShapeLength = 0;
              if (!shapeData.shape._mdf && shapeData.pathsData.length) {
                totalShapeLength = shapeData.totalShapeLength;
              } else {
                pathsData = this.releasePathsData(shapeData.pathsData);
                for (j = 0; j < jLen; j += 1) {
                  pathData = bez.getSegmentsLength(shapePaths.shapes[j]);
                  pathsData.push(pathData);
                  totalShapeLength += pathData.totalLength;
                }
                shapeData.totalShapeLength = totalShapeLength;
                shapeData.pathsData = pathsData;
              }
              totalModifierLength += totalShapeLength;
              shapeData.shape._mdf = true;
            }
          }
          var shapeS = s;
          var shapeE = e;
          var addedLength = 0;
          var edges;
          for (i = len - 1; i >= 0; i -= 1) {
            shapeData = this.shapes[i];
            if (shapeData.shape._mdf) {
              localShapeCollection = shapeData.localShapeCollection;
              localShapeCollection.releaseShapes();
              if (this.m === 2 && len > 1) {
                edges = this.calculateShapeEdges(s, e, shapeData.totalShapeLength, addedLength, totalModifierLength);
                addedLength += shapeData.totalShapeLength;
              } else {
                edges = [[shapeS, shapeE]];
              }
              jLen = edges.length;
              for (j = 0; j < jLen; j += 1) {
                shapeS = edges[j][0];
                shapeE = edges[j][1];
                segments.length = 0;
                if (shapeE <= 1) {
                  segments.push({
                    s: shapeData.totalShapeLength * shapeS,
                    e: shapeData.totalShapeLength * shapeE
                  });
                } else if (shapeS >= 1) {
                  segments.push({
                    s: shapeData.totalShapeLength * (shapeS - 1),
                    e: shapeData.totalShapeLength * (shapeE - 1)
                  });
                } else {
                  segments.push({
                    s: shapeData.totalShapeLength * shapeS,
                    e: shapeData.totalShapeLength
                  });
                  segments.push({
                    s: 0,
                    e: shapeData.totalShapeLength * (shapeE - 1)
                  });
                }
                var newShapesData = this.addShapes(shapeData, segments[0]);
                if (segments[0].s !== segments[0].e) {
                  if (segments.length > 1) {
                    var lastShapeInCollection = shapeData.shape.paths.shapes[shapeData.shape.paths._length - 1];
                    if (lastShapeInCollection.c) {
                      var lastShape = newShapesData.pop();
                      this.addPaths(newShapesData, localShapeCollection);
                      newShapesData = this.addShapes(shapeData, segments[1], lastShape);
                    } else {
                      this.addPaths(newShapesData, localShapeCollection);
                      newShapesData = this.addShapes(shapeData, segments[1]);
                    }
                  }
                  this.addPaths(newShapesData, localShapeCollection);
                }
              }
              shapeData.shape.paths = localShapeCollection;
            }
          }
        } else if (this._mdf) {
          for (i = 0; i < len; i += 1) {
            this.shapes[i].pathsData.length = 0;
            this.shapes[i].shape._mdf = true;
          }
        }
      };
      TrimModifier.prototype.addPaths = function(newPaths, localShapeCollection) {
        var i;
        var len = newPaths.length;
        for (i = 0; i < len; i += 1) {
          localShapeCollection.addShape(newPaths[i]);
        }
      };
      TrimModifier.prototype.addSegment = function(pt1, pt2, pt3, pt4, shapePath, pos, newShape) {
        shapePath.setXYAt(pt2[0], pt2[1], "o", pos);
        shapePath.setXYAt(pt3[0], pt3[1], "i", pos + 1);
        if (newShape) {
          shapePath.setXYAt(pt1[0], pt1[1], "v", pos);
        }
        shapePath.setXYAt(pt4[0], pt4[1], "v", pos + 1);
      };
      TrimModifier.prototype.addSegmentFromArray = function(points, shapePath, pos, newShape) {
        shapePath.setXYAt(points[1], points[5], "o", pos);
        shapePath.setXYAt(points[2], points[6], "i", pos + 1);
        if (newShape) {
          shapePath.setXYAt(points[0], points[4], "v", pos);
        }
        shapePath.setXYAt(points[3], points[7], "v", pos + 1);
      };
      TrimModifier.prototype.addShapes = function(shapeData, shapeSegment, shapePath) {
        var pathsData = shapeData.pathsData;
        var shapePaths = shapeData.shape.paths.shapes;
        var i;
        var len = shapeData.shape.paths._length;
        var j;
        var jLen;
        var addedLength = 0;
        var currentLengthData;
        var segmentCount;
        var lengths;
        var segment;
        var shapes = [];
        var initPos;
        var newShape = true;
        if (!shapePath) {
          shapePath = shapePool.newElement();
          segmentCount = 0;
          initPos = 0;
        } else {
          segmentCount = shapePath._length;
          initPos = shapePath._length;
        }
        shapes.push(shapePath);
        for (i = 0; i < len; i += 1) {
          lengths = pathsData[i].lengths;
          shapePath.c = shapePaths[i].c;
          jLen = shapePaths[i].c ? lengths.length : lengths.length + 1;
          for (j = 1; j < jLen; j += 1) {
            currentLengthData = lengths[j - 1];
            if (addedLength + currentLengthData.addedLength < shapeSegment.s) {
              addedLength += currentLengthData.addedLength;
              shapePath.c = false;
            } else if (addedLength > shapeSegment.e) {
              shapePath.c = false;
              break;
            } else {
              if (shapeSegment.s <= addedLength && shapeSegment.e >= addedLength + currentLengthData.addedLength) {
                this.addSegment(shapePaths[i].v[j - 1], shapePaths[i].o[j - 1], shapePaths[i].i[j], shapePaths[i].v[j], shapePath, segmentCount, newShape);
                newShape = false;
              } else {
                segment = bez.getNewSegment(shapePaths[i].v[j - 1], shapePaths[i].v[j], shapePaths[i].o[j - 1], shapePaths[i].i[j], (shapeSegment.s - addedLength) / currentLengthData.addedLength, (shapeSegment.e - addedLength) / currentLengthData.addedLength, lengths[j - 1]);
                this.addSegmentFromArray(segment, shapePath, segmentCount, newShape);
                newShape = false;
                shapePath.c = false;
              }
              addedLength += currentLengthData.addedLength;
              segmentCount += 1;
            }
          }
          if (shapePaths[i].c && lengths.length) {
            currentLengthData = lengths[j - 1];
            if (addedLength <= shapeSegment.e) {
              var segmentLength = lengths[j - 1].addedLength;
              if (shapeSegment.s <= addedLength && shapeSegment.e >= addedLength + segmentLength) {
                this.addSegment(shapePaths[i].v[j - 1], shapePaths[i].o[j - 1], shapePaths[i].i[0], shapePaths[i].v[0], shapePath, segmentCount, newShape);
                newShape = false;
              } else {
                segment = bez.getNewSegment(shapePaths[i].v[j - 1], shapePaths[i].v[0], shapePaths[i].o[j - 1], shapePaths[i].i[0], (shapeSegment.s - addedLength) / segmentLength, (shapeSegment.e - addedLength) / segmentLength, lengths[j - 1]);
                this.addSegmentFromArray(segment, shapePath, segmentCount, newShape);
                newShape = false;
                shapePath.c = false;
              }
            } else {
              shapePath.c = false;
            }
            addedLength += currentLengthData.addedLength;
            segmentCount += 1;
          }
          if (shapePath._length) {
            shapePath.setXYAt(shapePath.v[initPos][0], shapePath.v[initPos][1], "i", initPos);
            shapePath.setXYAt(shapePath.v[shapePath._length - 1][0], shapePath.v[shapePath._length - 1][1], "o", shapePath._length - 1);
          }
          if (addedLength > shapeSegment.e) {
            break;
          }
          if (i < len - 1) {
            shapePath = shapePool.newElement();
            newShape = true;
            shapes.push(shapePath);
            segmentCount = 0;
          }
        }
        return shapes;
      };
      function PuckerAndBloatModifier() {
      }
      extendPrototype([ShapeModifier], PuckerAndBloatModifier);
      PuckerAndBloatModifier.prototype.initModifierProperties = function(elem2, data2) {
        this.getValue = this.processKeys;
        this.amount = PropertyFactory.getProp(elem2, data2.a, 0, null, this);
        this._isAnimated = !!this.amount.effectsSequence.length;
      };
      PuckerAndBloatModifier.prototype.processPath = function(path, amount) {
        var percent = amount / 100;
        var centerPoint = [0, 0];
        var pathLength = path._length;
        var i = 0;
        for (i = 0; i < pathLength; i += 1) {
          centerPoint[0] += path.v[i][0];
          centerPoint[1] += path.v[i][1];
        }
        centerPoint[0] /= pathLength;
        centerPoint[1] /= pathLength;
        var clonedPath = shapePool.newElement();
        clonedPath.c = path.c;
        var vX;
        var vY;
        var oX;
        var oY;
        var iX;
        var iY;
        for (i = 0; i < pathLength; i += 1) {
          vX = path.v[i][0] + (centerPoint[0] - path.v[i][0]) * percent;
          vY = path.v[i][1] + (centerPoint[1] - path.v[i][1]) * percent;
          oX = path.o[i][0] + (centerPoint[0] - path.o[i][0]) * -percent;
          oY = path.o[i][1] + (centerPoint[1] - path.o[i][1]) * -percent;
          iX = path.i[i][0] + (centerPoint[0] - path.i[i][0]) * -percent;
          iY = path.i[i][1] + (centerPoint[1] - path.i[i][1]) * -percent;
          clonedPath.setTripleAt(vX, vY, oX, oY, iX, iY, i);
        }
        return clonedPath;
      };
      PuckerAndBloatModifier.prototype.processShapes = function(_isFirstFrame) {
        var shapePaths;
        var i;
        var len = this.shapes.length;
        var j;
        var jLen;
        var amount = this.amount.v;
        if (amount !== 0) {
          var shapeData;
          var localShapeCollection;
          for (i = 0; i < len; i += 1) {
            shapeData = this.shapes[i];
            localShapeCollection = shapeData.localShapeCollection;
            if (!(!shapeData.shape._mdf && !this._mdf && !_isFirstFrame)) {
              localShapeCollection.releaseShapes();
              shapeData.shape._mdf = true;
              shapePaths = shapeData.shape.paths.shapes;
              jLen = shapeData.shape.paths._length;
              for (j = 0; j < jLen; j += 1) {
                localShapeCollection.addShape(this.processPath(shapePaths[j], amount));
              }
            }
            shapeData.shape.paths = shapeData.localShapeCollection;
          }
        }
        if (!this.dynamicProperties.length) {
          this._mdf = false;
        }
      };
      var TransformPropertyFactory = function() {
        var defaultVector = [0, 0];
        function applyToMatrix(mat) {
          var _mdf = this._mdf;
          this.iterateDynamicProperties();
          this._mdf = this._mdf || _mdf;
          if (this.a) {
            mat.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]);
          }
          if (this.s) {
            mat.scale(this.s.v[0], this.s.v[1], this.s.v[2]);
          }
          if (this.sk) {
            mat.skewFromAxis(-this.sk.v, this.sa.v);
          }
          if (this.r) {
            mat.rotate(-this.r.v);
          } else {
            mat.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]);
          }
          if (this.data.p.s) {
            if (this.data.p.z) {
              mat.translate(this.px.v, this.py.v, -this.pz.v);
            } else {
              mat.translate(this.px.v, this.py.v, 0);
            }
          } else {
            mat.translate(this.p.v[0], this.p.v[1], -this.p.v[2]);
          }
        }
        function processKeys(forceRender) {
          if (this.elem.globalData.frameId === this.frameId) {
            return;
          }
          if (this._isDirty) {
            this.precalculateMatrix();
            this._isDirty = false;
          }
          this.iterateDynamicProperties();
          if (this._mdf || forceRender) {
            var frameRate;
            this.v.cloneFromProps(this.pre.props);
            if (this.appliedTransformations < 1) {
              this.v.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]);
            }
            if (this.appliedTransformations < 2) {
              this.v.scale(this.s.v[0], this.s.v[1], this.s.v[2]);
            }
            if (this.sk && this.appliedTransformations < 3) {
              this.v.skewFromAxis(-this.sk.v, this.sa.v);
            }
            if (this.r && this.appliedTransformations < 4) {
              this.v.rotate(-this.r.v);
            } else if (!this.r && this.appliedTransformations < 4) {
              this.v.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]);
            }
            if (this.autoOriented) {
              var v1;
              var v2;
              frameRate = this.elem.globalData.frameRate;
              if (this.p && this.p.keyframes && this.p.getValueAtTime) {
                if (this.p._caching.lastFrame + this.p.offsetTime <= this.p.keyframes[0].t) {
                  v1 = this.p.getValueAtTime((this.p.keyframes[0].t + 0.01) / frameRate, 0);
                  v2 = this.p.getValueAtTime(this.p.keyframes[0].t / frameRate, 0);
                } else if (this.p._caching.lastFrame + this.p.offsetTime >= this.p.keyframes[this.p.keyframes.length - 1].t) {
                  v1 = this.p.getValueAtTime(this.p.keyframes[this.p.keyframes.length - 1].t / frameRate, 0);
                  v2 = this.p.getValueAtTime((this.p.keyframes[this.p.keyframes.length - 1].t - 0.05) / frameRate, 0);
                } else {
                  v1 = this.p.pv;
                  v2 = this.p.getValueAtTime((this.p._caching.lastFrame + this.p.offsetTime - 0.01) / frameRate, this.p.offsetTime);
                }
              } else if (this.px && this.px.keyframes && this.py.keyframes && this.px.getValueAtTime && this.py.getValueAtTime) {
                v1 = [];
                v2 = [];
                var px = this.px;
                var py = this.py;
                if (px._caching.lastFrame + px.offsetTime <= px.keyframes[0].t) {
                  v1[0] = px.getValueAtTime((px.keyframes[0].t + 0.01) / frameRate, 0);
                  v1[1] = py.getValueAtTime((py.keyframes[0].t + 0.01) / frameRate, 0);
                  v2[0] = px.getValueAtTime(px.keyframes[0].t / frameRate, 0);
                  v2[1] = py.getValueAtTime(py.keyframes[0].t / frameRate, 0);
                } else if (px._caching.lastFrame + px.offsetTime >= px.keyframes[px.keyframes.length - 1].t) {
                  v1[0] = px.getValueAtTime(px.keyframes[px.keyframes.length - 1].t / frameRate, 0);
                  v1[1] = py.getValueAtTime(py.keyframes[py.keyframes.length - 1].t / frameRate, 0);
                  v2[0] = px.getValueAtTime((px.keyframes[px.keyframes.length - 1].t - 0.01) / frameRate, 0);
                  v2[1] = py.getValueAtTime((py.keyframes[py.keyframes.length - 1].t - 0.01) / frameRate, 0);
                } else {
                  v1 = [px.pv, py.pv];
                  v2[0] = px.getValueAtTime((px._caching.lastFrame + px.offsetTime - 0.01) / frameRate, px.offsetTime);
                  v2[1] = py.getValueAtTime((py._caching.lastFrame + py.offsetTime - 0.01) / frameRate, py.offsetTime);
                }
              } else {
                v2 = defaultVector;
                v1 = v2;
              }
              this.v.rotate(-Math.atan2(v1[1] - v2[1], v1[0] - v2[0]));
            }
            if (this.data.p && this.data.p.s) {
              if (this.data.p.z) {
                this.v.translate(this.px.v, this.py.v, -this.pz.v);
              } else {
                this.v.translate(this.px.v, this.py.v, 0);
              }
            } else {
              this.v.translate(this.p.v[0], this.p.v[1], -this.p.v[2]);
            }
          }
          this.frameId = this.elem.globalData.frameId;
        }
        function precalculateMatrix() {
          this.appliedTransformations = 0;
          this.pre.reset();
          if (!this.a.effectsSequence.length) {
            this.pre.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]);
            this.appliedTransformations = 1;
          } else {
            return;
          }
          if (!this.s.effectsSequence.length) {
            this.pre.scale(this.s.v[0], this.s.v[1], this.s.v[2]);
            this.appliedTransformations = 2;
          } else {
            return;
          }
          if (this.sk) {
            if (!this.sk.effectsSequence.length && !this.sa.effectsSequence.length) {
              this.pre.skewFromAxis(-this.sk.v, this.sa.v);
              this.appliedTransformations = 3;
            } else {
              return;
            }
          }
          if (this.r) {
            if (!this.r.effectsSequence.length) {
              this.pre.rotate(-this.r.v);
              this.appliedTransformations = 4;
            }
          } else if (!this.rz.effectsSequence.length && !this.ry.effectsSequence.length && !this.rx.effectsSequence.length && !this.or.effectsSequence.length) {
            this.pre.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]);
            this.appliedTransformations = 4;
          }
        }
        function autoOrient() {
        }
        function addDynamicProperty(prop) {
          this._addDynamicProperty(prop);
          this.elem.addDynamicProperty(prop);
          this._isDirty = true;
        }
        function TransformProperty(elem2, data2, container) {
          this.elem = elem2;
          this.frameId = -1;
          this.propType = "transform";
          this.data = data2;
          this.v = new Matrix();
          this.pre = new Matrix();
          this.appliedTransformations = 0;
          this.initDynamicPropertyContainer(container || elem2);
          if (data2.p && data2.p.s) {
            this.px = PropertyFactory.getProp(elem2, data2.p.x, 0, 0, this);
            this.py = PropertyFactory.getProp(elem2, data2.p.y, 0, 0, this);
            if (data2.p.z) {
              this.pz = PropertyFactory.getProp(elem2, data2.p.z, 0, 0, this);
            }
          } else {
            this.p = PropertyFactory.getProp(elem2, data2.p || {
              k: [0, 0, 0]
            }, 1, 0, this);
          }
          if (data2.rx) {
            this.rx = PropertyFactory.getProp(elem2, data2.rx, 0, degToRads, this);
            this.ry = PropertyFactory.getProp(elem2, data2.ry, 0, degToRads, this);
            this.rz = PropertyFactory.getProp(elem2, data2.rz, 0, degToRads, this);
            if (data2.or.k[0].ti) {
              var i;
              var len = data2.or.k.length;
              for (i = 0; i < len; i += 1) {
                data2.or.k[i].to = null;
                data2.or.k[i].ti = null;
              }
            }
            this.or = PropertyFactory.getProp(elem2, data2.or, 1, degToRads, this);
            this.or.sh = true;
          } else {
            this.r = PropertyFactory.getProp(elem2, data2.r || {
              k: 0
            }, 0, degToRads, this);
          }
          if (data2.sk) {
            this.sk = PropertyFactory.getProp(elem2, data2.sk, 0, degToRads, this);
            this.sa = PropertyFactory.getProp(elem2, data2.sa, 0, degToRads, this);
          }
          this.a = PropertyFactory.getProp(elem2, data2.a || {
            k: [0, 0, 0]
          }, 1, 0, this);
          this.s = PropertyFactory.getProp(elem2, data2.s || {
            k: [100, 100, 100]
          }, 1, 0.01, this);
          if (data2.o) {
            this.o = PropertyFactory.getProp(elem2, data2.o, 0, 0.01, elem2);
          } else {
            this.o = {
              _mdf: false,
              v: 1
            };
          }
          this._isDirty = true;
          if (!this.dynamicProperties.length) {
            this.getValue(true);
          }
        }
        TransformProperty.prototype = {
          applyToMatrix,
          getValue: processKeys,
          precalculateMatrix,
          autoOrient
        };
        extendPrototype([DynamicPropertyContainer], TransformProperty);
        TransformProperty.prototype.addDynamicProperty = addDynamicProperty;
        TransformProperty.prototype._addDynamicProperty = DynamicPropertyContainer.prototype.addDynamicProperty;
        function getTransformProperty(elem2, data2, container) {
          return new TransformProperty(elem2, data2, container);
        }
        return {
          getTransformProperty
        };
      }();
      function RepeaterModifier() {
      }
      extendPrototype([ShapeModifier], RepeaterModifier);
      RepeaterModifier.prototype.initModifierProperties = function(elem2, data2) {
        this.getValue = this.processKeys;
        this.c = PropertyFactory.getProp(elem2, data2.c, 0, null, this);
        this.o = PropertyFactory.getProp(elem2, data2.o, 0, null, this);
        this.tr = TransformPropertyFactory.getTransformProperty(elem2, data2.tr, this);
        this.so = PropertyFactory.getProp(elem2, data2.tr.so, 0, 0.01, this);
        this.eo = PropertyFactory.getProp(elem2, data2.tr.eo, 0, 0.01, this);
        this.data = data2;
        if (!this.dynamicProperties.length) {
          this.getValue(true);
        }
        this._isAnimated = !!this.dynamicProperties.length;
        this.pMatrix = new Matrix();
        this.rMatrix = new Matrix();
        this.sMatrix = new Matrix();
        this.tMatrix = new Matrix();
        this.matrix = new Matrix();
      };
      RepeaterModifier.prototype.applyTransforms = function(pMatrix, rMatrix, sMatrix, transform2, perc, inv) {
        var dir = inv ? -1 : 1;
        var scaleX = transform2.s.v[0] + (1 - transform2.s.v[0]) * (1 - perc);
        var scaleY = transform2.s.v[1] + (1 - transform2.s.v[1]) * (1 - perc);
        pMatrix.translate(transform2.p.v[0] * dir * perc, transform2.p.v[1] * dir * perc, transform2.p.v[2]);
        rMatrix.translate(-transform2.a.v[0], -transform2.a.v[1], transform2.a.v[2]);
        rMatrix.rotate(-transform2.r.v * dir * perc);
        rMatrix.translate(transform2.a.v[0], transform2.a.v[1], transform2.a.v[2]);
        sMatrix.translate(-transform2.a.v[0], -transform2.a.v[1], transform2.a.v[2]);
        sMatrix.scale(inv ? 1 / scaleX : scaleX, inv ? 1 / scaleY : scaleY);
        sMatrix.translate(transform2.a.v[0], transform2.a.v[1], transform2.a.v[2]);
      };
      RepeaterModifier.prototype.init = function(elem2, arr, pos, elemsData) {
        this.elem = elem2;
        this.arr = arr;
        this.pos = pos;
        this.elemsData = elemsData;
        this._currentCopies = 0;
        this._elements = [];
        this._groups = [];
        this.frameId = -1;
        this.initDynamicPropertyContainer(elem2);
        this.initModifierProperties(elem2, arr[pos]);
        while (pos > 0) {
          pos -= 1;
          this._elements.unshift(arr[pos]);
        }
        if (this.dynamicProperties.length) {
          this.k = true;
        } else {
          this.getValue(true);
        }
      };
      RepeaterModifier.prototype.resetElements = function(elements) {
        var i;
        var len = elements.length;
        for (i = 0; i < len; i += 1) {
          elements[i]._processed = false;
          if (elements[i].ty === "gr") {
            this.resetElements(elements[i].it);
          }
        }
      };
      RepeaterModifier.prototype.cloneElements = function(elements) {
        var newElements = JSON.parse(JSON.stringify(elements));
        this.resetElements(newElements);
        return newElements;
      };
      RepeaterModifier.prototype.changeGroupRender = function(elements, renderFlag) {
        var i;
        var len = elements.length;
        for (i = 0; i < len; i += 1) {
          elements[i]._render = renderFlag;
          if (elements[i].ty === "gr") {
            this.changeGroupRender(elements[i].it, renderFlag);
          }
        }
      };
      RepeaterModifier.prototype.processShapes = function(_isFirstFrame) {
        var items;
        var itemsTransform;
        var i;
        var dir;
        var cont;
        var hasReloaded = false;
        if (this._mdf || _isFirstFrame) {
          var copies = Math.ceil(this.c.v);
          if (this._groups.length < copies) {
            while (this._groups.length < copies) {
              var group = {
                it: this.cloneElements(this._elements),
                ty: "gr"
              };
              group.it.push({
                a: {
                  a: 0,
                  ix: 1,
                  k: [0, 0]
                },
                nm: "Transform",
                o: {
                  a: 0,
                  ix: 7,
                  k: 100
                },
                p: {
                  a: 0,
                  ix: 2,
                  k: [0, 0]
                },
                r: {
                  a: 1,
                  ix: 6,
                  k: [{
                    s: 0,
                    e: 0,
                    t: 0
                  }, {
                    s: 0,
                    e: 0,
                    t: 1
                  }]
                },
                s: {
                  a: 0,
                  ix: 3,
                  k: [100, 100]
                },
                sa: {
                  a: 0,
                  ix: 5,
                  k: 0
                },
                sk: {
                  a: 0,
                  ix: 4,
                  k: 0
                },
                ty: "tr"
              });
              this.arr.splice(0, 0, group);
              this._groups.splice(0, 0, group);
              this._currentCopies += 1;
            }
            this.elem.reloadShapes();
            hasReloaded = true;
          }
          cont = 0;
          var renderFlag;
          for (i = 0; i <= this._groups.length - 1; i += 1) {
            renderFlag = cont < copies;
            this._groups[i]._render = renderFlag;
            this.changeGroupRender(this._groups[i].it, renderFlag);
            if (!renderFlag) {
              var elems = this.elemsData[i].it;
              var transformData = elems[elems.length - 1];
              if (transformData.transform.op.v !== 0) {
                transformData.transform.op._mdf = true;
                transformData.transform.op.v = 0;
              } else {
                transformData.transform.op._mdf = false;
              }
            }
            cont += 1;
          }
          this._currentCopies = copies;
          var offset = this.o.v;
          var offsetModulo = offset % 1;
          var roundOffset = offset > 0 ? Math.floor(offset) : Math.ceil(offset);
          var pProps = this.pMatrix.props;
          var rProps = this.rMatrix.props;
          var sProps = this.sMatrix.props;
          this.pMatrix.reset();
          this.rMatrix.reset();
          this.sMatrix.reset();
          this.tMatrix.reset();
          this.matrix.reset();
          var iteration = 0;
          if (offset > 0) {
            while (iteration < roundOffset) {
              this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, false);
              iteration += 1;
            }
            if (offsetModulo) {
              this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, offsetModulo, false);
              iteration += offsetModulo;
            }
          } else if (offset < 0) {
            while (iteration > roundOffset) {
              this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, true);
              iteration -= 1;
            }
            if (offsetModulo) {
              this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, -offsetModulo, true);
              iteration -= offsetModulo;
            }
          }
          i = this.data.m === 1 ? 0 : this._currentCopies - 1;
          dir = this.data.m === 1 ? 1 : -1;
          cont = this._currentCopies;
          var j;
          var jLen;
          while (cont) {
            items = this.elemsData[i].it;
            itemsTransform = items[items.length - 1].transform.mProps.v.props;
            jLen = itemsTransform.length;
            items[items.length - 1].transform.mProps._mdf = true;
            items[items.length - 1].transform.op._mdf = true;
            items[items.length - 1].transform.op.v = this._currentCopies === 1 ? this.so.v : this.so.v + (this.eo.v - this.so.v) * (i / (this._currentCopies - 1));
            if (iteration !== 0) {
              if (i !== 0 && dir === 1 || i !== this._currentCopies - 1 && dir === -1) {
                this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, false);
              }
              this.matrix.transform(rProps[0], rProps[1], rProps[2], rProps[3], rProps[4], rProps[5], rProps[6], rProps[7], rProps[8], rProps[9], rProps[10], rProps[11], rProps[12], rProps[13], rProps[14], rProps[15]);
              this.matrix.transform(sProps[0], sProps[1], sProps[2], sProps[3], sProps[4], sProps[5], sProps[6], sProps[7], sProps[8], sProps[9], sProps[10], sProps[11], sProps[12], sProps[13], sProps[14], sProps[15]);
              this.matrix.transform(pProps[0], pProps[1], pProps[2], pProps[3], pProps[4], pProps[5], pProps[6], pProps[7], pProps[8], pProps[9], pProps[10], pProps[11], pProps[12], pProps[13], pProps[14], pProps[15]);
              for (j = 0; j < jLen; j += 1) {
                itemsTransform[j] = this.matrix.props[j];
              }
              this.matrix.reset();
            } else {
              this.matrix.reset();
              for (j = 0; j < jLen; j += 1) {
                itemsTransform[j] = this.matrix.props[j];
              }
            }
            iteration += 1;
            cont -= 1;
            i += dir;
          }
        } else {
          cont = this._currentCopies;
          i = 0;
          dir = 1;
          while (cont) {
            items = this.elemsData[i].it;
            itemsTransform = items[items.length - 1].transform.mProps.v.props;
            items[items.length - 1].transform.mProps._mdf = false;
            items[items.length - 1].transform.op._mdf = false;
            cont -= 1;
            i += dir;
          }
        }
        return hasReloaded;
      };
      RepeaterModifier.prototype.addShape = function() {
      };
      function RoundCornersModifier() {
      }
      extendPrototype([ShapeModifier], RoundCornersModifier);
      RoundCornersModifier.prototype.initModifierProperties = function(elem2, data2) {
        this.getValue = this.processKeys;
        this.rd = PropertyFactory.getProp(elem2, data2.r, 0, null, this);
        this._isAnimated = !!this.rd.effectsSequence.length;
      };
      RoundCornersModifier.prototype.processPath = function(path, round) {
        var clonedPath = shapePool.newElement();
        clonedPath.c = path.c;
        var i;
        var len = path._length;
        var currentV;
        var currentI;
        var currentO;
        var closerV;
        var distance2;
        var newPosPerc;
        var index2 = 0;
        var vX;
        var vY;
        var oX;
        var oY;
        var iX;
        var iY;
        for (i = 0; i < len; i += 1) {
          currentV = path.v[i];
          currentO = path.o[i];
          currentI = path.i[i];
          if (currentV[0] === currentO[0] && currentV[1] === currentO[1] && currentV[0] === currentI[0] && currentV[1] === currentI[1]) {
            if ((i === 0 || i === len - 1) && !path.c) {
              clonedPath.setTripleAt(currentV[0], currentV[1], currentO[0], currentO[1], currentI[0], currentI[1], index2);
              index2 += 1;
            } else {
              if (i === 0) {
                closerV = path.v[len - 1];
              } else {
                closerV = path.v[i - 1];
              }
              distance2 = Math.sqrt(Math.pow(currentV[0] - closerV[0], 2) + Math.pow(currentV[1] - closerV[1], 2));
              newPosPerc = distance2 ? Math.min(distance2 / 2, round) / distance2 : 0;
              iX = currentV[0] + (closerV[0] - currentV[0]) * newPosPerc;
              vX = iX;
              iY = currentV[1] - (currentV[1] - closerV[1]) * newPosPerc;
              vY = iY;
              oX = vX - (vX - currentV[0]) * roundCorner;
              oY = vY - (vY - currentV[1]) * roundCorner;
              clonedPath.setTripleAt(vX, vY, oX, oY, iX, iY, index2);
              index2 += 1;
              if (i === len - 1) {
                closerV = path.v[0];
              } else {
                closerV = path.v[i + 1];
              }
              distance2 = Math.sqrt(Math.pow(currentV[0] - closerV[0], 2) + Math.pow(currentV[1] - closerV[1], 2));
              newPosPerc = distance2 ? Math.min(distance2 / 2, round) / distance2 : 0;
              oX = currentV[0] + (closerV[0] - currentV[0]) * newPosPerc;
              vX = oX;
              oY = currentV[1] + (closerV[1] - currentV[1]) * newPosPerc;
              vY = oY;
              iX = vX - (vX - currentV[0]) * roundCorner;
              iY = vY - (vY - currentV[1]) * roundCorner;
              clonedPath.setTripleAt(vX, vY, oX, oY, iX, iY, index2);
              index2 += 1;
            }
          } else {
            clonedPath.setTripleAt(path.v[i][0], path.v[i][1], path.o[i][0], path.o[i][1], path.i[i][0], path.i[i][1], index2);
            index2 += 1;
          }
        }
        return clonedPath;
      };
      RoundCornersModifier.prototype.processShapes = function(_isFirstFrame) {
        var shapePaths;
        var i;
        var len = this.shapes.length;
        var j;
        var jLen;
        var rd = this.rd.v;
        if (rd !== 0) {
          var shapeData;
          var localShapeCollection;
          for (i = 0; i < len; i += 1) {
            shapeData = this.shapes[i];
            localShapeCollection = shapeData.localShapeCollection;
            if (!(!shapeData.shape._mdf && !this._mdf && !_isFirstFrame)) {
              localShapeCollection.releaseShapes();
              shapeData.shape._mdf = true;
              shapePaths = shapeData.shape.paths.shapes;
              jLen = shapeData.shape.paths._length;
              for (j = 0; j < jLen; j += 1) {
                localShapeCollection.addShape(this.processPath(shapePaths[j], rd));
              }
            }
            shapeData.shape.paths = shapeData.localShapeCollection;
          }
        }
        if (!this.dynamicProperties.length) {
          this._mdf = false;
        }
      };
      function floatEqual(a, b) {
        return Math.abs(a - b) * 1e5 <= Math.min(Math.abs(a), Math.abs(b));
      }
      function floatZero(f3) {
        return Math.abs(f3) <= 1e-5;
      }
      function lerp(p0, p1, amount) {
        return p0 * (1 - amount) + p1 * amount;
      }
      function lerpPoint(p0, p1, amount) {
        return [lerp(p0[0], p1[0], amount), lerp(p0[1], p1[1], amount)];
      }
      function quadRoots(a, b, c) {
        if (a === 0) return [];
        var s = b * b - 4 * a * c;
        if (s < 0) return [];
        var singleRoot = -b / (2 * a);
        if (s === 0) return [singleRoot];
        var delta = Math.sqrt(s) / (2 * a);
        return [singleRoot - delta, singleRoot + delta];
      }
      function polynomialCoefficients(p0, p1, p2, p3) {
        return [-p0 + 3 * p1 - 3 * p2 + p3, 3 * p0 - 6 * p1 + 3 * p2, -3 * p0 + 3 * p1, p0];
      }
      function singlePoint(p) {
        return new PolynomialBezier(p, p, p, p, false);
      }
      function PolynomialBezier(p0, p1, p2, p3, linearize) {
        if (linearize && pointEqual(p0, p1)) {
          p1 = lerpPoint(p0, p3, 1 / 3);
        }
        if (linearize && pointEqual(p2, p3)) {
          p2 = lerpPoint(p0, p3, 2 / 3);
        }
        var coeffx = polynomialCoefficients(p0[0], p1[0], p2[0], p3[0]);
        var coeffy = polynomialCoefficients(p0[1], p1[1], p2[1], p3[1]);
        this.a = [coeffx[0], coeffy[0]];
        this.b = [coeffx[1], coeffy[1]];
        this.c = [coeffx[2], coeffy[2]];
        this.d = [coeffx[3], coeffy[3]];
        this.points = [p0, p1, p2, p3];
      }
      PolynomialBezier.prototype.point = function(t) {
        return [((this.a[0] * t + this.b[0]) * t + this.c[0]) * t + this.d[0], ((this.a[1] * t + this.b[1]) * t + this.c[1]) * t + this.d[1]];
      };
      PolynomialBezier.prototype.derivative = function(t) {
        return [(3 * t * this.a[0] + 2 * this.b[0]) * t + this.c[0], (3 * t * this.a[1] + 2 * this.b[1]) * t + this.c[1]];
      };
      PolynomialBezier.prototype.tangentAngle = function(t) {
        var p = this.derivative(t);
        return Math.atan2(p[1], p[0]);
      };
      PolynomialBezier.prototype.normalAngle = function(t) {
        var p = this.derivative(t);
        return Math.atan2(p[0], p[1]);
      };
      PolynomialBezier.prototype.inflectionPoints = function() {
        var denom = this.a[1] * this.b[0] - this.a[0] * this.b[1];
        if (floatZero(denom)) return [];
        var tcusp = -0.5 * (this.a[1] * this.c[0] - this.a[0] * this.c[1]) / denom;
        var square2 = tcusp * tcusp - 1 / 3 * (this.b[1] * this.c[0] - this.b[0] * this.c[1]) / denom;
        if (square2 < 0) return [];
        var root = Math.sqrt(square2);
        if (floatZero(root)) {
          if (root > 0 && root < 1) return [tcusp];
          return [];
        }
        return [tcusp - root, tcusp + root].filter(function(r) {
          return r > 0 && r < 1;
        });
      };
      PolynomialBezier.prototype.split = function(t) {
        if (t <= 0) return [singlePoint(this.points[0]), this];
        if (t >= 1) return [this, singlePoint(this.points[this.points.length - 1])];
        var p10 = lerpPoint(this.points[0], this.points[1], t);
        var p11 = lerpPoint(this.points[1], this.points[2], t);
        var p12 = lerpPoint(this.points[2], this.points[3], t);
        var p20 = lerpPoint(p10, p11, t);
        var p21 = lerpPoint(p11, p12, t);
        var p3 = lerpPoint(p20, p21, t);
        return [new PolynomialBezier(this.points[0], p10, p20, p3, true), new PolynomialBezier(p3, p21, p12, this.points[3], true)];
      };
      function extrema(bez2, comp2) {
        var min = bez2.points[0][comp2];
        var max = bez2.points[bez2.points.length - 1][comp2];
        if (min > max) {
          var e = max;
          max = min;
          min = e;
        }
        var f3 = quadRoots(3 * bez2.a[comp2], 2 * bez2.b[comp2], bez2.c[comp2]);
        for (var i = 0; i < f3.length; i += 1) {
          if (f3[i] > 0 && f3[i] < 1) {
            var val2 = bez2.point(f3[i])[comp2];
            if (val2 < min) min = val2;
            else if (val2 > max) max = val2;
          }
        }
        return {
          min,
          max
        };
      }
      PolynomialBezier.prototype.bounds = function() {
        return {
          x: extrema(this, 0),
          y: extrema(this, 1)
        };
      };
      PolynomialBezier.prototype.boundingBox = function() {
        var bounds = this.bounds();
        return {
          left: bounds.x.min,
          right: bounds.x.max,
          top: bounds.y.min,
          bottom: bounds.y.max,
          width: bounds.x.max - bounds.x.min,
          height: bounds.y.max - bounds.y.min,
          cx: (bounds.x.max + bounds.x.min) / 2,
          cy: (bounds.y.max + bounds.y.min) / 2
        };
      };
      function intersectData(bez2, t1, t2) {
        var box = bez2.boundingBox();
        return {
          cx: box.cx,
          cy: box.cy,
          width: box.width,
          height: box.height,
          bez: bez2,
          t: (t1 + t2) / 2,
          t1,
          t2
        };
      }
      function splitData(data2) {
        var split = data2.bez.split(0.5);
        return [intersectData(split[0], data2.t1, data2.t), intersectData(split[1], data2.t, data2.t2)];
      }
      function boxIntersect(b1, b2) {
        return Math.abs(b1.cx - b2.cx) * 2 < b1.width + b2.width && Math.abs(b1.cy - b2.cy) * 2 < b1.height + b2.height;
      }
      function intersectsImpl(d1, d2, depth, tolerance, intersections, maxRecursion) {
        if (!boxIntersect(d1, d2)) return;
        if (depth >= maxRecursion || d1.width <= tolerance && d1.height <= tolerance && d2.width <= tolerance && d2.height <= tolerance) {
          intersections.push([d1.t, d2.t]);
          return;
        }
        var d1s = splitData(d1);
        var d2s = splitData(d2);
        intersectsImpl(d1s[0], d2s[0], depth + 1, tolerance, intersections, maxRecursion);
        intersectsImpl(d1s[0], d2s[1], depth + 1, tolerance, intersections, maxRecursion);
        intersectsImpl(d1s[1], d2s[0], depth + 1, tolerance, intersections, maxRecursion);
        intersectsImpl(d1s[1], d2s[1], depth + 1, tolerance, intersections, maxRecursion);
      }
      PolynomialBezier.prototype.intersections = function(other, tolerance, maxRecursion) {
        if (tolerance === void 0) tolerance = 2;
        if (maxRecursion === void 0) maxRecursion = 7;
        var intersections = [];
        intersectsImpl(intersectData(this, 0, 1), intersectData(other, 0, 1), 0, tolerance, intersections, maxRecursion);
        return intersections;
      };
      PolynomialBezier.shapeSegment = function(shapePath, index2) {
        var nextIndex = (index2 + 1) % shapePath.length();
        return new PolynomialBezier(shapePath.v[index2], shapePath.o[index2], shapePath.i[nextIndex], shapePath.v[nextIndex], true);
      };
      PolynomialBezier.shapeSegmentInverted = function(shapePath, index2) {
        var nextIndex = (index2 + 1) % shapePath.length();
        return new PolynomialBezier(shapePath.v[nextIndex], shapePath.i[nextIndex], shapePath.o[index2], shapePath.v[index2], true);
      };
      function crossProduct(a, b) {
        return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
      }
      function lineIntersection(start1, end1, start2, end2) {
        var v1 = [start1[0], start1[1], 1];
        var v2 = [end1[0], end1[1], 1];
        var v33 = [start2[0], start2[1], 1];
        var v43 = [end2[0], end2[1], 1];
        var r = crossProduct(crossProduct(v1, v2), crossProduct(v33, v43));
        if (floatZero(r[2])) return null;
        return [r[0] / r[2], r[1] / r[2]];
      }
      function polarOffset(p, angle, length2) {
        return [p[0] + Math.cos(angle) * length2, p[1] - Math.sin(angle) * length2];
      }
      function pointDistance(p1, p2) {
        return Math.hypot(p1[0] - p2[0], p1[1] - p2[1]);
      }
      function pointEqual(p1, p2) {
        return floatEqual(p1[0], p2[0]) && floatEqual(p1[1], p2[1]);
      }
      function ZigZagModifier() {
      }
      extendPrototype([ShapeModifier], ZigZagModifier);
      ZigZagModifier.prototype.initModifierProperties = function(elem2, data2) {
        this.getValue = this.processKeys;
        this.amplitude = PropertyFactory.getProp(elem2, data2.s, 0, null, this);
        this.frequency = PropertyFactory.getProp(elem2, data2.r, 0, null, this);
        this.pointsType = PropertyFactory.getProp(elem2, data2.pt, 0, null, this);
        this._isAnimated = this.amplitude.effectsSequence.length !== 0 || this.frequency.effectsSequence.length !== 0 || this.pointsType.effectsSequence.length !== 0;
      };
      function setPoint(outputBezier, point, angle, direction, amplitude, outAmplitude, inAmplitude) {
        var angO = angle - Math.PI / 2;
        var angI = angle + Math.PI / 2;
        var px = point[0] + Math.cos(angle) * direction * amplitude;
        var py = point[1] - Math.sin(angle) * direction * amplitude;
        outputBezier.setTripleAt(px, py, px + Math.cos(angO) * outAmplitude, py - Math.sin(angO) * outAmplitude, px + Math.cos(angI) * inAmplitude, py - Math.sin(angI) * inAmplitude, outputBezier.length());
      }
      function getPerpendicularVector(pt1, pt2) {
        var vector = [pt2[0] - pt1[0], pt2[1] - pt1[1]];
        var rot = -Math.PI * 0.5;
        var rotatedVector = [Math.cos(rot) * vector[0] - Math.sin(rot) * vector[1], Math.sin(rot) * vector[0] + Math.cos(rot) * vector[1]];
        return rotatedVector;
      }
      function getProjectingAngle(path, cur) {
        var prevIndex = cur === 0 ? path.length() - 1 : cur - 1;
        var nextIndex = (cur + 1) % path.length();
        var prevPoint = path.v[prevIndex];
        var nextPoint = path.v[nextIndex];
        var pVector = getPerpendicularVector(prevPoint, nextPoint);
        return Math.atan2(0, 1) - Math.atan2(pVector[1], pVector[0]);
      }
      function zigZagCorner(outputBezier, path, cur, amplitude, frequency, pointType, direction) {
        var angle = getProjectingAngle(path, cur);
        var point = path.v[cur % path._length];
        var prevPoint = path.v[cur === 0 ? path._length - 1 : cur - 1];
        var nextPoint = path.v[(cur + 1) % path._length];
        var prevDist = pointType === 2 ? Math.sqrt(Math.pow(point[0] - prevPoint[0], 2) + Math.pow(point[1] - prevPoint[1], 2)) : 0;
        var nextDist = pointType === 2 ? Math.sqrt(Math.pow(point[0] - nextPoint[0], 2) + Math.pow(point[1] - nextPoint[1], 2)) : 0;
        setPoint(outputBezier, path.v[cur % path._length], angle, direction, amplitude, nextDist / ((frequency + 1) * 2), prevDist / ((frequency + 1) * 2), pointType);
      }
      function zigZagSegment(outputBezier, segment, amplitude, frequency, pointType, direction) {
        for (var i = 0; i < frequency; i += 1) {
          var t = (i + 1) / (frequency + 1);
          var dist = pointType === 2 ? Math.sqrt(Math.pow(segment.points[3][0] - segment.points[0][0], 2) + Math.pow(segment.points[3][1] - segment.points[0][1], 2)) : 0;
          var angle = segment.normalAngle(t);
          var point = segment.point(t);
          setPoint(outputBezier, point, angle, direction, amplitude, dist / ((frequency + 1) * 2), dist / ((frequency + 1) * 2), pointType);
          direction = -direction;
        }
        return direction;
      }
      ZigZagModifier.prototype.processPath = function(path, amplitude, frequency, pointType) {
        var count = path._length;
        var clonedPath = shapePool.newElement();
        clonedPath.c = path.c;
        if (!path.c) {
          count -= 1;
        }
        if (count === 0) return clonedPath;
        var direction = -1;
        var segment = PolynomialBezier.shapeSegment(path, 0);
        zigZagCorner(clonedPath, path, 0, amplitude, frequency, pointType, direction);
        for (var i = 0; i < count; i += 1) {
          direction = zigZagSegment(clonedPath, segment, amplitude, frequency, pointType, -direction);
          if (i === count - 1 && !path.c) {
            segment = null;
          } else {
            segment = PolynomialBezier.shapeSegment(path, (i + 1) % count);
          }
          zigZagCorner(clonedPath, path, i + 1, amplitude, frequency, pointType, direction);
        }
        return clonedPath;
      };
      ZigZagModifier.prototype.processShapes = function(_isFirstFrame) {
        var shapePaths;
        var i;
        var len = this.shapes.length;
        var j;
        var jLen;
        var amplitude = this.amplitude.v;
        var frequency = Math.max(0, Math.round(this.frequency.v));
        var pointType = this.pointsType.v;
        if (amplitude !== 0) {
          var shapeData;
          var localShapeCollection;
          for (i = 0; i < len; i += 1) {
            shapeData = this.shapes[i];
            localShapeCollection = shapeData.localShapeCollection;
            if (!(!shapeData.shape._mdf && !this._mdf && !_isFirstFrame)) {
              localShapeCollection.releaseShapes();
              shapeData.shape._mdf = true;
              shapePaths = shapeData.shape.paths.shapes;
              jLen = shapeData.shape.paths._length;
              for (j = 0; j < jLen; j += 1) {
                localShapeCollection.addShape(this.processPath(shapePaths[j], amplitude, frequency, pointType));
              }
            }
            shapeData.shape.paths = shapeData.localShapeCollection;
          }
        }
        if (!this.dynamicProperties.length) {
          this._mdf = false;
        }
      };
      function linearOffset(p1, p2, amount) {
        var angle = Math.atan2(p2[0] - p1[0], p2[1] - p1[1]);
        return [polarOffset(p1, angle, amount), polarOffset(p2, angle, amount)];
      }
      function offsetSegment(segment, amount) {
        var p0;
        var p1a;
        var p1b;
        var p2b;
        var p2a;
        var p3;
        var e;
        e = linearOffset(segment.points[0], segment.points[1], amount);
        p0 = e[0];
        p1a = e[1];
        e = linearOffset(segment.points[1], segment.points[2], amount);
        p1b = e[0];
        p2b = e[1];
        e = linearOffset(segment.points[2], segment.points[3], amount);
        p2a = e[0];
        p3 = e[1];
        var p1 = lineIntersection(p0, p1a, p1b, p2b);
        if (p1 === null) p1 = p1a;
        var p2 = lineIntersection(p2a, p3, p1b, p2b);
        if (p2 === null) p2 = p2a;
        return new PolynomialBezier(p0, p1, p2, p3);
      }
      function joinLines(outputBezier, seg1, seg2, lineJoin, miterLimit) {
        var p0 = seg1.points[3];
        var p1 = seg2.points[0];
        if (lineJoin === 3) return p0;
        if (pointEqual(p0, p1)) return p0;
        if (lineJoin === 2) {
          var angleOut = -seg1.tangentAngle(1);
          var angleIn = -seg2.tangentAngle(0) + Math.PI;
          var center = lineIntersection(p0, polarOffset(p0, angleOut + Math.PI / 2, 100), p1, polarOffset(p1, angleOut + Math.PI / 2, 100));
          var radius = center ? pointDistance(center, p0) : pointDistance(p0, p1) / 2;
          var tan = polarOffset(p0, angleOut, 2 * radius * roundCorner);
          outputBezier.setXYAt(tan[0], tan[1], "o", outputBezier.length() - 1);
          tan = polarOffset(p1, angleIn, 2 * radius * roundCorner);
          outputBezier.setTripleAt(p1[0], p1[1], p1[0], p1[1], tan[0], tan[1], outputBezier.length());
          return p1;
        }
        var t0 = pointEqual(p0, seg1.points[2]) ? seg1.points[0] : seg1.points[2];
        var t1 = pointEqual(p1, seg2.points[1]) ? seg2.points[3] : seg2.points[1];
        var intersection = lineIntersection(t0, p0, p1, t1);
        if (intersection && pointDistance(intersection, p0) < miterLimit) {
          outputBezier.setTripleAt(intersection[0], intersection[1], intersection[0], intersection[1], intersection[0], intersection[1], outputBezier.length());
          return intersection;
        }
        return p0;
      }
      function getIntersection(a, b) {
        var intersect = a.intersections(b);
        if (intersect.length && floatEqual(intersect[0][0], 1)) intersect.shift();
        if (intersect.length) return intersect[0];
        return null;
      }
      function pruneSegmentIntersection(a, b) {
        var outa = a.slice();
        var outb = b.slice();
        var intersect = getIntersection(a[a.length - 1], b[0]);
        if (intersect) {
          outa[a.length - 1] = a[a.length - 1].split(intersect[0])[0];
          outb[0] = b[0].split(intersect[1])[1];
        }
        if (a.length > 1 && b.length > 1) {
          intersect = getIntersection(a[0], b[b.length - 1]);
          if (intersect) {
            return [[a[0].split(intersect[0])[0]], [b[b.length - 1].split(intersect[1])[1]]];
          }
        }
        return [outa, outb];
      }
      function pruneIntersections(segments) {
        var e;
        for (var i = 1; i < segments.length; i += 1) {
          e = pruneSegmentIntersection(segments[i - 1], segments[i]);
          segments[i - 1] = e[0];
          segments[i] = e[1];
        }
        if (segments.length > 1) {
          e = pruneSegmentIntersection(segments[segments.length - 1], segments[0]);
          segments[segments.length - 1] = e[0];
          segments[0] = e[1];
        }
        return segments;
      }
      function offsetSegmentSplit(segment, amount) {
        var flex = segment.inflectionPoints();
        var left2;
        var right2;
        var split;
        var mid;
        if (flex.length === 0) {
          return [offsetSegment(segment, amount)];
        }
        if (flex.length === 1 || floatEqual(flex[1], 1)) {
          split = segment.split(flex[0]);
          left2 = split[0];
          right2 = split[1];
          return [offsetSegment(left2, amount), offsetSegment(right2, amount)];
        }
        split = segment.split(flex[0]);
        left2 = split[0];
        var t = (flex[1] - flex[0]) / (1 - flex[0]);
        split = split[1].split(t);
        mid = split[0];
        right2 = split[1];
        return [offsetSegment(left2, amount), offsetSegment(mid, amount), offsetSegment(right2, amount)];
      }
      function OffsetPathModifier() {
      }
      extendPrototype([ShapeModifier], OffsetPathModifier);
      OffsetPathModifier.prototype.initModifierProperties = function(elem2, data2) {
        this.getValue = this.processKeys;
        this.amount = PropertyFactory.getProp(elem2, data2.a, 0, null, this);
        this.miterLimit = PropertyFactory.getProp(elem2, data2.ml, 0, null, this);
        this.lineJoin = data2.lj;
        this._isAnimated = this.amount.effectsSequence.length !== 0;
      };
      OffsetPathModifier.prototype.processPath = function(inputBezier, amount, lineJoin, miterLimit) {
        var outputBezier = shapePool.newElement();
        outputBezier.c = inputBezier.c;
        var count = inputBezier.length();
        if (!inputBezier.c) {
          count -= 1;
        }
        var i;
        var j;
        var segment;
        var multiSegments = [];
        for (i = 0; i < count; i += 1) {
          segment = PolynomialBezier.shapeSegment(inputBezier, i);
          multiSegments.push(offsetSegmentSplit(segment, amount));
        }
        if (!inputBezier.c) {
          for (i = count - 1; i >= 0; i -= 1) {
            segment = PolynomialBezier.shapeSegmentInverted(inputBezier, i);
            multiSegments.push(offsetSegmentSplit(segment, amount));
          }
        }
        multiSegments = pruneIntersections(multiSegments);
        var lastPoint = null;
        var lastSeg = null;
        for (i = 0; i < multiSegments.length; i += 1) {
          var multiSegment = multiSegments[i];
          if (lastSeg) lastPoint = joinLines(outputBezier, lastSeg, multiSegment[0], lineJoin, miterLimit);
          lastSeg = multiSegment[multiSegment.length - 1];
          for (j = 0; j < multiSegment.length; j += 1) {
            segment = multiSegment[j];
            if (lastPoint && pointEqual(segment.points[0], lastPoint)) {
              outputBezier.setXYAt(segment.points[1][0], segment.points[1][1], "o", outputBezier.length() - 1);
            } else {
              outputBezier.setTripleAt(segment.points[0][0], segment.points[0][1], segment.points[1][0], segment.points[1][1], segment.points[0][0], segment.points[0][1], outputBezier.length());
            }
            outputBezier.setTripleAt(segment.points[3][0], segment.points[3][1], segment.points[3][0], segment.points[3][1], segment.points[2][0], segment.points[2][1], outputBezier.length());
            lastPoint = segment.points[3];
          }
        }
        if (multiSegments.length) joinLines(outputBezier, lastSeg, multiSegments[0][0], lineJoin, miterLimit);
        return outputBezier;
      };
      OffsetPathModifier.prototype.processShapes = function(_isFirstFrame) {
        var shapePaths;
        var i;
        var len = this.shapes.length;
        var j;
        var jLen;
        var amount = this.amount.v;
        var miterLimit = this.miterLimit.v;
        var lineJoin = this.lineJoin;
        if (amount !== 0) {
          var shapeData;
          var localShapeCollection;
          for (i = 0; i < len; i += 1) {
            shapeData = this.shapes[i];
            localShapeCollection = shapeData.localShapeCollection;
            if (!(!shapeData.shape._mdf && !this._mdf && !_isFirstFrame)) {
              localShapeCollection.releaseShapes();
              shapeData.shape._mdf = true;
              shapePaths = shapeData.shape.paths.shapes;
              jLen = shapeData.shape.paths._length;
              for (j = 0; j < jLen; j += 1) {
                localShapeCollection.addShape(this.processPath(shapePaths[j], amount, lineJoin, miterLimit));
              }
            }
            shapeData.shape.paths = shapeData.localShapeCollection;
          }
        }
        if (!this.dynamicProperties.length) {
          this._mdf = false;
        }
      };
      function getFontProperties(fontData) {
        var styles = fontData.fStyle ? fontData.fStyle.split(" ") : [];
        var fWeight = "normal";
        var fStyle = "normal";
        var len = styles.length;
        var styleName;
        for (var i = 0; i < len; i += 1) {
          styleName = styles[i].toLowerCase();
          switch (styleName) {
            case "italic":
              fStyle = "italic";
              break;
            case "bold":
              fWeight = "700";
              break;
            case "black":
              fWeight = "900";
              break;
            case "medium":
              fWeight = "500";
              break;
            case "regular":
            case "normal":
              fWeight = "400";
              break;
            case "light":
            case "thin":
              fWeight = "200";
              break;
            default:
              break;
          }
        }
        return {
          style: fStyle,
          weight: fontData.fWeight || fWeight
        };
      }
      var FontManager = function() {
        var maxWaitingTime = 5e3;
        var emptyChar = {
          w: 0,
          size: 0,
          shapes: [],
          data: {
            shapes: []
          }
        };
        var combinedCharacters = [];
        combinedCharacters = combinedCharacters.concat([2304, 2305, 2306, 2307, 2362, 2363, 2364, 2364, 2366, 2367, 2368, 2369, 2370, 2371, 2372, 2373, 2374, 2375, 2376, 2377, 2378, 2379, 2380, 2381, 2382, 2383, 2387, 2388, 2389, 2390, 2391, 2402, 2403]);
        var BLACK_FLAG_CODE_POINT = 127988;
        var CANCEL_TAG_CODE_POINT = 917631;
        var A_TAG_CODE_POINT = 917601;
        var Z_TAG_CODE_POINT = 917626;
        var VARIATION_SELECTOR_16_CODE_POINT = 65039;
        var ZERO_WIDTH_JOINER_CODE_POINT = 8205;
        var REGIONAL_CHARACTER_A_CODE_POINT = 127462;
        var REGIONAL_CHARACTER_Z_CODE_POINT = 127487;
        var surrogateModifiers = ["d83cdffb", "d83cdffc", "d83cdffd", "d83cdffe", "d83cdfff"];
        function trimFontOptions(font) {
          var familyArray = font.split(",");
          var i;
          var len = familyArray.length;
          var enabledFamilies = [];
          for (i = 0; i < len; i += 1) {
            if (familyArray[i] !== "sans-serif" && familyArray[i] !== "monospace") {
              enabledFamilies.push(familyArray[i]);
            }
          }
          return enabledFamilies.join(",");
        }
        function setUpNode(font, family) {
          var parentNode = createTag("span");
          parentNode.setAttribute("aria-hidden", true);
          parentNode.style.fontFamily = family;
          var node = createTag("span");
          node.innerText = "giItT1WQy@!-/#";
          parentNode.style.position = "absolute";
          parentNode.style.left = "-10000px";
          parentNode.style.top = "-10000px";
          parentNode.style.fontSize = "300px";
          parentNode.style.fontVariant = "normal";
          parentNode.style.fontStyle = "normal";
          parentNode.style.fontWeight = "normal";
          parentNode.style.letterSpacing = "0";
          parentNode.appendChild(node);
          document.body.appendChild(parentNode);
          var width2 = node.offsetWidth;
          node.style.fontFamily = trimFontOptions(font) + ", " + family;
          return {
            node,
            w: width2,
            parent: parentNode
          };
        }
        function checkLoadedFonts() {
          var i;
          var len = this.fonts.length;
          var node;
          var w;
          var loadedCount = len;
          for (i = 0; i < len; i += 1) {
            if (this.fonts[i].loaded) {
              loadedCount -= 1;
            } else if (this.fonts[i].fOrigin === "n" || this.fonts[i].origin === 0) {
              this.fonts[i].loaded = true;
            } else {
              node = this.fonts[i].monoCase.node;
              w = this.fonts[i].monoCase.w;
              if (node.offsetWidth !== w) {
                loadedCount -= 1;
                this.fonts[i].loaded = true;
              } else {
                node = this.fonts[i].sansCase.node;
                w = this.fonts[i].sansCase.w;
                if (node.offsetWidth !== w) {
                  loadedCount -= 1;
                  this.fonts[i].loaded = true;
                }
              }
              if (this.fonts[i].loaded) {
                this.fonts[i].sansCase.parent.parentNode.removeChild(this.fonts[i].sansCase.parent);
                this.fonts[i].monoCase.parent.parentNode.removeChild(this.fonts[i].monoCase.parent);
              }
            }
          }
          if (loadedCount !== 0 && Date.now() - this.initTime < maxWaitingTime) {
            setTimeout(this.checkLoadedFontsBinded, 20);
          } else {
            setTimeout(this.setIsLoadedBinded, 10);
          }
        }
        function createHelper(fontData, def) {
          var engine = document.body && def ? "svg" : "canvas";
          var helper;
          var fontProps = getFontProperties(fontData);
          if (engine === "svg") {
            var tHelper = createNS("text");
            tHelper.style.fontSize = "100px";
            tHelper.setAttribute("font-family", fontData.fFamily);
            tHelper.setAttribute("font-style", fontProps.style);
            tHelper.setAttribute("font-weight", fontProps.weight);
            tHelper.textContent = "1";
            if (fontData.fClass) {
              tHelper.style.fontFamily = "inherit";
              tHelper.setAttribute("class", fontData.fClass);
            } else {
              tHelper.style.fontFamily = fontData.fFamily;
            }
            def.appendChild(tHelper);
            helper = tHelper;
          } else {
            var tCanvasHelper = new OffscreenCanvas(500, 500).getContext("2d");
            tCanvasHelper.font = fontProps.style + " " + fontProps.weight + " 100px " + fontData.fFamily;
            helper = tCanvasHelper;
          }
          function measure(text2) {
            if (engine === "svg") {
              helper.textContent = text2;
              return helper.getComputedTextLength();
            }
            return helper.measureText(text2).width;
          }
          return {
            measureText: measure
          };
        }
        function addFonts(fontData, defs) {
          if (!fontData) {
            this.isLoaded = true;
            return;
          }
          if (this.chars) {
            this.isLoaded = true;
            this.fonts = fontData.list;
            return;
          }
          if (!document.body) {
            this.isLoaded = true;
            fontData.list.forEach(function(data2) {
              data2.helper = createHelper(data2);
              data2.cache = {};
            });
            this.fonts = fontData.list;
            return;
          }
          var fontArr = fontData.list;
          var i;
          var len = fontArr.length;
          var _pendingFonts = len;
          for (i = 0; i < len; i += 1) {
            var shouldLoadFont = true;
            var loadedSelector;
            var j;
            fontArr[i].loaded = false;
            fontArr[i].monoCase = setUpNode(fontArr[i].fFamily, "monospace");
            fontArr[i].sansCase = setUpNode(fontArr[i].fFamily, "sans-serif");
            if (!fontArr[i].fPath) {
              fontArr[i].loaded = true;
              _pendingFonts -= 1;
            } else if (fontArr[i].fOrigin === "p" || fontArr[i].origin === 3) {
              loadedSelector = document.querySelectorAll('style[f-forigin="p"][f-family="' + fontArr[i].fFamily + '"], style[f-origin="3"][f-family="' + fontArr[i].fFamily + '"]');
              if (loadedSelector.length > 0) {
                shouldLoadFont = false;
              }
              if (shouldLoadFont) {
                var s = createTag("style");
                s.setAttribute("f-forigin", fontArr[i].fOrigin);
                s.setAttribute("f-origin", fontArr[i].origin);
                s.setAttribute("f-family", fontArr[i].fFamily);
                s.type = "text/css";
                s.innerText = "@font-face {font-family: " + fontArr[i].fFamily + "; font-style: normal; src: url('" + fontArr[i].fPath + "');}";
                defs.appendChild(s);
              }
            } else if (fontArr[i].fOrigin === "g" || fontArr[i].origin === 1) {
              loadedSelector = document.querySelectorAll('link[f-forigin="g"], link[f-origin="1"]');
              for (j = 0; j < loadedSelector.length; j += 1) {
                if (loadedSelector[j].href.indexOf(fontArr[i].fPath) !== -1) {
                  shouldLoadFont = false;
                }
              }
              if (shouldLoadFont) {
                var l = createTag("link");
                l.setAttribute("f-forigin", fontArr[i].fOrigin);
                l.setAttribute("f-origin", fontArr[i].origin);
                l.type = "text/css";
                l.rel = "stylesheet";
                l.href = fontArr[i].fPath;
                document.body.appendChild(l);
              }
            } else if (fontArr[i].fOrigin === "t" || fontArr[i].origin === 2) {
              loadedSelector = document.querySelectorAll('script[f-forigin="t"], script[f-origin="2"]');
              for (j = 0; j < loadedSelector.length; j += 1) {
                if (fontArr[i].fPath === loadedSelector[j].src) {
                  shouldLoadFont = false;
                }
              }
              if (shouldLoadFont) {
                var sc = createTag("link");
                sc.setAttribute("f-forigin", fontArr[i].fOrigin);
                sc.setAttribute("f-origin", fontArr[i].origin);
                sc.setAttribute("rel", "stylesheet");
                sc.setAttribute("href", fontArr[i].fPath);
                defs.appendChild(sc);
              }
            }
            fontArr[i].helper = createHelper(fontArr[i], defs);
            fontArr[i].cache = {};
            this.fonts.push(fontArr[i]);
          }
          if (_pendingFonts === 0) {
            this.isLoaded = true;
          } else {
            setTimeout(this.checkLoadedFonts.bind(this), 100);
          }
        }
        function addChars(chars2) {
          if (!chars2) {
            return;
          }
          if (!this.chars) {
            this.chars = [];
          }
          var i;
          var len = chars2.length;
          var j;
          var jLen = this.chars.length;
          var found;
          for (i = 0; i < len; i += 1) {
            j = 0;
            found = false;
            while (j < jLen) {
              if (this.chars[j].style === chars2[i].style && this.chars[j].fFamily === chars2[i].fFamily && this.chars[j].ch === chars2[i].ch) {
                found = true;
              }
              j += 1;
            }
            if (!found) {
              this.chars.push(chars2[i]);
              jLen += 1;
            }
          }
        }
        function getCharData(_char, style, font) {
          var i = 0;
          var len = this.chars.length;
          while (i < len) {
            if (this.chars[i].ch === _char && this.chars[i].style === style && this.chars[i].fFamily === font) {
              return this.chars[i];
            }
            i += 1;
          }
          if ((typeof _char === "string" && _char.charCodeAt(0) !== 13 || !_char) && console && console.warn && !this._warned) {
            this._warned = true;
            console.warn("Missing character from exported characters list: ", _char, style, font);
          }
          return emptyChar;
        }
        function measureText(_char2, fontName, size) {
          var fontData = this.getFontByName(fontName);
          var index2 = _char2;
          if (!fontData.cache[index2]) {
            var tHelper = fontData.helper;
            if (_char2 === " ") {
              var doubleSize = tHelper.measureText("|" + _char2 + "|");
              var singleSize = tHelper.measureText("||");
              fontData.cache[index2] = (doubleSize - singleSize) / 100;
            } else {
              fontData.cache[index2] = tHelper.measureText(_char2) / 100;
            }
          }
          return fontData.cache[index2] * size;
        }
        function getFontByName(name2) {
          var i = 0;
          var len = this.fonts.length;
          while (i < len) {
            if (this.fonts[i].fName === name2) {
              return this.fonts[i];
            }
            i += 1;
          }
          return this.fonts[0];
        }
        function getCodePoint(string) {
          var codePoint = 0;
          var first = string.charCodeAt(0);
          if (first >= 55296 && first <= 56319) {
            var second = string.charCodeAt(1);
            if (second >= 56320 && second <= 57343) {
              codePoint = (first - 55296) * 1024 + second - 56320 + 65536;
            }
          }
          return codePoint;
        }
        function isModifier(firstCharCode, secondCharCode) {
          var sum2 = firstCharCode.toString(16) + secondCharCode.toString(16);
          return surrogateModifiers.indexOf(sum2) !== -1;
        }
        function isZeroWidthJoiner(charCode) {
          return charCode === ZERO_WIDTH_JOINER_CODE_POINT;
        }
        function isVariationSelector(charCode) {
          return charCode === VARIATION_SELECTOR_16_CODE_POINT;
        }
        function isRegionalCode(string) {
          var codePoint = getCodePoint(string);
          if (codePoint >= REGIONAL_CHARACTER_A_CODE_POINT && codePoint <= REGIONAL_CHARACTER_Z_CODE_POINT) {
            return true;
          }
          return false;
        }
        function isFlagEmoji(string) {
          return isRegionalCode(string.substr(0, 2)) && isRegionalCode(string.substr(2, 2));
        }
        function isCombinedCharacter(_char3) {
          return combinedCharacters.indexOf(_char3) !== -1;
        }
        function isRegionalFlag(text2, index2) {
          var codePoint = getCodePoint(text2.substr(index2, 2));
          if (codePoint !== BLACK_FLAG_CODE_POINT) {
            return false;
          }
          var count = 0;
          index2 += 2;
          while (count < 5) {
            codePoint = getCodePoint(text2.substr(index2, 2));
            if (codePoint < A_TAG_CODE_POINT || codePoint > Z_TAG_CODE_POINT) {
              return false;
            }
            count += 1;
            index2 += 2;
          }
          return getCodePoint(text2.substr(index2, 2)) === CANCEL_TAG_CODE_POINT;
        }
        function setIsLoaded() {
          this.isLoaded = true;
        }
        var Font = function Font2() {
          this.fonts = [];
          this.chars = null;
          this.typekitLoaded = 0;
          this.isLoaded = false;
          this._warned = false;
          this.initTime = Date.now();
          this.setIsLoadedBinded = this.setIsLoaded.bind(this);
          this.checkLoadedFontsBinded = this.checkLoadedFonts.bind(this);
        };
        Font.isModifier = isModifier;
        Font.isZeroWidthJoiner = isZeroWidthJoiner;
        Font.isFlagEmoji = isFlagEmoji;
        Font.isRegionalCode = isRegionalCode;
        Font.isCombinedCharacter = isCombinedCharacter;
        Font.isRegionalFlag = isRegionalFlag;
        Font.isVariationSelector = isVariationSelector;
        Font.BLACK_FLAG_CODE_POINT = BLACK_FLAG_CODE_POINT;
        var fontPrototype = {
          addChars,
          addFonts,
          getCharData,
          getFontByName,
          measureText,
          checkLoadedFonts,
          setIsLoaded
        };
        Font.prototype = fontPrototype;
        return Font;
      }();
      function SlotManager(animationData2) {
        this.animationData = animationData2;
      }
      SlotManager.prototype.getProp = function(data2) {
        if (this.animationData.slots && this.animationData.slots[data2.sid]) {
          return Object.assign(data2, this.animationData.slots[data2.sid].p);
        }
        return data2;
      };
      function slotFactory(animationData2) {
        return new SlotManager(animationData2);
      }
      function RenderableElement() {
      }
      RenderableElement.prototype = {
        initRenderable: function initRenderable() {
          this.isInRange = false;
          this.hidden = false;
          this.isTransparent = false;
          this.renderableComponents = [];
        },
        addRenderableComponent: function addRenderableComponent(component) {
          if (this.renderableComponents.indexOf(component) === -1) {
            this.renderableComponents.push(component);
          }
        },
        removeRenderableComponent: function removeRenderableComponent(component) {
          if (this.renderableComponents.indexOf(component) !== -1) {
            this.renderableComponents.splice(this.renderableComponents.indexOf(component), 1);
          }
        },
        prepareRenderableFrame: function prepareRenderableFrame(num) {
          this.checkLayerLimits(num);
        },
        checkTransparency: function checkTransparency() {
          if (this.finalTransform.mProp.o.v <= 0) {
            if (!this.isTransparent && this.globalData.renderConfig.hideOnTransparent) {
              this.isTransparent = true;
              this.hide();
            }
          } else if (this.isTransparent) {
            this.isTransparent = false;
            this.show();
          }
        },
        /**
           * @function
           * Initializes frame related properties.
           *
           * @param {number} num
           * current frame number in Layer's time
           *
           */
        checkLayerLimits: function checkLayerLimits(num) {
          if (this.data.ip - this.data.st <= num && this.data.op - this.data.st > num) {
            if (this.isInRange !== true) {
              this.globalData._mdf = true;
              this._mdf = true;
              this.isInRange = true;
              this.show();
            }
          } else if (this.isInRange !== false) {
            this.globalData._mdf = true;
            this.isInRange = false;
            this.hide();
          }
        },
        renderRenderable: function renderRenderable() {
          var i;
          var len = this.renderableComponents.length;
          for (i = 0; i < len; i += 1) {
            this.renderableComponents[i].renderFrame(this._isFirstFrame);
          }
        },
        sourceRectAtTime: function sourceRectAtTime2() {
          return {
            top: 0,
            left: 0,
            width: 100,
            height: 100
          };
        },
        getLayerSize: function getLayerSize() {
          if (this.data.ty === 5) {
            return {
              w: this.data.textData.width,
              h: this.data.textData.height
            };
          }
          return {
            w: this.data.width,
            h: this.data.height
          };
        }
      };
      var getBlendMode = /* @__PURE__ */ function() {
        var blendModeEnums = {
          0: "source-over",
          1: "multiply",
          2: "screen",
          3: "overlay",
          4: "darken",
          5: "lighten",
          6: "color-dodge",
          7: "color-burn",
          8: "hard-light",
          9: "soft-light",
          10: "difference",
          11: "exclusion",
          12: "hue",
          13: "saturation",
          14: "color",
          15: "luminosity"
        };
        return function(mode) {
          return blendModeEnums[mode] || "";
        };
      }();
      function SliderEffect(data2, elem2, container) {
        this.p = PropertyFactory.getProp(elem2, data2.v, 0, 0, container);
      }
      function AngleEffect(data2, elem2, container) {
        this.p = PropertyFactory.getProp(elem2, data2.v, 0, 0, container);
      }
      function ColorEffect(data2, elem2, container) {
        this.p = PropertyFactory.getProp(elem2, data2.v, 1, 0, container);
      }
      function PointEffect(data2, elem2, container) {
        this.p = PropertyFactory.getProp(elem2, data2.v, 1, 0, container);
      }
      function LayerIndexEffect(data2, elem2, container) {
        this.p = PropertyFactory.getProp(elem2, data2.v, 0, 0, container);
      }
      function MaskIndexEffect(data2, elem2, container) {
        this.p = PropertyFactory.getProp(elem2, data2.v, 0, 0, container);
      }
      function CheckboxEffect(data2, elem2, container) {
        this.p = PropertyFactory.getProp(elem2, data2.v, 0, 0, container);
      }
      function NoValueEffect() {
        this.p = {};
      }
      function EffectsManager(data2, element) {
        var effects = data2.ef || [];
        this.effectElements = [];
        var i;
        var len = effects.length;
        var effectItem;
        for (i = 0; i < len; i += 1) {
          effectItem = new GroupEffect(effects[i], element);
          this.effectElements.push(effectItem);
        }
      }
      function GroupEffect(data2, element) {
        this.init(data2, element);
      }
      extendPrototype([DynamicPropertyContainer], GroupEffect);
      GroupEffect.prototype.getValue = GroupEffect.prototype.iterateDynamicProperties;
      GroupEffect.prototype.init = function(data2, element) {
        this.data = data2;
        this.effectElements = [];
        this.initDynamicPropertyContainer(element);
        var i;
        var len = this.data.ef.length;
        var eff;
        var effects = this.data.ef;
        for (i = 0; i < len; i += 1) {
          eff = null;
          switch (effects[i].ty) {
            case 0:
              eff = new SliderEffect(effects[i], element, this);
              break;
            case 1:
              eff = new AngleEffect(effects[i], element, this);
              break;
            case 2:
              eff = new ColorEffect(effects[i], element, this);
              break;
            case 3:
              eff = new PointEffect(effects[i], element, this);
              break;
            case 4:
            case 7:
              eff = new CheckboxEffect(effects[i], element, this);
              break;
            case 10:
              eff = new LayerIndexEffect(effects[i], element, this);
              break;
            case 11:
              eff = new MaskIndexEffect(effects[i], element, this);
              break;
            case 5:
              eff = new EffectsManager(effects[i], element, this);
              break;
            // case 6:
            default:
              eff = new NoValueEffect(effects[i], element, this);
              break;
          }
          if (eff) {
            this.effectElements.push(eff);
          }
        }
      };
      function BaseElement() {
      }
      BaseElement.prototype = {
        checkMasks: function checkMasks() {
          if (!this.data.hasMask) {
            return false;
          }
          var i = 0;
          var len = this.data.masksProperties.length;
          while (i < len) {
            if (this.data.masksProperties[i].mode !== "n" && this.data.masksProperties[i].cl !== false) {
              return true;
            }
            i += 1;
          }
          return false;
        },
        initExpressions: function initExpressions() {
          var expressionsInterfaces2 = getExpressionInterfaces();
          if (!expressionsInterfaces2) {
            return;
          }
          var LayerExpressionInterface2 = expressionsInterfaces2("layer");
          var EffectsExpressionInterface2 = expressionsInterfaces2("effects");
          var ShapeExpressionInterface2 = expressionsInterfaces2("shape");
          var TextExpressionInterface2 = expressionsInterfaces2("text");
          var CompExpressionInterface2 = expressionsInterfaces2("comp");
          this.layerInterface = LayerExpressionInterface2(this);
          if (this.data.hasMask && this.maskManager) {
            this.layerInterface.registerMaskInterface(this.maskManager);
          }
          var effectsInterface = EffectsExpressionInterface2.createEffectsInterface(this, this.layerInterface);
          this.layerInterface.registerEffectsInterface(effectsInterface);
          if (this.data.ty === 0 || this.data.xt) {
            this.compInterface = CompExpressionInterface2(this);
          } else if (this.data.ty === 4) {
            this.layerInterface.shapeInterface = ShapeExpressionInterface2(this.shapesData, this.itemsData, this.layerInterface);
            this.layerInterface.content = this.layerInterface.shapeInterface;
          } else if (this.data.ty === 5) {
            this.layerInterface.textInterface = TextExpressionInterface2(this);
            this.layerInterface.text = this.layerInterface.textInterface;
          }
        },
        setBlendMode: function setBlendMode() {
          var blendModeValue = getBlendMode(this.data.bm);
          var elem2 = this.baseElement || this.layerElement;
          elem2.style["mix-blend-mode"] = blendModeValue;
        },
        initBaseData: function initBaseData(data2, globalData2, comp2) {
          this.globalData = globalData2;
          this.comp = comp2;
          this.data = data2;
          this.layerId = createElementID();
          if (!this.data.sr) {
            this.data.sr = 1;
          }
          this.effectsManager = new EffectsManager(this.data, this, this.dynamicProperties);
        },
        getType: function getType() {
          return this.type;
        },
        sourceRectAtTime: function sourceRectAtTime2() {
        }
      };
      function FrameElement() {
      }
      FrameElement.prototype = {
        /**
           * @function
           * Initializes frame related properties.
           *
           */
        initFrame: function initFrame2() {
          this._isFirstFrame = false;
          this.dynamicProperties = [];
          this._mdf = false;
        },
        /**
           * @function
           * Calculates all dynamic values
           *
           * @param {number} num
           * current frame number in Layer's time
           * @param {boolean} isVisible
           * if layers is currently in range
           *
           */
        prepareProperties: function prepareProperties(num, isVisible) {
          var i;
          var len = this.dynamicProperties.length;
          for (i = 0; i < len; i += 1) {
            if (isVisible || this._isParent && this.dynamicProperties[i].propType === "transform") {
              this.dynamicProperties[i].getValue();
              if (this.dynamicProperties[i]._mdf) {
                this.globalData._mdf = true;
                this._mdf = true;
              }
            }
          }
        },
        addDynamicProperty: function addDynamicProperty(prop) {
          if (this.dynamicProperties.indexOf(prop) === -1) {
            this.dynamicProperties.push(prop);
          }
        }
      };
      function FootageElement(data2, globalData2, comp2) {
        this.initFrame();
        this.initRenderable();
        this.assetData = globalData2.getAssetData(data2.refId);
        this.footageData = globalData2.imageLoader.getAsset(this.assetData);
        this.initBaseData(data2, globalData2, comp2);
      }
      FootageElement.prototype.prepareFrame = function() {
      };
      extendPrototype([RenderableElement, BaseElement, FrameElement], FootageElement);
      FootageElement.prototype.getBaseElement = function() {
        return null;
      };
      FootageElement.prototype.renderFrame = function() {
      };
      FootageElement.prototype.destroy = function() {
      };
      FootageElement.prototype.initExpressions = function() {
        var expressionsInterfaces2 = getExpressionInterfaces();
        if (!expressionsInterfaces2) {
          return;
        }
        var FootageInterface2 = expressionsInterfaces2("footage");
        this.layerInterface = FootageInterface2(this);
      };
      FootageElement.prototype.getFootageData = function() {
        return this.footageData;
      };
      function AudioElement(data2, globalData2, comp2) {
        this.initFrame();
        this.initRenderable();
        this.assetData = globalData2.getAssetData(data2.refId);
        this.initBaseData(data2, globalData2, comp2);
        this._isPlaying = false;
        this._canPlay = false;
        var assetPath = this.globalData.getAssetsPath(this.assetData);
        this.audio = this.globalData.audioController.createAudio(assetPath);
        this._currentTime = 0;
        this.globalData.audioController.addAudio(this);
        this._volumeMultiplier = 1;
        this._volume = 1;
        this._previousVolume = null;
        this.tm = data2.tm ? PropertyFactory.getProp(this, data2.tm, 0, globalData2.frameRate, this) : {
          _placeholder: true
        };
        this.lv = PropertyFactory.getProp(this, data2.au && data2.au.lv ? data2.au.lv : {
          k: [100]
        }, 1, 0.01, this);
      }
      AudioElement.prototype.prepareFrame = function(num) {
        this.prepareRenderableFrame(num, true);
        this.prepareProperties(num, true);
        if (!this.tm._placeholder) {
          var timeRemapped = this.tm.v;
          this._currentTime = timeRemapped;
        } else {
          this._currentTime = num / this.data.sr;
        }
        this._volume = this.lv.v[0];
        var totalVolume = this._volume * this._volumeMultiplier;
        if (this._previousVolume !== totalVolume) {
          this._previousVolume = totalVolume;
          this.audio.volume(totalVolume);
        }
      };
      extendPrototype([RenderableElement, BaseElement, FrameElement], AudioElement);
      AudioElement.prototype.renderFrame = function() {
        if (this.isInRange && this._canPlay) {
          if (!this._isPlaying) {
            this.audio.play();
            this.audio.seek(this._currentTime / this.globalData.frameRate);
            this._isPlaying = true;
          } else if (!this.audio.playing() || Math.abs(this._currentTime / this.globalData.frameRate - this.audio.seek()) > 0.1) {
            this.audio.seek(this._currentTime / this.globalData.frameRate);
          }
        }
      };
      AudioElement.prototype.show = function() {
      };
      AudioElement.prototype.hide = function() {
        this.audio.pause();
        this._isPlaying = false;
      };
      AudioElement.prototype.pause = function() {
        this.audio.pause();
        this._isPlaying = false;
        this._canPlay = false;
      };
      AudioElement.prototype.resume = function() {
        this._canPlay = true;
      };
      AudioElement.prototype.setRate = function(rateValue) {
        this.audio.rate(rateValue);
      };
      AudioElement.prototype.volume = function(volumeValue) {
        this._volumeMultiplier = volumeValue;
        this._previousVolume = volumeValue * this._volume;
        this.audio.volume(this._previousVolume);
      };
      AudioElement.prototype.getBaseElement = function() {
        return null;
      };
      AudioElement.prototype.destroy = function() {
      };
      AudioElement.prototype.sourceRectAtTime = function() {
      };
      AudioElement.prototype.initExpressions = function() {
      };
      function BaseRenderer() {
      }
      BaseRenderer.prototype.checkLayers = function(num) {
        var i;
        var len = this.layers.length;
        var data2;
        this.completeLayers = true;
        for (i = len - 1; i >= 0; i -= 1) {
          if (!this.elements[i]) {
            data2 = this.layers[i];
            if (data2.ip - data2.st <= num - this.layers[i].st && data2.op - data2.st > num - this.layers[i].st) {
              this.buildItem(i);
            }
          }
          this.completeLayers = this.elements[i] ? this.completeLayers : false;
        }
        this.checkPendingElements();
      };
      BaseRenderer.prototype.createItem = function(layer) {
        switch (layer.ty) {
          case 2:
            return this.createImage(layer);
          case 0:
            return this.createComp(layer);
          case 1:
            return this.createSolid(layer);
          case 3:
            return this.createNull(layer);
          case 4:
            return this.createShape(layer);
          case 5:
            return this.createText(layer);
          case 6:
            return this.createAudio(layer);
          case 13:
            return this.createCamera(layer);
          case 15:
            return this.createFootage(layer);
          default:
            return this.createNull(layer);
        }
      };
      BaseRenderer.prototype.createCamera = function() {
        throw new Error("You're using a 3d camera. Try the html renderer.");
      };
      BaseRenderer.prototype.createAudio = function(data2) {
        return new AudioElement(data2, this.globalData, this);
      };
      BaseRenderer.prototype.createFootage = function(data2) {
        return new FootageElement(data2, this.globalData, this);
      };
      BaseRenderer.prototype.buildAllItems = function() {
        var i;
        var len = this.layers.length;
        for (i = 0; i < len; i += 1) {
          this.buildItem(i);
        }
        this.checkPendingElements();
      };
      BaseRenderer.prototype.includeLayers = function(newLayers) {
        this.completeLayers = false;
        var i;
        var len = newLayers.length;
        var j;
        var jLen = this.layers.length;
        for (i = 0; i < len; i += 1) {
          j = 0;
          while (j < jLen) {
            if (this.layers[j].id === newLayers[i].id) {
              this.layers[j] = newLayers[i];
              break;
            }
            j += 1;
          }
        }
      };
      BaseRenderer.prototype.setProjectInterface = function(pInterface) {
        this.globalData.projectInterface = pInterface;
      };
      BaseRenderer.prototype.initItems = function() {
        if (!this.globalData.progressiveLoad) {
          this.buildAllItems();
        }
      };
      BaseRenderer.prototype.buildElementParenting = function(element, parentName, hierarchy) {
        var elements = this.elements;
        var layers = this.layers;
        var i = 0;
        var len = layers.length;
        while (i < len) {
          if (layers[i].ind == parentName) {
            if (!elements[i] || elements[i] === true) {
              this.buildItem(i);
              this.addPendingElement(element);
            } else {
              hierarchy.push(elements[i]);
              elements[i].setAsParent();
              if (layers[i].parent !== void 0) {
                this.buildElementParenting(element, layers[i].parent, hierarchy);
              } else {
                element.setHierarchy(hierarchy);
              }
            }
          }
          i += 1;
        }
      };
      BaseRenderer.prototype.addPendingElement = function(element) {
        this.pendingElements.push(element);
      };
      BaseRenderer.prototype.searchExtraCompositions = function(assets) {
        var i;
        var len = assets.length;
        for (i = 0; i < len; i += 1) {
          if (assets[i].xt) {
            var comp2 = this.createComp(assets[i]);
            comp2.initExpressions();
            this.globalData.projectInterface.registerComposition(comp2);
          }
        }
      };
      BaseRenderer.prototype.getElementById = function(ind) {
        var i;
        var len = this.elements.length;
        for (i = 0; i < len; i += 1) {
          if (this.elements[i].data.ind === ind) {
            return this.elements[i];
          }
        }
        return null;
      };
      BaseRenderer.prototype.getElementByPath = function(path) {
        var pathValue = path.shift();
        var element;
        if (typeof pathValue === "number") {
          element = this.elements[pathValue];
        } else {
          var i;
          var len = this.elements.length;
          for (i = 0; i < len; i += 1) {
            if (this.elements[i].data.nm === pathValue) {
              element = this.elements[i];
              break;
            }
          }
        }
        if (path.length === 0) {
          return element;
        }
        return element.getElementByPath(path);
      };
      BaseRenderer.prototype.setupGlobalData = function(animData, fontsContainer) {
        this.globalData.fontManager = new FontManager();
        this.globalData.slotManager = slotFactory(animData);
        this.globalData.fontManager.addChars(animData.chars);
        this.globalData.fontManager.addFonts(animData.fonts, fontsContainer);
        this.globalData.getAssetData = this.animationItem.getAssetData.bind(this.animationItem);
        this.globalData.getAssetsPath = this.animationItem.getAssetsPath.bind(this.animationItem);
        this.globalData.imageLoader = this.animationItem.imagePreloader;
        this.globalData.audioController = this.animationItem.audioController;
        this.globalData.frameId = 0;
        this.globalData.frameRate = animData.fr;
        this.globalData.nm = animData.nm;
        this.globalData.compSize = {
          w: animData.w,
          h: animData.h
        };
      };
      var effectTypes = {
        TRANSFORM_EFFECT: "transformEFfect"
      };
      function TransformElement() {
      }
      TransformElement.prototype = {
        initTransform: function initTransform() {
          var mat = new Matrix();
          this.finalTransform = {
            mProp: this.data.ks ? TransformPropertyFactory.getTransformProperty(this, this.data.ks, this) : {
              o: 0
            },
            _matMdf: false,
            _localMatMdf: false,
            _opMdf: false,
            mat,
            localMat: mat,
            localOpacity: 1
          };
          if (this.data.ao) {
            this.finalTransform.mProp.autoOriented = true;
          }
          if (this.data.ty !== 11) {
          }
        },
        renderTransform: function renderTransform() {
          this.finalTransform._opMdf = this.finalTransform.mProp.o._mdf || this._isFirstFrame;
          this.finalTransform._matMdf = this.finalTransform.mProp._mdf || this._isFirstFrame;
          if (this.hierarchy) {
            var mat;
            var finalMat = this.finalTransform.mat;
            var i = 0;
            var len = this.hierarchy.length;
            if (!this.finalTransform._matMdf) {
              while (i < len) {
                if (this.hierarchy[i].finalTransform.mProp._mdf) {
                  this.finalTransform._matMdf = true;
                  break;
                }
                i += 1;
              }
            }
            if (this.finalTransform._matMdf) {
              mat = this.finalTransform.mProp.v.props;
              finalMat.cloneFromProps(mat);
              for (i = 0; i < len; i += 1) {
                finalMat.multiply(this.hierarchy[i].finalTransform.mProp.v);
              }
            }
          }
          if (!this.localTransforms || this.finalTransform._matMdf) {
            this.finalTransform._localMatMdf = this.finalTransform._matMdf;
          }
          if (this.finalTransform._opMdf) {
            this.finalTransform.localOpacity = this.finalTransform.mProp.o.v;
          }
        },
        renderLocalTransform: function renderLocalTransform() {
          if (this.localTransforms) {
            var i = 0;
            var len = this.localTransforms.length;
            this.finalTransform._localMatMdf = this.finalTransform._matMdf;
            if (!this.finalTransform._localMatMdf || !this.finalTransform._opMdf) {
              while (i < len) {
                if (this.localTransforms[i]._mdf) {
                  this.finalTransform._localMatMdf = true;
                }
                if (this.localTransforms[i]._opMdf && !this.finalTransform._opMdf) {
                  this.finalTransform.localOpacity = this.finalTransform.mProp.o.v;
                  this.finalTransform._opMdf = true;
                }
                i += 1;
              }
            }
            if (this.finalTransform._localMatMdf) {
              var localMat = this.finalTransform.localMat;
              this.localTransforms[0].matrix.clone(localMat);
              for (i = 1; i < len; i += 1) {
                var lmat = this.localTransforms[i].matrix;
                localMat.multiply(lmat);
              }
              localMat.multiply(this.finalTransform.mat);
            }
            if (this.finalTransform._opMdf) {
              var localOp = this.finalTransform.localOpacity;
              for (i = 0; i < len; i += 1) {
                localOp *= this.localTransforms[i].opacity * 0.01;
              }
              this.finalTransform.localOpacity = localOp;
            }
          }
        },
        searchEffectTransforms: function searchEffectTransforms() {
          if (this.renderableEffectsManager) {
            var transformEffects = this.renderableEffectsManager.getEffects(effectTypes.TRANSFORM_EFFECT);
            if (transformEffects.length) {
              this.localTransforms = [];
              this.finalTransform.localMat = new Matrix();
              var i = 0;
              var len = transformEffects.length;
              for (i = 0; i < len; i += 1) {
                this.localTransforms.push(transformEffects[i]);
              }
            }
          }
        },
        globalToLocal: function globalToLocal(pt) {
          var transforms = [];
          transforms.push(this.finalTransform);
          var flag = true;
          var comp2 = this.comp;
          while (flag) {
            if (comp2.finalTransform) {
              if (comp2.data.hasMask) {
                transforms.splice(0, 0, comp2.finalTransform);
              }
              comp2 = comp2.comp;
            } else {
              flag = false;
            }
          }
          var i;
          var len = transforms.length;
          var ptNew;
          for (i = 0; i < len; i += 1) {
            ptNew = transforms[i].mat.applyToPointArray(0, 0, 0);
            pt = [pt[0] - ptNew[0], pt[1] - ptNew[1], 0];
          }
          return pt;
        },
        mHelper: new Matrix()
      };
      function MaskElement(data2, element, globalData2) {
        this.data = data2;
        this.element = element;
        this.globalData = globalData2;
        this.storedData = [];
        this.masksProperties = this.data.masksProperties || [];
        this.maskElement = null;
        var defs = this.globalData.defs;
        var i;
        var len = this.masksProperties ? this.masksProperties.length : 0;
        this.viewData = createSizedArray(len);
        this.solidPath = "";
        var path;
        var properties = this.masksProperties;
        var count = 0;
        var currentMasks = [];
        var j;
        var jLen;
        var layerId = createElementID();
        var rect;
        var expansor;
        var feMorph;
        var x;
        var maskType = "clipPath";
        var maskRef = "clip-path";
        for (i = 0; i < len; i += 1) {
          if (properties[i].mode !== "a" && properties[i].mode !== "n" || properties[i].inv || properties[i].o.k !== 100 || properties[i].o.x) {
            maskType = "mask";
            maskRef = "mask";
          }
          if ((properties[i].mode === "s" || properties[i].mode === "i") && count === 0) {
            rect = createNS("rect");
            rect.setAttribute("fill", "#ffffff");
            rect.setAttribute("width", this.element.comp.data.w || 0);
            rect.setAttribute("height", this.element.comp.data.h || 0);
            currentMasks.push(rect);
          } else {
            rect = null;
          }
          path = createNS("path");
          if (properties[i].mode === "n") {
            this.viewData[i] = {
              op: PropertyFactory.getProp(this.element, properties[i].o, 0, 0.01, this.element),
              prop: ShapePropertyFactory.getShapeProp(this.element, properties[i], 3),
              elem: path,
              lastPath: ""
            };
            defs.appendChild(path);
          } else {
            count += 1;
            path.setAttribute("fill", properties[i].mode === "s" ? "#000000" : "#ffffff");
            path.setAttribute("clip-rule", "nonzero");
            var filterID;
            if (properties[i].x.k !== 0) {
              maskType = "mask";
              maskRef = "mask";
              x = PropertyFactory.getProp(this.element, properties[i].x, 0, null, this.element);
              filterID = createElementID();
              expansor = createNS("filter");
              expansor.setAttribute("id", filterID);
              feMorph = createNS("feMorphology");
              feMorph.setAttribute("operator", "erode");
              feMorph.setAttribute("in", "SourceGraphic");
              feMorph.setAttribute("radius", "0");
              expansor.appendChild(feMorph);
              defs.appendChild(expansor);
              path.setAttribute("stroke", properties[i].mode === "s" ? "#000000" : "#ffffff");
            } else {
              feMorph = null;
              x = null;
            }
            this.storedData[i] = {
              elem: path,
              x,
              expan: feMorph,
              lastPath: "",
              lastOperator: "",
              filterId: filterID,
              lastRadius: 0
            };
            if (properties[i].mode === "i") {
              jLen = currentMasks.length;
              var g = createNS("g");
              for (j = 0; j < jLen; j += 1) {
                g.appendChild(currentMasks[j]);
              }
              var mask2 = createNS("mask");
              mask2.setAttribute("mask-type", "alpha");
              mask2.setAttribute("id", layerId + "_" + count);
              mask2.appendChild(path);
              defs.appendChild(mask2);
              g.setAttribute("mask", "url(" + getLocationHref() + "#" + layerId + "_" + count + ")");
              currentMasks.length = 0;
              currentMasks.push(g);
            } else {
              currentMasks.push(path);
            }
            if (properties[i].inv && !this.solidPath) {
              this.solidPath = this.createLayerSolidPath();
            }
            this.viewData[i] = {
              elem: path,
              lastPath: "",
              op: PropertyFactory.getProp(this.element, properties[i].o, 0, 0.01, this.element),
              prop: ShapePropertyFactory.getShapeProp(this.element, properties[i], 3),
              invRect: rect
            };
            if (!this.viewData[i].prop.k) {
              this.drawPath(properties[i], this.viewData[i].prop.v, this.viewData[i]);
            }
          }
        }
        this.maskElement = createNS(maskType);
        len = currentMasks.length;
        for (i = 0; i < len; i += 1) {
          this.maskElement.appendChild(currentMasks[i]);
        }
        if (count > 0) {
          this.maskElement.setAttribute("id", layerId);
          this.element.maskedElement.setAttribute(maskRef, "url(" + getLocationHref() + "#" + layerId + ")");
          defs.appendChild(this.maskElement);
        }
        if (this.viewData.length) {
          this.element.addRenderableComponent(this);
        }
      }
      MaskElement.prototype.getMaskProperty = function(pos) {
        return this.viewData[pos].prop;
      };
      MaskElement.prototype.renderFrame = function(isFirstFrame) {
        var finalMat = this.element.finalTransform.mat;
        var i;
        var len = this.masksProperties.length;
        for (i = 0; i < len; i += 1) {
          if (this.viewData[i].prop._mdf || isFirstFrame) {
            this.drawPath(this.masksProperties[i], this.viewData[i].prop.v, this.viewData[i]);
          }
          if (this.viewData[i].op._mdf || isFirstFrame) {
            this.viewData[i].elem.setAttribute("fill-opacity", this.viewData[i].op.v);
          }
          if (this.masksProperties[i].mode !== "n") {
            if (this.viewData[i].invRect && (this.element.finalTransform.mProp._mdf || isFirstFrame)) {
              this.viewData[i].invRect.setAttribute("transform", finalMat.getInverseMatrix().to2dCSS());
            }
            if (this.storedData[i].x && (this.storedData[i].x._mdf || isFirstFrame)) {
              var feMorph = this.storedData[i].expan;
              if (this.storedData[i].x.v < 0) {
                if (this.storedData[i].lastOperator !== "erode") {
                  this.storedData[i].lastOperator = "erode";
                  this.storedData[i].elem.setAttribute("filter", "url(" + getLocationHref() + "#" + this.storedData[i].filterId + ")");
                }
                feMorph.setAttribute("radius", -this.storedData[i].x.v);
              } else {
                if (this.storedData[i].lastOperator !== "dilate") {
                  this.storedData[i].lastOperator = "dilate";
                  this.storedData[i].elem.setAttribute("filter", null);
                }
                this.storedData[i].elem.setAttribute("stroke-width", this.storedData[i].x.v * 2);
              }
            }
          }
        }
      };
      MaskElement.prototype.getMaskelement = function() {
        return this.maskElement;
      };
      MaskElement.prototype.createLayerSolidPath = function() {
        var path = "M0,0 ";
        path += " h" + this.globalData.compSize.w;
        path += " v" + this.globalData.compSize.h;
        path += " h-" + this.globalData.compSize.w;
        path += " v-" + this.globalData.compSize.h + " ";
        return path;
      };
      MaskElement.prototype.drawPath = function(pathData, pathNodes, viewData) {
        var pathString = " M" + pathNodes.v[0][0] + "," + pathNodes.v[0][1];
        var i;
        var len;
        len = pathNodes._length;
        for (i = 1; i < len; i += 1) {
          pathString += " C" + pathNodes.o[i - 1][0] + "," + pathNodes.o[i - 1][1] + " " + pathNodes.i[i][0] + "," + pathNodes.i[i][1] + " " + pathNodes.v[i][0] + "," + pathNodes.v[i][1];
        }
        if (pathNodes.c && len > 1) {
          pathString += " C" + pathNodes.o[i - 1][0] + "," + pathNodes.o[i - 1][1] + " " + pathNodes.i[0][0] + "," + pathNodes.i[0][1] + " " + pathNodes.v[0][0] + "," + pathNodes.v[0][1];
        }
        if (viewData.lastPath !== pathString) {
          var pathShapeValue = "";
          if (viewData.elem) {
            if (pathNodes.c) {
              pathShapeValue = pathData.inv ? this.solidPath + pathString : pathString;
            }
            viewData.elem.setAttribute("d", pathShapeValue);
          }
          viewData.lastPath = pathString;
        }
      };
      MaskElement.prototype.destroy = function() {
        this.element = null;
        this.globalData = null;
        this.maskElement = null;
        this.data = null;
        this.masksProperties = null;
      };
      var filtersFactory = function() {
        var ob2 = {};
        ob2.createFilter = createFilter;
        ob2.createAlphaToLuminanceFilter = createAlphaToLuminanceFilter;
        function createFilter(filId, skipCoordinates) {
          var fil = createNS("filter");
          fil.setAttribute("id", filId);
          if (skipCoordinates !== true) {
            fil.setAttribute("filterUnits", "objectBoundingBox");
            fil.setAttribute("x", "0%");
            fil.setAttribute("y", "0%");
            fil.setAttribute("width", "100%");
            fil.setAttribute("height", "100%");
          }
          return fil;
        }
        function createAlphaToLuminanceFilter() {
          var feColorMatrix = createNS("feColorMatrix");
          feColorMatrix.setAttribute("type", "matrix");
          feColorMatrix.setAttribute("color-interpolation-filters", "sRGB");
          feColorMatrix.setAttribute("values", "0 0 0 1 0  0 0 0 1 0  0 0 0 1 0  0 0 0 1 1");
          return feColorMatrix;
        }
        return ob2;
      }();
      var featureSupport = function() {
        var ob2 = {
          maskType: true,
          svgLumaHidden: true,
          offscreenCanvas: typeof OffscreenCanvas !== "undefined"
        };
        if (/MSIE 10/i.test(navigator.userAgent) || /MSIE 9/i.test(navigator.userAgent) || /rv:11.0/i.test(navigator.userAgent) || /Edge\/\d./i.test(navigator.userAgent)) {
          ob2.maskType = false;
        }
        if (/firefox/i.test(navigator.userAgent)) {
          ob2.svgLumaHidden = false;
        }
        return ob2;
      }();
      var registeredEffects$1 = {};
      var idPrefix = "filter_result_";
      function SVGEffects(elem2) {
        var i;
        var source = "SourceGraphic";
        var len = elem2.data.ef ? elem2.data.ef.length : 0;
        var filId = createElementID();
        var fil = filtersFactory.createFilter(filId, true);
        var count = 0;
        this.filters = [];
        var filterManager;
        for (i = 0; i < len; i += 1) {
          filterManager = null;
          var type = elem2.data.ef[i].ty;
          if (registeredEffects$1[type]) {
            var Effect = registeredEffects$1[type].effect;
            filterManager = new Effect(fil, elem2.effectsManager.effectElements[i], elem2, idPrefix + count, source);
            source = idPrefix + count;
            if (registeredEffects$1[type].countsAsEffect) {
              count += 1;
            }
          }
          if (filterManager) {
            this.filters.push(filterManager);
          }
        }
        if (count) {
          elem2.globalData.defs.appendChild(fil);
          elem2.layerElement.setAttribute("filter", "url(" + getLocationHref() + "#" + filId + ")");
        }
        if (this.filters.length) {
          elem2.addRenderableComponent(this);
        }
      }
      SVGEffects.prototype.renderFrame = function(_isFirstFrame) {
        var i;
        var len = this.filters.length;
        for (i = 0; i < len; i += 1) {
          this.filters[i].renderFrame(_isFirstFrame);
        }
      };
      SVGEffects.prototype.getEffects = function(type) {
        var i;
        var len = this.filters.length;
        var effects = [];
        for (i = 0; i < len; i += 1) {
          if (this.filters[i].type === type) {
            effects.push(this.filters[i]);
          }
        }
        return effects;
      };
      function registerEffect$1(id, effect2, countsAsEffect) {
        registeredEffects$1[id] = {
          effect: effect2,
          countsAsEffect
        };
      }
      function SVGBaseElement() {
      }
      SVGBaseElement.prototype = {
        initRendererElement: function initRendererElement() {
          this.layerElement = createNS("g");
        },
        createContainerElements: function createContainerElements() {
          this.matteElement = createNS("g");
          this.transformedElement = this.layerElement;
          this.maskedElement = this.layerElement;
          this._sizeChanged = false;
          var layerElementParent = null;
          if (this.data.td) {
            this.matteMasks = {};
            var gg = createNS("g");
            gg.setAttribute("id", this.layerId);
            gg.appendChild(this.layerElement);
            layerElementParent = gg;
            this.globalData.defs.appendChild(gg);
          } else if (this.data.tt) {
            this.matteElement.appendChild(this.layerElement);
            layerElementParent = this.matteElement;
            this.baseElement = this.matteElement;
          } else {
            this.baseElement = this.layerElement;
          }
          if (this.data.ln) {
            this.layerElement.setAttribute("id", this.data.ln);
          }
          if (this.data.cl) {
            this.layerElement.setAttribute("class", this.data.cl);
          }
          if (this.data.ty === 0 && !this.data.hd) {
            var cp = createNS("clipPath");
            var pt = createNS("path");
            pt.setAttribute("d", "M0,0 L" + this.data.w + ",0 L" + this.data.w + "," + this.data.h + " L0," + this.data.h + "z");
            var clipId = createElementID();
            cp.setAttribute("id", clipId);
            cp.appendChild(pt);
            this.globalData.defs.appendChild(cp);
            if (this.checkMasks()) {
              var cpGroup = createNS("g");
              cpGroup.setAttribute("clip-path", "url(" + getLocationHref() + "#" + clipId + ")");
              cpGroup.appendChild(this.layerElement);
              this.transformedElement = cpGroup;
              if (layerElementParent) {
                layerElementParent.appendChild(this.transformedElement);
              } else {
                this.baseElement = this.transformedElement;
              }
            } else {
              this.layerElement.setAttribute("clip-path", "url(" + getLocationHref() + "#" + clipId + ")");
            }
          }
          if (this.data.bm !== 0) {
            this.setBlendMode();
          }
        },
        renderElement: function renderElement() {
          if (this.finalTransform._localMatMdf) {
            this.transformedElement.setAttribute("transform", this.finalTransform.localMat.to2dCSS());
          }
          if (this.finalTransform._opMdf) {
            this.transformedElement.setAttribute("opacity", this.finalTransform.localOpacity);
          }
        },
        destroyBaseElement: function destroyBaseElement() {
          this.layerElement = null;
          this.matteElement = null;
          this.maskManager.destroy();
        },
        getBaseElement: function getBaseElement() {
          if (this.data.hd) {
            return null;
          }
          return this.baseElement;
        },
        createRenderableComponents: function createRenderableComponents() {
          this.maskManager = new MaskElement(this.data, this, this.globalData);
          this.renderableEffectsManager = new SVGEffects(this);
          this.searchEffectTransforms();
        },
        getMatte: function getMatte(matteType) {
          if (!this.matteMasks) {
            this.matteMasks = {};
          }
          if (!this.matteMasks[matteType]) {
            var id = this.layerId + "_" + matteType;
            var filId;
            var fil;
            var useElement;
            var gg;
            if (matteType === 1 || matteType === 3) {
              var masker = createNS("mask");
              masker.setAttribute("id", id);
              masker.setAttribute("mask-type", matteType === 3 ? "luminance" : "alpha");
              useElement = createNS("use");
              useElement.setAttributeNS("http://www.w3.org/1999/xlink", "href", "#" + this.layerId);
              masker.appendChild(useElement);
              this.globalData.defs.appendChild(masker);
              if (!featureSupport.maskType && matteType === 1) {
                masker.setAttribute("mask-type", "luminance");
                filId = createElementID();
                fil = filtersFactory.createFilter(filId);
                this.globalData.defs.appendChild(fil);
                fil.appendChild(filtersFactory.createAlphaToLuminanceFilter());
                gg = createNS("g");
                gg.appendChild(useElement);
                masker.appendChild(gg);
                gg.setAttribute("filter", "url(" + getLocationHref() + "#" + filId + ")");
              }
            } else if (matteType === 2) {
              var maskGroup = createNS("mask");
              maskGroup.setAttribute("id", id);
              maskGroup.setAttribute("mask-type", "alpha");
              var maskGrouper = createNS("g");
              maskGroup.appendChild(maskGrouper);
              filId = createElementID();
              fil = filtersFactory.createFilter(filId);
              var feCTr = createNS("feComponentTransfer");
              feCTr.setAttribute("in", "SourceGraphic");
              fil.appendChild(feCTr);
              var feFunc = createNS("feFuncA");
              feFunc.setAttribute("type", "table");
              feFunc.setAttribute("tableValues", "1.0 0.0");
              feCTr.appendChild(feFunc);
              this.globalData.defs.appendChild(fil);
              var alphaRect = createNS("rect");
              alphaRect.setAttribute("width", this.comp.data.w);
              alphaRect.setAttribute("height", this.comp.data.h);
              alphaRect.setAttribute("x", "0");
              alphaRect.setAttribute("y", "0");
              alphaRect.setAttribute("fill", "#ffffff");
              alphaRect.setAttribute("opacity", "0");
              maskGrouper.setAttribute("filter", "url(" + getLocationHref() + "#" + filId + ")");
              maskGrouper.appendChild(alphaRect);
              useElement = createNS("use");
              useElement.setAttributeNS("http://www.w3.org/1999/xlink", "href", "#" + this.layerId);
              maskGrouper.appendChild(useElement);
              if (!featureSupport.maskType) {
                maskGroup.setAttribute("mask-type", "luminance");
                fil.appendChild(filtersFactory.createAlphaToLuminanceFilter());
                gg = createNS("g");
                maskGrouper.appendChild(alphaRect);
                gg.appendChild(this.layerElement);
                maskGrouper.appendChild(gg);
              }
              this.globalData.defs.appendChild(maskGroup);
            }
            this.matteMasks[matteType] = id;
          }
          return this.matteMasks[matteType];
        },
        setMatte: function setMatte(id) {
          if (!this.matteElement) {
            return;
          }
          this.matteElement.setAttribute("mask", "url(" + getLocationHref() + "#" + id + ")");
        }
      };
      function HierarchyElement() {
      }
      HierarchyElement.prototype = {
        /**
           * @function
           * Initializes hierarchy properties
           *
           */
        initHierarchy: function initHierarchy() {
          this.hierarchy = [];
          this._isParent = false;
          this.checkParenting();
        },
        /**
           * @function
           * Sets layer's hierarchy.
           * @param {array} hierarch
           * layer's parent list
           *
           */
        setHierarchy: function setHierarchy(hierarchy) {
          this.hierarchy = hierarchy;
        },
        /**
           * @function
           * Sets layer as parent.
           *
           */
        setAsParent: function setAsParent() {
          this._isParent = true;
        },
        /**
           * @function
           * Searches layer's parenting chain
           *
           */
        checkParenting: function checkParenting() {
          if (this.data.parent !== void 0) {
            this.comp.buildElementParenting(this, this.data.parent, []);
          }
        }
      };
      function RenderableDOMElement() {
      }
      (function() {
        var _prototype = {
          initElement: function initElement(data2, globalData2, comp2) {
            this.initFrame();
            this.initBaseData(data2, globalData2, comp2);
            this.initTransform(data2, globalData2, comp2);
            this.initHierarchy();
            this.initRenderable();
            this.initRendererElement();
            this.createContainerElements();
            this.createRenderableComponents();
            this.createContent();
            this.hide();
          },
          hide: function hide() {
            if (!this.hidden && (!this.isInRange || this.isTransparent)) {
              var elem2 = this.baseElement || this.layerElement;
              elem2.style.display = "none";
              this.hidden = true;
            }
          },
          show: function show() {
            if (this.isInRange && !this.isTransparent) {
              if (!this.data.hd) {
                var elem2 = this.baseElement || this.layerElement;
                elem2.style.display = "block";
              }
              this.hidden = false;
              this._isFirstFrame = true;
            }
          },
          renderFrame: function renderFrame() {
            if (this.data.hd || this.hidden) {
              return;
            }
            this.renderTransform();
            this.renderRenderable();
            this.renderLocalTransform();
            this.renderElement();
            this.renderInnerContent();
            if (this._isFirstFrame) {
              this._isFirstFrame = false;
            }
          },
          renderInnerContent: function renderInnerContent() {
          },
          prepareFrame: function prepareFrame(num) {
            this._mdf = false;
            this.prepareRenderableFrame(num);
            this.prepareProperties(num, this.isInRange);
            this.checkTransparency();
          },
          destroy: function destroy() {
            this.innerElem = null;
            this.destroyBaseElement();
          }
        };
        extendPrototype([RenderableElement, createProxyFunction(_prototype)], RenderableDOMElement);
      })();
      function IImageElement(data2, globalData2, comp2) {
        this.assetData = globalData2.getAssetData(data2.refId);
        if (this.assetData && this.assetData.sid) {
          this.assetData = globalData2.slotManager.getProp(this.assetData);
        }
        this.initElement(data2, globalData2, comp2);
        this.sourceRect = {
          top: 0,
          left: 0,
          width: this.assetData.w,
          height: this.assetData.h
        };
      }
      extendPrototype([BaseElement, TransformElement, SVGBaseElement, HierarchyElement, FrameElement, RenderableDOMElement], IImageElement);
      IImageElement.prototype.createContent = function() {
        var assetPath = this.globalData.getAssetsPath(this.assetData);
        this.innerElem = createNS("image");
        this.innerElem.setAttribute("width", this.assetData.w + "px");
        this.innerElem.setAttribute("height", this.assetData.h + "px");
        this.innerElem.setAttribute("preserveAspectRatio", this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio);
        this.innerElem.setAttributeNS("http://www.w3.org/1999/xlink", "href", assetPath);
        this.layerElement.appendChild(this.innerElem);
      };
      IImageElement.prototype.sourceRectAtTime = function() {
        return this.sourceRect;
      };
      function ProcessedElement(element, position2) {
        this.elem = element;
        this.pos = position2;
      }
      function IShapeElement() {
      }
      IShapeElement.prototype = {
        addShapeToModifiers: function addShapeToModifiers(data2) {
          var i;
          var len = this.shapeModifiers.length;
          for (i = 0; i < len; i += 1) {
            this.shapeModifiers[i].addShape(data2);
          }
        },
        isShapeInAnimatedModifiers: function isShapeInAnimatedModifiers(data2) {
          var i = 0;
          var len = this.shapeModifiers.length;
          while (i < len) {
            if (this.shapeModifiers[i].isAnimatedWithShape(data2)) {
              return true;
            }
          }
          return false;
        },
        renderModifiers: function renderModifiers() {
          if (!this.shapeModifiers.length) {
            return;
          }
          var i;
          var len = this.shapes.length;
          for (i = 0; i < len; i += 1) {
            this.shapes[i].sh.reset();
          }
          len = this.shapeModifiers.length;
          var shouldBreakProcess;
          for (i = len - 1; i >= 0; i -= 1) {
            shouldBreakProcess = this.shapeModifiers[i].processShapes(this._isFirstFrame);
            if (shouldBreakProcess) {
              break;
            }
          }
        },
        searchProcessedElement: function searchProcessedElement(elem2) {
          var elements = this.processedElements;
          var i = 0;
          var len = elements.length;
          while (i < len) {
            if (elements[i].elem === elem2) {
              return elements[i].pos;
            }
            i += 1;
          }
          return 0;
        },
        addProcessedElement: function addProcessedElement(elem2, pos) {
          var elements = this.processedElements;
          var i = elements.length;
          while (i) {
            i -= 1;
            if (elements[i].elem === elem2) {
              elements[i].pos = pos;
              return;
            }
          }
          elements.push(new ProcessedElement(elem2, pos));
        },
        prepareFrame: function prepareFrame(num) {
          this.prepareRenderableFrame(num);
          this.prepareProperties(num, this.isInRange);
        }
      };
      var lineCapEnum = {
        1: "butt",
        2: "round",
        3: "square"
      };
      var lineJoinEnum = {
        1: "miter",
        2: "round",
        3: "bevel"
      };
      function SVGShapeData(transformers, level, shape) {
        this.caches = [];
        this.styles = [];
        this.transformers = transformers;
        this.lStr = "";
        this.sh = shape;
        this.lvl = level;
        this._isAnimated = !!shape.k;
        var i = 0;
        var len = transformers.length;
        while (i < len) {
          if (transformers[i].mProps.dynamicProperties.length) {
            this._isAnimated = true;
            break;
          }
          i += 1;
        }
      }
      SVGShapeData.prototype.setAsAnimated = function() {
        this._isAnimated = true;
      };
      function SVGStyleData(data2, level) {
        this.data = data2;
        this.type = data2.ty;
        this.d = "";
        this.lvl = level;
        this._mdf = false;
        this.closed = data2.hd === true;
        this.pElem = createNS("path");
        this.msElem = null;
      }
      SVGStyleData.prototype.reset = function() {
        this.d = "";
        this._mdf = false;
      };
      function DashProperty(elem2, data2, renderer2, container) {
        this.elem = elem2;
        this.frameId = -1;
        this.dataProps = createSizedArray(data2.length);
        this.renderer = renderer2;
        this.k = false;
        this.dashStr = "";
        this.dashArray = createTypedArray("float32", data2.length ? data2.length - 1 : 0);
        this.dashoffset = createTypedArray("float32", 1);
        this.initDynamicPropertyContainer(container);
        var i;
        var len = data2.length || 0;
        var prop;
        for (i = 0; i < len; i += 1) {
          prop = PropertyFactory.getProp(elem2, data2[i].v, 0, 0, this);
          this.k = prop.k || this.k;
          this.dataProps[i] = {
            n: data2[i].n,
            p: prop
          };
        }
        if (!this.k) {
          this.getValue(true);
        }
        this._isAnimated = this.k;
      }
      DashProperty.prototype.getValue = function(forceRender) {
        if (this.elem.globalData.frameId === this.frameId && !forceRender) {
          return;
        }
        this.frameId = this.elem.globalData.frameId;
        this.iterateDynamicProperties();
        this._mdf = this._mdf || forceRender;
        if (this._mdf) {
          var i = 0;
          var len = this.dataProps.length;
          if (this.renderer === "svg") {
            this.dashStr = "";
          }
          for (i = 0; i < len; i += 1) {
            if (this.dataProps[i].n !== "o") {
              if (this.renderer === "svg") {
                this.dashStr += " " + this.dataProps[i].p.v;
              } else {
                this.dashArray[i] = this.dataProps[i].p.v;
              }
            } else {
              this.dashoffset[0] = this.dataProps[i].p.v;
            }
          }
        }
      };
      extendPrototype([DynamicPropertyContainer], DashProperty);
      function SVGStrokeStyleData(elem2, data2, styleOb) {
        this.initDynamicPropertyContainer(elem2);
        this.getValue = this.iterateDynamicProperties;
        this.o = PropertyFactory.getProp(elem2, data2.o, 0, 0.01, this);
        this.w = PropertyFactory.getProp(elem2, data2.w, 0, null, this);
        this.d = new DashProperty(elem2, data2.d || {}, "svg", this);
        this.c = PropertyFactory.getProp(elem2, data2.c, 1, 255, this);
        this.style = styleOb;
        this._isAnimated = !!this._isAnimated;
      }
      extendPrototype([DynamicPropertyContainer], SVGStrokeStyleData);
      function SVGFillStyleData(elem2, data2, styleOb) {
        this.initDynamicPropertyContainer(elem2);
        this.getValue = this.iterateDynamicProperties;
        this.o = PropertyFactory.getProp(elem2, data2.o, 0, 0.01, this);
        this.c = PropertyFactory.getProp(elem2, data2.c, 1, 255, this);
        this.style = styleOb;
      }
      extendPrototype([DynamicPropertyContainer], SVGFillStyleData);
      function SVGNoStyleData(elem2, data2, styleOb) {
        this.initDynamicPropertyContainer(elem2);
        this.getValue = this.iterateDynamicProperties;
        this.style = styleOb;
      }
      extendPrototype([DynamicPropertyContainer], SVGNoStyleData);
      function GradientProperty(elem2, data2, container) {
        this.data = data2;
        this.c = createTypedArray("uint8c", data2.p * 4);
        var cLength = data2.k.k[0].s ? data2.k.k[0].s.length - data2.p * 4 : data2.k.k.length - data2.p * 4;
        this.o = createTypedArray("float32", cLength);
        this._cmdf = false;
        this._omdf = false;
        this._collapsable = this.checkCollapsable();
        this._hasOpacity = cLength;
        this.initDynamicPropertyContainer(container);
        this.prop = PropertyFactory.getProp(elem2, data2.k, 1, null, this);
        this.k = this.prop.k;
        this.getValue(true);
      }
      GradientProperty.prototype.comparePoints = function(values, points) {
        var i = 0;
        var len = this.o.length / 2;
        var diff;
        while (i < len) {
          diff = Math.abs(values[i * 4] - values[points * 4 + i * 2]);
          if (diff > 0.01) {
            return false;
          }
          i += 1;
        }
        return true;
      };
      GradientProperty.prototype.checkCollapsable = function() {
        if (this.o.length / 2 !== this.c.length / 4) {
          return false;
        }
        if (this.data.k.k[0].s) {
          var i = 0;
          var len = this.data.k.k.length;
          while (i < len) {
            if (!this.comparePoints(this.data.k.k[i].s, this.data.p)) {
              return false;
            }
            i += 1;
          }
        } else if (!this.comparePoints(this.data.k.k, this.data.p)) {
          return false;
        }
        return true;
      };
      GradientProperty.prototype.getValue = function(forceRender) {
        this.prop.getValue();
        this._mdf = false;
        this._cmdf = false;
        this._omdf = false;
        if (this.prop._mdf || forceRender) {
          var i;
          var len = this.data.p * 4;
          var mult;
          var val2;
          for (i = 0; i < len; i += 1) {
            mult = i % 4 === 0 ? 100 : 255;
            val2 = Math.round(this.prop.v[i] * mult);
            if (this.c[i] !== val2) {
              this.c[i] = val2;
              this._cmdf = !forceRender;
            }
          }
          if (this.o.length) {
            len = this.prop.v.length;
            for (i = this.data.p * 4; i < len; i += 1) {
              mult = i % 2 === 0 ? 100 : 1;
              val2 = i % 2 === 0 ? Math.round(this.prop.v[i] * 100) : this.prop.v[i];
              if (this.o[i - this.data.p * 4] !== val2) {
                this.o[i - this.data.p * 4] = val2;
                this._omdf = !forceRender;
              }
            }
          }
          this._mdf = !forceRender;
        }
      };
      extendPrototype([DynamicPropertyContainer], GradientProperty);
      function SVGGradientFillStyleData(elem2, data2, styleOb) {
        this.initDynamicPropertyContainer(elem2);
        this.getValue = this.iterateDynamicProperties;
        this.initGradientData(elem2, data2, styleOb);
      }
      SVGGradientFillStyleData.prototype.initGradientData = function(elem2, data2, styleOb) {
        this.o = PropertyFactory.getProp(elem2, data2.o, 0, 0.01, this);
        this.s = PropertyFactory.getProp(elem2, data2.s, 1, null, this);
        this.e = PropertyFactory.getProp(elem2, data2.e, 1, null, this);
        this.h = PropertyFactory.getProp(elem2, data2.h || {
          k: 0
        }, 0, 0.01, this);
        this.a = PropertyFactory.getProp(elem2, data2.a || {
          k: 0
        }, 0, degToRads, this);
        this.g = new GradientProperty(elem2, data2.g, this);
        this.style = styleOb;
        this.stops = [];
        this.setGradientData(styleOb.pElem, data2);
        this.setGradientOpacity(data2, styleOb);
        this._isAnimated = !!this._isAnimated;
      };
      SVGGradientFillStyleData.prototype.setGradientData = function(pathElement, data2) {
        var gradientId = createElementID();
        var gfill = createNS(data2.t === 1 ? "linearGradient" : "radialGradient");
        gfill.setAttribute("id", gradientId);
        gfill.setAttribute("spreadMethod", "pad");
        gfill.setAttribute("gradientUnits", "userSpaceOnUse");
        var stops = [];
        var stop;
        var j;
        var jLen;
        jLen = data2.g.p * 4;
        for (j = 0; j < jLen; j += 4) {
          stop = createNS("stop");
          gfill.appendChild(stop);
          stops.push(stop);
        }
        pathElement.setAttribute(data2.ty === "gf" ? "fill" : "stroke", "url(" + getLocationHref() + "#" + gradientId + ")");
        this.gf = gfill;
        this.cst = stops;
      };
      SVGGradientFillStyleData.prototype.setGradientOpacity = function(data2, styleOb) {
        if (this.g._hasOpacity && !this.g._collapsable) {
          var stop;
          var j;
          var jLen;
          var mask2 = createNS("mask");
          var maskElement = createNS("path");
          mask2.appendChild(maskElement);
          var opacityId = createElementID();
          var maskId = createElementID();
          mask2.setAttribute("id", maskId);
          var opFill = createNS(data2.t === 1 ? "linearGradient" : "radialGradient");
          opFill.setAttribute("id", opacityId);
          opFill.setAttribute("spreadMethod", "pad");
          opFill.setAttribute("gradientUnits", "userSpaceOnUse");
          jLen = data2.g.k.k[0].s ? data2.g.k.k[0].s.length : data2.g.k.k.length;
          var stops = this.stops;
          for (j = data2.g.p * 4; j < jLen; j += 2) {
            stop = createNS("stop");
            stop.setAttribute("stop-color", "rgb(255,255,255)");
            opFill.appendChild(stop);
            stops.push(stop);
          }
          maskElement.setAttribute(data2.ty === "gf" ? "fill" : "stroke", "url(" + getLocationHref() + "#" + opacityId + ")");
          if (data2.ty === "gs") {
            maskElement.setAttribute("stroke-linecap", lineCapEnum[data2.lc || 2]);
            maskElement.setAttribute("stroke-linejoin", lineJoinEnum[data2.lj || 2]);
            if (data2.lj === 1) {
              maskElement.setAttribute("stroke-miterlimit", data2.ml);
            }
          }
          this.of = opFill;
          this.ms = mask2;
          this.ost = stops;
          this.maskId = maskId;
          styleOb.msElem = maskElement;
        }
      };
      extendPrototype([DynamicPropertyContainer], SVGGradientFillStyleData);
      function SVGGradientStrokeStyleData(elem2, data2, styleOb) {
        this.initDynamicPropertyContainer(elem2);
        this.getValue = this.iterateDynamicProperties;
        this.w = PropertyFactory.getProp(elem2, data2.w, 0, null, this);
        this.d = new DashProperty(elem2, data2.d || {}, "svg", this);
        this.initGradientData(elem2, data2, styleOb);
        this._isAnimated = !!this._isAnimated;
      }
      extendPrototype([SVGGradientFillStyleData, DynamicPropertyContainer], SVGGradientStrokeStyleData);
      function ShapeGroupData() {
        this.it = [];
        this.prevViewData = [];
        this.gr = createNS("g");
      }
      function SVGTransformData(mProps, op, container) {
        this.transform = {
          mProps,
          op,
          container
        };
        this.elements = [];
        this._isAnimated = this.transform.mProps.dynamicProperties.length || this.transform.op.effectsSequence.length;
      }
      var buildShapeString = function buildShapeString2(pathNodes, length2, closed, mat) {
        if (length2 === 0) {
          return "";
        }
        var _o = pathNodes.o;
        var _i = pathNodes.i;
        var _v = pathNodes.v;
        var i;
        var shapeString = " M" + mat.applyToPointStringified(_v[0][0], _v[0][1]);
        for (i = 1; i < length2; i += 1) {
          shapeString += " C" + mat.applyToPointStringified(_o[i - 1][0], _o[i - 1][1]) + " " + mat.applyToPointStringified(_i[i][0], _i[i][1]) + " " + mat.applyToPointStringified(_v[i][0], _v[i][1]);
        }
        if (closed && length2) {
          shapeString += " C" + mat.applyToPointStringified(_o[i - 1][0], _o[i - 1][1]) + " " + mat.applyToPointStringified(_i[0][0], _i[0][1]) + " " + mat.applyToPointStringified(_v[0][0], _v[0][1]);
          shapeString += "z";
        }
        return shapeString;
      };
      var SVGElementsRenderer = function() {
        var _identityMatrix = new Matrix();
        var _matrixHelper = new Matrix();
        var ob2 = {
          createRenderFunction
        };
        function createRenderFunction(data2) {
          switch (data2.ty) {
            case "fl":
              return renderFill;
            case "gf":
              return renderGradient;
            case "gs":
              return renderGradientStroke;
            case "st":
              return renderStroke;
            case "sh":
            case "el":
            case "rc":
            case "sr":
              return renderPath;
            case "tr":
              return renderContentTransform;
            case "no":
              return renderNoop;
            default:
              return null;
          }
        }
        function renderContentTransform(styleData, itemData, isFirstFrame) {
          if (isFirstFrame || itemData.transform.op._mdf) {
            itemData.transform.container.setAttribute("opacity", itemData.transform.op.v);
          }
          if (isFirstFrame || itemData.transform.mProps._mdf) {
            itemData.transform.container.setAttribute("transform", itemData.transform.mProps.v.to2dCSS());
          }
        }
        function renderNoop() {
        }
        function renderPath(styleData, itemData, isFirstFrame) {
          var j;
          var jLen;
          var pathStringTransformed;
          var redraw;
          var pathNodes;
          var l;
          var lLen = itemData.styles.length;
          var lvl = itemData.lvl;
          var paths;
          var mat;
          var iterations;
          var k;
          for (l = 0; l < lLen; l += 1) {
            redraw = itemData.sh._mdf || isFirstFrame;
            if (itemData.styles[l].lvl < lvl) {
              mat = _matrixHelper.reset();
              iterations = lvl - itemData.styles[l].lvl;
              k = itemData.transformers.length - 1;
              while (!redraw && iterations > 0) {
                redraw = itemData.transformers[k].mProps._mdf || redraw;
                iterations -= 1;
                k -= 1;
              }
              if (redraw) {
                iterations = lvl - itemData.styles[l].lvl;
                k = itemData.transformers.length - 1;
                while (iterations > 0) {
                  mat.multiply(itemData.transformers[k].mProps.v);
                  iterations -= 1;
                  k -= 1;
                }
              }
            } else {
              mat = _identityMatrix;
            }
            paths = itemData.sh.paths;
            jLen = paths._length;
            if (redraw) {
              pathStringTransformed = "";
              for (j = 0; j < jLen; j += 1) {
                pathNodes = paths.shapes[j];
                if (pathNodes && pathNodes._length) {
                  pathStringTransformed += buildShapeString(pathNodes, pathNodes._length, pathNodes.c, mat);
                }
              }
              itemData.caches[l] = pathStringTransformed;
            } else {
              pathStringTransformed = itemData.caches[l];
            }
            itemData.styles[l].d += styleData.hd === true ? "" : pathStringTransformed;
            itemData.styles[l]._mdf = redraw || itemData.styles[l]._mdf;
          }
        }
        function renderFill(styleData, itemData, isFirstFrame) {
          var styleElem = itemData.style;
          if (itemData.c._mdf || isFirstFrame) {
            styleElem.pElem.setAttribute("fill", "rgb(" + bmFloor(itemData.c.v[0]) + "," + bmFloor(itemData.c.v[1]) + "," + bmFloor(itemData.c.v[2]) + ")");
          }
          if (itemData.o._mdf || isFirstFrame) {
            styleElem.pElem.setAttribute("fill-opacity", itemData.o.v);
          }
        }
        function renderGradientStroke(styleData, itemData, isFirstFrame) {
          renderGradient(styleData, itemData, isFirstFrame);
          renderStroke(styleData, itemData, isFirstFrame);
        }
        function renderGradient(styleData, itemData, isFirstFrame) {
          var gfill = itemData.gf;
          var hasOpacity = itemData.g._hasOpacity;
          var pt1 = itemData.s.v;
          var pt2 = itemData.e.v;
          if (itemData.o._mdf || isFirstFrame) {
            var attr = styleData.ty === "gf" ? "fill-opacity" : "stroke-opacity";
            itemData.style.pElem.setAttribute(attr, itemData.o.v);
          }
          if (itemData.s._mdf || isFirstFrame) {
            var attr1 = styleData.t === 1 ? "x1" : "cx";
            var attr2 = attr1 === "x1" ? "y1" : "cy";
            gfill.setAttribute(attr1, pt1[0]);
            gfill.setAttribute(attr2, pt1[1]);
            if (hasOpacity && !itemData.g._collapsable) {
              itemData.of.setAttribute(attr1, pt1[0]);
              itemData.of.setAttribute(attr2, pt1[1]);
            }
          }
          var stops;
          var i;
          var len;
          var stop;
          if (itemData.g._cmdf || isFirstFrame) {
            stops = itemData.cst;
            var cValues = itemData.g.c;
            len = stops.length;
            for (i = 0; i < len; i += 1) {
              stop = stops[i];
              stop.setAttribute("offset", cValues[i * 4] + "%");
              stop.setAttribute("stop-color", "rgb(" + cValues[i * 4 + 1] + "," + cValues[i * 4 + 2] + "," + cValues[i * 4 + 3] + ")");
            }
          }
          if (hasOpacity && (itemData.g._omdf || isFirstFrame)) {
            var oValues = itemData.g.o;
            if (itemData.g._collapsable) {
              stops = itemData.cst;
            } else {
              stops = itemData.ost;
            }
            len = stops.length;
            for (i = 0; i < len; i += 1) {
              stop = stops[i];
              if (!itemData.g._collapsable) {
                stop.setAttribute("offset", oValues[i * 2] + "%");
              }
              stop.setAttribute("stop-opacity", oValues[i * 2 + 1]);
            }
          }
          if (styleData.t === 1) {
            if (itemData.e._mdf || isFirstFrame) {
              gfill.setAttribute("x2", pt2[0]);
              gfill.setAttribute("y2", pt2[1]);
              if (hasOpacity && !itemData.g._collapsable) {
                itemData.of.setAttribute("x2", pt2[0]);
                itemData.of.setAttribute("y2", pt2[1]);
              }
            }
          } else {
            var rad;
            if (itemData.s._mdf || itemData.e._mdf || isFirstFrame) {
              rad = Math.sqrt(Math.pow(pt1[0] - pt2[0], 2) + Math.pow(pt1[1] - pt2[1], 2));
              gfill.setAttribute("r", rad);
              if (hasOpacity && !itemData.g._collapsable) {
                itemData.of.setAttribute("r", rad);
              }
            }
            if (itemData.s._mdf || itemData.e._mdf || itemData.h._mdf || itemData.a._mdf || isFirstFrame) {
              if (!rad) {
                rad = Math.sqrt(Math.pow(pt1[0] - pt2[0], 2) + Math.pow(pt1[1] - pt2[1], 2));
              }
              var ang = Math.atan2(pt2[1] - pt1[1], pt2[0] - pt1[0]);
              var percent = itemData.h.v;
              if (percent >= 1) {
                percent = 0.99;
              } else if (percent <= -1) {
                percent = -0.99;
              }
              var dist = rad * percent;
              var x = Math.cos(ang + itemData.a.v) * dist + pt1[0];
              var y = Math.sin(ang + itemData.a.v) * dist + pt1[1];
              gfill.setAttribute("fx", x);
              gfill.setAttribute("fy", y);
              if (hasOpacity && !itemData.g._collapsable) {
                itemData.of.setAttribute("fx", x);
                itemData.of.setAttribute("fy", y);
              }
            }
          }
        }
        function renderStroke(styleData, itemData, isFirstFrame) {
          var styleElem = itemData.style;
          var d = itemData.d;
          if (d && (d._mdf || isFirstFrame) && d.dashStr) {
            styleElem.pElem.setAttribute("stroke-dasharray", d.dashStr);
            styleElem.pElem.setAttribute("stroke-dashoffset", d.dashoffset[0]);
          }
          if (itemData.c && (itemData.c._mdf || isFirstFrame)) {
            styleElem.pElem.setAttribute("stroke", "rgb(" + bmFloor(itemData.c.v[0]) + "," + bmFloor(itemData.c.v[1]) + "," + bmFloor(itemData.c.v[2]) + ")");
          }
          if (itemData.o._mdf || isFirstFrame) {
            styleElem.pElem.setAttribute("stroke-opacity", itemData.o.v);
          }
          if (itemData.w._mdf || isFirstFrame) {
            styleElem.pElem.setAttribute("stroke-width", itemData.w.v);
            if (styleElem.msElem) {
              styleElem.msElem.setAttribute("stroke-width", itemData.w.v);
            }
          }
        }
        return ob2;
      }();
      function SVGShapeElement(data2, globalData2, comp2) {
        this.shapes = [];
        this.shapesData = data2.shapes;
        this.stylesList = [];
        this.shapeModifiers = [];
        this.itemsData = [];
        this.processedElements = [];
        this.animatedContents = [];
        this.initElement(data2, globalData2, comp2);
        this.prevViewData = [];
      }
      extendPrototype([BaseElement, TransformElement, SVGBaseElement, IShapeElement, HierarchyElement, FrameElement, RenderableDOMElement], SVGShapeElement);
      SVGShapeElement.prototype.initSecondaryElement = function() {
      };
      SVGShapeElement.prototype.identityMatrix = new Matrix();
      SVGShapeElement.prototype.buildExpressionInterface = function() {
      };
      SVGShapeElement.prototype.createContent = function() {
        this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.layerElement, 0, [], true);
        this.filterUniqueShapes();
      };
      SVGShapeElement.prototype.filterUniqueShapes = function() {
        var i;
        var len = this.shapes.length;
        var shape;
        var j;
        var jLen = this.stylesList.length;
        var style;
        var tempShapes = [];
        var areAnimated = false;
        for (j = 0; j < jLen; j += 1) {
          style = this.stylesList[j];
          areAnimated = false;
          tempShapes.length = 0;
          for (i = 0; i < len; i += 1) {
            shape = this.shapes[i];
            if (shape.styles.indexOf(style) !== -1) {
              tempShapes.push(shape);
              areAnimated = shape._isAnimated || areAnimated;
            }
          }
          if (tempShapes.length > 1 && areAnimated) {
            this.setShapesAsAnimated(tempShapes);
          }
        }
      };
      SVGShapeElement.prototype.setShapesAsAnimated = function(shapes) {
        var i;
        var len = shapes.length;
        for (i = 0; i < len; i += 1) {
          shapes[i].setAsAnimated();
        }
      };
      SVGShapeElement.prototype.createStyleElement = function(data2, level) {
        var elementData;
        var styleOb = new SVGStyleData(data2, level);
        var pathElement = styleOb.pElem;
        if (data2.ty === "st") {
          elementData = new SVGStrokeStyleData(this, data2, styleOb);
        } else if (data2.ty === "fl") {
          elementData = new SVGFillStyleData(this, data2, styleOb);
        } else if (data2.ty === "gf" || data2.ty === "gs") {
          var GradientConstructor = data2.ty === "gf" ? SVGGradientFillStyleData : SVGGradientStrokeStyleData;
          elementData = new GradientConstructor(this, data2, styleOb);
          this.globalData.defs.appendChild(elementData.gf);
          if (elementData.maskId) {
            this.globalData.defs.appendChild(elementData.ms);
            this.globalData.defs.appendChild(elementData.of);
            pathElement.setAttribute("mask", "url(" + getLocationHref() + "#" + elementData.maskId + ")");
          }
        } else if (data2.ty === "no") {
          elementData = new SVGNoStyleData(this, data2, styleOb);
        }
        if (data2.ty === "st" || data2.ty === "gs") {
          pathElement.setAttribute("stroke-linecap", lineCapEnum[data2.lc || 2]);
          pathElement.setAttribute("stroke-linejoin", lineJoinEnum[data2.lj || 2]);
          pathElement.setAttribute("fill-opacity", "0");
          if (data2.lj === 1) {
            pathElement.setAttribute("stroke-miterlimit", data2.ml);
          }
        }
        if (data2.r === 2) {
          pathElement.setAttribute("fill-rule", "evenodd");
        }
        if (data2.ln) {
          pathElement.setAttribute("id", data2.ln);
        }
        if (data2.cl) {
          pathElement.setAttribute("class", data2.cl);
        }
        if (data2.bm) {
          pathElement.style["mix-blend-mode"] = getBlendMode(data2.bm);
        }
        this.stylesList.push(styleOb);
        this.addToAnimatedContents(data2, elementData);
        return elementData;
      };
      SVGShapeElement.prototype.createGroupElement = function(data2) {
        var elementData = new ShapeGroupData();
        if (data2.ln) {
          elementData.gr.setAttribute("id", data2.ln);
        }
        if (data2.cl) {
          elementData.gr.setAttribute("class", data2.cl);
        }
        if (data2.bm) {
          elementData.gr.style["mix-blend-mode"] = getBlendMode(data2.bm);
        }
        return elementData;
      };
      SVGShapeElement.prototype.createTransformElement = function(data2, container) {
        var transformProperty = TransformPropertyFactory.getTransformProperty(this, data2, this);
        var elementData = new SVGTransformData(transformProperty, transformProperty.o, container);
        this.addToAnimatedContents(data2, elementData);
        return elementData;
      };
      SVGShapeElement.prototype.createShapeElement = function(data2, ownTransformers, level) {
        var ty = 4;
        if (data2.ty === "rc") {
          ty = 5;
        } else if (data2.ty === "el") {
          ty = 6;
        } else if (data2.ty === "sr") {
          ty = 7;
        }
        var shapeProperty = ShapePropertyFactory.getShapeProp(this, data2, ty, this);
        var elementData = new SVGShapeData(ownTransformers, level, shapeProperty);
        this.shapes.push(elementData);
        this.addShapeToModifiers(elementData);
        this.addToAnimatedContents(data2, elementData);
        return elementData;
      };
      SVGShapeElement.prototype.addToAnimatedContents = function(data2, element) {
        var i = 0;
        var len = this.animatedContents.length;
        while (i < len) {
          if (this.animatedContents[i].element === element) {
            return;
          }
          i += 1;
        }
        this.animatedContents.push({
          fn: SVGElementsRenderer.createRenderFunction(data2),
          element,
          data: data2
        });
      };
      SVGShapeElement.prototype.setElementStyles = function(elementData) {
        var arr = elementData.styles;
        var j;
        var jLen = this.stylesList.length;
        for (j = 0; j < jLen; j += 1) {
          if (arr.indexOf(this.stylesList[j]) === -1 && !this.stylesList[j].closed) {
            arr.push(this.stylesList[j]);
          }
        }
      };
      SVGShapeElement.prototype.reloadShapes = function() {
        this._isFirstFrame = true;
        var i;
        var len = this.itemsData.length;
        for (i = 0; i < len; i += 1) {
          this.prevViewData[i] = this.itemsData[i];
        }
        this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.layerElement, 0, [], true);
        this.filterUniqueShapes();
        len = this.dynamicProperties.length;
        for (i = 0; i < len; i += 1) {
          this.dynamicProperties[i].getValue();
        }
        this.renderModifiers();
      };
      SVGShapeElement.prototype.searchShapes = function(arr, itemsData, prevViewData, container, level, transformers, render) {
        var ownTransformers = [].concat(transformers);
        var i;
        var len = arr.length - 1;
        var j;
        var jLen;
        var ownStyles = [];
        var ownModifiers = [];
        var currentTransform;
        var modifier;
        var processedPos;
        for (i = len; i >= 0; i -= 1) {
          processedPos = this.searchProcessedElement(arr[i]);
          if (!processedPos) {
            arr[i]._render = render;
          } else {
            itemsData[i] = prevViewData[processedPos - 1];
          }
          if (arr[i].ty === "fl" || arr[i].ty === "st" || arr[i].ty === "gf" || arr[i].ty === "gs" || arr[i].ty === "no") {
            if (!processedPos) {
              itemsData[i] = this.createStyleElement(arr[i], level);
            } else {
              itemsData[i].style.closed = arr[i].hd;
            }
            if (arr[i]._render) {
              if (itemsData[i].style.pElem.parentNode !== container) {
                container.appendChild(itemsData[i].style.pElem);
              }
            }
            ownStyles.push(itemsData[i].style);
          } else if (arr[i].ty === "gr") {
            if (!processedPos) {
              itemsData[i] = this.createGroupElement(arr[i]);
            } else {
              jLen = itemsData[i].it.length;
              for (j = 0; j < jLen; j += 1) {
                itemsData[i].prevViewData[j] = itemsData[i].it[j];
              }
            }
            this.searchShapes(arr[i].it, itemsData[i].it, itemsData[i].prevViewData, itemsData[i].gr, level + 1, ownTransformers, render);
            if (arr[i]._render) {
              if (itemsData[i].gr.parentNode !== container) {
                container.appendChild(itemsData[i].gr);
              }
            }
          } else if (arr[i].ty === "tr") {
            if (!processedPos) {
              itemsData[i] = this.createTransformElement(arr[i], container);
            }
            currentTransform = itemsData[i].transform;
            ownTransformers.push(currentTransform);
          } else if (arr[i].ty === "sh" || arr[i].ty === "rc" || arr[i].ty === "el" || arr[i].ty === "sr") {
            if (!processedPos) {
              itemsData[i] = this.createShapeElement(arr[i], ownTransformers, level);
            }
            this.setElementStyles(itemsData[i]);
          } else if (arr[i].ty === "tm" || arr[i].ty === "rd" || arr[i].ty === "ms" || arr[i].ty === "pb" || arr[i].ty === "zz" || arr[i].ty === "op") {
            if (!processedPos) {
              modifier = ShapeModifiers.getModifier(arr[i].ty);
              modifier.init(this, arr[i]);
              itemsData[i] = modifier;
              this.shapeModifiers.push(modifier);
            } else {
              modifier = itemsData[i];
              modifier.closed = false;
            }
            ownModifiers.push(modifier);
          } else if (arr[i].ty === "rp") {
            if (!processedPos) {
              modifier = ShapeModifiers.getModifier(arr[i].ty);
              itemsData[i] = modifier;
              modifier.init(this, arr, i, itemsData);
              this.shapeModifiers.push(modifier);
              render = false;
            } else {
              modifier = itemsData[i];
              modifier.closed = true;
            }
            ownModifiers.push(modifier);
          }
          this.addProcessedElement(arr[i], i + 1);
        }
        len = ownStyles.length;
        for (i = 0; i < len; i += 1) {
          ownStyles[i].closed = true;
        }
        len = ownModifiers.length;
        for (i = 0; i < len; i += 1) {
          ownModifiers[i].closed = true;
        }
      };
      SVGShapeElement.prototype.renderInnerContent = function() {
        this.renderModifiers();
        var i;
        var len = this.stylesList.length;
        for (i = 0; i < len; i += 1) {
          this.stylesList[i].reset();
        }
        this.renderShape();
        for (i = 0; i < len; i += 1) {
          if (this.stylesList[i]._mdf || this._isFirstFrame) {
            if (this.stylesList[i].msElem) {
              this.stylesList[i].msElem.setAttribute("d", this.stylesList[i].d);
              this.stylesList[i].d = "M0 0" + this.stylesList[i].d;
            }
            this.stylesList[i].pElem.setAttribute("d", this.stylesList[i].d || "M0 0");
          }
        }
      };
      SVGShapeElement.prototype.renderShape = function() {
        var i;
        var len = this.animatedContents.length;
        var animatedContent;
        for (i = 0; i < len; i += 1) {
          animatedContent = this.animatedContents[i];
          if ((this._isFirstFrame || animatedContent.element._isAnimated) && animatedContent.data !== true) {
            animatedContent.fn(animatedContent.data, animatedContent.element, this._isFirstFrame);
          }
        }
      };
      SVGShapeElement.prototype.destroy = function() {
        this.destroyBaseElement();
        this.shapesData = null;
        this.itemsData = null;
      };
      function LetterProps(o, sw, sc, fc, m, p) {
        this.o = o;
        this.sw = sw;
        this.sc = sc;
        this.fc = fc;
        this.m = m;
        this.p = p;
        this._mdf = {
          o: true,
          sw: !!sw,
          sc: !!sc,
          fc: !!fc,
          m: true,
          p: true
        };
      }
      LetterProps.prototype.update = function(o, sw, sc, fc, m, p) {
        this._mdf.o = false;
        this._mdf.sw = false;
        this._mdf.sc = false;
        this._mdf.fc = false;
        this._mdf.m = false;
        this._mdf.p = false;
        var updated = false;
        if (this.o !== o) {
          this.o = o;
          this._mdf.o = true;
          updated = true;
        }
        if (this.sw !== sw) {
          this.sw = sw;
          this._mdf.sw = true;
          updated = true;
        }
        if (this.sc !== sc) {
          this.sc = sc;
          this._mdf.sc = true;
          updated = true;
        }
        if (this.fc !== fc) {
          this.fc = fc;
          this._mdf.fc = true;
          updated = true;
        }
        if (this.m !== m) {
          this.m = m;
          this._mdf.m = true;
          updated = true;
        }
        if (p.length && (this.p[0] !== p[0] || this.p[1] !== p[1] || this.p[4] !== p[4] || this.p[5] !== p[5] || this.p[12] !== p[12] || this.p[13] !== p[13])) {
          this.p = p;
          this._mdf.p = true;
          updated = true;
        }
        return updated;
      };
      function TextProperty(elem2, data2) {
        this._frameId = initialDefaultFrame;
        this.pv = "";
        this.v = "";
        this.kf = false;
        this._isFirstFrame = true;
        this._mdf = false;
        if (data2.d && data2.d.sid) {
          data2.d = elem2.globalData.slotManager.getProp(data2.d);
        }
        this.data = data2;
        this.elem = elem2;
        this.comp = this.elem.comp;
        this.keysIndex = 0;
        this.canResize = false;
        this.minimumFontSize = 1;
        this.effectsSequence = [];
        this.currentData = {
          ascent: 0,
          boxWidth: this.defaultBoxWidth,
          f: "",
          fStyle: "",
          fWeight: "",
          fc: "",
          j: "",
          justifyOffset: "",
          l: [],
          lh: 0,
          lineWidths: [],
          ls: "",
          of: "",
          s: "",
          sc: "",
          sw: 0,
          t: 0,
          tr: 0,
          sz: 0,
          ps: null,
          fillColorAnim: false,
          strokeColorAnim: false,
          strokeWidthAnim: false,
          yOffset: 0,
          finalSize: 0,
          finalText: [],
          finalLineHeight: 0,
          __complete: false
        };
        this.copyData(this.currentData, this.data.d.k[0].s);
        if (!this.searchProperty()) {
          this.completeTextData(this.currentData);
        }
      }
      TextProperty.prototype.defaultBoxWidth = [0, 0];
      TextProperty.prototype.copyData = function(obj, data2) {
        for (var s in data2) {
          if (Object.prototype.hasOwnProperty.call(data2, s)) {
            obj[s] = data2[s];
          }
        }
        return obj;
      };
      TextProperty.prototype.setCurrentData = function(data2) {
        if (!data2.__complete) {
          this.completeTextData(data2);
        }
        this.currentData = data2;
        this.currentData.boxWidth = this.currentData.boxWidth || this.defaultBoxWidth;
        this._mdf = true;
      };
      TextProperty.prototype.searchProperty = function() {
        return this.searchKeyframes();
      };
      TextProperty.prototype.searchKeyframes = function() {
        this.kf = this.data.d.k.length > 1;
        if (this.kf) {
          this.addEffect(this.getKeyframeValue.bind(this));
        }
        return this.kf;
      };
      TextProperty.prototype.addEffect = function(effectFunction) {
        this.effectsSequence.push(effectFunction);
        this.elem.addDynamicProperty(this);
      };
      TextProperty.prototype.getValue = function(_finalValue) {
        if ((this.elem.globalData.frameId === this.frameId || !this.effectsSequence.length) && !_finalValue) {
          return;
        }
        this.currentData.t = this.data.d.k[this.keysIndex].s.t;
        var currentValue = this.currentData;
        var currentIndex = this.keysIndex;
        if (this.lock) {
          this.setCurrentData(this.currentData);
          return;
        }
        this.lock = true;
        this._mdf = false;
        var i;
        var len = this.effectsSequence.length;
        var finalValue = _finalValue || this.data.d.k[this.keysIndex].s;
        for (i = 0; i < len; i += 1) {
          if (currentIndex !== this.keysIndex) {
            finalValue = this.effectsSequence[i](finalValue, finalValue.t);
          } else {
            finalValue = this.effectsSequence[i](this.currentData, finalValue.t);
          }
        }
        if (currentValue !== finalValue) {
          this.setCurrentData(finalValue);
        }
        this.v = this.currentData;
        this.pv = this.v;
        this.lock = false;
        this.frameId = this.elem.globalData.frameId;
      };
      TextProperty.prototype.getKeyframeValue = function() {
        var textKeys = this.data.d.k;
        var frameNum = this.elem.comp.renderedFrame;
        var i = 0;
        var len = textKeys.length;
        while (i <= len - 1) {
          if (i === len - 1 || textKeys[i + 1].t > frameNum) {
            break;
          }
          i += 1;
        }
        if (this.keysIndex !== i) {
          this.keysIndex = i;
        }
        return this.data.d.k[this.keysIndex].s;
      };
      TextProperty.prototype.buildFinalText = function(text2) {
        var charactersArray = [];
        var i = 0;
        var len = text2.length;
        var charCode;
        var secondCharCode;
        var shouldCombine = false;
        var shouldCombineNext = false;
        var currentChars = "";
        while (i < len) {
          shouldCombine = shouldCombineNext;
          shouldCombineNext = false;
          charCode = text2.charCodeAt(i);
          currentChars = text2.charAt(i);
          if (FontManager.isCombinedCharacter(charCode)) {
            shouldCombine = true;
          } else if (charCode >= 55296 && charCode <= 56319) {
            if (FontManager.isRegionalFlag(text2, i)) {
              currentChars = text2.substr(i, 14);
            } else {
              secondCharCode = text2.charCodeAt(i + 1);
              if (secondCharCode >= 56320 && secondCharCode <= 57343) {
                if (FontManager.isModifier(charCode, secondCharCode)) {
                  currentChars = text2.substr(i, 2);
                  shouldCombine = true;
                } else if (FontManager.isFlagEmoji(text2.substr(i, 4))) {
                  currentChars = text2.substr(i, 4);
                } else {
                  currentChars = text2.substr(i, 2);
                }
              }
            }
          } else if (charCode > 56319) {
            secondCharCode = text2.charCodeAt(i + 1);
            if (FontManager.isVariationSelector(charCode)) {
              shouldCombine = true;
            }
          } else if (FontManager.isZeroWidthJoiner(charCode)) {
            shouldCombine = true;
            shouldCombineNext = true;
          }
          if (shouldCombine) {
            charactersArray[charactersArray.length - 1] += currentChars;
            shouldCombine = false;
          } else {
            charactersArray.push(currentChars);
          }
          i += currentChars.length;
        }
        return charactersArray;
      };
      TextProperty.prototype.completeTextData = function(documentData) {
        documentData.__complete = true;
        var fontManager = this.elem.globalData.fontManager;
        var data2 = this.data;
        var letters = [];
        var i;
        var len;
        var newLineFlag;
        var index2 = 0;
        var val2;
        var anchorGrouping = data2.m.g;
        var currentSize = 0;
        var currentPos = 0;
        var currentLine = 0;
        var lineWidths = [];
        var lineWidth = 0;
        var maxLineWidth = 0;
        var j;
        var jLen;
        var fontData = fontManager.getFontByName(documentData.f);
        var charData;
        var cLength = 0;
        var fontProps = getFontProperties(fontData);
        documentData.fWeight = fontProps.weight;
        documentData.fStyle = fontProps.style;
        documentData.finalSize = documentData.s;
        documentData.finalText = this.buildFinalText(documentData.t);
        len = documentData.finalText.length;
        documentData.finalLineHeight = documentData.lh;
        var trackingOffset = documentData.tr / 1e3 * documentData.finalSize;
        var charCode;
        if (documentData.sz) {
          var flag = true;
          var boxWidth = documentData.sz[0];
          var boxHeight = documentData.sz[1];
          var currentHeight;
          var finalText;
          while (flag) {
            finalText = this.buildFinalText(documentData.t);
            currentHeight = 0;
            lineWidth = 0;
            len = finalText.length;
            trackingOffset = documentData.tr / 1e3 * documentData.finalSize;
            var lastSpaceIndex = -1;
            for (i = 0; i < len; i += 1) {
              charCode = finalText[i].charCodeAt(0);
              newLineFlag = false;
              if (finalText[i] === " ") {
                lastSpaceIndex = i;
              } else if (charCode === 13 || charCode === 3) {
                lineWidth = 0;
                newLineFlag = true;
                currentHeight += documentData.finalLineHeight || documentData.finalSize * 1.2;
              }
              if (fontManager.chars) {
                charData = fontManager.getCharData(finalText[i], fontData.fStyle, fontData.fFamily);
                cLength = newLineFlag ? 0 : charData.w * documentData.finalSize / 100;
              } else {
                cLength = fontManager.measureText(finalText[i], documentData.f, documentData.finalSize);
              }
              if (lineWidth + cLength > boxWidth && finalText[i] !== " ") {
                if (lastSpaceIndex === -1) {
                  len += 1;
                } else {
                  i = lastSpaceIndex;
                }
                currentHeight += documentData.finalLineHeight || documentData.finalSize * 1.2;
                finalText.splice(i, lastSpaceIndex === i ? 1 : 0, "\r");
                lastSpaceIndex = -1;
                lineWidth = 0;
              } else {
                lineWidth += cLength;
                lineWidth += trackingOffset;
              }
            }
            currentHeight += fontData.ascent * documentData.finalSize / 100;
            if (this.canResize && documentData.finalSize > this.minimumFontSize && boxHeight < currentHeight) {
              documentData.finalSize -= 1;
              documentData.finalLineHeight = documentData.finalSize * documentData.lh / documentData.s;
            } else {
              documentData.finalText = finalText;
              len = documentData.finalText.length;
              flag = false;
            }
          }
        }
        lineWidth = -trackingOffset;
        cLength = 0;
        var uncollapsedSpaces = 0;
        var currentChar;
        for (i = 0; i < len; i += 1) {
          newLineFlag = false;
          currentChar = documentData.finalText[i];
          charCode = currentChar.charCodeAt(0);
          if (charCode === 13 || charCode === 3) {
            uncollapsedSpaces = 0;
            lineWidths.push(lineWidth);
            maxLineWidth = lineWidth > maxLineWidth ? lineWidth : maxLineWidth;
            lineWidth = -2 * trackingOffset;
            val2 = "";
            newLineFlag = true;
            currentLine += 1;
          } else {
            val2 = currentChar;
          }
          if (fontManager.chars) {
            charData = fontManager.getCharData(currentChar, fontData.fStyle, fontManager.getFontByName(documentData.f).fFamily);
            cLength = newLineFlag ? 0 : charData.w * documentData.finalSize / 100;
          } else {
            cLength = fontManager.measureText(val2, documentData.f, documentData.finalSize);
          }
          if (currentChar === " ") {
            uncollapsedSpaces += cLength + trackingOffset;
          } else {
            lineWidth += cLength + trackingOffset + uncollapsedSpaces;
            uncollapsedSpaces = 0;
          }
          letters.push({
            l: cLength,
            an: cLength,
            add: currentSize,
            n: newLineFlag,
            anIndexes: [],
            val: val2,
            line: currentLine,
            animatorJustifyOffset: 0
          });
          if (anchorGrouping == 2) {
            currentSize += cLength;
            if (val2 === "" || val2 === " " || i === len - 1) {
              if (val2 === "" || val2 === " ") {
                currentSize -= cLength;
              }
              while (currentPos <= i) {
                letters[currentPos].an = currentSize;
                letters[currentPos].ind = index2;
                letters[currentPos].extra = cLength;
                currentPos += 1;
              }
              index2 += 1;
              currentSize = 0;
            }
          } else if (anchorGrouping == 3) {
            currentSize += cLength;
            if (val2 === "" || i === len - 1) {
              if (val2 === "") {
                currentSize -= cLength;
              }
              while (currentPos <= i) {
                letters[currentPos].an = currentSize;
                letters[currentPos].ind = index2;
                letters[currentPos].extra = cLength;
                currentPos += 1;
              }
              currentSize = 0;
              index2 += 1;
            }
          } else {
            letters[index2].ind = index2;
            letters[index2].extra = 0;
            index2 += 1;
          }
        }
        documentData.l = letters;
        maxLineWidth = lineWidth > maxLineWidth ? lineWidth : maxLineWidth;
        lineWidths.push(lineWidth);
        if (documentData.sz) {
          documentData.boxWidth = documentData.sz[0];
          documentData.justifyOffset = 0;
        } else {
          documentData.boxWidth = maxLineWidth;
          switch (documentData.j) {
            case 1:
              documentData.justifyOffset = -documentData.boxWidth;
              break;
            case 2:
              documentData.justifyOffset = -documentData.boxWidth / 2;
              break;
            default:
              documentData.justifyOffset = 0;
          }
        }
        documentData.lineWidths = lineWidths;
        var animators = data2.a;
        var animatorData;
        var letterData;
        jLen = animators.length;
        var based;
        var ind;
        var indexes = [];
        for (j = 0; j < jLen; j += 1) {
          animatorData = animators[j];
          if (animatorData.a.sc) {
            documentData.strokeColorAnim = true;
          }
          if (animatorData.a.sw) {
            documentData.strokeWidthAnim = true;
          }
          if (animatorData.a.fc || animatorData.a.fh || animatorData.a.fs || animatorData.a.fb) {
            documentData.fillColorAnim = true;
          }
          ind = 0;
          based = animatorData.s.b;
          for (i = 0; i < len; i += 1) {
            letterData = letters[i];
            letterData.anIndexes[j] = ind;
            if (based == 1 && letterData.val !== "" || based == 2 && letterData.val !== "" && letterData.val !== " " || based == 3 && (letterData.n || letterData.val == " " || i == len - 1) || based == 4 && (letterData.n || i == len - 1)) {
              if (animatorData.s.rn === 1) {
                indexes.push(ind);
              }
              ind += 1;
            }
          }
          data2.a[j].s.totalChars = ind;
          var currentInd = -1;
          var newInd;
          if (animatorData.s.rn === 1) {
            for (i = 0; i < len; i += 1) {
              letterData = letters[i];
              if (currentInd != letterData.anIndexes[j]) {
                currentInd = letterData.anIndexes[j];
                newInd = indexes.splice(Math.floor(Math.random() * indexes.length), 1)[0];
              }
              letterData.anIndexes[j] = newInd;
            }
          }
        }
        documentData.yOffset = documentData.finalLineHeight || documentData.finalSize * 1.2;
        documentData.ls = documentData.ls || 0;
        documentData.ascent = fontData.ascent * documentData.finalSize / 100;
      };
      TextProperty.prototype.updateDocumentData = function(newData, index2) {
        index2 = index2 === void 0 ? this.keysIndex : index2;
        var dData = this.copyData({}, this.data.d.k[index2].s);
        dData = this.copyData(dData, newData);
        this.data.d.k[index2].s = dData;
        this.recalculate(index2);
        this.setCurrentData(dData);
        this.elem.addDynamicProperty(this);
      };
      TextProperty.prototype.recalculate = function(index2) {
        var dData = this.data.d.k[index2].s;
        dData.__complete = false;
        this.keysIndex = 0;
        this._isFirstFrame = true;
        this.getValue(dData);
      };
      TextProperty.prototype.canResizeFont = function(_canResize) {
        this.canResize = _canResize;
        this.recalculate(this.keysIndex);
        this.elem.addDynamicProperty(this);
      };
      TextProperty.prototype.setMinimumFontSize = function(_fontValue) {
        this.minimumFontSize = Math.floor(_fontValue) || 1;
        this.recalculate(this.keysIndex);
        this.elem.addDynamicProperty(this);
      };
      var TextSelectorProp = function() {
        var max = Math.max;
        var min = Math.min;
        var floor = Math.floor;
        function TextSelectorPropFactory(elem2, data2) {
          this._currentTextLength = -1;
          this.k = false;
          this.data = data2;
          this.elem = elem2;
          this.comp = elem2.comp;
          this.finalS = 0;
          this.finalE = 0;
          this.initDynamicPropertyContainer(elem2);
          this.s = PropertyFactory.getProp(elem2, data2.s || {
            k: 0
          }, 0, 0, this);
          if ("e" in data2) {
            this.e = PropertyFactory.getProp(elem2, data2.e, 0, 0, this);
          } else {
            this.e = {
              v: 100
            };
          }
          this.o = PropertyFactory.getProp(elem2, data2.o || {
            k: 0
          }, 0, 0, this);
          this.xe = PropertyFactory.getProp(elem2, data2.xe || {
            k: 0
          }, 0, 0, this);
          this.ne = PropertyFactory.getProp(elem2, data2.ne || {
            k: 0
          }, 0, 0, this);
          this.sm = PropertyFactory.getProp(elem2, data2.sm || {
            k: 100
          }, 0, 0, this);
          this.a = PropertyFactory.getProp(elem2, data2.a, 0, 0.01, this);
          if (!this.dynamicProperties.length) {
            this.getValue();
          }
        }
        TextSelectorPropFactory.prototype = {
          getMult: function getMult(ind) {
            if (this._currentTextLength !== this.elem.textProperty.currentData.l.length) {
              this.getValue();
            }
            var x1 = 0;
            var y1 = 0;
            var x2 = 1;
            var y2 = 1;
            if (this.ne.v > 0) {
              x1 = this.ne.v / 100;
            } else {
              y1 = -this.ne.v / 100;
            }
            if (this.xe.v > 0) {
              x2 = 1 - this.xe.v / 100;
            } else {
              y2 = 1 + this.xe.v / 100;
            }
            var easer = BezierFactory.getBezierEasing(x1, y1, x2, y2).get;
            var mult = 0;
            var s = this.finalS;
            var e = this.finalE;
            var type = this.data.sh;
            if (type === 2) {
              if (e === s) {
                mult = ind >= e ? 1 : 0;
              } else {
                mult = max(0, min(0.5 / (e - s) + (ind - s) / (e - s), 1));
              }
              mult = easer(mult);
            } else if (type === 3) {
              if (e === s) {
                mult = ind >= e ? 0 : 1;
              } else {
                mult = 1 - max(0, min(0.5 / (e - s) + (ind - s) / (e - s), 1));
              }
              mult = easer(mult);
            } else if (type === 4) {
              if (e === s) {
                mult = 0;
              } else {
                mult = max(0, min(0.5 / (e - s) + (ind - s) / (e - s), 1));
                if (mult < 0.5) {
                  mult *= 2;
                } else {
                  mult = 1 - 2 * (mult - 0.5);
                }
              }
              mult = easer(mult);
            } else if (type === 5) {
              if (e === s) {
                mult = 0;
              } else {
                var tot = e - s;
                ind = min(max(0, ind + 0.5 - s), e - s);
                var x = -tot / 2 + ind;
                var a = tot / 2;
                mult = Math.sqrt(1 - x * x / (a * a));
              }
              mult = easer(mult);
            } else if (type === 6) {
              if (e === s) {
                mult = 0;
              } else {
                ind = min(max(0, ind + 0.5 - s), e - s);
                mult = (1 + Math.cos(Math.PI + Math.PI * 2 * ind / (e - s))) / 2;
              }
              mult = easer(mult);
            } else {
              if (ind >= floor(s)) {
                if (ind - s < 0) {
                  mult = max(0, min(min(e, 1) - (s - ind), 1));
                } else {
                  mult = max(0, min(e - ind, 1));
                }
              }
              mult = easer(mult);
            }
            if (this.sm.v !== 100) {
              var smoothness = this.sm.v * 0.01;
              if (smoothness === 0) {
                smoothness = 1e-8;
              }
              var threshold = 0.5 - smoothness * 0.5;
              if (mult < threshold) {
                mult = 0;
              } else {
                mult = (mult - threshold) / smoothness;
                if (mult > 1) {
                  mult = 1;
                }
              }
            }
            return mult * this.a.v;
          },
          getValue: function getValue(newCharsFlag) {
            this.iterateDynamicProperties();
            this._mdf = newCharsFlag || this._mdf;
            this._currentTextLength = this.elem.textProperty.currentData.l.length || 0;
            if (newCharsFlag && this.data.r === 2) {
              this.e.v = this._currentTextLength;
            }
            var divisor = this.data.r === 2 ? 1 : 100 / this.data.totalChars;
            var o = this.o.v / divisor;
            var s = this.s.v / divisor + o;
            var e = this.e.v / divisor + o;
            if (s > e) {
              var _s = s;
              s = e;
              e = _s;
            }
            this.finalS = s;
            this.finalE = e;
          }
        };
        extendPrototype([DynamicPropertyContainer], TextSelectorPropFactory);
        function getTextSelectorProp(elem2, data2, arr) {
          return new TextSelectorPropFactory(elem2, data2, arr);
        }
        return {
          getTextSelectorProp
        };
      }();
      function TextAnimatorDataProperty(elem2, animatorProps, container) {
        var defaultData = {
          propType: false
        };
        var getProp = PropertyFactory.getProp;
        var textAnimatorAnimatables = animatorProps.a;
        this.a = {
          r: textAnimatorAnimatables.r ? getProp(elem2, textAnimatorAnimatables.r, 0, degToRads, container) : defaultData,
          rx: textAnimatorAnimatables.rx ? getProp(elem2, textAnimatorAnimatables.rx, 0, degToRads, container) : defaultData,
          ry: textAnimatorAnimatables.ry ? getProp(elem2, textAnimatorAnimatables.ry, 0, degToRads, container) : defaultData,
          sk: textAnimatorAnimatables.sk ? getProp(elem2, textAnimatorAnimatables.sk, 0, degToRads, container) : defaultData,
          sa: textAnimatorAnimatables.sa ? getProp(elem2, textAnimatorAnimatables.sa, 0, degToRads, container) : defaultData,
          s: textAnimatorAnimatables.s ? getProp(elem2, textAnimatorAnimatables.s, 1, 0.01, container) : defaultData,
          a: textAnimatorAnimatables.a ? getProp(elem2, textAnimatorAnimatables.a, 1, 0, container) : defaultData,
          o: textAnimatorAnimatables.o ? getProp(elem2, textAnimatorAnimatables.o, 0, 0.01, container) : defaultData,
          p: textAnimatorAnimatables.p ? getProp(elem2, textAnimatorAnimatables.p, 1, 0, container) : defaultData,
          sw: textAnimatorAnimatables.sw ? getProp(elem2, textAnimatorAnimatables.sw, 0, 0, container) : defaultData,
          sc: textAnimatorAnimatables.sc ? getProp(elem2, textAnimatorAnimatables.sc, 1, 0, container) : defaultData,
          fc: textAnimatorAnimatables.fc ? getProp(elem2, textAnimatorAnimatables.fc, 1, 0, container) : defaultData,
          fh: textAnimatorAnimatables.fh ? getProp(elem2, textAnimatorAnimatables.fh, 0, 0, container) : defaultData,
          fs: textAnimatorAnimatables.fs ? getProp(elem2, textAnimatorAnimatables.fs, 0, 0.01, container) : defaultData,
          fb: textAnimatorAnimatables.fb ? getProp(elem2, textAnimatorAnimatables.fb, 0, 0.01, container) : defaultData,
          t: textAnimatorAnimatables.t ? getProp(elem2, textAnimatorAnimatables.t, 0, 0, container) : defaultData
        };
        this.s = TextSelectorProp.getTextSelectorProp(elem2, animatorProps.s, container);
        this.s.t = animatorProps.s.t;
      }
      function TextAnimatorProperty(textData, renderType, elem2) {
        this._isFirstFrame = true;
        this._hasMaskedPath = false;
        this._frameId = -1;
        this._textData = textData;
        this._renderType = renderType;
        this._elem = elem2;
        this._animatorsData = createSizedArray(this._textData.a.length);
        this._pathData = {};
        this._moreOptions = {
          alignment: {}
        };
        this.renderedLetters = [];
        this.lettersChangedFlag = false;
        this.initDynamicPropertyContainer(elem2);
      }
      TextAnimatorProperty.prototype.searchProperties = function() {
        var i;
        var len = this._textData.a.length;
        var animatorProps;
        var getProp = PropertyFactory.getProp;
        for (i = 0; i < len; i += 1) {
          animatorProps = this._textData.a[i];
          this._animatorsData[i] = new TextAnimatorDataProperty(this._elem, animatorProps, this);
        }
        if (this._textData.p && "m" in this._textData.p) {
          this._pathData = {
            a: getProp(this._elem, this._textData.p.a, 0, 0, this),
            f: getProp(this._elem, this._textData.p.f, 0, 0, this),
            l: getProp(this._elem, this._textData.p.l, 0, 0, this),
            r: getProp(this._elem, this._textData.p.r, 0, 0, this),
            p: getProp(this._elem, this._textData.p.p, 0, 0, this),
            m: this._elem.maskManager.getMaskProperty(this._textData.p.m)
          };
          this._hasMaskedPath = true;
        } else {
          this._hasMaskedPath = false;
        }
        this._moreOptions.alignment = getProp(this._elem, this._textData.m.a, 1, 0, this);
      };
      TextAnimatorProperty.prototype.getMeasures = function(documentData, lettersChangedFlag) {
        this.lettersChangedFlag = lettersChangedFlag;
        if (!this._mdf && !this._isFirstFrame && !lettersChangedFlag && (!this._hasMaskedPath || !this._pathData.m._mdf)) {
          return;
        }
        this._isFirstFrame = false;
        var alignment = this._moreOptions.alignment.v;
        var animators = this._animatorsData;
        var textData = this._textData;
        var matrixHelper = this.mHelper;
        var renderType = this._renderType;
        var renderedLettersCount = this.renderedLetters.length;
        var xPos;
        var yPos;
        var i;
        var len;
        var letters = documentData.l;
        var pathInfo;
        var currentLength;
        var currentPoint;
        var segmentLength;
        var flag;
        var pointInd;
        var segmentInd;
        var prevPoint;
        var points;
        var segments;
        var partialLength;
        var totalLength2;
        var perc;
        var tanAngle;
        var mask2;
        if (this._hasMaskedPath) {
          mask2 = this._pathData.m;
          if (!this._pathData.n || this._pathData._mdf) {
            var paths = mask2.v;
            if (this._pathData.r.v) {
              paths = paths.reverse();
            }
            pathInfo = {
              tLength: 0,
              segments: []
            };
            len = paths._length - 1;
            var bezierData;
            totalLength2 = 0;
            for (i = 0; i < len; i += 1) {
              bezierData = bez.buildBezierData(paths.v[i], paths.v[i + 1], [paths.o[i][0] - paths.v[i][0], paths.o[i][1] - paths.v[i][1]], [paths.i[i + 1][0] - paths.v[i + 1][0], paths.i[i + 1][1] - paths.v[i + 1][1]]);
              pathInfo.tLength += bezierData.segmentLength;
              pathInfo.segments.push(bezierData);
              totalLength2 += bezierData.segmentLength;
            }
            i = len;
            if (mask2.v.c) {
              bezierData = bez.buildBezierData(paths.v[i], paths.v[0], [paths.o[i][0] - paths.v[i][0], paths.o[i][1] - paths.v[i][1]], [paths.i[0][0] - paths.v[0][0], paths.i[0][1] - paths.v[0][1]]);
              pathInfo.tLength += bezierData.segmentLength;
              pathInfo.segments.push(bezierData);
              totalLength2 += bezierData.segmentLength;
            }
            this._pathData.pi = pathInfo;
          }
          pathInfo = this._pathData.pi;
          currentLength = this._pathData.f.v;
          segmentInd = 0;
          pointInd = 1;
          segmentLength = 0;
          flag = true;
          segments = pathInfo.segments;
          if (currentLength < 0 && mask2.v.c) {
            if (pathInfo.tLength < Math.abs(currentLength)) {
              currentLength = -Math.abs(currentLength) % pathInfo.tLength;
            }
            segmentInd = segments.length - 1;
            points = segments[segmentInd].points;
            pointInd = points.length - 1;
            while (currentLength < 0) {
              currentLength += points[pointInd].partialLength;
              pointInd -= 1;
              if (pointInd < 0) {
                segmentInd -= 1;
                points = segments[segmentInd].points;
                pointInd = points.length - 1;
              }
            }
          }
          points = segments[segmentInd].points;
          prevPoint = points[pointInd - 1];
          currentPoint = points[pointInd];
          partialLength = currentPoint.partialLength;
        }
        len = letters.length;
        xPos = 0;
        yPos = 0;
        var yOff = documentData.finalSize * 1.2 * 0.714;
        var firstLine = true;
        var animatorProps;
        var animatorSelector;
        var j;
        var jLen;
        var letterValue;
        jLen = animators.length;
        var mult;
        var ind = -1;
        var offf;
        var xPathPos;
        var yPathPos;
        var initPathPos = currentLength;
        var initSegmentInd = segmentInd;
        var initPointInd = pointInd;
        var currentLine = -1;
        var elemOpacity;
        var sc;
        var sw;
        var fc;
        var k;
        var letterSw;
        var letterSc;
        var letterFc;
        var letterM = "";
        var letterP = this.defaultPropsArray;
        var letterO;
        if (documentData.j === 2 || documentData.j === 1) {
          var animatorJustifyOffset = 0;
          var animatorFirstCharOffset = 0;
          var justifyOffsetMult = documentData.j === 2 ? -0.5 : -1;
          var lastIndex = 0;
          var isNewLine = true;
          for (i = 0; i < len; i += 1) {
            if (letters[i].n) {
              if (animatorJustifyOffset) {
                animatorJustifyOffset += animatorFirstCharOffset;
              }
              while (lastIndex < i) {
                letters[lastIndex].animatorJustifyOffset = animatorJustifyOffset;
                lastIndex += 1;
              }
              animatorJustifyOffset = 0;
              isNewLine = true;
            } else {
              for (j = 0; j < jLen; j += 1) {
                animatorProps = animators[j].a;
                if (animatorProps.t.propType) {
                  if (isNewLine && documentData.j === 2) {
                    animatorFirstCharOffset += animatorProps.t.v * justifyOffsetMult;
                  }
                  animatorSelector = animators[j].s;
                  mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);
                  if (mult.length) {
                    animatorJustifyOffset += animatorProps.t.v * mult[0] * justifyOffsetMult;
                  } else {
                    animatorJustifyOffset += animatorProps.t.v * mult * justifyOffsetMult;
                  }
                }
              }
              isNewLine = false;
            }
          }
          if (animatorJustifyOffset) {
            animatorJustifyOffset += animatorFirstCharOffset;
          }
          while (lastIndex < i) {
            letters[lastIndex].animatorJustifyOffset = animatorJustifyOffset;
            lastIndex += 1;
          }
        }
        for (i = 0; i < len; i += 1) {
          matrixHelper.reset();
          elemOpacity = 1;
          if (letters[i].n) {
            xPos = 0;
            yPos += documentData.yOffset;
            yPos += firstLine ? 1 : 0;
            currentLength = initPathPos;
            firstLine = false;
            if (this._hasMaskedPath) {
              segmentInd = initSegmentInd;
              pointInd = initPointInd;
              points = segments[segmentInd].points;
              prevPoint = points[pointInd - 1];
              currentPoint = points[pointInd];
              partialLength = currentPoint.partialLength;
              segmentLength = 0;
            }
            letterM = "";
            letterFc = "";
            letterSw = "";
            letterO = "";
            letterP = this.defaultPropsArray;
          } else {
            if (this._hasMaskedPath) {
              if (currentLine !== letters[i].line) {
                switch (documentData.j) {
                  case 1:
                    currentLength += totalLength2 - documentData.lineWidths[letters[i].line];
                    break;
                  case 2:
                    currentLength += (totalLength2 - documentData.lineWidths[letters[i].line]) / 2;
                    break;
                  default:
                    break;
                }
                currentLine = letters[i].line;
              }
              if (ind !== letters[i].ind) {
                if (letters[ind]) {
                  currentLength += letters[ind].extra;
                }
                currentLength += letters[i].an / 2;
                ind = letters[i].ind;
              }
              currentLength += alignment[0] * letters[i].an * 5e-3;
              var animatorOffset = 0;
              for (j = 0; j < jLen; j += 1) {
                animatorProps = animators[j].a;
                if (animatorProps.p.propType) {
                  animatorSelector = animators[j].s;
                  mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);
                  if (mult.length) {
                    animatorOffset += animatorProps.p.v[0] * mult[0];
                  } else {
                    animatorOffset += animatorProps.p.v[0] * mult;
                  }
                }
                if (animatorProps.a.propType) {
                  animatorSelector = animators[j].s;
                  mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);
                  if (mult.length) {
                    animatorOffset += animatorProps.a.v[0] * mult[0];
                  } else {
                    animatorOffset += animatorProps.a.v[0] * mult;
                  }
                }
              }
              flag = true;
              if (this._pathData.a.v) {
                currentLength = letters[0].an * 0.5 + (totalLength2 - this._pathData.f.v - letters[0].an * 0.5 - letters[letters.length - 1].an * 0.5) * ind / (len - 1);
                currentLength += this._pathData.f.v;
              }
              while (flag) {
                if (segmentLength + partialLength >= currentLength + animatorOffset || !points) {
                  perc = (currentLength + animatorOffset - segmentLength) / currentPoint.partialLength;
                  xPathPos = prevPoint.point[0] + (currentPoint.point[0] - prevPoint.point[0]) * perc;
                  yPathPos = prevPoint.point[1] + (currentPoint.point[1] - prevPoint.point[1]) * perc;
                  matrixHelper.translate(-alignment[0] * letters[i].an * 5e-3, -(alignment[1] * yOff) * 0.01);
                  flag = false;
                } else if (points) {
                  segmentLength += currentPoint.partialLength;
                  pointInd += 1;
                  if (pointInd >= points.length) {
                    pointInd = 0;
                    segmentInd += 1;
                    if (!segments[segmentInd]) {
                      if (mask2.v.c) {
                        pointInd = 0;
                        segmentInd = 0;
                        points = segments[segmentInd].points;
                      } else {
                        segmentLength -= currentPoint.partialLength;
                        points = null;
                      }
                    } else {
                      points = segments[segmentInd].points;
                    }
                  }
                  if (points) {
                    prevPoint = currentPoint;
                    currentPoint = points[pointInd];
                    partialLength = currentPoint.partialLength;
                  }
                }
              }
              offf = letters[i].an / 2 - letters[i].add;
              matrixHelper.translate(-offf, 0, 0);
            } else {
              offf = letters[i].an / 2 - letters[i].add;
              matrixHelper.translate(-offf, 0, 0);
              matrixHelper.translate(-alignment[0] * letters[i].an * 5e-3, -alignment[1] * yOff * 0.01, 0);
            }
            for (j = 0; j < jLen; j += 1) {
              animatorProps = animators[j].a;
              if (animatorProps.t.propType) {
                animatorSelector = animators[j].s;
                mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);
                if (xPos !== 0 || documentData.j !== 0) {
                  if (this._hasMaskedPath) {
                    if (mult.length) {
                      currentLength += animatorProps.t.v * mult[0];
                    } else {
                      currentLength += animatorProps.t.v * mult;
                    }
                  } else if (mult.length) {
                    xPos += animatorProps.t.v * mult[0];
                  } else {
                    xPos += animatorProps.t.v * mult;
                  }
                }
              }
            }
            if (documentData.strokeWidthAnim) {
              sw = documentData.sw || 0;
            }
            if (documentData.strokeColorAnim) {
              if (documentData.sc) {
                sc = [documentData.sc[0], documentData.sc[1], documentData.sc[2]];
              } else {
                sc = [0, 0, 0];
              }
            }
            if (documentData.fillColorAnim && documentData.fc) {
              fc = [documentData.fc[0], documentData.fc[1], documentData.fc[2]];
            }
            for (j = 0; j < jLen; j += 1) {
              animatorProps = animators[j].a;
              if (animatorProps.a.propType) {
                animatorSelector = animators[j].s;
                mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);
                if (mult.length) {
                  matrixHelper.translate(-animatorProps.a.v[0] * mult[0], -animatorProps.a.v[1] * mult[1], animatorProps.a.v[2] * mult[2]);
                } else {
                  matrixHelper.translate(-animatorProps.a.v[0] * mult, -animatorProps.a.v[1] * mult, animatorProps.a.v[2] * mult);
                }
              }
            }
            for (j = 0; j < jLen; j += 1) {
              animatorProps = animators[j].a;
              if (animatorProps.s.propType) {
                animatorSelector = animators[j].s;
                mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);
                if (mult.length) {
                  matrixHelper.scale(1 + (animatorProps.s.v[0] - 1) * mult[0], 1 + (animatorProps.s.v[1] - 1) * mult[1], 1);
                } else {
                  matrixHelper.scale(1 + (animatorProps.s.v[0] - 1) * mult, 1 + (animatorProps.s.v[1] - 1) * mult, 1);
                }
              }
            }
            for (j = 0; j < jLen; j += 1) {
              animatorProps = animators[j].a;
              animatorSelector = animators[j].s;
              mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);
              if (animatorProps.sk.propType) {
                if (mult.length) {
                  matrixHelper.skewFromAxis(-animatorProps.sk.v * mult[0], animatorProps.sa.v * mult[1]);
                } else {
                  matrixHelper.skewFromAxis(-animatorProps.sk.v * mult, animatorProps.sa.v * mult);
                }
              }
              if (animatorProps.r.propType) {
                if (mult.length) {
                  matrixHelper.rotateZ(-animatorProps.r.v * mult[2]);
                } else {
                  matrixHelper.rotateZ(-animatorProps.r.v * mult);
                }
              }
              if (animatorProps.ry.propType) {
                if (mult.length) {
                  matrixHelper.rotateY(animatorProps.ry.v * mult[1]);
                } else {
                  matrixHelper.rotateY(animatorProps.ry.v * mult);
                }
              }
              if (animatorProps.rx.propType) {
                if (mult.length) {
                  matrixHelper.rotateX(animatorProps.rx.v * mult[0]);
                } else {
                  matrixHelper.rotateX(animatorProps.rx.v * mult);
                }
              }
              if (animatorProps.o.propType) {
                if (mult.length) {
                  elemOpacity += (animatorProps.o.v * mult[0] - elemOpacity) * mult[0];
                } else {
                  elemOpacity += (animatorProps.o.v * mult - elemOpacity) * mult;
                }
              }
              if (documentData.strokeWidthAnim && animatorProps.sw.propType) {
                if (mult.length) {
                  sw += animatorProps.sw.v * mult[0];
                } else {
                  sw += animatorProps.sw.v * mult;
                }
              }
              if (documentData.strokeColorAnim && animatorProps.sc.propType) {
                for (k = 0; k < 3; k += 1) {
                  if (mult.length) {
                    sc[k] += (animatorProps.sc.v[k] - sc[k]) * mult[0];
                  } else {
                    sc[k] += (animatorProps.sc.v[k] - sc[k]) * mult;
                  }
                }
              }
              if (documentData.fillColorAnim && documentData.fc) {
                if (animatorProps.fc.propType) {
                  for (k = 0; k < 3; k += 1) {
                    if (mult.length) {
                      fc[k] += (animatorProps.fc.v[k] - fc[k]) * mult[0];
                    } else {
                      fc[k] += (animatorProps.fc.v[k] - fc[k]) * mult;
                    }
                  }
                }
                if (animatorProps.fh.propType) {
                  if (mult.length) {
                    fc = addHueToRGB(fc, animatorProps.fh.v * mult[0]);
                  } else {
                    fc = addHueToRGB(fc, animatorProps.fh.v * mult);
                  }
                }
                if (animatorProps.fs.propType) {
                  if (mult.length) {
                    fc = addSaturationToRGB(fc, animatorProps.fs.v * mult[0]);
                  } else {
                    fc = addSaturationToRGB(fc, animatorProps.fs.v * mult);
                  }
                }
                if (animatorProps.fb.propType) {
                  if (mult.length) {
                    fc = addBrightnessToRGB(fc, animatorProps.fb.v * mult[0]);
                  } else {
                    fc = addBrightnessToRGB(fc, animatorProps.fb.v * mult);
                  }
                }
              }
            }
            for (j = 0; j < jLen; j += 1) {
              animatorProps = animators[j].a;
              if (animatorProps.p.propType) {
                animatorSelector = animators[j].s;
                mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);
                if (this._hasMaskedPath) {
                  if (mult.length) {
                    matrixHelper.translate(0, animatorProps.p.v[1] * mult[0], -animatorProps.p.v[2] * mult[1]);
                  } else {
                    matrixHelper.translate(0, animatorProps.p.v[1] * mult, -animatorProps.p.v[2] * mult);
                  }
                } else if (mult.length) {
                  matrixHelper.translate(animatorProps.p.v[0] * mult[0], animatorProps.p.v[1] * mult[1], -animatorProps.p.v[2] * mult[2]);
                } else {
                  matrixHelper.translate(animatorProps.p.v[0] * mult, animatorProps.p.v[1] * mult, -animatorProps.p.v[2] * mult);
                }
              }
            }
            if (documentData.strokeWidthAnim) {
              letterSw = sw < 0 ? 0 : sw;
            }
            if (documentData.strokeColorAnim) {
              letterSc = "rgb(" + Math.round(sc[0] * 255) + "," + Math.round(sc[1] * 255) + "," + Math.round(sc[2] * 255) + ")";
            }
            if (documentData.fillColorAnim && documentData.fc) {
              letterFc = "rgb(" + Math.round(fc[0] * 255) + "," + Math.round(fc[1] * 255) + "," + Math.round(fc[2] * 255) + ")";
            }
            if (this._hasMaskedPath) {
              matrixHelper.translate(0, -documentData.ls);
              matrixHelper.translate(0, alignment[1] * yOff * 0.01 + yPos, 0);
              if (this._pathData.p.v) {
                tanAngle = (currentPoint.point[1] - prevPoint.point[1]) / (currentPoint.point[0] - prevPoint.point[0]);
                var rot = Math.atan(tanAngle) * 180 / Math.PI;
                if (currentPoint.point[0] < prevPoint.point[0]) {
                  rot += 180;
                }
                matrixHelper.rotate(-rot * Math.PI / 180);
              }
              matrixHelper.translate(xPathPos, yPathPos, 0);
              currentLength -= alignment[0] * letters[i].an * 5e-3;
              if (letters[i + 1] && ind !== letters[i + 1].ind) {
                currentLength += letters[i].an / 2;
                currentLength += documentData.tr * 1e-3 * documentData.finalSize;
              }
            } else {
              matrixHelper.translate(xPos, yPos, 0);
              if (documentData.ps) {
                matrixHelper.translate(documentData.ps[0], documentData.ps[1] + documentData.ascent, 0);
              }
              switch (documentData.j) {
                case 1:
                  matrixHelper.translate(letters[i].animatorJustifyOffset + documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[letters[i].line]), 0, 0);
                  break;
                case 2:
                  matrixHelper.translate(letters[i].animatorJustifyOffset + documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[letters[i].line]) / 2, 0, 0);
                  break;
                default:
                  break;
              }
              matrixHelper.translate(0, -documentData.ls);
              matrixHelper.translate(offf, 0, 0);
              matrixHelper.translate(alignment[0] * letters[i].an * 5e-3, alignment[1] * yOff * 0.01, 0);
              xPos += letters[i].l + documentData.tr * 1e-3 * documentData.finalSize;
            }
            if (renderType === "html") {
              letterM = matrixHelper.toCSS();
            } else if (renderType === "svg") {
              letterM = matrixHelper.to2dCSS();
            } else {
              letterP = [matrixHelper.props[0], matrixHelper.props[1], matrixHelper.props[2], matrixHelper.props[3], matrixHelper.props[4], matrixHelper.props[5], matrixHelper.props[6], matrixHelper.props[7], matrixHelper.props[8], matrixHelper.props[9], matrixHelper.props[10], matrixHelper.props[11], matrixHelper.props[12], matrixHelper.props[13], matrixHelper.props[14], matrixHelper.props[15]];
            }
            letterO = elemOpacity;
          }
          if (renderedLettersCount <= i) {
            letterValue = new LetterProps(letterO, letterSw, letterSc, letterFc, letterM, letterP);
            this.renderedLetters.push(letterValue);
            renderedLettersCount += 1;
            this.lettersChangedFlag = true;
          } else {
            letterValue = this.renderedLetters[i];
            this.lettersChangedFlag = letterValue.update(letterO, letterSw, letterSc, letterFc, letterM, letterP) || this.lettersChangedFlag;
          }
        }
      };
      TextAnimatorProperty.prototype.getValue = function() {
        if (this._elem.globalData.frameId === this._frameId) {
          return;
        }
        this._frameId = this._elem.globalData.frameId;
        this.iterateDynamicProperties();
      };
      TextAnimatorProperty.prototype.mHelper = new Matrix();
      TextAnimatorProperty.prototype.defaultPropsArray = [];
      extendPrototype([DynamicPropertyContainer], TextAnimatorProperty);
      function ITextElement() {
      }
      ITextElement.prototype.initElement = function(data2, globalData2, comp2) {
        this.lettersChangedFlag = true;
        this.initFrame();
        this.initBaseData(data2, globalData2, comp2);
        this.textProperty = new TextProperty(this, data2.t, this.dynamicProperties);
        this.textAnimator = new TextAnimatorProperty(data2.t, this.renderType, this);
        this.initTransform(data2, globalData2, comp2);
        this.initHierarchy();
        this.initRenderable();
        this.initRendererElement();
        this.createContainerElements();
        this.createRenderableComponents();
        this.createContent();
        this.hide();
        this.textAnimator.searchProperties(this.dynamicProperties);
      };
      ITextElement.prototype.prepareFrame = function(num) {
        this._mdf = false;
        this.prepareRenderableFrame(num);
        this.prepareProperties(num, this.isInRange);
      };
      ITextElement.prototype.createPathShape = function(matrixHelper, shapes) {
        var j;
        var jLen = shapes.length;
        var pathNodes;
        var shapeStr = "";
        for (j = 0; j < jLen; j += 1) {
          if (shapes[j].ty === "sh") {
            pathNodes = shapes[j].ks.k;
            shapeStr += buildShapeString(pathNodes, pathNodes.i.length, true, matrixHelper);
          }
        }
        return shapeStr;
      };
      ITextElement.prototype.updateDocumentData = function(newData, index2) {
        this.textProperty.updateDocumentData(newData, index2);
      };
      ITextElement.prototype.canResizeFont = function(_canResize) {
        this.textProperty.canResizeFont(_canResize);
      };
      ITextElement.prototype.setMinimumFontSize = function(_fontSize) {
        this.textProperty.setMinimumFontSize(_fontSize);
      };
      ITextElement.prototype.applyTextPropertiesToMatrix = function(documentData, matrixHelper, lineNumber, xPos, yPos) {
        if (documentData.ps) {
          matrixHelper.translate(documentData.ps[0], documentData.ps[1] + documentData.ascent, 0);
        }
        matrixHelper.translate(0, -documentData.ls, 0);
        switch (documentData.j) {
          case 1:
            matrixHelper.translate(documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[lineNumber]), 0, 0);
            break;
          case 2:
            matrixHelper.translate(documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[lineNumber]) / 2, 0, 0);
            break;
          default:
            break;
        }
        matrixHelper.translate(xPos, yPos, 0);
      };
      ITextElement.prototype.buildColor = function(colorData) {
        return "rgb(" + Math.round(colorData[0] * 255) + "," + Math.round(colorData[1] * 255) + "," + Math.round(colorData[2] * 255) + ")";
      };
      ITextElement.prototype.emptyProp = new LetterProps();
      ITextElement.prototype.destroy = function() {
      };
      ITextElement.prototype.validateText = function() {
        if (this.textProperty._mdf || this.textProperty._isFirstFrame) {
          this.buildNewText();
          this.textProperty._isFirstFrame = false;
          this.textProperty._mdf = false;
        }
      };
      var emptyShapeData = {
        shapes: []
      };
      function SVGTextLottieElement(data2, globalData2, comp2) {
        this.textSpans = [];
        this.renderType = "svg";
        this.initElement(data2, globalData2, comp2);
      }
      extendPrototype([BaseElement, TransformElement, SVGBaseElement, HierarchyElement, FrameElement, RenderableDOMElement, ITextElement], SVGTextLottieElement);
      SVGTextLottieElement.prototype.createContent = function() {
        if (this.data.singleShape && !this.globalData.fontManager.chars) {
          this.textContainer = createNS("text");
        }
      };
      SVGTextLottieElement.prototype.buildTextContents = function(textArray) {
        var i = 0;
        var len = textArray.length;
        var textContents = [];
        var currentTextContent = "";
        while (i < len) {
          if (textArray[i] === String.fromCharCode(13) || textArray[i] === String.fromCharCode(3)) {
            textContents.push(currentTextContent);
            currentTextContent = "";
          } else {
            currentTextContent += textArray[i];
          }
          i += 1;
        }
        textContents.push(currentTextContent);
        return textContents;
      };
      SVGTextLottieElement.prototype.buildShapeData = function(data2, scale3) {
        if (data2.shapes && data2.shapes.length) {
          var shape = data2.shapes[0];
          if (shape.it) {
            var shapeItem = shape.it[shape.it.length - 1];
            if (shapeItem.s) {
              shapeItem.s.k[0] = scale3;
              shapeItem.s.k[1] = scale3;
            }
          }
        }
        return data2;
      };
      SVGTextLottieElement.prototype.buildNewText = function() {
        this.addDynamicProperty(this);
        var i;
        var len;
        var documentData = this.textProperty.currentData;
        this.renderedLetters = createSizedArray(documentData ? documentData.l.length : 0);
        if (documentData.fc) {
          this.layerElement.setAttribute("fill", this.buildColor(documentData.fc));
        } else {
          this.layerElement.setAttribute("fill", "rgba(0,0,0,0)");
        }
        if (documentData.sc) {
          this.layerElement.setAttribute("stroke", this.buildColor(documentData.sc));
          this.layerElement.setAttribute("stroke-width", documentData.sw);
        }
        this.layerElement.setAttribute("font-size", documentData.finalSize);
        var fontData = this.globalData.fontManager.getFontByName(documentData.f);
        if (fontData.fClass) {
          this.layerElement.setAttribute("class", fontData.fClass);
        } else {
          this.layerElement.setAttribute("font-family", fontData.fFamily);
          var fWeight = documentData.fWeight;
          var fStyle = documentData.fStyle;
          this.layerElement.setAttribute("font-style", fStyle);
          this.layerElement.setAttribute("font-weight", fWeight);
        }
        this.layerElement.setAttribute("aria-label", documentData.t);
        var letters = documentData.l || [];
        var usesGlyphs = !!this.globalData.fontManager.chars;
        len = letters.length;
        var tSpan;
        var matrixHelper = this.mHelper;
        var shapeStr = "";
        var singleShape = this.data.singleShape;
        var xPos = 0;
        var yPos = 0;
        var firstLine = true;
        var trackingOffset = documentData.tr * 1e-3 * documentData.finalSize;
        if (singleShape && !usesGlyphs && !documentData.sz) {
          var tElement = this.textContainer;
          var justify = "start";
          switch (documentData.j) {
            case 1:
              justify = "end";
              break;
            case 2:
              justify = "middle";
              break;
            default:
              justify = "start";
              break;
          }
          tElement.setAttribute("text-anchor", justify);
          tElement.setAttribute("letter-spacing", trackingOffset);
          var textContent = this.buildTextContents(documentData.finalText);
          len = textContent.length;
          yPos = documentData.ps ? documentData.ps[1] + documentData.ascent : 0;
          for (i = 0; i < len; i += 1) {
            tSpan = this.textSpans[i].span || createNS("tspan");
            tSpan.textContent = textContent[i];
            tSpan.setAttribute("x", 0);
            tSpan.setAttribute("y", yPos);
            tSpan.style.display = "inherit";
            tElement.appendChild(tSpan);
            if (!this.textSpans[i]) {
              this.textSpans[i] = {
                span: null,
                glyph: null
              };
            }
            this.textSpans[i].span = tSpan;
            yPos += documentData.finalLineHeight;
          }
          this.layerElement.appendChild(tElement);
        } else {
          var cachedSpansLength = this.textSpans.length;
          var charData;
          for (i = 0; i < len; i += 1) {
            if (!this.textSpans[i]) {
              this.textSpans[i] = {
                span: null,
                childSpan: null,
                glyph: null
              };
            }
            if (!usesGlyphs || !singleShape || i === 0) {
              tSpan = cachedSpansLength > i ? this.textSpans[i].span : createNS(usesGlyphs ? "g" : "text");
              if (cachedSpansLength <= i) {
                tSpan.setAttribute("stroke-linecap", "butt");
                tSpan.setAttribute("stroke-linejoin", "round");
                tSpan.setAttribute("stroke-miterlimit", "4");
                this.textSpans[i].span = tSpan;
                if (usesGlyphs) {
                  var childSpan = createNS("g");
                  tSpan.appendChild(childSpan);
                  this.textSpans[i].childSpan = childSpan;
                }
                this.textSpans[i].span = tSpan;
                this.layerElement.appendChild(tSpan);
              }
              tSpan.style.display = "inherit";
            }
            matrixHelper.reset();
            if (singleShape) {
              if (letters[i].n) {
                xPos = -trackingOffset;
                yPos += documentData.yOffset;
                yPos += firstLine ? 1 : 0;
                firstLine = false;
              }
              this.applyTextPropertiesToMatrix(documentData, matrixHelper, letters[i].line, xPos, yPos);
              xPos += letters[i].l || 0;
              xPos += trackingOffset;
            }
            if (usesGlyphs) {
              charData = this.globalData.fontManager.getCharData(documentData.finalText[i], fontData.fStyle, this.globalData.fontManager.getFontByName(documentData.f).fFamily);
              var glyphElement;
              if (charData.t === 1) {
                glyphElement = new SVGCompElement(charData.data, this.globalData, this);
              } else {
                var data2 = emptyShapeData;
                if (charData.data && charData.data.shapes) {
                  data2 = this.buildShapeData(charData.data, documentData.finalSize);
                }
                glyphElement = new SVGShapeElement(data2, this.globalData, this);
              }
              if (this.textSpans[i].glyph) {
                var glyph = this.textSpans[i].glyph;
                this.textSpans[i].childSpan.removeChild(glyph.layerElement);
                glyph.destroy();
              }
              this.textSpans[i].glyph = glyphElement;
              glyphElement._debug = true;
              glyphElement.prepareFrame(0);
              glyphElement.renderFrame();
              this.textSpans[i].childSpan.appendChild(glyphElement.layerElement);
              if (charData.t === 1) {
                this.textSpans[i].childSpan.setAttribute("transform", "scale(" + documentData.finalSize / 100 + "," + documentData.finalSize / 100 + ")");
              }
            } else {
              if (singleShape) {
                tSpan.setAttribute("transform", "translate(" + matrixHelper.props[12] + "," + matrixHelper.props[13] + ")");
              }
              tSpan.textContent = letters[i].val;
              tSpan.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve");
            }
          }
          if (singleShape && tSpan) {
            tSpan.setAttribute("d", shapeStr);
          }
        }
        while (i < this.textSpans.length) {
          this.textSpans[i].span.style.display = "none";
          i += 1;
        }
        this._sizeChanged = true;
      };
      SVGTextLottieElement.prototype.sourceRectAtTime = function() {
        this.prepareFrame(this.comp.renderedFrame - this.data.st);
        this.renderInnerContent();
        if (this._sizeChanged) {
          this._sizeChanged = false;
          var textBox = this.layerElement.getBBox();
          this.bbox = {
            top: textBox.y,
            left: textBox.x,
            width: textBox.width,
            height: textBox.height
          };
        }
        return this.bbox;
      };
      SVGTextLottieElement.prototype.getValue = function() {
        var i;
        var len = this.textSpans.length;
        var glyphElement;
        this.renderedFrame = this.comp.renderedFrame;
        for (i = 0; i < len; i += 1) {
          glyphElement = this.textSpans[i].glyph;
          if (glyphElement) {
            glyphElement.prepareFrame(this.comp.renderedFrame - this.data.st);
            if (glyphElement._mdf) {
              this._mdf = true;
            }
          }
        }
      };
      SVGTextLottieElement.prototype.renderInnerContent = function() {
        this.validateText();
        if (!this.data.singleShape || this._mdf) {
          this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag);
          if (this.lettersChangedFlag || this.textAnimator.lettersChangedFlag) {
            this._sizeChanged = true;
            var i;
            var len;
            var renderedLetters = this.textAnimator.renderedLetters;
            var letters = this.textProperty.currentData.l;
            len = letters.length;
            var renderedLetter;
            var textSpan;
            var glyphElement;
            for (i = 0; i < len; i += 1) {
              if (!letters[i].n) {
                renderedLetter = renderedLetters[i];
                textSpan = this.textSpans[i].span;
                glyphElement = this.textSpans[i].glyph;
                if (glyphElement) {
                  glyphElement.renderFrame();
                }
                if (renderedLetter._mdf.m) {
                  textSpan.setAttribute("transform", renderedLetter.m);
                }
                if (renderedLetter._mdf.o) {
                  textSpan.setAttribute("opacity", renderedLetter.o);
                }
                if (renderedLetter._mdf.sw) {
                  textSpan.setAttribute("stroke-width", renderedLetter.sw);
                }
                if (renderedLetter._mdf.sc) {
                  textSpan.setAttribute("stroke", renderedLetter.sc);
                }
                if (renderedLetter._mdf.fc) {
                  textSpan.setAttribute("fill", renderedLetter.fc);
                }
              }
            }
          }
        }
      };
      function ISolidElement(data2, globalData2, comp2) {
        this.initElement(data2, globalData2, comp2);
      }
      extendPrototype([IImageElement], ISolidElement);
      ISolidElement.prototype.createContent = function() {
        var rect = createNS("rect");
        rect.setAttribute("width", this.data.sw);
        rect.setAttribute("height", this.data.sh);
        rect.setAttribute("fill", this.data.sc);
        this.layerElement.appendChild(rect);
      };
      function NullElement(data2, globalData2, comp2) {
        this.initFrame();
        this.initBaseData(data2, globalData2, comp2);
        this.initFrame();
        this.initTransform(data2, globalData2, comp2);
        this.initHierarchy();
      }
      NullElement.prototype.prepareFrame = function(num) {
        this.prepareProperties(num, true);
      };
      NullElement.prototype.renderFrame = function() {
      };
      NullElement.prototype.getBaseElement = function() {
        return null;
      };
      NullElement.prototype.destroy = function() {
      };
      NullElement.prototype.sourceRectAtTime = function() {
      };
      NullElement.prototype.hide = function() {
      };
      extendPrototype([BaseElement, TransformElement, HierarchyElement, FrameElement], NullElement);
      function SVGRendererBase() {
      }
      extendPrototype([BaseRenderer], SVGRendererBase);
      SVGRendererBase.prototype.createNull = function(data2) {
        return new NullElement(data2, this.globalData, this);
      };
      SVGRendererBase.prototype.createShape = function(data2) {
        return new SVGShapeElement(data2, this.globalData, this);
      };
      SVGRendererBase.prototype.createText = function(data2) {
        return new SVGTextLottieElement(data2, this.globalData, this);
      };
      SVGRendererBase.prototype.createImage = function(data2) {
        return new IImageElement(data2, this.globalData, this);
      };
      SVGRendererBase.prototype.createSolid = function(data2) {
        return new ISolidElement(data2, this.globalData, this);
      };
      SVGRendererBase.prototype.configAnimation = function(animData) {
        this.svgElement.setAttribute("xmlns", "http://www.w3.org/2000/svg");
        this.svgElement.setAttribute("xmlns:xlink", "http://www.w3.org/1999/xlink");
        if (this.renderConfig.viewBoxSize) {
          this.svgElement.setAttribute("viewBox", this.renderConfig.viewBoxSize);
        } else {
          this.svgElement.setAttribute("viewBox", "0 0 " + animData.w + " " + animData.h);
        }
        if (!this.renderConfig.viewBoxOnly) {
          this.svgElement.setAttribute("width", animData.w);
          this.svgElement.setAttribute("height", animData.h);
          this.svgElement.style.width = "100%";
          this.svgElement.style.height = "100%";
          this.svgElement.style.transform = "translate3d(0,0,0)";
          this.svgElement.style.contentVisibility = this.renderConfig.contentVisibility;
        }
        if (this.renderConfig.width) {
          this.svgElement.setAttribute("width", this.renderConfig.width);
        }
        if (this.renderConfig.height) {
          this.svgElement.setAttribute("height", this.renderConfig.height);
        }
        if (this.renderConfig.className) {
          this.svgElement.setAttribute("class", this.renderConfig.className);
        }
        if (this.renderConfig.id) {
          this.svgElement.setAttribute("id", this.renderConfig.id);
        }
        if (this.renderConfig.focusable !== void 0) {
          this.svgElement.setAttribute("focusable", this.renderConfig.focusable);
        }
        this.svgElement.setAttribute("preserveAspectRatio", this.renderConfig.preserveAspectRatio);
        this.animationItem.wrapper.appendChild(this.svgElement);
        var defs = this.globalData.defs;
        this.setupGlobalData(animData, defs);
        this.globalData.progressiveLoad = this.renderConfig.progressiveLoad;
        this.data = animData;
        var maskElement = createNS("clipPath");
        var rect = createNS("rect");
        rect.setAttribute("width", animData.w);
        rect.setAttribute("height", animData.h);
        rect.setAttribute("x", 0);
        rect.setAttribute("y", 0);
        var maskId = createElementID();
        maskElement.setAttribute("id", maskId);
        maskElement.appendChild(rect);
        this.layerElement.setAttribute("clip-path", "url(" + getLocationHref() + "#" + maskId + ")");
        defs.appendChild(maskElement);
        this.layers = animData.layers;
        this.elements = createSizedArray(animData.layers.length);
      };
      SVGRendererBase.prototype.destroy = function() {
        if (this.animationItem.wrapper) {
          this.animationItem.wrapper.innerText = "";
        }
        this.layerElement = null;
        this.globalData.defs = null;
        var i;
        var len = this.layers ? this.layers.length : 0;
        for (i = 0; i < len; i += 1) {
          if (this.elements[i] && this.elements[i].destroy) {
            this.elements[i].destroy();
          }
        }
        this.elements.length = 0;
        this.destroyed = true;
        this.animationItem = null;
      };
      SVGRendererBase.prototype.updateContainerSize = function() {
      };
      SVGRendererBase.prototype.findIndexByInd = function(ind) {
        var i = 0;
        var len = this.layers.length;
        for (i = 0; i < len; i += 1) {
          if (this.layers[i].ind === ind) {
            return i;
          }
        }
        return -1;
      };
      SVGRendererBase.prototype.buildItem = function(pos) {
        var elements = this.elements;
        if (elements[pos] || this.layers[pos].ty === 99) {
          return;
        }
        elements[pos] = true;
        var element = this.createItem(this.layers[pos]);
        elements[pos] = element;
        if (getExpressionsPlugin()) {
          if (this.layers[pos].ty === 0) {
            this.globalData.projectInterface.registerComposition(element);
          }
          element.initExpressions();
        }
        this.appendElementInPos(element, pos);
        if (this.layers[pos].tt) {
          var elementIndex = "tp" in this.layers[pos] ? this.findIndexByInd(this.layers[pos].tp) : pos - 1;
          if (elementIndex === -1) {
            return;
          }
          if (!this.elements[elementIndex] || this.elements[elementIndex] === true) {
            this.buildItem(elementIndex);
            this.addPendingElement(element);
          } else {
            var matteElement = elements[elementIndex];
            var matteMask = matteElement.getMatte(this.layers[pos].tt);
            element.setMatte(matteMask);
          }
        }
      };
      SVGRendererBase.prototype.checkPendingElements = function() {
        while (this.pendingElements.length) {
          var element = this.pendingElements.pop();
          element.checkParenting();
          if (element.data.tt) {
            var i = 0;
            var len = this.elements.length;
            while (i < len) {
              if (this.elements[i] === element) {
                var elementIndex = "tp" in element.data ? this.findIndexByInd(element.data.tp) : i - 1;
                var matteElement = this.elements[elementIndex];
                var matteMask = matteElement.getMatte(this.layers[i].tt);
                element.setMatte(matteMask);
                break;
              }
              i += 1;
            }
          }
        }
      };
      SVGRendererBase.prototype.renderFrame = function(num) {
        if (this.renderedFrame === num || this.destroyed) {
          return;
        }
        if (num === null) {
          num = this.renderedFrame;
        } else {
          this.renderedFrame = num;
        }
        this.globalData.frameNum = num;
        this.globalData.frameId += 1;
        this.globalData.projectInterface.currentFrame = num;
        this.globalData._mdf = false;
        var i;
        var len = this.layers.length;
        if (!this.completeLayers) {
          this.checkLayers(num);
        }
        for (i = len - 1; i >= 0; i -= 1) {
          if (this.completeLayers || this.elements[i]) {
            this.elements[i].prepareFrame(num - this.layers[i].st);
          }
        }
        if (this.globalData._mdf) {
          for (i = 0; i < len; i += 1) {
            if (this.completeLayers || this.elements[i]) {
              this.elements[i].renderFrame();
            }
          }
        }
      };
      SVGRendererBase.prototype.appendElementInPos = function(element, pos) {
        var newElement = element.getBaseElement();
        if (!newElement) {
          return;
        }
        var i = 0;
        var nextElement;
        while (i < pos) {
          if (this.elements[i] && this.elements[i] !== true && this.elements[i].getBaseElement()) {
            nextElement = this.elements[i].getBaseElement();
          }
          i += 1;
        }
        if (nextElement) {
          this.layerElement.insertBefore(newElement, nextElement);
        } else {
          this.layerElement.appendChild(newElement);
        }
      };
      SVGRendererBase.prototype.hide = function() {
        this.layerElement.style.display = "none";
      };
      SVGRendererBase.prototype.show = function() {
        this.layerElement.style.display = "block";
      };
      function ICompElement() {
      }
      extendPrototype([BaseElement, TransformElement, HierarchyElement, FrameElement, RenderableDOMElement], ICompElement);
      ICompElement.prototype.initElement = function(data2, globalData2, comp2) {
        this.initFrame();
        this.initBaseData(data2, globalData2, comp2);
        this.initTransform(data2, globalData2, comp2);
        this.initRenderable();
        this.initHierarchy();
        this.initRendererElement();
        this.createContainerElements();
        this.createRenderableComponents();
        if (this.data.xt || !globalData2.progressiveLoad) {
          this.buildAllItems();
        }
        this.hide();
      };
      ICompElement.prototype.prepareFrame = function(num) {
        this._mdf = false;
        this.prepareRenderableFrame(num);
        this.prepareProperties(num, this.isInRange);
        if (!this.isInRange && !this.data.xt) {
          return;
        }
        if (!this.tm._placeholder) {
          var timeRemapped = this.tm.v;
          if (timeRemapped === this.data.op) {
            timeRemapped = this.data.op - 1;
          }
          this.renderedFrame = timeRemapped;
        } else {
          this.renderedFrame = num / this.data.sr;
        }
        var i;
        var len = this.elements.length;
        if (!this.completeLayers) {
          this.checkLayers(this.renderedFrame);
        }
        for (i = len - 1; i >= 0; i -= 1) {
          if (this.completeLayers || this.elements[i]) {
            this.elements[i].prepareFrame(this.renderedFrame - this.layers[i].st);
            if (this.elements[i]._mdf) {
              this._mdf = true;
            }
          }
        }
      };
      ICompElement.prototype.renderInnerContent = function() {
        var i;
        var len = this.layers.length;
        for (i = 0; i < len; i += 1) {
          if (this.completeLayers || this.elements[i]) {
            this.elements[i].renderFrame();
          }
        }
      };
      ICompElement.prototype.setElements = function(elems) {
        this.elements = elems;
      };
      ICompElement.prototype.getElements = function() {
        return this.elements;
      };
      ICompElement.prototype.destroyElements = function() {
        var i;
        var len = this.layers.length;
        for (i = 0; i < len; i += 1) {
          if (this.elements[i]) {
            this.elements[i].destroy();
          }
        }
      };
      ICompElement.prototype.destroy = function() {
        this.destroyElements();
        this.destroyBaseElement();
      };
      function SVGCompElement(data2, globalData2, comp2) {
        this.layers = data2.layers;
        this.supports3d = true;
        this.completeLayers = false;
        this.pendingElements = [];
        this.elements = this.layers ? createSizedArray(this.layers.length) : [];
        this.initElement(data2, globalData2, comp2);
        this.tm = data2.tm ? PropertyFactory.getProp(this, data2.tm, 0, globalData2.frameRate, this) : {
          _placeholder: true
        };
      }
      extendPrototype([SVGRendererBase, ICompElement, SVGBaseElement], SVGCompElement);
      SVGCompElement.prototype.createComp = function(data2) {
        return new SVGCompElement(data2, this.globalData, this);
      };
      function SVGRenderer(animationItem, config) {
        this.animationItem = animationItem;
        this.layers = null;
        this.renderedFrame = -1;
        this.svgElement = createNS("svg");
        var ariaLabel = "";
        if (config && config.title) {
          var titleElement = createNS("title");
          var titleId = createElementID();
          titleElement.setAttribute("id", titleId);
          titleElement.textContent = config.title;
          this.svgElement.appendChild(titleElement);
          ariaLabel += titleId;
        }
        if (config && config.description) {
          var descElement = createNS("desc");
          var descId = createElementID();
          descElement.setAttribute("id", descId);
          descElement.textContent = config.description;
          this.svgElement.appendChild(descElement);
          ariaLabel += " " + descId;
        }
        if (ariaLabel) {
          this.svgElement.setAttribute("aria-labelledby", ariaLabel);
        }
        var defs = createNS("defs");
        this.svgElement.appendChild(defs);
        var maskElement = createNS("g");
        this.svgElement.appendChild(maskElement);
        this.layerElement = maskElement;
        this.renderConfig = {
          preserveAspectRatio: config && config.preserveAspectRatio || "xMidYMid meet",
          imagePreserveAspectRatio: config && config.imagePreserveAspectRatio || "xMidYMid slice",
          contentVisibility: config && config.contentVisibility || "visible",
          progressiveLoad: config && config.progressiveLoad || false,
          hideOnTransparent: !(config && config.hideOnTransparent === false),
          viewBoxOnly: config && config.viewBoxOnly || false,
          viewBoxSize: config && config.viewBoxSize || false,
          className: config && config.className || "",
          id: config && config.id || "",
          focusable: config && config.focusable,
          filterSize: {
            width: config && config.filterSize && config.filterSize.width || "100%",
            height: config && config.filterSize && config.filterSize.height || "100%",
            x: config && config.filterSize && config.filterSize.x || "0%",
            y: config && config.filterSize && config.filterSize.y || "0%"
          },
          width: config && config.width,
          height: config && config.height,
          runExpressions: !config || config.runExpressions === void 0 || config.runExpressions
        };
        this.globalData = {
          _mdf: false,
          frameNum: -1,
          defs,
          renderConfig: this.renderConfig
        };
        this.elements = [];
        this.pendingElements = [];
        this.destroyed = false;
        this.rendererType = "svg";
      }
      extendPrototype([SVGRendererBase], SVGRenderer);
      SVGRenderer.prototype.createComp = function(data2) {
        return new SVGCompElement(data2, this.globalData, this);
      };
      function ShapeTransformManager() {
        this.sequences = {};
        this.sequenceList = [];
        this.transform_key_count = 0;
      }
      ShapeTransformManager.prototype = {
        addTransformSequence: function addTransformSequence(transforms) {
          var i;
          var len = transforms.length;
          var key2 = "_";
          for (i = 0; i < len; i += 1) {
            key2 += transforms[i].transform.key + "_";
          }
          var sequence = this.sequences[key2];
          if (!sequence) {
            sequence = {
              transforms: [].concat(transforms),
              finalTransform: new Matrix(),
              _mdf: false
            };
            this.sequences[key2] = sequence;
            this.sequenceList.push(sequence);
          }
          return sequence;
        },
        processSequence: function processSequence(sequence, isFirstFrame) {
          var i = 0;
          var len = sequence.transforms.length;
          var _mdf = isFirstFrame;
          while (i < len && !isFirstFrame) {
            if (sequence.transforms[i].transform.mProps._mdf) {
              _mdf = true;
              break;
            }
            i += 1;
          }
          if (_mdf) {
            sequence.finalTransform.reset();
            for (i = len - 1; i >= 0; i -= 1) {
              sequence.finalTransform.multiply(sequence.transforms[i].transform.mProps.v);
            }
          }
          sequence._mdf = _mdf;
        },
        processSequences: function processSequences(isFirstFrame) {
          var i;
          var len = this.sequenceList.length;
          for (i = 0; i < len; i += 1) {
            this.processSequence(this.sequenceList[i], isFirstFrame);
          }
        },
        getNewKey: function getNewKey() {
          this.transform_key_count += 1;
          return "_" + this.transform_key_count;
        }
      };
      var lumaLoader = function lumaLoader2() {
        var id = "__lottie_element_luma_buffer";
        var lumaBuffer = null;
        var lumaBufferCtx = null;
        var svg = null;
        function createLumaSvgFilter() {
          var _svg = createNS("svg");
          var fil = createNS("filter");
          var matrix = createNS("feColorMatrix");
          fil.setAttribute("id", id);
          matrix.setAttribute("type", "matrix");
          matrix.setAttribute("color-interpolation-filters", "sRGB");
          matrix.setAttribute("values", "0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0");
          fil.appendChild(matrix);
          _svg.appendChild(fil);
          _svg.setAttribute("id", id + "_svg");
          if (featureSupport.svgLumaHidden) {
            _svg.style.display = "none";
          }
          return _svg;
        }
        function loadLuma() {
          if (!lumaBuffer) {
            svg = createLumaSvgFilter();
            document.body.appendChild(svg);
            lumaBuffer = createTag("canvas");
            lumaBufferCtx = lumaBuffer.getContext("2d");
            lumaBufferCtx.filter = "url(#" + id + ")";
            lumaBufferCtx.fillStyle = "rgba(0,0,0,0)";
            lumaBufferCtx.fillRect(0, 0, 1, 1);
          }
        }
        function getLuma(canvas) {
          if (!lumaBuffer) {
            loadLuma();
          }
          lumaBuffer.width = canvas.width;
          lumaBuffer.height = canvas.height;
          lumaBufferCtx.filter = "url(#" + id + ")";
          return lumaBuffer;
        }
        return {
          load: loadLuma,
          get: getLuma
        };
      };
      function createCanvas(width2, height2) {
        if (featureSupport.offscreenCanvas) {
          return new OffscreenCanvas(width2, height2);
        }
        var canvas = createTag("canvas");
        canvas.width = width2;
        canvas.height = height2;
        return canvas;
      }
      var assetLoader = function() {
        return {
          loadLumaCanvas: lumaLoader.load,
          getLumaCanvas: lumaLoader.get,
          createCanvas
        };
      }();
      var registeredEffects = {};
      function CVEffects(elem2) {
        var i;
        var len = elem2.data.ef ? elem2.data.ef.length : 0;
        this.filters = [];
        var filterManager;
        for (i = 0; i < len; i += 1) {
          filterManager = null;
          var type = elem2.data.ef[i].ty;
          if (registeredEffects[type]) {
            var Effect = registeredEffects[type].effect;
            filterManager = new Effect(elem2.effectsManager.effectElements[i], elem2);
          }
          if (filterManager) {
            this.filters.push(filterManager);
          }
        }
        if (this.filters.length) {
          elem2.addRenderableComponent(this);
        }
      }
      CVEffects.prototype.renderFrame = function(_isFirstFrame) {
        var i;
        var len = this.filters.length;
        for (i = 0; i < len; i += 1) {
          this.filters[i].renderFrame(_isFirstFrame);
        }
      };
      CVEffects.prototype.getEffects = function(type) {
        var i;
        var len = this.filters.length;
        var effects = [];
        for (i = 0; i < len; i += 1) {
          if (this.filters[i].type === type) {
            effects.push(this.filters[i]);
          }
        }
        return effects;
      };
      function registerEffect(id, effect2) {
        registeredEffects[id] = {
          effect: effect2
        };
      }
      function CVMaskElement(data2, element) {
        this.data = data2;
        this.element = element;
        this.masksProperties = this.data.masksProperties || [];
        this.viewData = createSizedArray(this.masksProperties.length);
        var i;
        var len = this.masksProperties.length;
        var hasMasks = false;
        for (i = 0; i < len; i += 1) {
          if (this.masksProperties[i].mode !== "n") {
            hasMasks = true;
          }
          this.viewData[i] = ShapePropertyFactory.getShapeProp(this.element, this.masksProperties[i], 3);
        }
        this.hasMasks = hasMasks;
        if (hasMasks) {
          this.element.addRenderableComponent(this);
        }
      }
      CVMaskElement.prototype.renderFrame = function() {
        if (!this.hasMasks) {
          return;
        }
        var transform2 = this.element.finalTransform.mat;
        var ctx = this.element.canvasContext;
        var i;
        var len = this.masksProperties.length;
        var pt;
        var pts;
        var data2;
        ctx.beginPath();
        for (i = 0; i < len; i += 1) {
          if (this.masksProperties[i].mode !== "n") {
            if (this.masksProperties[i].inv) {
              ctx.moveTo(0, 0);
              ctx.lineTo(this.element.globalData.compSize.w, 0);
              ctx.lineTo(this.element.globalData.compSize.w, this.element.globalData.compSize.h);
              ctx.lineTo(0, this.element.globalData.compSize.h);
              ctx.lineTo(0, 0);
            }
            data2 = this.viewData[i].v;
            pt = transform2.applyToPointArray(data2.v[0][0], data2.v[0][1], 0);
            ctx.moveTo(pt[0], pt[1]);
            var j;
            var jLen = data2._length;
            for (j = 1; j < jLen; j += 1) {
              pts = transform2.applyToTriplePoints(data2.o[j - 1], data2.i[j], data2.v[j]);
              ctx.bezierCurveTo(pts[0], pts[1], pts[2], pts[3], pts[4], pts[5]);
            }
            pts = transform2.applyToTriplePoints(data2.o[j - 1], data2.i[0], data2.v[0]);
            ctx.bezierCurveTo(pts[0], pts[1], pts[2], pts[3], pts[4], pts[5]);
          }
        }
        this.element.globalData.renderer.save(true);
        ctx.clip();
      };
      CVMaskElement.prototype.getMaskProperty = MaskElement.prototype.getMaskProperty;
      CVMaskElement.prototype.destroy = function() {
        this.element = null;
      };
      function CVBaseElement() {
      }
      var operationsMap = {
        1: "source-in",
        2: "source-out",
        3: "source-in",
        4: "source-out"
      };
      CVBaseElement.prototype = {
        createElements: function createElements() {
        },
        initRendererElement: function initRendererElement() {
        },
        createContainerElements: function createContainerElements() {
          if (this.data.tt >= 1) {
            this.buffers = [];
            var canvasContext = this.globalData.canvasContext;
            var bufferCanvas = assetLoader.createCanvas(canvasContext.canvas.width, canvasContext.canvas.height);
            this.buffers.push(bufferCanvas);
            var bufferCanvas2 = assetLoader.createCanvas(canvasContext.canvas.width, canvasContext.canvas.height);
            this.buffers.push(bufferCanvas2);
            if (this.data.tt >= 3 && !document._isProxy) {
              assetLoader.loadLumaCanvas();
            }
          }
          this.canvasContext = this.globalData.canvasContext;
          this.transformCanvas = this.globalData.transformCanvas;
          this.renderableEffectsManager = new CVEffects(this);
          this.searchEffectTransforms();
        },
        createContent: function createContent() {
        },
        setBlendMode: function setBlendMode() {
          var globalData2 = this.globalData;
          if (globalData2.blendMode !== this.data.bm) {
            globalData2.blendMode = this.data.bm;
            var blendModeValue = getBlendMode(this.data.bm);
            globalData2.canvasContext.globalCompositeOperation = blendModeValue;
          }
        },
        createRenderableComponents: function createRenderableComponents() {
          this.maskManager = new CVMaskElement(this.data, this);
          this.transformEffects = this.renderableEffectsManager.getEffects(effectTypes.TRANSFORM_EFFECT);
        },
        hideElement: function hideElement() {
          if (!this.hidden && (!this.isInRange || this.isTransparent)) {
            this.hidden = true;
          }
        },
        showElement: function showElement() {
          if (this.isInRange && !this.isTransparent) {
            this.hidden = false;
            this._isFirstFrame = true;
            this.maskManager._isFirstFrame = true;
          }
        },
        clearCanvas: function clearCanvas(canvasContext) {
          canvasContext.clearRect(this.transformCanvas.tx, this.transformCanvas.ty, this.transformCanvas.w * this.transformCanvas.sx, this.transformCanvas.h * this.transformCanvas.sy);
        },
        prepareLayer: function prepareLayer() {
          if (this.data.tt >= 1) {
            var buffer = this.buffers[0];
            var bufferCtx = buffer.getContext("2d");
            this.clearCanvas(bufferCtx);
            bufferCtx.drawImage(this.canvasContext.canvas, 0, 0);
            this.currentTransform = this.canvasContext.getTransform();
            this.canvasContext.setTransform(1, 0, 0, 1, 0, 0);
            this.clearCanvas(this.canvasContext);
            this.canvasContext.setTransform(this.currentTransform);
          }
        },
        exitLayer: function exitLayer() {
          if (this.data.tt >= 1) {
            var buffer = this.buffers[1];
            var bufferCtx = buffer.getContext("2d");
            this.clearCanvas(bufferCtx);
            bufferCtx.drawImage(this.canvasContext.canvas, 0, 0);
            this.canvasContext.setTransform(1, 0, 0, 1, 0, 0);
            this.clearCanvas(this.canvasContext);
            this.canvasContext.setTransform(this.currentTransform);
            var mask2 = this.comp.getElementById("tp" in this.data ? this.data.tp : this.data.ind - 1);
            mask2.renderFrame(true);
            this.canvasContext.setTransform(1, 0, 0, 1, 0, 0);
            if (this.data.tt >= 3 && !document._isProxy) {
              var lumaBuffer = assetLoader.getLumaCanvas(this.canvasContext.canvas);
              var lumaBufferCtx = lumaBuffer.getContext("2d");
              lumaBufferCtx.drawImage(this.canvasContext.canvas, 0, 0);
              this.clearCanvas(this.canvasContext);
              this.canvasContext.drawImage(lumaBuffer, 0, 0);
            }
            this.canvasContext.globalCompositeOperation = operationsMap[this.data.tt];
            this.canvasContext.drawImage(buffer, 0, 0);
            this.canvasContext.globalCompositeOperation = "destination-over";
            this.canvasContext.drawImage(this.buffers[0], 0, 0);
            this.canvasContext.setTransform(this.currentTransform);
            this.canvasContext.globalCompositeOperation = "source-over";
          }
        },
        renderFrame: function renderFrame(forceRender) {
          if (this.hidden || this.data.hd) {
            return;
          }
          if (this.data.td === 1 && !forceRender) {
            return;
          }
          this.renderTransform();
          this.renderRenderable();
          this.renderLocalTransform();
          this.setBlendMode();
          var forceRealStack = this.data.ty === 0;
          this.prepareLayer();
          this.globalData.renderer.save(forceRealStack);
          this.globalData.renderer.ctxTransform(this.finalTransform.localMat.props);
          this.globalData.renderer.ctxOpacity(this.finalTransform.localOpacity);
          this.renderInnerContent();
          this.globalData.renderer.restore(forceRealStack);
          this.exitLayer();
          if (this.maskManager.hasMasks) {
            this.globalData.renderer.restore(true);
          }
          if (this._isFirstFrame) {
            this._isFirstFrame = false;
          }
        },
        destroy: function destroy() {
          this.canvasContext = null;
          this.data = null;
          this.globalData = null;
          this.maskManager.destroy();
        },
        mHelper: new Matrix()
      };
      CVBaseElement.prototype.hide = CVBaseElement.prototype.hideElement;
      CVBaseElement.prototype.show = CVBaseElement.prototype.showElement;
      function CVShapeData(element, data2, styles, transformsManager) {
        this.styledShapes = [];
        this.tr = [0, 0, 0, 0, 0, 0];
        var ty = 4;
        if (data2.ty === "rc") {
          ty = 5;
        } else if (data2.ty === "el") {
          ty = 6;
        } else if (data2.ty === "sr") {
          ty = 7;
        }
        this.sh = ShapePropertyFactory.getShapeProp(element, data2, ty, element);
        var i;
        var len = styles.length;
        var styledShape;
        for (i = 0; i < len; i += 1) {
          if (!styles[i].closed) {
            styledShape = {
              transforms: transformsManager.addTransformSequence(styles[i].transforms),
              trNodes: []
            };
            this.styledShapes.push(styledShape);
            styles[i].elements.push(styledShape);
          }
        }
      }
      CVShapeData.prototype.setAsAnimated = SVGShapeData.prototype.setAsAnimated;
      function CVShapeElement(data2, globalData2, comp2) {
        this.shapes = [];
        this.shapesData = data2.shapes;
        this.stylesList = [];
        this.itemsData = [];
        this.prevViewData = [];
        this.shapeModifiers = [];
        this.processedElements = [];
        this.transformsManager = new ShapeTransformManager();
        this.initElement(data2, globalData2, comp2);
      }
      extendPrototype([BaseElement, TransformElement, CVBaseElement, IShapeElement, HierarchyElement, FrameElement, RenderableElement], CVShapeElement);
      CVShapeElement.prototype.initElement = RenderableDOMElement.prototype.initElement;
      CVShapeElement.prototype.transformHelper = {
        opacity: 1,
        _opMdf: false
      };
      CVShapeElement.prototype.dashResetter = [];
      CVShapeElement.prototype.createContent = function() {
        this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, true, []);
      };
      CVShapeElement.prototype.createStyleElement = function(data2, transforms) {
        var styleElem = {
          data: data2,
          type: data2.ty,
          preTransforms: this.transformsManager.addTransformSequence(transforms),
          transforms: [],
          elements: [],
          closed: data2.hd === true
        };
        var elementData = {};
        if (data2.ty === "fl" || data2.ty === "st") {
          elementData.c = PropertyFactory.getProp(this, data2.c, 1, 255, this);
          if (!elementData.c.k) {
            styleElem.co = "rgb(" + bmFloor(elementData.c.v[0]) + "," + bmFloor(elementData.c.v[1]) + "," + bmFloor(elementData.c.v[2]) + ")";
          }
        } else if (data2.ty === "gf" || data2.ty === "gs") {
          elementData.s = PropertyFactory.getProp(this, data2.s, 1, null, this);
          elementData.e = PropertyFactory.getProp(this, data2.e, 1, null, this);
          elementData.h = PropertyFactory.getProp(this, data2.h || {
            k: 0
          }, 0, 0.01, this);
          elementData.a = PropertyFactory.getProp(this, data2.a || {
            k: 0
          }, 0, degToRads, this);
          elementData.g = new GradientProperty(this, data2.g, this);
        }
        elementData.o = PropertyFactory.getProp(this, data2.o, 0, 0.01, this);
        if (data2.ty === "st" || data2.ty === "gs") {
          styleElem.lc = lineCapEnum[data2.lc || 2];
          styleElem.lj = lineJoinEnum[data2.lj || 2];
          if (data2.lj == 1) {
            styleElem.ml = data2.ml;
          }
          elementData.w = PropertyFactory.getProp(this, data2.w, 0, null, this);
          if (!elementData.w.k) {
            styleElem.wi = elementData.w.v;
          }
          if (data2.d) {
            var d = new DashProperty(this, data2.d, "canvas", this);
            elementData.d = d;
            if (!elementData.d.k) {
              styleElem.da = elementData.d.dashArray;
              styleElem["do"] = elementData.d.dashoffset[0];
            }
          }
        } else {
          styleElem.r = data2.r === 2 ? "evenodd" : "nonzero";
        }
        this.stylesList.push(styleElem);
        elementData.style = styleElem;
        return elementData;
      };
      CVShapeElement.prototype.createGroupElement = function() {
        var elementData = {
          it: [],
          prevViewData: []
        };
        return elementData;
      };
      CVShapeElement.prototype.createTransformElement = function(data2) {
        var elementData = {
          transform: {
            opacity: 1,
            _opMdf: false,
            key: this.transformsManager.getNewKey(),
            op: PropertyFactory.getProp(this, data2.o, 0, 0.01, this),
            mProps: TransformPropertyFactory.getTransformProperty(this, data2, this)
          }
        };
        return elementData;
      };
      CVShapeElement.prototype.createShapeElement = function(data2) {
        var elementData = new CVShapeData(this, data2, this.stylesList, this.transformsManager);
        this.shapes.push(elementData);
        this.addShapeToModifiers(elementData);
        return elementData;
      };
      CVShapeElement.prototype.reloadShapes = function() {
        this._isFirstFrame = true;
        var i;
        var len = this.itemsData.length;
        for (i = 0; i < len; i += 1) {
          this.prevViewData[i] = this.itemsData[i];
        }
        this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, true, []);
        len = this.dynamicProperties.length;
        for (i = 0; i < len; i += 1) {
          this.dynamicProperties[i].getValue();
        }
        this.renderModifiers();
        this.transformsManager.processSequences(this._isFirstFrame);
      };
      CVShapeElement.prototype.addTransformToStyleList = function(transform2) {
        var i;
        var len = this.stylesList.length;
        for (i = 0; i < len; i += 1) {
          if (!this.stylesList[i].closed) {
            this.stylesList[i].transforms.push(transform2);
          }
        }
      };
      CVShapeElement.prototype.removeTransformFromStyleList = function() {
        var i;
        var len = this.stylesList.length;
        for (i = 0; i < len; i += 1) {
          if (!this.stylesList[i].closed) {
            this.stylesList[i].transforms.pop();
          }
        }
      };
      CVShapeElement.prototype.closeStyles = function(styles) {
        var i;
        var len = styles.length;
        for (i = 0; i < len; i += 1) {
          styles[i].closed = true;
        }
      };
      CVShapeElement.prototype.searchShapes = function(arr, itemsData, prevViewData, shouldRender, transforms) {
        var i;
        var len = arr.length - 1;
        var j;
        var jLen;
        var ownStyles = [];
        var ownModifiers = [];
        var processedPos;
        var modifier;
        var currentTransform;
        var ownTransforms = [].concat(transforms);
        for (i = len; i >= 0; i -= 1) {
          processedPos = this.searchProcessedElement(arr[i]);
          if (!processedPos) {
            arr[i]._shouldRender = shouldRender;
          } else {
            itemsData[i] = prevViewData[processedPos - 1];
          }
          if (arr[i].ty === "fl" || arr[i].ty === "st" || arr[i].ty === "gf" || arr[i].ty === "gs") {
            if (!processedPos) {
              itemsData[i] = this.createStyleElement(arr[i], ownTransforms);
            } else {
              itemsData[i].style.closed = false;
            }
            ownStyles.push(itemsData[i].style);
          } else if (arr[i].ty === "gr") {
            if (!processedPos) {
              itemsData[i] = this.createGroupElement(arr[i]);
            } else {
              jLen = itemsData[i].it.length;
              for (j = 0; j < jLen; j += 1) {
                itemsData[i].prevViewData[j] = itemsData[i].it[j];
              }
            }
            this.searchShapes(arr[i].it, itemsData[i].it, itemsData[i].prevViewData, shouldRender, ownTransforms);
          } else if (arr[i].ty === "tr") {
            if (!processedPos) {
              currentTransform = this.createTransformElement(arr[i]);
              itemsData[i] = currentTransform;
            }
            ownTransforms.push(itemsData[i]);
            this.addTransformToStyleList(itemsData[i]);
          } else if (arr[i].ty === "sh" || arr[i].ty === "rc" || arr[i].ty === "el" || arr[i].ty === "sr") {
            if (!processedPos) {
              itemsData[i] = this.createShapeElement(arr[i]);
            }
          } else if (arr[i].ty === "tm" || arr[i].ty === "rd" || arr[i].ty === "pb" || arr[i].ty === "zz" || arr[i].ty === "op") {
            if (!processedPos) {
              modifier = ShapeModifiers.getModifier(arr[i].ty);
              modifier.init(this, arr[i]);
              itemsData[i] = modifier;
              this.shapeModifiers.push(modifier);
            } else {
              modifier = itemsData[i];
              modifier.closed = false;
            }
            ownModifiers.push(modifier);
          } else if (arr[i].ty === "rp") {
            if (!processedPos) {
              modifier = ShapeModifiers.getModifier(arr[i].ty);
              itemsData[i] = modifier;
              modifier.init(this, arr, i, itemsData);
              this.shapeModifiers.push(modifier);
              shouldRender = false;
            } else {
              modifier = itemsData[i];
              modifier.closed = true;
            }
            ownModifiers.push(modifier);
          }
          this.addProcessedElement(arr[i], i + 1);
        }
        this.removeTransformFromStyleList();
        this.closeStyles(ownStyles);
        len = ownModifiers.length;
        for (i = 0; i < len; i += 1) {
          ownModifiers[i].closed = true;
        }
      };
      CVShapeElement.prototype.renderInnerContent = function() {
        this.transformHelper.opacity = 1;
        this.transformHelper._opMdf = false;
        this.renderModifiers();
        this.transformsManager.processSequences(this._isFirstFrame);
        this.renderShape(this.transformHelper, this.shapesData, this.itemsData, true);
      };
      CVShapeElement.prototype.renderShapeTransform = function(parentTransform, groupTransform) {
        if (parentTransform._opMdf || groupTransform.op._mdf || this._isFirstFrame) {
          groupTransform.opacity = parentTransform.opacity;
          groupTransform.opacity *= groupTransform.op.v;
          groupTransform._opMdf = true;
        }
      };
      CVShapeElement.prototype.drawLayer = function() {
        var i;
        var len = this.stylesList.length;
        var j;
        var jLen;
        var k;
        var kLen;
        var elems;
        var nodes;
        var renderer2 = this.globalData.renderer;
        var ctx = this.globalData.canvasContext;
        var type;
        var currentStyle;
        for (i = 0; i < len; i += 1) {
          currentStyle = this.stylesList[i];
          type = currentStyle.type;
          if (!((type === "st" || type === "gs") && currentStyle.wi === 0 || !currentStyle.data._shouldRender || currentStyle.coOp === 0 || this.globalData.currentGlobalAlpha === 0)) {
            renderer2.save();
            elems = currentStyle.elements;
            if (type === "st" || type === "gs") {
              renderer2.ctxStrokeStyle(type === "st" ? currentStyle.co : currentStyle.grd);
              renderer2.ctxLineWidth(currentStyle.wi);
              renderer2.ctxLineCap(currentStyle.lc);
              renderer2.ctxLineJoin(currentStyle.lj);
              renderer2.ctxMiterLimit(currentStyle.ml || 0);
            } else {
              renderer2.ctxFillStyle(type === "fl" ? currentStyle.co : currentStyle.grd);
            }
            renderer2.ctxOpacity(currentStyle.coOp);
            if (type !== "st" && type !== "gs") {
              ctx.beginPath();
            }
            renderer2.ctxTransform(currentStyle.preTransforms.finalTransform.props);
            jLen = elems.length;
            for (j = 0; j < jLen; j += 1) {
              if (type === "st" || type === "gs") {
                ctx.beginPath();
                if (currentStyle.da) {
                  ctx.setLineDash(currentStyle.da);
                  ctx.lineDashOffset = currentStyle["do"];
                }
              }
              nodes = elems[j].trNodes;
              kLen = nodes.length;
              for (k = 0; k < kLen; k += 1) {
                if (nodes[k].t === "m") {
                  ctx.moveTo(nodes[k].p[0], nodes[k].p[1]);
                } else if (nodes[k].t === "c") {
                  ctx.bezierCurveTo(nodes[k].pts[0], nodes[k].pts[1], nodes[k].pts[2], nodes[k].pts[3], nodes[k].pts[4], nodes[k].pts[5]);
                } else {
                  ctx.closePath();
                }
              }
              if (type === "st" || type === "gs") {
                renderer2.ctxStroke();
                if (currentStyle.da) {
                  ctx.setLineDash(this.dashResetter);
                }
              }
            }
            if (type !== "st" && type !== "gs") {
              this.globalData.renderer.ctxFill(currentStyle.r);
            }
            renderer2.restore();
          }
        }
      };
      CVShapeElement.prototype.renderShape = function(parentTransform, items, data2, isMain) {
        var i;
        var len = items.length - 1;
        var groupTransform;
        groupTransform = parentTransform;
        for (i = len; i >= 0; i -= 1) {
          if (items[i].ty === "tr") {
            groupTransform = data2[i].transform;
            this.renderShapeTransform(parentTransform, groupTransform);
          } else if (items[i].ty === "sh" || items[i].ty === "el" || items[i].ty === "rc" || items[i].ty === "sr") {
            this.renderPath(items[i], data2[i]);
          } else if (items[i].ty === "fl") {
            this.renderFill(items[i], data2[i], groupTransform);
          } else if (items[i].ty === "st") {
            this.renderStroke(items[i], data2[i], groupTransform);
          } else if (items[i].ty === "gf" || items[i].ty === "gs") {
            this.renderGradientFill(items[i], data2[i], groupTransform);
          } else if (items[i].ty === "gr") {
            this.renderShape(groupTransform, items[i].it, data2[i].it);
          } else if (items[i].ty === "tm") {
          }
        }
        if (isMain) {
          this.drawLayer();
        }
      };
      CVShapeElement.prototype.renderStyledShape = function(styledShape, shape) {
        if (this._isFirstFrame || shape._mdf || styledShape.transforms._mdf) {
          var shapeNodes = styledShape.trNodes;
          var paths = shape.paths;
          var i;
          var len;
          var j;
          var jLen = paths._length;
          shapeNodes.length = 0;
          var groupTransformMat = styledShape.transforms.finalTransform;
          for (j = 0; j < jLen; j += 1) {
            var pathNodes = paths.shapes[j];
            if (pathNodes && pathNodes.v) {
              len = pathNodes._length;
              for (i = 1; i < len; i += 1) {
                if (i === 1) {
                  shapeNodes.push({
                    t: "m",
                    p: groupTransformMat.applyToPointArray(pathNodes.v[0][0], pathNodes.v[0][1], 0)
                  });
                }
                shapeNodes.push({
                  t: "c",
                  pts: groupTransformMat.applyToTriplePoints(pathNodes.o[i - 1], pathNodes.i[i], pathNodes.v[i])
                });
              }
              if (len === 1) {
                shapeNodes.push({
                  t: "m",
                  p: groupTransformMat.applyToPointArray(pathNodes.v[0][0], pathNodes.v[0][1], 0)
                });
              }
              if (pathNodes.c && len) {
                shapeNodes.push({
                  t: "c",
                  pts: groupTransformMat.applyToTriplePoints(pathNodes.o[i - 1], pathNodes.i[0], pathNodes.v[0])
                });
                shapeNodes.push({
                  t: "z"
                });
              }
            }
          }
          styledShape.trNodes = shapeNodes;
        }
      };
      CVShapeElement.prototype.renderPath = function(pathData, itemData) {
        if (pathData.hd !== true && pathData._shouldRender) {
          var i;
          var len = itemData.styledShapes.length;
          for (i = 0; i < len; i += 1) {
            this.renderStyledShape(itemData.styledShapes[i], itemData.sh);
          }
        }
      };
      CVShapeElement.prototype.renderFill = function(styleData, itemData, groupTransform) {
        var styleElem = itemData.style;
        if (itemData.c._mdf || this._isFirstFrame) {
          styleElem.co = "rgb(" + bmFloor(itemData.c.v[0]) + "," + bmFloor(itemData.c.v[1]) + "," + bmFloor(itemData.c.v[2]) + ")";
        }
        if (itemData.o._mdf || groupTransform._opMdf || this._isFirstFrame) {
          styleElem.coOp = itemData.o.v * groupTransform.opacity;
        }
      };
      CVShapeElement.prototype.renderGradientFill = function(styleData, itemData, groupTransform) {
        var styleElem = itemData.style;
        var grd;
        if (!styleElem.grd || itemData.g._mdf || itemData.s._mdf || itemData.e._mdf || styleData.t !== 1 && (itemData.h._mdf || itemData.a._mdf)) {
          var ctx = this.globalData.canvasContext;
          var pt1 = itemData.s.v;
          var pt2 = itemData.e.v;
          if (styleData.t === 1) {
            grd = ctx.createLinearGradient(pt1[0], pt1[1], pt2[0], pt2[1]);
          } else {
            var rad = Math.sqrt(Math.pow(pt1[0] - pt2[0], 2) + Math.pow(pt1[1] - pt2[1], 2));
            var ang = Math.atan2(pt2[1] - pt1[1], pt2[0] - pt1[0]);
            var percent = itemData.h.v;
            if (percent >= 1) {
              percent = 0.99;
            } else if (percent <= -1) {
              percent = -0.99;
            }
            var dist = rad * percent;
            var x = Math.cos(ang + itemData.a.v) * dist + pt1[0];
            var y = Math.sin(ang + itemData.a.v) * dist + pt1[1];
            grd = ctx.createRadialGradient(x, y, 0, pt1[0], pt1[1], rad);
          }
          var i;
          var len = styleData.g.p;
          var cValues = itemData.g.c;
          var opacity = 1;
          for (i = 0; i < len; i += 1) {
            if (itemData.g._hasOpacity && itemData.g._collapsable) {
              opacity = itemData.g.o[i * 2 + 1];
            }
            grd.addColorStop(cValues[i * 4] / 100, "rgba(" + cValues[i * 4 + 1] + "," + cValues[i * 4 + 2] + "," + cValues[i * 4 + 3] + "," + opacity + ")");
          }
          styleElem.grd = grd;
        }
        styleElem.coOp = itemData.o.v * groupTransform.opacity;
      };
      CVShapeElement.prototype.renderStroke = function(styleData, itemData, groupTransform) {
        var styleElem = itemData.style;
        var d = itemData.d;
        if (d && (d._mdf || this._isFirstFrame)) {
          styleElem.da = d.dashArray;
          styleElem["do"] = d.dashoffset[0];
        }
        if (itemData.c._mdf || this._isFirstFrame) {
          styleElem.co = "rgb(" + bmFloor(itemData.c.v[0]) + "," + bmFloor(itemData.c.v[1]) + "," + bmFloor(itemData.c.v[2]) + ")";
        }
        if (itemData.o._mdf || groupTransform._opMdf || this._isFirstFrame) {
          styleElem.coOp = itemData.o.v * groupTransform.opacity;
        }
        if (itemData.w._mdf || this._isFirstFrame) {
          styleElem.wi = itemData.w.v;
        }
      };
      CVShapeElement.prototype.destroy = function() {
        this.shapesData = null;
        this.globalData = null;
        this.canvasContext = null;
        this.stylesList.length = 0;
        this.itemsData.length = 0;
      };
      function CVTextElement(data2, globalData2, comp2) {
        this.textSpans = [];
        this.yOffset = 0;
        this.fillColorAnim = false;
        this.strokeColorAnim = false;
        this.strokeWidthAnim = false;
        this.stroke = false;
        this.fill = false;
        this.justifyOffset = 0;
        this.currentRender = null;
        this.renderType = "canvas";
        this.values = {
          fill: "rgba(0,0,0,0)",
          stroke: "rgba(0,0,0,0)",
          sWidth: 0,
          fValue: ""
        };
        this.initElement(data2, globalData2, comp2);
      }
      extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement, ITextElement], CVTextElement);
      CVTextElement.prototype.tHelper = createTag("canvas").getContext("2d");
      CVTextElement.prototype.buildNewText = function() {
        var documentData = this.textProperty.currentData;
        this.renderedLetters = createSizedArray(documentData.l ? documentData.l.length : 0);
        var hasFill = false;
        if (documentData.fc) {
          hasFill = true;
          this.values.fill = this.buildColor(documentData.fc);
        } else {
          this.values.fill = "rgba(0,0,0,0)";
        }
        this.fill = hasFill;
        var hasStroke = false;
        if (documentData.sc) {
          hasStroke = true;
          this.values.stroke = this.buildColor(documentData.sc);
          this.values.sWidth = documentData.sw;
        }
        var fontData = this.globalData.fontManager.getFontByName(documentData.f);
        var i;
        var len;
        var letters = documentData.l;
        var matrixHelper = this.mHelper;
        this.stroke = hasStroke;
        this.values.fValue = documentData.finalSize + "px " + this.globalData.fontManager.getFontByName(documentData.f).fFamily;
        len = documentData.finalText.length;
        var charData;
        var shapeData;
        var k;
        var kLen;
        var shapes;
        var j;
        var jLen;
        var pathNodes;
        var commands;
        var pathArr;
        var singleShape = this.data.singleShape;
        var trackingOffset = documentData.tr * 1e-3 * documentData.finalSize;
        var xPos = 0;
        var yPos = 0;
        var firstLine = true;
        var cnt = 0;
        for (i = 0; i < len; i += 1) {
          charData = this.globalData.fontManager.getCharData(documentData.finalText[i], fontData.fStyle, this.globalData.fontManager.getFontByName(documentData.f).fFamily);
          shapeData = charData && charData.data || {};
          matrixHelper.reset();
          if (singleShape && letters[i].n) {
            xPos = -trackingOffset;
            yPos += documentData.yOffset;
            yPos += firstLine ? 1 : 0;
            firstLine = false;
          }
          shapes = shapeData.shapes ? shapeData.shapes[0].it : [];
          jLen = shapes.length;
          matrixHelper.scale(documentData.finalSize / 100, documentData.finalSize / 100);
          if (singleShape) {
            this.applyTextPropertiesToMatrix(documentData, matrixHelper, letters[i].line, xPos, yPos);
          }
          commands = createSizedArray(jLen - 1);
          var commandsCounter = 0;
          for (j = 0; j < jLen; j += 1) {
            if (shapes[j].ty === "sh") {
              kLen = shapes[j].ks.k.i.length;
              pathNodes = shapes[j].ks.k;
              pathArr = [];
              for (k = 1; k < kLen; k += 1) {
                if (k === 1) {
                  pathArr.push(matrixHelper.applyToX(pathNodes.v[0][0], pathNodes.v[0][1], 0), matrixHelper.applyToY(pathNodes.v[0][0], pathNodes.v[0][1], 0));
                }
                pathArr.push(matrixHelper.applyToX(pathNodes.o[k - 1][0], pathNodes.o[k - 1][1], 0), matrixHelper.applyToY(pathNodes.o[k - 1][0], pathNodes.o[k - 1][1], 0), matrixHelper.applyToX(pathNodes.i[k][0], pathNodes.i[k][1], 0), matrixHelper.applyToY(pathNodes.i[k][0], pathNodes.i[k][1], 0), matrixHelper.applyToX(pathNodes.v[k][0], pathNodes.v[k][1], 0), matrixHelper.applyToY(pathNodes.v[k][0], pathNodes.v[k][1], 0));
              }
              pathArr.push(matrixHelper.applyToX(pathNodes.o[k - 1][0], pathNodes.o[k - 1][1], 0), matrixHelper.applyToY(pathNodes.o[k - 1][0], pathNodes.o[k - 1][1], 0), matrixHelper.applyToX(pathNodes.i[0][0], pathNodes.i[0][1], 0), matrixHelper.applyToY(pathNodes.i[0][0], pathNodes.i[0][1], 0), matrixHelper.applyToX(pathNodes.v[0][0], pathNodes.v[0][1], 0), matrixHelper.applyToY(pathNodes.v[0][0], pathNodes.v[0][1], 0));
              commands[commandsCounter] = pathArr;
              commandsCounter += 1;
            }
          }
          if (singleShape) {
            xPos += letters[i].l;
            xPos += trackingOffset;
          }
          if (this.textSpans[cnt]) {
            this.textSpans[cnt].elem = commands;
          } else {
            this.textSpans[cnt] = {
              elem: commands
            };
          }
          cnt += 1;
        }
      };
      CVTextElement.prototype.renderInnerContent = function() {
        this.validateText();
        var ctx = this.canvasContext;
        ctx.font = this.values.fValue;
        this.globalData.renderer.ctxLineCap("butt");
        this.globalData.renderer.ctxLineJoin("miter");
        this.globalData.renderer.ctxMiterLimit(4);
        if (!this.data.singleShape) {
          this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag);
        }
        var i;
        var len;
        var j;
        var jLen;
        var k;
        var kLen;
        var renderedLetters = this.textAnimator.renderedLetters;
        var letters = this.textProperty.currentData.l;
        len = letters.length;
        var renderedLetter;
        var lastFill = null;
        var lastStroke = null;
        var lastStrokeW = null;
        var commands;
        var pathArr;
        var renderer2 = this.globalData.renderer;
        for (i = 0; i < len; i += 1) {
          if (!letters[i].n) {
            renderedLetter = renderedLetters[i];
            if (renderedLetter) {
              renderer2.save();
              renderer2.ctxTransform(renderedLetter.p);
              renderer2.ctxOpacity(renderedLetter.o);
            }
            if (this.fill) {
              if (renderedLetter && renderedLetter.fc) {
                if (lastFill !== renderedLetter.fc) {
                  renderer2.ctxFillStyle(renderedLetter.fc);
                  lastFill = renderedLetter.fc;
                }
              } else if (lastFill !== this.values.fill) {
                lastFill = this.values.fill;
                renderer2.ctxFillStyle(this.values.fill);
              }
              commands = this.textSpans[i].elem;
              jLen = commands.length;
              this.globalData.canvasContext.beginPath();
              for (j = 0; j < jLen; j += 1) {
                pathArr = commands[j];
                kLen = pathArr.length;
                this.globalData.canvasContext.moveTo(pathArr[0], pathArr[1]);
                for (k = 2; k < kLen; k += 6) {
                  this.globalData.canvasContext.bezierCurveTo(pathArr[k], pathArr[k + 1], pathArr[k + 2], pathArr[k + 3], pathArr[k + 4], pathArr[k + 5]);
                }
              }
              this.globalData.canvasContext.closePath();
              renderer2.ctxFill();
            }
            if (this.stroke) {
              if (renderedLetter && renderedLetter.sw) {
                if (lastStrokeW !== renderedLetter.sw) {
                  lastStrokeW = renderedLetter.sw;
                  renderer2.ctxLineWidth(renderedLetter.sw);
                }
              } else if (lastStrokeW !== this.values.sWidth) {
                lastStrokeW = this.values.sWidth;
                renderer2.ctxLineWidth(this.values.sWidth);
              }
              if (renderedLetter && renderedLetter.sc) {
                if (lastStroke !== renderedLetter.sc) {
                  lastStroke = renderedLetter.sc;
                  renderer2.ctxStrokeStyle(renderedLetter.sc);
                }
              } else if (lastStroke !== this.values.stroke) {
                lastStroke = this.values.stroke;
                renderer2.ctxStrokeStyle(this.values.stroke);
              }
              commands = this.textSpans[i].elem;
              jLen = commands.length;
              this.globalData.canvasContext.beginPath();
              for (j = 0; j < jLen; j += 1) {
                pathArr = commands[j];
                kLen = pathArr.length;
                this.globalData.canvasContext.moveTo(pathArr[0], pathArr[1]);
                for (k = 2; k < kLen; k += 6) {
                  this.globalData.canvasContext.bezierCurveTo(pathArr[k], pathArr[k + 1], pathArr[k + 2], pathArr[k + 3], pathArr[k + 4], pathArr[k + 5]);
                }
              }
              this.globalData.canvasContext.closePath();
              renderer2.ctxStroke();
            }
            if (renderedLetter) {
              this.globalData.renderer.restore();
            }
          }
        }
      };
      function CVImageElement(data2, globalData2, comp2) {
        this.assetData = globalData2.getAssetData(data2.refId);
        this.img = globalData2.imageLoader.getAsset(this.assetData);
        this.initElement(data2, globalData2, comp2);
      }
      extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement], CVImageElement);
      CVImageElement.prototype.initElement = SVGShapeElement.prototype.initElement;
      CVImageElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame;
      CVImageElement.prototype.createContent = function() {
        if (this.img.width && (this.assetData.w !== this.img.width || this.assetData.h !== this.img.height)) {
          var canvas = createTag("canvas");
          canvas.width = this.assetData.w;
          canvas.height = this.assetData.h;
          var ctx = canvas.getContext("2d");
          var imgW = this.img.width;
          var imgH = this.img.height;
          var imgRel = imgW / imgH;
          var canvasRel = this.assetData.w / this.assetData.h;
          var widthCrop;
          var heightCrop;
          var par = this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio;
          if (imgRel > canvasRel && par === "xMidYMid slice" || imgRel < canvasRel && par !== "xMidYMid slice") {
            heightCrop = imgH;
            widthCrop = heightCrop * canvasRel;
          } else {
            widthCrop = imgW;
            heightCrop = widthCrop / canvasRel;
          }
          ctx.drawImage(this.img, (imgW - widthCrop) / 2, (imgH - heightCrop) / 2, widthCrop, heightCrop, 0, 0, this.assetData.w, this.assetData.h);
          this.img = canvas;
        }
      };
      CVImageElement.prototype.renderInnerContent = function() {
        this.canvasContext.drawImage(this.img, 0, 0);
      };
      CVImageElement.prototype.destroy = function() {
        this.img = null;
      };
      function CVSolidElement(data2, globalData2, comp2) {
        this.initElement(data2, globalData2, comp2);
      }
      extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement], CVSolidElement);
      CVSolidElement.prototype.initElement = SVGShapeElement.prototype.initElement;
      CVSolidElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame;
      CVSolidElement.prototype.renderInnerContent = function() {
        this.globalData.renderer.ctxFillStyle(this.data.sc);
        this.globalData.renderer.ctxFillRect(0, 0, this.data.sw, this.data.sh);
      };
      function CanvasRendererBase() {
      }
      extendPrototype([BaseRenderer], CanvasRendererBase);
      CanvasRendererBase.prototype.createShape = function(data2) {
        return new CVShapeElement(data2, this.globalData, this);
      };
      CanvasRendererBase.prototype.createText = function(data2) {
        return new CVTextElement(data2, this.globalData, this);
      };
      CanvasRendererBase.prototype.createImage = function(data2) {
        return new CVImageElement(data2, this.globalData, this);
      };
      CanvasRendererBase.prototype.createSolid = function(data2) {
        return new CVSolidElement(data2, this.globalData, this);
      };
      CanvasRendererBase.prototype.createNull = SVGRenderer.prototype.createNull;
      CanvasRendererBase.prototype.ctxTransform = function(props) {
        if (props[0] === 1 && props[1] === 0 && props[4] === 0 && props[5] === 1 && props[12] === 0 && props[13] === 0) {
          return;
        }
        this.canvasContext.transform(props[0], props[1], props[4], props[5], props[12], props[13]);
      };
      CanvasRendererBase.prototype.ctxOpacity = function(op) {
        this.canvasContext.globalAlpha *= op < 0 ? 0 : op;
      };
      CanvasRendererBase.prototype.ctxFillStyle = function(value3) {
        this.canvasContext.fillStyle = value3;
      };
      CanvasRendererBase.prototype.ctxStrokeStyle = function(value3) {
        this.canvasContext.strokeStyle = value3;
      };
      CanvasRendererBase.prototype.ctxLineWidth = function(value3) {
        this.canvasContext.lineWidth = value3;
      };
      CanvasRendererBase.prototype.ctxLineCap = function(value3) {
        this.canvasContext.lineCap = value3;
      };
      CanvasRendererBase.prototype.ctxLineJoin = function(value3) {
        this.canvasContext.lineJoin = value3;
      };
      CanvasRendererBase.prototype.ctxMiterLimit = function(value3) {
        this.canvasContext.miterLimit = value3;
      };
      CanvasRendererBase.prototype.ctxFill = function(rule) {
        this.canvasContext.fill(rule);
      };
      CanvasRendererBase.prototype.ctxFillRect = function(x, y, w, h) {
        this.canvasContext.fillRect(x, y, w, h);
      };
      CanvasRendererBase.prototype.ctxStroke = function() {
        this.canvasContext.stroke();
      };
      CanvasRendererBase.prototype.reset = function() {
        if (!this.renderConfig.clearCanvas) {
          this.canvasContext.restore();
          return;
        }
        this.contextData.reset();
      };
      CanvasRendererBase.prototype.save = function() {
        this.canvasContext.save();
      };
      CanvasRendererBase.prototype.restore = function(actionFlag) {
        if (!this.renderConfig.clearCanvas) {
          this.canvasContext.restore();
          return;
        }
        if (actionFlag) {
          this.globalData.blendMode = "source-over";
        }
        this.contextData.restore(actionFlag);
      };
      CanvasRendererBase.prototype.configAnimation = function(animData) {
        if (this.animationItem.wrapper) {
          this.animationItem.container = createTag("canvas");
          var containerStyle2 = this.animationItem.container.style;
          containerStyle2.width = "100%";
          containerStyle2.height = "100%";
          var origin = "0px 0px 0px";
          containerStyle2.transformOrigin = origin;
          containerStyle2.mozTransformOrigin = origin;
          containerStyle2.webkitTransformOrigin = origin;
          containerStyle2["-webkit-transform"] = origin;
          containerStyle2.contentVisibility = this.renderConfig.contentVisibility;
          this.animationItem.wrapper.appendChild(this.animationItem.container);
          this.canvasContext = this.animationItem.container.getContext("2d");
          if (this.renderConfig.className) {
            this.animationItem.container.setAttribute("class", this.renderConfig.className);
          }
          if (this.renderConfig.id) {
            this.animationItem.container.setAttribute("id", this.renderConfig.id);
          }
        } else {
          this.canvasContext = this.renderConfig.context;
        }
        this.contextData.setContext(this.canvasContext);
        this.data = animData;
        this.layers = animData.layers;
        this.transformCanvas = {
          w: animData.w,
          h: animData.h,
          sx: 0,
          sy: 0,
          tx: 0,
          ty: 0
        };
        this.setupGlobalData(animData, document.body);
        this.globalData.canvasContext = this.canvasContext;
        this.globalData.renderer = this;
        this.globalData.isDashed = false;
        this.globalData.progressiveLoad = this.renderConfig.progressiveLoad;
        this.globalData.transformCanvas = this.transformCanvas;
        this.elements = createSizedArray(animData.layers.length);
        this.updateContainerSize();
      };
      CanvasRendererBase.prototype.updateContainerSize = function(width2, height2) {
        this.reset();
        var elementWidth;
        var elementHeight;
        if (width2) {
          elementWidth = width2;
          elementHeight = height2;
          this.canvasContext.canvas.width = elementWidth;
          this.canvasContext.canvas.height = elementHeight;
        } else {
          if (this.animationItem.wrapper && this.animationItem.container) {
            elementWidth = this.animationItem.wrapper.offsetWidth;
            elementHeight = this.animationItem.wrapper.offsetHeight;
          } else {
            elementWidth = this.canvasContext.canvas.width;
            elementHeight = this.canvasContext.canvas.height;
          }
          this.canvasContext.canvas.width = elementWidth * this.renderConfig.dpr;
          this.canvasContext.canvas.height = elementHeight * this.renderConfig.dpr;
        }
        var elementRel;
        var animationRel;
        if (this.renderConfig.preserveAspectRatio.indexOf("meet") !== -1 || this.renderConfig.preserveAspectRatio.indexOf("slice") !== -1) {
          var par = this.renderConfig.preserveAspectRatio.split(" ");
          var fillType = par[1] || "meet";
          var pos = par[0] || "xMidYMid";
          var xPos = pos.substr(0, 4);
          var yPos = pos.substr(4);
          elementRel = elementWidth / elementHeight;
          animationRel = this.transformCanvas.w / this.transformCanvas.h;
          if (animationRel > elementRel && fillType === "meet" || animationRel < elementRel && fillType === "slice") {
            this.transformCanvas.sx = elementWidth / (this.transformCanvas.w / this.renderConfig.dpr);
            this.transformCanvas.sy = elementWidth / (this.transformCanvas.w / this.renderConfig.dpr);
          } else {
            this.transformCanvas.sx = elementHeight / (this.transformCanvas.h / this.renderConfig.dpr);
            this.transformCanvas.sy = elementHeight / (this.transformCanvas.h / this.renderConfig.dpr);
          }
          if (xPos === "xMid" && (animationRel < elementRel && fillType === "meet" || animationRel > elementRel && fillType === "slice")) {
            this.transformCanvas.tx = (elementWidth - this.transformCanvas.w * (elementHeight / this.transformCanvas.h)) / 2 * this.renderConfig.dpr;
          } else if (xPos === "xMax" && (animationRel < elementRel && fillType === "meet" || animationRel > elementRel && fillType === "slice")) {
            this.transformCanvas.tx = (elementWidth - this.transformCanvas.w * (elementHeight / this.transformCanvas.h)) * this.renderConfig.dpr;
          } else {
            this.transformCanvas.tx = 0;
          }
          if (yPos === "YMid" && (animationRel > elementRel && fillType === "meet" || animationRel < elementRel && fillType === "slice")) {
            this.transformCanvas.ty = (elementHeight - this.transformCanvas.h * (elementWidth / this.transformCanvas.w)) / 2 * this.renderConfig.dpr;
          } else if (yPos === "YMax" && (animationRel > elementRel && fillType === "meet" || animationRel < elementRel && fillType === "slice")) {
            this.transformCanvas.ty = (elementHeight - this.transformCanvas.h * (elementWidth / this.transformCanvas.w)) * this.renderConfig.dpr;
          } else {
            this.transformCanvas.ty = 0;
          }
        } else if (this.renderConfig.preserveAspectRatio === "none") {
          this.transformCanvas.sx = elementWidth / (this.transformCanvas.w / this.renderConfig.dpr);
          this.transformCanvas.sy = elementHeight / (this.transformCanvas.h / this.renderConfig.dpr);
          this.transformCanvas.tx = 0;
          this.transformCanvas.ty = 0;
        } else {
          this.transformCanvas.sx = this.renderConfig.dpr;
          this.transformCanvas.sy = this.renderConfig.dpr;
          this.transformCanvas.tx = 0;
          this.transformCanvas.ty = 0;
        }
        this.transformCanvas.props = [this.transformCanvas.sx, 0, 0, 0, 0, this.transformCanvas.sy, 0, 0, 0, 0, 1, 0, this.transformCanvas.tx, this.transformCanvas.ty, 0, 1];
        this.ctxTransform(this.transformCanvas.props);
        this.canvasContext.beginPath();
        this.canvasContext.rect(0, 0, this.transformCanvas.w, this.transformCanvas.h);
        this.canvasContext.closePath();
        this.canvasContext.clip();
        this.renderFrame(this.renderedFrame, true);
      };
      CanvasRendererBase.prototype.destroy = function() {
        if (this.renderConfig.clearCanvas && this.animationItem.wrapper) {
          this.animationItem.wrapper.innerText = "";
        }
        var i;
        var len = this.layers ? this.layers.length : 0;
        for (i = len - 1; i >= 0; i -= 1) {
          if (this.elements[i] && this.elements[i].destroy) {
            this.elements[i].destroy();
          }
        }
        this.elements.length = 0;
        this.globalData.canvasContext = null;
        this.animationItem.container = null;
        this.destroyed = true;
      };
      CanvasRendererBase.prototype.renderFrame = function(num, forceRender) {
        if (this.renderedFrame === num && this.renderConfig.clearCanvas === true && !forceRender || this.destroyed || num === -1) {
          return;
        }
        this.renderedFrame = num;
        this.globalData.frameNum = num - this.animationItem._isFirstFrame;
        this.globalData.frameId += 1;
        this.globalData._mdf = !this.renderConfig.clearCanvas || forceRender;
        this.globalData.projectInterface.currentFrame = num;
        var i;
        var len = this.layers.length;
        if (!this.completeLayers) {
          this.checkLayers(num);
        }
        for (i = len - 1; i >= 0; i -= 1) {
          if (this.completeLayers || this.elements[i]) {
            this.elements[i].prepareFrame(num - this.layers[i].st);
          }
        }
        if (this.globalData._mdf) {
          if (this.renderConfig.clearCanvas === true) {
            this.canvasContext.clearRect(0, 0, this.transformCanvas.w, this.transformCanvas.h);
          } else {
            this.save();
          }
          for (i = len - 1; i >= 0; i -= 1) {
            if (this.completeLayers || this.elements[i]) {
              this.elements[i].renderFrame();
            }
          }
          if (this.renderConfig.clearCanvas !== true) {
            this.restore();
          }
        }
      };
      CanvasRendererBase.prototype.buildItem = function(pos) {
        var elements = this.elements;
        if (elements[pos] || this.layers[pos].ty === 99) {
          return;
        }
        var element = this.createItem(this.layers[pos], this, this.globalData);
        elements[pos] = element;
        element.initExpressions();
      };
      CanvasRendererBase.prototype.checkPendingElements = function() {
        while (this.pendingElements.length) {
          var element = this.pendingElements.pop();
          element.checkParenting();
        }
      };
      CanvasRendererBase.prototype.hide = function() {
        this.animationItem.container.style.display = "none";
      };
      CanvasRendererBase.prototype.show = function() {
        this.animationItem.container.style.display = "block";
      };
      function CanvasContext() {
        this.opacity = -1;
        this.transform = createTypedArray("float32", 16);
        this.fillStyle = "";
        this.strokeStyle = "";
        this.lineWidth = "";
        this.lineCap = "";
        this.lineJoin = "";
        this.miterLimit = "";
        this.id = Math.random();
      }
      function CVContextData() {
        this.stack = [];
        this.cArrPos = 0;
        this.cTr = new Matrix();
        var i;
        var len = 15;
        for (i = 0; i < len; i += 1) {
          var canvasContext = new CanvasContext();
          this.stack[i] = canvasContext;
        }
        this._length = len;
        this.nativeContext = null;
        this.transformMat = new Matrix();
        this.currentOpacity = 1;
        this.currentFillStyle = "";
        this.appliedFillStyle = "";
        this.currentStrokeStyle = "";
        this.appliedStrokeStyle = "";
        this.currentLineWidth = "";
        this.appliedLineWidth = "";
        this.currentLineCap = "";
        this.appliedLineCap = "";
        this.currentLineJoin = "";
        this.appliedLineJoin = "";
        this.appliedMiterLimit = "";
        this.currentMiterLimit = "";
      }
      CVContextData.prototype.duplicate = function() {
        var newLength = this._length * 2;
        var i = 0;
        for (i = this._length; i < newLength; i += 1) {
          this.stack[i] = new CanvasContext();
        }
        this._length = newLength;
      };
      CVContextData.prototype.reset = function() {
        this.cArrPos = 0;
        this.cTr.reset();
        this.stack[this.cArrPos].opacity = 1;
      };
      CVContextData.prototype.restore = function(forceRestore) {
        this.cArrPos -= 1;
        var currentContext = this.stack[this.cArrPos];
        var transform2 = currentContext.transform;
        var i;
        var arr = this.cTr.props;
        for (i = 0; i < 16; i += 1) {
          arr[i] = transform2[i];
        }
        if (forceRestore) {
          this.nativeContext.restore();
          var prevStack = this.stack[this.cArrPos + 1];
          this.appliedFillStyle = prevStack.fillStyle;
          this.appliedStrokeStyle = prevStack.strokeStyle;
          this.appliedLineWidth = prevStack.lineWidth;
          this.appliedLineCap = prevStack.lineCap;
          this.appliedLineJoin = prevStack.lineJoin;
          this.appliedMiterLimit = prevStack.miterLimit;
        }
        this.nativeContext.setTransform(transform2[0], transform2[1], transform2[4], transform2[5], transform2[12], transform2[13]);
        if (forceRestore || currentContext.opacity !== -1 && this.currentOpacity !== currentContext.opacity) {
          this.nativeContext.globalAlpha = currentContext.opacity;
          this.currentOpacity = currentContext.opacity;
        }
        this.currentFillStyle = currentContext.fillStyle;
        this.currentStrokeStyle = currentContext.strokeStyle;
        this.currentLineWidth = currentContext.lineWidth;
        this.currentLineCap = currentContext.lineCap;
        this.currentLineJoin = currentContext.lineJoin;
        this.currentMiterLimit = currentContext.miterLimit;
      };
      CVContextData.prototype.save = function(saveOnNativeFlag) {
        if (saveOnNativeFlag) {
          this.nativeContext.save();
        }
        var props = this.cTr.props;
        if (this._length <= this.cArrPos) {
          this.duplicate();
        }
        var currentStack = this.stack[this.cArrPos];
        var i;
        for (i = 0; i < 16; i += 1) {
          currentStack.transform[i] = props[i];
        }
        this.cArrPos += 1;
        var newStack = this.stack[this.cArrPos];
        newStack.opacity = currentStack.opacity;
        newStack.fillStyle = currentStack.fillStyle;
        newStack.strokeStyle = currentStack.strokeStyle;
        newStack.lineWidth = currentStack.lineWidth;
        newStack.lineCap = currentStack.lineCap;
        newStack.lineJoin = currentStack.lineJoin;
        newStack.miterLimit = currentStack.miterLimit;
      };
      CVContextData.prototype.setOpacity = function(value3) {
        this.stack[this.cArrPos].opacity = value3;
      };
      CVContextData.prototype.setContext = function(value3) {
        this.nativeContext = value3;
      };
      CVContextData.prototype.fillStyle = function(value3) {
        if (this.stack[this.cArrPos].fillStyle !== value3) {
          this.currentFillStyle = value3;
          this.stack[this.cArrPos].fillStyle = value3;
        }
      };
      CVContextData.prototype.strokeStyle = function(value3) {
        if (this.stack[this.cArrPos].strokeStyle !== value3) {
          this.currentStrokeStyle = value3;
          this.stack[this.cArrPos].strokeStyle = value3;
        }
      };
      CVContextData.prototype.lineWidth = function(value3) {
        if (this.stack[this.cArrPos].lineWidth !== value3) {
          this.currentLineWidth = value3;
          this.stack[this.cArrPos].lineWidth = value3;
        }
      };
      CVContextData.prototype.lineCap = function(value3) {
        if (this.stack[this.cArrPos].lineCap !== value3) {
          this.currentLineCap = value3;
          this.stack[this.cArrPos].lineCap = value3;
        }
      };
      CVContextData.prototype.lineJoin = function(value3) {
        if (this.stack[this.cArrPos].lineJoin !== value3) {
          this.currentLineJoin = value3;
          this.stack[this.cArrPos].lineJoin = value3;
        }
      };
      CVContextData.prototype.miterLimit = function(value3) {
        if (this.stack[this.cArrPos].miterLimit !== value3) {
          this.currentMiterLimit = value3;
          this.stack[this.cArrPos].miterLimit = value3;
        }
      };
      CVContextData.prototype.transform = function(props) {
        this.transformMat.cloneFromProps(props);
        var currentTransform = this.cTr;
        this.transformMat.multiply(currentTransform);
        currentTransform.cloneFromProps(this.transformMat.props);
        var trProps = currentTransform.props;
        this.nativeContext.setTransform(trProps[0], trProps[1], trProps[4], trProps[5], trProps[12], trProps[13]);
      };
      CVContextData.prototype.opacity = function(op) {
        var currentOpacity = this.stack[this.cArrPos].opacity;
        currentOpacity *= op < 0 ? 0 : op;
        if (this.stack[this.cArrPos].opacity !== currentOpacity) {
          if (this.currentOpacity !== op) {
            this.nativeContext.globalAlpha = op;
            this.currentOpacity = op;
          }
          this.stack[this.cArrPos].opacity = currentOpacity;
        }
      };
      CVContextData.prototype.fill = function(rule) {
        if (this.appliedFillStyle !== this.currentFillStyle) {
          this.appliedFillStyle = this.currentFillStyle;
          this.nativeContext.fillStyle = this.appliedFillStyle;
        }
        this.nativeContext.fill(rule);
      };
      CVContextData.prototype.fillRect = function(x, y, w, h) {
        if (this.appliedFillStyle !== this.currentFillStyle) {
          this.appliedFillStyle = this.currentFillStyle;
          this.nativeContext.fillStyle = this.appliedFillStyle;
        }
        this.nativeContext.fillRect(x, y, w, h);
      };
      CVContextData.prototype.stroke = function() {
        if (this.appliedStrokeStyle !== this.currentStrokeStyle) {
          this.appliedStrokeStyle = this.currentStrokeStyle;
          this.nativeContext.strokeStyle = this.appliedStrokeStyle;
        }
        if (this.appliedLineWidth !== this.currentLineWidth) {
          this.appliedLineWidth = this.currentLineWidth;
          this.nativeContext.lineWidth = this.appliedLineWidth;
        }
        if (this.appliedLineCap !== this.currentLineCap) {
          this.appliedLineCap = this.currentLineCap;
          this.nativeContext.lineCap = this.appliedLineCap;
        }
        if (this.appliedLineJoin !== this.currentLineJoin) {
          this.appliedLineJoin = this.currentLineJoin;
          this.nativeContext.lineJoin = this.appliedLineJoin;
        }
        if (this.appliedMiterLimit !== this.currentMiterLimit) {
          this.appliedMiterLimit = this.currentMiterLimit;
          this.nativeContext.miterLimit = this.appliedMiterLimit;
        }
        this.nativeContext.stroke();
      };
      function CVCompElement(data2, globalData2, comp2) {
        this.completeLayers = false;
        this.layers = data2.layers;
        this.pendingElements = [];
        this.elements = createSizedArray(this.layers.length);
        this.initElement(data2, globalData2, comp2);
        this.tm = data2.tm ? PropertyFactory.getProp(this, data2.tm, 0, globalData2.frameRate, this) : {
          _placeholder: true
        };
      }
      extendPrototype([CanvasRendererBase, ICompElement, CVBaseElement], CVCompElement);
      CVCompElement.prototype.renderInnerContent = function() {
        var ctx = this.canvasContext;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(this.data.w, 0);
        ctx.lineTo(this.data.w, this.data.h);
        ctx.lineTo(0, this.data.h);
        ctx.lineTo(0, 0);
        ctx.clip();
        var i;
        var len = this.layers.length;
        for (i = len - 1; i >= 0; i -= 1) {
          if (this.completeLayers || this.elements[i]) {
            this.elements[i].renderFrame();
          }
        }
      };
      CVCompElement.prototype.destroy = function() {
        var i;
        var len = this.layers.length;
        for (i = len - 1; i >= 0; i -= 1) {
          if (this.elements[i]) {
            this.elements[i].destroy();
          }
        }
        this.layers = null;
        this.elements = null;
      };
      CVCompElement.prototype.createComp = function(data2) {
        return new CVCompElement(data2, this.globalData, this);
      };
      function CanvasRenderer(animationItem, config) {
        this.animationItem = animationItem;
        this.renderConfig = {
          clearCanvas: config && config.clearCanvas !== void 0 ? config.clearCanvas : true,
          context: config && config.context || null,
          progressiveLoad: config && config.progressiveLoad || false,
          preserveAspectRatio: config && config.preserveAspectRatio || "xMidYMid meet",
          imagePreserveAspectRatio: config && config.imagePreserveAspectRatio || "xMidYMid slice",
          contentVisibility: config && config.contentVisibility || "visible",
          className: config && config.className || "",
          id: config && config.id || "",
          runExpressions: !config || config.runExpressions === void 0 || config.runExpressions
        };
        this.renderConfig.dpr = config && config.dpr || 1;
        if (this.animationItem.wrapper) {
          this.renderConfig.dpr = config && config.dpr || window.devicePixelRatio || 1;
        }
        this.renderedFrame = -1;
        this.globalData = {
          frameNum: -1,
          _mdf: false,
          renderConfig: this.renderConfig,
          currentGlobalAlpha: -1
        };
        this.contextData = new CVContextData();
        this.elements = [];
        this.pendingElements = [];
        this.transformMat = new Matrix();
        this.completeLayers = false;
        this.rendererType = "canvas";
        if (this.renderConfig.clearCanvas) {
          this.ctxTransform = this.contextData.transform.bind(this.contextData);
          this.ctxOpacity = this.contextData.opacity.bind(this.contextData);
          this.ctxFillStyle = this.contextData.fillStyle.bind(this.contextData);
          this.ctxStrokeStyle = this.contextData.strokeStyle.bind(this.contextData);
          this.ctxLineWidth = this.contextData.lineWidth.bind(this.contextData);
          this.ctxLineCap = this.contextData.lineCap.bind(this.contextData);
          this.ctxLineJoin = this.contextData.lineJoin.bind(this.contextData);
          this.ctxMiterLimit = this.contextData.miterLimit.bind(this.contextData);
          this.ctxFill = this.contextData.fill.bind(this.contextData);
          this.ctxFillRect = this.contextData.fillRect.bind(this.contextData);
          this.ctxStroke = this.contextData.stroke.bind(this.contextData);
          this.save = this.contextData.save.bind(this.contextData);
        }
      }
      extendPrototype([CanvasRendererBase], CanvasRenderer);
      CanvasRenderer.prototype.createComp = function(data2) {
        return new CVCompElement(data2, this.globalData, this);
      };
      function HBaseElement() {
      }
      HBaseElement.prototype = {
        checkBlendMode: function checkBlendMode() {
        },
        initRendererElement: function initRendererElement() {
          this.baseElement = createTag(this.data.tg || "div");
          if (this.data.hasMask) {
            this.svgElement = createNS("svg");
            this.layerElement = createNS("g");
            this.maskedElement = this.layerElement;
            this.svgElement.appendChild(this.layerElement);
            this.baseElement.appendChild(this.svgElement);
          } else {
            this.layerElement = this.baseElement;
          }
          styleDiv(this.baseElement);
        },
        createContainerElements: function createContainerElements() {
          this.renderableEffectsManager = new CVEffects(this);
          this.transformedElement = this.baseElement;
          this.maskedElement = this.layerElement;
          if (this.data.ln) {
            this.layerElement.setAttribute("id", this.data.ln);
          }
          if (this.data.cl) {
            this.layerElement.setAttribute("class", this.data.cl);
          }
          if (this.data.bm !== 0) {
            this.setBlendMode();
          }
        },
        renderElement: function renderElement() {
          var transformedElementStyle = this.transformedElement ? this.transformedElement.style : {};
          if (this.finalTransform._matMdf) {
            var matrixValue = this.finalTransform.mat.toCSS();
            transformedElementStyle.transform = matrixValue;
            transformedElementStyle.webkitTransform = matrixValue;
          }
          if (this.finalTransform._opMdf) {
            transformedElementStyle.opacity = this.finalTransform.mProp.o.v;
          }
        },
        renderFrame: function renderFrame() {
          if (this.data.hd || this.hidden) {
            return;
          }
          this.renderTransform();
          this.renderRenderable();
          this.renderElement();
          this.renderInnerContent();
          if (this._isFirstFrame) {
            this._isFirstFrame = false;
          }
        },
        destroy: function destroy() {
          this.layerElement = null;
          this.transformedElement = null;
          if (this.matteElement) {
            this.matteElement = null;
          }
          if (this.maskManager) {
            this.maskManager.destroy();
            this.maskManager = null;
          }
        },
        createRenderableComponents: function createRenderableComponents() {
          this.maskManager = new MaskElement(this.data, this, this.globalData);
        },
        addEffects: function addEffects() {
        },
        setMatte: function setMatte() {
        }
      };
      HBaseElement.prototype.getBaseElement = SVGBaseElement.prototype.getBaseElement;
      HBaseElement.prototype.destroyBaseElement = HBaseElement.prototype.destroy;
      HBaseElement.prototype.buildElementParenting = BaseRenderer.prototype.buildElementParenting;
      function HSolidElement(data2, globalData2, comp2) {
        this.initElement(data2, globalData2, comp2);
      }
      extendPrototype([BaseElement, TransformElement, HBaseElement, HierarchyElement, FrameElement, RenderableDOMElement], HSolidElement);
      HSolidElement.prototype.createContent = function() {
        var rect;
        if (this.data.hasMask) {
          rect = createNS("rect");
          rect.setAttribute("width", this.data.sw);
          rect.setAttribute("height", this.data.sh);
          rect.setAttribute("fill", this.data.sc);
          this.svgElement.setAttribute("width", this.data.sw);
          this.svgElement.setAttribute("height", this.data.sh);
        } else {
          rect = createTag("div");
          rect.style.width = this.data.sw + "px";
          rect.style.height = this.data.sh + "px";
          rect.style.backgroundColor = this.data.sc;
        }
        this.layerElement.appendChild(rect);
      };
      function HShapeElement(data2, globalData2, comp2) {
        this.shapes = [];
        this.shapesData = data2.shapes;
        this.stylesList = [];
        this.shapeModifiers = [];
        this.itemsData = [];
        this.processedElements = [];
        this.animatedContents = [];
        this.shapesContainer = createNS("g");
        this.initElement(data2, globalData2, comp2);
        this.prevViewData = [];
        this.currentBBox = {
          x: 999999,
          y: -999999,
          h: 0,
          w: 0
        };
      }
      extendPrototype([BaseElement, TransformElement, HSolidElement, SVGShapeElement, HBaseElement, HierarchyElement, FrameElement, RenderableElement], HShapeElement);
      HShapeElement.prototype._renderShapeFrame = HShapeElement.prototype.renderInnerContent;
      HShapeElement.prototype.createContent = function() {
        var cont;
        this.baseElement.style.fontSize = 0;
        if (this.data.hasMask) {
          this.layerElement.appendChild(this.shapesContainer);
          cont = this.svgElement;
        } else {
          cont = createNS("svg");
          var size = this.comp.data ? this.comp.data : this.globalData.compSize;
          cont.setAttribute("width", size.w);
          cont.setAttribute("height", size.h);
          cont.appendChild(this.shapesContainer);
          this.layerElement.appendChild(cont);
        }
        this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.shapesContainer, 0, [], true);
        this.filterUniqueShapes();
        this.shapeCont = cont;
      };
      HShapeElement.prototype.getTransformedPoint = function(transformers, point) {
        var i;
        var len = transformers.length;
        for (i = 0; i < len; i += 1) {
          point = transformers[i].mProps.v.applyToPointArray(point[0], point[1], 0);
        }
        return point;
      };
      HShapeElement.prototype.calculateShapeBoundingBox = function(item, boundingBox) {
        var shape = item.sh.v;
        var transformers = item.transformers;
        var i;
        var len = shape._length;
        var vPoint;
        var oPoint;
        var nextIPoint;
        var nextVPoint;
        if (len <= 1) {
          return;
        }
        for (i = 0; i < len - 1; i += 1) {
          vPoint = this.getTransformedPoint(transformers, shape.v[i]);
          oPoint = this.getTransformedPoint(transformers, shape.o[i]);
          nextIPoint = this.getTransformedPoint(transformers, shape.i[i + 1]);
          nextVPoint = this.getTransformedPoint(transformers, shape.v[i + 1]);
          this.checkBounds(vPoint, oPoint, nextIPoint, nextVPoint, boundingBox);
        }
        if (shape.c) {
          vPoint = this.getTransformedPoint(transformers, shape.v[i]);
          oPoint = this.getTransformedPoint(transformers, shape.o[i]);
          nextIPoint = this.getTransformedPoint(transformers, shape.i[0]);
          nextVPoint = this.getTransformedPoint(transformers, shape.v[0]);
          this.checkBounds(vPoint, oPoint, nextIPoint, nextVPoint, boundingBox);
        }
      };
      HShapeElement.prototype.checkBounds = function(vPoint, oPoint, nextIPoint, nextVPoint, boundingBox) {
        this.getBoundsOfCurve(vPoint, oPoint, nextIPoint, nextVPoint);
        var bounds = this.shapeBoundingBox;
        boundingBox.x = bmMin(bounds.left, boundingBox.x);
        boundingBox.xMax = bmMax(bounds.right, boundingBox.xMax);
        boundingBox.y = bmMin(bounds.top, boundingBox.y);
        boundingBox.yMax = bmMax(bounds.bottom, boundingBox.yMax);
      };
      HShapeElement.prototype.shapeBoundingBox = {
        left: 0,
        right: 0,
        top: 0,
        bottom: 0
      };
      HShapeElement.prototype.tempBoundingBox = {
        x: 0,
        xMax: 0,
        y: 0,
        yMax: 0,
        width: 0,
        height: 0
      };
      HShapeElement.prototype.getBoundsOfCurve = function(p0, p1, p2, p3) {
        var bounds = [[p0[0], p3[0]], [p0[1], p3[1]]];
        for (var a, b, c, t, b2ac, t1, t2, i = 0; i < 2; ++i) {
          b = 6 * p0[i] - 12 * p1[i] + 6 * p2[i];
          a = -3 * p0[i] + 9 * p1[i] - 9 * p2[i] + 3 * p3[i];
          c = 3 * p1[i] - 3 * p0[i];
          b |= 0;
          a |= 0;
          c |= 0;
          if (a === 0 && b === 0) {
          } else if (a === 0) {
            t = -c / b;
            if (t > 0 && t < 1) {
              bounds[i].push(this.calculateF(t, p0, p1, p2, p3, i));
            }
          } else {
            b2ac = b * b - 4 * c * a;
            if (b2ac >= 0) {
              t1 = (-b + bmSqrt(b2ac)) / (2 * a);
              if (t1 > 0 && t1 < 1) bounds[i].push(this.calculateF(t1, p0, p1, p2, p3, i));
              t2 = (-b - bmSqrt(b2ac)) / (2 * a);
              if (t2 > 0 && t2 < 1) bounds[i].push(this.calculateF(t2, p0, p1, p2, p3, i));
            }
          }
        }
        this.shapeBoundingBox.left = bmMin.apply(null, bounds[0]);
        this.shapeBoundingBox.top = bmMin.apply(null, bounds[1]);
        this.shapeBoundingBox.right = bmMax.apply(null, bounds[0]);
        this.shapeBoundingBox.bottom = bmMax.apply(null, bounds[1]);
      };
      HShapeElement.prototype.calculateF = function(t, p0, p1, p2, p3, i) {
        return bmPow(1 - t, 3) * p0[i] + 3 * bmPow(1 - t, 2) * t * p1[i] + 3 * (1 - t) * bmPow(t, 2) * p2[i] + bmPow(t, 3) * p3[i];
      };
      HShapeElement.prototype.calculateBoundingBox = function(itemsData, boundingBox) {
        var i;
        var len = itemsData.length;
        for (i = 0; i < len; i += 1) {
          if (itemsData[i] && itemsData[i].sh) {
            this.calculateShapeBoundingBox(itemsData[i], boundingBox);
          } else if (itemsData[i] && itemsData[i].it) {
            this.calculateBoundingBox(itemsData[i].it, boundingBox);
          } else if (itemsData[i] && itemsData[i].style && itemsData[i].w) {
            this.expandStrokeBoundingBox(itemsData[i].w, boundingBox);
          }
        }
      };
      HShapeElement.prototype.expandStrokeBoundingBox = function(widthProperty, boundingBox) {
        var width2 = 0;
        if (widthProperty.keyframes) {
          for (var i = 0; i < widthProperty.keyframes.length; i += 1) {
            var kfw = widthProperty.keyframes[i].s;
            if (kfw > width2) {
              width2 = kfw;
            }
          }
          width2 *= widthProperty.mult;
        } else {
          width2 = widthProperty.v * widthProperty.mult;
        }
        boundingBox.x -= width2;
        boundingBox.xMax += width2;
        boundingBox.y -= width2;
        boundingBox.yMax += width2;
      };
      HShapeElement.prototype.currentBoxContains = function(box) {
        return this.currentBBox.x <= box.x && this.currentBBox.y <= box.y && this.currentBBox.width + this.currentBBox.x >= box.x + box.width && this.currentBBox.height + this.currentBBox.y >= box.y + box.height;
      };
      HShapeElement.prototype.renderInnerContent = function() {
        this._renderShapeFrame();
        if (!this.hidden && (this._isFirstFrame || this._mdf)) {
          var tempBoundingBox = this.tempBoundingBox;
          var max = 999999;
          tempBoundingBox.x = max;
          tempBoundingBox.xMax = -max;
          tempBoundingBox.y = max;
          tempBoundingBox.yMax = -max;
          this.calculateBoundingBox(this.itemsData, tempBoundingBox);
          tempBoundingBox.width = tempBoundingBox.xMax < tempBoundingBox.x ? 0 : tempBoundingBox.xMax - tempBoundingBox.x;
          tempBoundingBox.height = tempBoundingBox.yMax < tempBoundingBox.y ? 0 : tempBoundingBox.yMax - tempBoundingBox.y;
          if (this.currentBoxContains(tempBoundingBox)) {
            return;
          }
          var changed = false;
          if (this.currentBBox.w !== tempBoundingBox.width) {
            this.currentBBox.w = tempBoundingBox.width;
            this.shapeCont.setAttribute("width", tempBoundingBox.width);
            changed = true;
          }
          if (this.currentBBox.h !== tempBoundingBox.height) {
            this.currentBBox.h = tempBoundingBox.height;
            this.shapeCont.setAttribute("height", tempBoundingBox.height);
            changed = true;
          }
          if (changed || this.currentBBox.x !== tempBoundingBox.x || this.currentBBox.y !== tempBoundingBox.y) {
            this.currentBBox.w = tempBoundingBox.width;
            this.currentBBox.h = tempBoundingBox.height;
            this.currentBBox.x = tempBoundingBox.x;
            this.currentBBox.y = tempBoundingBox.y;
            this.shapeCont.setAttribute("viewBox", this.currentBBox.x + " " + this.currentBBox.y + " " + this.currentBBox.w + " " + this.currentBBox.h);
            var shapeStyle = this.shapeCont.style;
            var shapeTransform = "translate(" + this.currentBBox.x + "px," + this.currentBBox.y + "px)";
            shapeStyle.transform = shapeTransform;
            shapeStyle.webkitTransform = shapeTransform;
          }
        }
      };
      function HTextElement(data2, globalData2, comp2) {
        this.textSpans = [];
        this.textPaths = [];
        this.currentBBox = {
          x: 999999,
          y: -999999,
          h: 0,
          w: 0
        };
        this.renderType = "svg";
        this.isMasked = false;
        this.initElement(data2, globalData2, comp2);
      }
      extendPrototype([BaseElement, TransformElement, HBaseElement, HierarchyElement, FrameElement, RenderableDOMElement, ITextElement], HTextElement);
      HTextElement.prototype.createContent = function() {
        this.isMasked = this.checkMasks();
        if (this.isMasked) {
          this.renderType = "svg";
          this.compW = this.comp.data.w;
          this.compH = this.comp.data.h;
          this.svgElement.setAttribute("width", this.compW);
          this.svgElement.setAttribute("height", this.compH);
          var g = createNS("g");
          this.maskedElement.appendChild(g);
          this.innerElem = g;
        } else {
          this.renderType = "html";
          this.innerElem = this.layerElement;
        }
        this.checkParenting();
      };
      HTextElement.prototype.buildNewText = function() {
        var documentData = this.textProperty.currentData;
        this.renderedLetters = createSizedArray(documentData.l ? documentData.l.length : 0);
        var innerElemStyle = this.innerElem.style;
        var textColor = documentData.fc ? this.buildColor(documentData.fc) : "rgba(0,0,0,0)";
        innerElemStyle.fill = textColor;
        innerElemStyle.color = textColor;
        if (documentData.sc) {
          innerElemStyle.stroke = this.buildColor(documentData.sc);
          innerElemStyle.strokeWidth = documentData.sw + "px";
        }
        var fontData = this.globalData.fontManager.getFontByName(documentData.f);
        if (!this.globalData.fontManager.chars) {
          innerElemStyle.fontSize = documentData.finalSize + "px";
          innerElemStyle.lineHeight = documentData.finalSize + "px";
          if (fontData.fClass) {
            this.innerElem.className = fontData.fClass;
          } else {
            innerElemStyle.fontFamily = fontData.fFamily;
            var fWeight = documentData.fWeight;
            var fStyle = documentData.fStyle;
            innerElemStyle.fontStyle = fStyle;
            innerElemStyle.fontWeight = fWeight;
          }
        }
        var i;
        var len;
        var letters = documentData.l;
        len = letters.length;
        var tSpan;
        var tParent;
        var tCont;
        var matrixHelper = this.mHelper;
        var shapes;
        var shapeStr = "";
        var cnt = 0;
        for (i = 0; i < len; i += 1) {
          if (this.globalData.fontManager.chars) {
            if (!this.textPaths[cnt]) {
              tSpan = createNS("path");
              tSpan.setAttribute("stroke-linecap", lineCapEnum[1]);
              tSpan.setAttribute("stroke-linejoin", lineJoinEnum[2]);
              tSpan.setAttribute("stroke-miterlimit", "4");
            } else {
              tSpan = this.textPaths[cnt];
            }
            if (!this.isMasked) {
              if (this.textSpans[cnt]) {
                tParent = this.textSpans[cnt];
                tCont = tParent.children[0];
              } else {
                tParent = createTag("div");
                tParent.style.lineHeight = 0;
                tCont = createNS("svg");
                tCont.appendChild(tSpan);
                styleDiv(tParent);
              }
            }
          } else if (!this.isMasked) {
            if (this.textSpans[cnt]) {
              tParent = this.textSpans[cnt];
              tSpan = this.textPaths[cnt];
            } else {
              tParent = createTag("span");
              styleDiv(tParent);
              tSpan = createTag("span");
              styleDiv(tSpan);
              tParent.appendChild(tSpan);
            }
          } else {
            tSpan = this.textPaths[cnt] ? this.textPaths[cnt] : createNS("text");
          }
          if (this.globalData.fontManager.chars) {
            var charData = this.globalData.fontManager.getCharData(documentData.finalText[i], fontData.fStyle, this.globalData.fontManager.getFontByName(documentData.f).fFamily);
            var shapeData;
            if (charData) {
              shapeData = charData.data;
            } else {
              shapeData = null;
            }
            matrixHelper.reset();
            if (shapeData && shapeData.shapes && shapeData.shapes.length) {
              shapes = shapeData.shapes[0].it;
              matrixHelper.scale(documentData.finalSize / 100, documentData.finalSize / 100);
              shapeStr = this.createPathShape(matrixHelper, shapes);
              tSpan.setAttribute("d", shapeStr);
            }
            if (!this.isMasked) {
              this.innerElem.appendChild(tParent);
              if (shapeData && shapeData.shapes) {
                document.body.appendChild(tCont);
                var boundingBox = tCont.getBBox();
                tCont.setAttribute("width", boundingBox.width + 2);
                tCont.setAttribute("height", boundingBox.height + 2);
                tCont.setAttribute("viewBox", boundingBox.x - 1 + " " + (boundingBox.y - 1) + " " + (boundingBox.width + 2) + " " + (boundingBox.height + 2));
                var tContStyle = tCont.style;
                var tContTranslation = "translate(" + (boundingBox.x - 1) + "px," + (boundingBox.y - 1) + "px)";
                tContStyle.transform = tContTranslation;
                tContStyle.webkitTransform = tContTranslation;
                letters[i].yOffset = boundingBox.y - 1;
              } else {
                tCont.setAttribute("width", 1);
                tCont.setAttribute("height", 1);
              }
              tParent.appendChild(tCont);
            } else {
              this.innerElem.appendChild(tSpan);
            }
          } else {
            tSpan.textContent = letters[i].val;
            tSpan.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve");
            if (!this.isMasked) {
              this.innerElem.appendChild(tParent);
              var tStyle = tSpan.style;
              var tSpanTranslation = "translate3d(0," + -documentData.finalSize / 1.2 + "px,0)";
              tStyle.transform = tSpanTranslation;
              tStyle.webkitTransform = tSpanTranslation;
            } else {
              this.innerElem.appendChild(tSpan);
            }
          }
          if (!this.isMasked) {
            this.textSpans[cnt] = tParent;
          } else {
            this.textSpans[cnt] = tSpan;
          }
          this.textSpans[cnt].style.display = "block";
          this.textPaths[cnt] = tSpan;
          cnt += 1;
        }
        while (cnt < this.textSpans.length) {
          this.textSpans[cnt].style.display = "none";
          cnt += 1;
        }
      };
      HTextElement.prototype.renderInnerContent = function() {
        this.validateText();
        var svgStyle;
        if (this.data.singleShape) {
          if (!this._isFirstFrame && !this.lettersChangedFlag) {
            return;
          }
          if (this.isMasked && this.finalTransform._matMdf) {
            this.svgElement.setAttribute("viewBox", -this.finalTransform.mProp.p.v[0] + " " + -this.finalTransform.mProp.p.v[1] + " " + this.compW + " " + this.compH);
            svgStyle = this.svgElement.style;
            var translation = "translate(" + -this.finalTransform.mProp.p.v[0] + "px," + -this.finalTransform.mProp.p.v[1] + "px)";
            svgStyle.transform = translation;
            svgStyle.webkitTransform = translation;
          }
        }
        this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag);
        if (!this.lettersChangedFlag && !this.textAnimator.lettersChangedFlag) {
          return;
        }
        var i;
        var len;
        var count = 0;
        var renderedLetters = this.textAnimator.renderedLetters;
        var letters = this.textProperty.currentData.l;
        len = letters.length;
        var renderedLetter;
        var textSpan;
        var textPath;
        for (i = 0; i < len; i += 1) {
          if (letters[i].n) {
            count += 1;
          } else {
            textSpan = this.textSpans[i];
            textPath = this.textPaths[i];
            renderedLetter = renderedLetters[count];
            count += 1;
            if (renderedLetter._mdf.m) {
              if (!this.isMasked) {
                textSpan.style.webkitTransform = renderedLetter.m;
                textSpan.style.transform = renderedLetter.m;
              } else {
                textSpan.setAttribute("transform", renderedLetter.m);
              }
            }
            textSpan.style.opacity = renderedLetter.o;
            if (renderedLetter.sw && renderedLetter._mdf.sw) {
              textPath.setAttribute("stroke-width", renderedLetter.sw);
            }
            if (renderedLetter.sc && renderedLetter._mdf.sc) {
              textPath.setAttribute("stroke", renderedLetter.sc);
            }
            if (renderedLetter.fc && renderedLetter._mdf.fc) {
              textPath.setAttribute("fill", renderedLetter.fc);
              textPath.style.color = renderedLetter.fc;
            }
          }
        }
        if (this.innerElem.getBBox && !this.hidden && (this._isFirstFrame || this._mdf)) {
          var boundingBox = this.innerElem.getBBox();
          if (this.currentBBox.w !== boundingBox.width) {
            this.currentBBox.w = boundingBox.width;
            this.svgElement.setAttribute("width", boundingBox.width);
          }
          if (this.currentBBox.h !== boundingBox.height) {
            this.currentBBox.h = boundingBox.height;
            this.svgElement.setAttribute("height", boundingBox.height);
          }
          var margin = 1;
          if (this.currentBBox.w !== boundingBox.width + margin * 2 || this.currentBBox.h !== boundingBox.height + margin * 2 || this.currentBBox.x !== boundingBox.x - margin || this.currentBBox.y !== boundingBox.y - margin) {
            this.currentBBox.w = boundingBox.width + margin * 2;
            this.currentBBox.h = boundingBox.height + margin * 2;
            this.currentBBox.x = boundingBox.x - margin;
            this.currentBBox.y = boundingBox.y - margin;
            this.svgElement.setAttribute("viewBox", this.currentBBox.x + " " + this.currentBBox.y + " " + this.currentBBox.w + " " + this.currentBBox.h);
            svgStyle = this.svgElement.style;
            var svgTransform = "translate(" + this.currentBBox.x + "px," + this.currentBBox.y + "px)";
            svgStyle.transform = svgTransform;
            svgStyle.webkitTransform = svgTransform;
          }
        }
      };
      function HCameraElement(data2, globalData2, comp2) {
        this.initFrame();
        this.initBaseData(data2, globalData2, comp2);
        this.initHierarchy();
        var getProp = PropertyFactory.getProp;
        this.pe = getProp(this, data2.pe, 0, 0, this);
        if (data2.ks.p.s) {
          this.px = getProp(this, data2.ks.p.x, 1, 0, this);
          this.py = getProp(this, data2.ks.p.y, 1, 0, this);
          this.pz = getProp(this, data2.ks.p.z, 1, 0, this);
        } else {
          this.p = getProp(this, data2.ks.p, 1, 0, this);
        }
        if (data2.ks.a) {
          this.a = getProp(this, data2.ks.a, 1, 0, this);
        }
        if (data2.ks.or.k.length && data2.ks.or.k[0].to) {
          var i;
          var len = data2.ks.or.k.length;
          for (i = 0; i < len; i += 1) {
            data2.ks.or.k[i].to = null;
            data2.ks.or.k[i].ti = null;
          }
        }
        this.or = getProp(this, data2.ks.or, 1, degToRads, this);
        this.or.sh = true;
        this.rx = getProp(this, data2.ks.rx, 0, degToRads, this);
        this.ry = getProp(this, data2.ks.ry, 0, degToRads, this);
        this.rz = getProp(this, data2.ks.rz, 0, degToRads, this);
        this.mat = new Matrix();
        this._prevMat = new Matrix();
        this._isFirstFrame = true;
        this.finalTransform = {
          mProp: this
        };
      }
      extendPrototype([BaseElement, FrameElement, HierarchyElement], HCameraElement);
      HCameraElement.prototype.setup = function() {
        var i;
        var len = this.comp.threeDElements.length;
        var comp2;
        var perspectiveStyle;
        var containerStyle2;
        for (i = 0; i < len; i += 1) {
          comp2 = this.comp.threeDElements[i];
          if (comp2.type === "3d") {
            perspectiveStyle = comp2.perspectiveElem.style;
            containerStyle2 = comp2.container.style;
            var perspective = this.pe.v + "px";
            var origin = "0px 0px 0px";
            var matrix = "matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)";
            perspectiveStyle.perspective = perspective;
            perspectiveStyle.webkitPerspective = perspective;
            containerStyle2.transformOrigin = origin;
            containerStyle2.mozTransformOrigin = origin;
            containerStyle2.webkitTransformOrigin = origin;
            perspectiveStyle.transform = matrix;
            perspectiveStyle.webkitTransform = matrix;
          }
        }
      };
      HCameraElement.prototype.createElements = function() {
      };
      HCameraElement.prototype.hide = function() {
      };
      HCameraElement.prototype.renderFrame = function() {
        var _mdf = this._isFirstFrame;
        var i;
        var len;
        if (this.hierarchy) {
          len = this.hierarchy.length;
          for (i = 0; i < len; i += 1) {
            _mdf = this.hierarchy[i].finalTransform.mProp._mdf || _mdf;
          }
        }
        if (_mdf || this.pe._mdf || this.p && this.p._mdf || this.px && (this.px._mdf || this.py._mdf || this.pz._mdf) || this.rx._mdf || this.ry._mdf || this.rz._mdf || this.or._mdf || this.a && this.a._mdf) {
          this.mat.reset();
          if (this.hierarchy) {
            len = this.hierarchy.length - 1;
            for (i = len; i >= 0; i -= 1) {
              var mTransf = this.hierarchy[i].finalTransform.mProp;
              this.mat.translate(-mTransf.p.v[0], -mTransf.p.v[1], mTransf.p.v[2]);
              this.mat.rotateX(-mTransf.or.v[0]).rotateY(-mTransf.or.v[1]).rotateZ(mTransf.or.v[2]);
              this.mat.rotateX(-mTransf.rx.v).rotateY(-mTransf.ry.v).rotateZ(mTransf.rz.v);
              this.mat.scale(1 / mTransf.s.v[0], 1 / mTransf.s.v[1], 1 / mTransf.s.v[2]);
              this.mat.translate(mTransf.a.v[0], mTransf.a.v[1], mTransf.a.v[2]);
            }
          }
          if (this.p) {
            this.mat.translate(-this.p.v[0], -this.p.v[1], this.p.v[2]);
          } else {
            this.mat.translate(-this.px.v, -this.py.v, this.pz.v);
          }
          if (this.a) {
            var diffVector;
            if (this.p) {
              diffVector = [this.p.v[0] - this.a.v[0], this.p.v[1] - this.a.v[1], this.p.v[2] - this.a.v[2]];
            } else {
              diffVector = [this.px.v - this.a.v[0], this.py.v - this.a.v[1], this.pz.v - this.a.v[2]];
            }
            var mag = Math.sqrt(Math.pow(diffVector[0], 2) + Math.pow(diffVector[1], 2) + Math.pow(diffVector[2], 2));
            var lookDir = [diffVector[0] / mag, diffVector[1] / mag, diffVector[2] / mag];
            var lookLengthOnXZ = Math.sqrt(lookDir[2] * lookDir[2] + lookDir[0] * lookDir[0]);
            var mRotationX = Math.atan2(lookDir[1], lookLengthOnXZ);
            var mRotationY = Math.atan2(lookDir[0], -lookDir[2]);
            this.mat.rotateY(mRotationY).rotateX(-mRotationX);
          }
          this.mat.rotateX(-this.rx.v).rotateY(-this.ry.v).rotateZ(this.rz.v);
          this.mat.rotateX(-this.or.v[0]).rotateY(-this.or.v[1]).rotateZ(this.or.v[2]);
          this.mat.translate(this.globalData.compSize.w / 2, this.globalData.compSize.h / 2, 0);
          this.mat.translate(0, 0, this.pe.v);
          var hasMatrixChanged = !this._prevMat.equals(this.mat);
          if ((hasMatrixChanged || this.pe._mdf) && this.comp.threeDElements) {
            len = this.comp.threeDElements.length;
            var comp2;
            var perspectiveStyle;
            var containerStyle2;
            for (i = 0; i < len; i += 1) {
              comp2 = this.comp.threeDElements[i];
              if (comp2.type === "3d") {
                if (hasMatrixChanged) {
                  var matValue = this.mat.toCSS();
                  containerStyle2 = comp2.container.style;
                  containerStyle2.transform = matValue;
                  containerStyle2.webkitTransform = matValue;
                }
                if (this.pe._mdf) {
                  perspectiveStyle = comp2.perspectiveElem.style;
                  perspectiveStyle.perspective = this.pe.v + "px";
                  perspectiveStyle.webkitPerspective = this.pe.v + "px";
                }
              }
            }
            this.mat.clone(this._prevMat);
          }
        }
        this._isFirstFrame = false;
      };
      HCameraElement.prototype.prepareFrame = function(num) {
        this.prepareProperties(num, true);
      };
      HCameraElement.prototype.destroy = function() {
      };
      HCameraElement.prototype.getBaseElement = function() {
        return null;
      };
      function HImageElement(data2, globalData2, comp2) {
        this.assetData = globalData2.getAssetData(data2.refId);
        this.initElement(data2, globalData2, comp2);
      }
      extendPrototype([BaseElement, TransformElement, HBaseElement, HSolidElement, HierarchyElement, FrameElement, RenderableElement], HImageElement);
      HImageElement.prototype.createContent = function() {
        var assetPath = this.globalData.getAssetsPath(this.assetData);
        var img = new Image();
        if (this.data.hasMask) {
          this.imageElem = createNS("image");
          this.imageElem.setAttribute("width", this.assetData.w + "px");
          this.imageElem.setAttribute("height", this.assetData.h + "px");
          this.imageElem.setAttributeNS("http://www.w3.org/1999/xlink", "href", assetPath);
          this.layerElement.appendChild(this.imageElem);
          this.baseElement.setAttribute("width", this.assetData.w);
          this.baseElement.setAttribute("height", this.assetData.h);
        } else {
          this.layerElement.appendChild(img);
        }
        img.crossOrigin = "anonymous";
        img.src = assetPath;
        if (this.data.ln) {
          this.baseElement.setAttribute("id", this.data.ln);
        }
      };
      function HybridRendererBase(animationItem, config) {
        this.animationItem = animationItem;
        this.layers = null;
        this.renderedFrame = -1;
        this.renderConfig = {
          className: config && config.className || "",
          imagePreserveAspectRatio: config && config.imagePreserveAspectRatio || "xMidYMid slice",
          hideOnTransparent: !(config && config.hideOnTransparent === false),
          filterSize: {
            width: config && config.filterSize && config.filterSize.width || "400%",
            height: config && config.filterSize && config.filterSize.height || "400%",
            x: config && config.filterSize && config.filterSize.x || "-100%",
            y: config && config.filterSize && config.filterSize.y || "-100%"
          }
        };
        this.globalData = {
          _mdf: false,
          frameNum: -1,
          renderConfig: this.renderConfig
        };
        this.pendingElements = [];
        this.elements = [];
        this.threeDElements = [];
        this.destroyed = false;
        this.camera = null;
        this.supports3d = true;
        this.rendererType = "html";
      }
      extendPrototype([BaseRenderer], HybridRendererBase);
      HybridRendererBase.prototype.buildItem = SVGRenderer.prototype.buildItem;
      HybridRendererBase.prototype.checkPendingElements = function() {
        while (this.pendingElements.length) {
          var element = this.pendingElements.pop();
          element.checkParenting();
        }
      };
      HybridRendererBase.prototype.appendElementInPos = function(element, pos) {
        var newDOMElement = element.getBaseElement();
        if (!newDOMElement) {
          return;
        }
        var layer = this.layers[pos];
        if (!layer.ddd || !this.supports3d) {
          if (this.threeDElements) {
            this.addTo3dContainer(newDOMElement, pos);
          } else {
            var i = 0;
            var nextDOMElement;
            var nextLayer;
            var tmpDOMElement;
            while (i < pos) {
              if (this.elements[i] && this.elements[i] !== true && this.elements[i].getBaseElement) {
                nextLayer = this.elements[i];
                tmpDOMElement = this.layers[i].ddd ? this.getThreeDContainerByPos(i) : nextLayer.getBaseElement();
                nextDOMElement = tmpDOMElement || nextDOMElement;
              }
              i += 1;
            }
            if (nextDOMElement) {
              if (!layer.ddd || !this.supports3d) {
                this.layerElement.insertBefore(newDOMElement, nextDOMElement);
              }
            } else if (!layer.ddd || !this.supports3d) {
              this.layerElement.appendChild(newDOMElement);
            }
          }
        } else {
          this.addTo3dContainer(newDOMElement, pos);
        }
      };
      HybridRendererBase.prototype.createShape = function(data2) {
        if (!this.supports3d) {
          return new SVGShapeElement(data2, this.globalData, this);
        }
        return new HShapeElement(data2, this.globalData, this);
      };
      HybridRendererBase.prototype.createText = function(data2) {
        if (!this.supports3d) {
          return new SVGTextLottieElement(data2, this.globalData, this);
        }
        return new HTextElement(data2, this.globalData, this);
      };
      HybridRendererBase.prototype.createCamera = function(data2) {
        this.camera = new HCameraElement(data2, this.globalData, this);
        return this.camera;
      };
      HybridRendererBase.prototype.createImage = function(data2) {
        if (!this.supports3d) {
          return new IImageElement(data2, this.globalData, this);
        }
        return new HImageElement(data2, this.globalData, this);
      };
      HybridRendererBase.prototype.createSolid = function(data2) {
        if (!this.supports3d) {
          return new ISolidElement(data2, this.globalData, this);
        }
        return new HSolidElement(data2, this.globalData, this);
      };
      HybridRendererBase.prototype.createNull = SVGRenderer.prototype.createNull;
      HybridRendererBase.prototype.getThreeDContainerByPos = function(pos) {
        var i = 0;
        var len = this.threeDElements.length;
        while (i < len) {
          if (this.threeDElements[i].startPos <= pos && this.threeDElements[i].endPos >= pos) {
            return this.threeDElements[i].perspectiveElem;
          }
          i += 1;
        }
        return null;
      };
      HybridRendererBase.prototype.createThreeDContainer = function(pos, type) {
        var perspectiveElem = createTag("div");
        var style;
        var containerStyle2;
        styleDiv(perspectiveElem);
        var container = createTag("div");
        styleDiv(container);
        if (type === "3d") {
          style = perspectiveElem.style;
          style.width = this.globalData.compSize.w + "px";
          style.height = this.globalData.compSize.h + "px";
          var center = "50% 50%";
          style.webkitTransformOrigin = center;
          style.mozTransformOrigin = center;
          style.transformOrigin = center;
          containerStyle2 = container.style;
          var matrix = "matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)";
          containerStyle2.transform = matrix;
          containerStyle2.webkitTransform = matrix;
        }
        perspectiveElem.appendChild(container);
        var threeDContainerData = {
          container,
          perspectiveElem,
          startPos: pos,
          endPos: pos,
          type
        };
        this.threeDElements.push(threeDContainerData);
        return threeDContainerData;
      };
      HybridRendererBase.prototype.build3dContainers = function() {
        var i;
        var len = this.layers.length;
        var lastThreeDContainerData;
        var currentContainer = "";
        for (i = 0; i < len; i += 1) {
          if (this.layers[i].ddd && this.layers[i].ty !== 3) {
            if (currentContainer !== "3d") {
              currentContainer = "3d";
              lastThreeDContainerData = this.createThreeDContainer(i, "3d");
            }
            lastThreeDContainerData.endPos = Math.max(lastThreeDContainerData.endPos, i);
          } else {
            if (currentContainer !== "2d") {
              currentContainer = "2d";
              lastThreeDContainerData = this.createThreeDContainer(i, "2d");
            }
            lastThreeDContainerData.endPos = Math.max(lastThreeDContainerData.endPos, i);
          }
        }
        len = this.threeDElements.length;
        for (i = len - 1; i >= 0; i -= 1) {
          this.resizerElem.appendChild(this.threeDElements[i].perspectiveElem);
        }
      };
      HybridRendererBase.prototype.addTo3dContainer = function(elem2, pos) {
        var i = 0;
        var len = this.threeDElements.length;
        while (i < len) {
          if (pos <= this.threeDElements[i].endPos) {
            var j = this.threeDElements[i].startPos;
            var nextElement;
            while (j < pos) {
              if (this.elements[j] && this.elements[j].getBaseElement) {
                nextElement = this.elements[j].getBaseElement();
              }
              j += 1;
            }
            if (nextElement) {
              this.threeDElements[i].container.insertBefore(elem2, nextElement);
            } else {
              this.threeDElements[i].container.appendChild(elem2);
            }
            break;
          }
          i += 1;
        }
      };
      HybridRendererBase.prototype.configAnimation = function(animData) {
        var resizerElem = createTag("div");
        var wrapper = this.animationItem.wrapper;
        var style = resizerElem.style;
        style.width = animData.w + "px";
        style.height = animData.h + "px";
        this.resizerElem = resizerElem;
        styleDiv(resizerElem);
        style.transformStyle = "flat";
        style.mozTransformStyle = "flat";
        style.webkitTransformStyle = "flat";
        if (this.renderConfig.className) {
          resizerElem.setAttribute("class", this.renderConfig.className);
        }
        wrapper.appendChild(resizerElem);
        style.overflow = "hidden";
        var svg = createNS("svg");
        svg.setAttribute("width", "1");
        svg.setAttribute("height", "1");
        styleDiv(svg);
        this.resizerElem.appendChild(svg);
        var defs = createNS("defs");
        svg.appendChild(defs);
        this.data = animData;
        this.setupGlobalData(animData, svg);
        this.globalData.defs = defs;
        this.layers = animData.layers;
        this.layerElement = this.resizerElem;
        this.build3dContainers();
        this.updateContainerSize();
      };
      HybridRendererBase.prototype.destroy = function() {
        if (this.animationItem.wrapper) {
          this.animationItem.wrapper.innerText = "";
        }
        this.animationItem.container = null;
        this.globalData.defs = null;
        var i;
        var len = this.layers ? this.layers.length : 0;
        for (i = 0; i < len; i += 1) {
          if (this.elements[i] && this.elements[i].destroy) {
            this.elements[i].destroy();
          }
        }
        this.elements.length = 0;
        this.destroyed = true;
        this.animationItem = null;
      };
      HybridRendererBase.prototype.updateContainerSize = function() {
        var elementWidth = this.animationItem.wrapper.offsetWidth;
        var elementHeight = this.animationItem.wrapper.offsetHeight;
        var elementRel = elementWidth / elementHeight;
        var animationRel = this.globalData.compSize.w / this.globalData.compSize.h;
        var sx;
        var sy;
        var tx;
        var ty;
        if (animationRel > elementRel) {
          sx = elementWidth / this.globalData.compSize.w;
          sy = elementWidth / this.globalData.compSize.w;
          tx = 0;
          ty = (elementHeight - this.globalData.compSize.h * (elementWidth / this.globalData.compSize.w)) / 2;
        } else {
          sx = elementHeight / this.globalData.compSize.h;
          sy = elementHeight / this.globalData.compSize.h;
          tx = (elementWidth - this.globalData.compSize.w * (elementHeight / this.globalData.compSize.h)) / 2;
          ty = 0;
        }
        var style = this.resizerElem.style;
        style.webkitTransform = "matrix3d(" + sx + ",0,0,0,0," + sy + ",0,0,0,0,1,0," + tx + "," + ty + ",0,1)";
        style.transform = style.webkitTransform;
      };
      HybridRendererBase.prototype.renderFrame = SVGRenderer.prototype.renderFrame;
      HybridRendererBase.prototype.hide = function() {
        this.resizerElem.style.display = "none";
      };
      HybridRendererBase.prototype.show = function() {
        this.resizerElem.style.display = "block";
      };
      HybridRendererBase.prototype.initItems = function() {
        this.buildAllItems();
        if (this.camera) {
          this.camera.setup();
        } else {
          var cWidth = this.globalData.compSize.w;
          var cHeight = this.globalData.compSize.h;
          var i;
          var len = this.threeDElements.length;
          for (i = 0; i < len; i += 1) {
            var style = this.threeDElements[i].perspectiveElem.style;
            style.webkitPerspective = Math.sqrt(Math.pow(cWidth, 2) + Math.pow(cHeight, 2)) + "px";
            style.perspective = style.webkitPerspective;
          }
        }
      };
      HybridRendererBase.prototype.searchExtraCompositions = function(assets) {
        var i;
        var len = assets.length;
        var floatingContainer = createTag("div");
        for (i = 0; i < len; i += 1) {
          if (assets[i].xt) {
            var comp2 = this.createComp(assets[i], floatingContainer, this.globalData.comp, null);
            comp2.initExpressions();
            this.globalData.projectInterface.registerComposition(comp2);
          }
        }
      };
      function HCompElement(data2, globalData2, comp2) {
        this.layers = data2.layers;
        this.supports3d = !data2.hasMask;
        this.completeLayers = false;
        this.pendingElements = [];
        this.elements = this.layers ? createSizedArray(this.layers.length) : [];
        this.initElement(data2, globalData2, comp2);
        this.tm = data2.tm ? PropertyFactory.getProp(this, data2.tm, 0, globalData2.frameRate, this) : {
          _placeholder: true
        };
      }
      extendPrototype([HybridRendererBase, ICompElement, HBaseElement], HCompElement);
      HCompElement.prototype._createBaseContainerElements = HCompElement.prototype.createContainerElements;
      HCompElement.prototype.createContainerElements = function() {
        this._createBaseContainerElements();
        if (this.data.hasMask) {
          this.svgElement.setAttribute("width", this.data.w);
          this.svgElement.setAttribute("height", this.data.h);
          this.transformedElement = this.baseElement;
        } else {
          this.transformedElement = this.layerElement;
        }
      };
      HCompElement.prototype.addTo3dContainer = function(elem2, pos) {
        var j = 0;
        var nextElement;
        while (j < pos) {
          if (this.elements[j] && this.elements[j].getBaseElement) {
            nextElement = this.elements[j].getBaseElement();
          }
          j += 1;
        }
        if (nextElement) {
          this.layerElement.insertBefore(elem2, nextElement);
        } else {
          this.layerElement.appendChild(elem2);
        }
      };
      HCompElement.prototype.createComp = function(data2) {
        if (!this.supports3d) {
          return new SVGCompElement(data2, this.globalData, this);
        }
        return new HCompElement(data2, this.globalData, this);
      };
      function HybridRenderer(animationItem, config) {
        this.animationItem = animationItem;
        this.layers = null;
        this.renderedFrame = -1;
        this.renderConfig = {
          className: config && config.className || "",
          imagePreserveAspectRatio: config && config.imagePreserveAspectRatio || "xMidYMid slice",
          hideOnTransparent: !(config && config.hideOnTransparent === false),
          filterSize: {
            width: config && config.filterSize && config.filterSize.width || "400%",
            height: config && config.filterSize && config.filterSize.height || "400%",
            x: config && config.filterSize && config.filterSize.x || "-100%",
            y: config && config.filterSize && config.filterSize.y || "-100%"
          },
          runExpressions: !config || config.runExpressions === void 0 || config.runExpressions
        };
        this.globalData = {
          _mdf: false,
          frameNum: -1,
          renderConfig: this.renderConfig
        };
        this.pendingElements = [];
        this.elements = [];
        this.threeDElements = [];
        this.destroyed = false;
        this.camera = null;
        this.supports3d = true;
        this.rendererType = "html";
      }
      extendPrototype([HybridRendererBase], HybridRenderer);
      HybridRenderer.prototype.createComp = function(data2) {
        if (!this.supports3d) {
          return new SVGCompElement(data2, this.globalData, this);
        }
        return new HCompElement(data2, this.globalData, this);
      };
      var CompExpressionInterface = /* @__PURE__ */ function() {
        return function(comp2) {
          function _thisLayerFunction(name2) {
            var i = 0;
            var len = comp2.layers.length;
            while (i < len) {
              if (comp2.layers[i].nm === name2 || comp2.layers[i].ind === name2) {
                return comp2.elements[i].layerInterface;
              }
              i += 1;
            }
            return null;
          }
          Object.defineProperty(_thisLayerFunction, "_name", {
            value: comp2.data.nm
          });
          _thisLayerFunction.layer = _thisLayerFunction;
          _thisLayerFunction.pixelAspect = 1;
          _thisLayerFunction.height = comp2.data.h || comp2.globalData.compSize.h;
          _thisLayerFunction.width = comp2.data.w || comp2.globalData.compSize.w;
          _thisLayerFunction.pixelAspect = 1;
          _thisLayerFunction.frameDuration = 1 / comp2.globalData.frameRate;
          _thisLayerFunction.displayStartTime = 0;
          _thisLayerFunction.numLayers = comp2.layers.length;
          return _thisLayerFunction;
        };
      }();
      function _typeof$2(o) {
        "@babel/helpers - typeof";
        return _typeof$2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
          return typeof o2;
        } : function(o2) {
          return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
        }, _typeof$2(o);
      }
      function seedRandom(pool, math) {
        var global2 = this, width2 = 256, chunks = 6, digits = 52, rngname = "random", startdenom = math.pow(width2, chunks), significance = math.pow(2, digits), overflow = significance * 2, mask2 = width2 - 1, nodecrypto;
        function seedrandom(seed, options, callback) {
          var key2 = [];
          options = options === true ? {
            entropy: true
          } : options || {};
          var shortseed = mixkey(flatten(options.entropy ? [seed, tostring(pool)] : seed === null ? autoseed() : seed, 3), key2);
          var arc4 = new ARC4(key2);
          var prng = function prng2() {
            var n = arc4.g(chunks), d = startdenom, x = 0;
            while (n < significance) {
              n = (n + x) * width2;
              d *= width2;
              x = arc4.g(1);
            }
            while (n >= overflow) {
              n /= 2;
              d /= 2;
              x >>>= 1;
            }
            return (n + x) / d;
          };
          prng.int32 = function() {
            return arc4.g(4) | 0;
          };
          prng.quick = function() {
            return arc4.g(4) / 4294967296;
          };
          prng["double"] = prng;
          mixkey(tostring(arc4.S), pool);
          return (options.pass || callback || function(prng2, seed2, is_math_call, state) {
            if (state) {
              if (state.S) {
                copy(state, arc4);
              }
              prng2.state = function() {
                return copy(arc4, {});
              };
            }
            if (is_math_call) {
              math[rngname] = prng2;
              return seed2;
            } else return prng2;
          })(prng, shortseed, "global" in options ? options.global : this == math, options.state);
        }
        math["seed" + rngname] = seedrandom;
        function ARC4(key2) {
          var t, keylen = key2.length, me = this, i = 0, j = me.i = me.j = 0, s = me.S = [];
          if (!keylen) {
            key2 = [keylen++];
          }
          while (i < width2) {
            s[i] = i++;
          }
          for (i = 0; i < width2; i++) {
            s[i] = s[j = mask2 & j + key2[i % keylen] + (t = s[i])];
            s[j] = t;
          }
          me.g = function(count) {
            var t2, r = 0, i2 = me.i, j2 = me.j, s2 = me.S;
            while (count--) {
              t2 = s2[i2 = mask2 & i2 + 1];
              r = r * width2 + s2[mask2 & (s2[i2] = s2[j2 = mask2 & j2 + t2]) + (s2[j2] = t2)];
            }
            me.i = i2;
            me.j = j2;
            return r;
          };
        }
        function copy(f3, t) {
          t.i = f3.i;
          t.j = f3.j;
          t.S = f3.S.slice();
          return t;
        }
        function flatten(obj, depth) {
          var result = [], typ = _typeof$2(obj), prop;
          if (depth && typ == "object") {
            for (prop in obj) {
              try {
                result.push(flatten(obj[prop], depth - 1));
              } catch (e) {
              }
            }
          }
          return result.length ? result : typ == "string" ? obj : obj + "\0";
        }
        function mixkey(seed, key2) {
          var stringseed = seed + "", smear, j = 0;
          while (j < stringseed.length) {
            key2[mask2 & j] = mask2 & (smear ^= key2[mask2 & j] * 19) + stringseed.charCodeAt(j++);
          }
          return tostring(key2);
        }
        function autoseed() {
          try {
            if (nodecrypto) {
              return tostring(nodecrypto.randomBytes(width2));
            }
            var out = new Uint8Array(width2);
            (global2.crypto || global2.msCrypto).getRandomValues(out);
            return tostring(out);
          } catch (e) {
            var browser = global2.navigator, plugins = browser && browser.plugins;
            return [+/* @__PURE__ */ new Date(), global2, plugins, global2.screen, tostring(pool)];
          }
        }
        function tostring(a) {
          return String.fromCharCode.apply(0, a);
        }
        mixkey(math.random(), pool);
      }
      ;
      function initialize$2(BMMath2) {
        seedRandom([], BMMath2);
      }
      var propTypes = {
        SHAPE: "shape"
      };
      function _typeof$1(o) {
        "@babel/helpers - typeof";
        return _typeof$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
          return typeof o2;
        } : function(o2) {
          return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
        }, _typeof$1(o);
      }
      var ExpressionManager = function() {
        "use strict";
        var ob = {};
        var Math = BMMath;
        var window = null;
        var document = null;
        var XMLHttpRequest = null;
        var fetch = null;
        var frames = null;
        var _lottieGlobal = {};
        initialize$2(BMMath);
        function resetFrame() {
          _lottieGlobal = {};
        }
        function $bm_isInstanceOfArray(arr) {
          return arr.constructor === Array || arr.constructor === Float32Array;
        }
        function isNumerable(tOfV, v) {
          return tOfV === "number" || v instanceof Number || tOfV === "boolean" || tOfV === "string";
        }
        function $bm_neg(a) {
          var tOfA = _typeof$1(a);
          if (tOfA === "number" || a instanceof Number || tOfA === "boolean") {
            return -a;
          }
          if ($bm_isInstanceOfArray(a)) {
            var i;
            var lenA = a.length;
            var retArr = [];
            for (i = 0; i < lenA; i += 1) {
              retArr[i] = -a[i];
            }
            return retArr;
          }
          if (a.propType) {
            return a.v;
          }
          return -a;
        }
        var easeInBez = BezierFactory.getBezierEasing(0.333, 0, 0.833, 0.833, "easeIn").get;
        var easeOutBez = BezierFactory.getBezierEasing(0.167, 0.167, 0.667, 1, "easeOut").get;
        var easeInOutBez = BezierFactory.getBezierEasing(0.33, 0, 0.667, 1, "easeInOut").get;
        function sum(a, b) {
          var tOfA = _typeof$1(a);
          var tOfB = _typeof$1(b);
          if (isNumerable(tOfA, a) && isNumerable(tOfB, b) || tOfA === "string" || tOfB === "string") {
            return a + b;
          }
          if ($bm_isInstanceOfArray(a) && isNumerable(tOfB, b)) {
            a = a.slice(0);
            a[0] += b;
            return a;
          }
          if (isNumerable(tOfA, a) && $bm_isInstanceOfArray(b)) {
            b = b.slice(0);
            b[0] = a + b[0];
            return b;
          }
          if ($bm_isInstanceOfArray(a) && $bm_isInstanceOfArray(b)) {
            var i = 0;
            var lenA = a.length;
            var lenB = b.length;
            var retArr = [];
            while (i < lenA || i < lenB) {
              if ((typeof a[i] === "number" || a[i] instanceof Number) && (typeof b[i] === "number" || b[i] instanceof Number)) {
                retArr[i] = a[i] + b[i];
              } else {
                retArr[i] = b[i] === void 0 ? a[i] : a[i] || b[i];
              }
              i += 1;
            }
            return retArr;
          }
          return 0;
        }
        var add = sum;
        function sub(a, b) {
          var tOfA = _typeof$1(a);
          var tOfB = _typeof$1(b);
          if (isNumerable(tOfA, a) && isNumerable(tOfB, b)) {
            if (tOfA === "string") {
              a = parseInt(a, 10);
            }
            if (tOfB === "string") {
              b = parseInt(b, 10);
            }
            return a - b;
          }
          if ($bm_isInstanceOfArray(a) && isNumerable(tOfB, b)) {
            a = a.slice(0);
            a[0] -= b;
            return a;
          }
          if (isNumerable(tOfA, a) && $bm_isInstanceOfArray(b)) {
            b = b.slice(0);
            b[0] = a - b[0];
            return b;
          }
          if ($bm_isInstanceOfArray(a) && $bm_isInstanceOfArray(b)) {
            var i = 0;
            var lenA = a.length;
            var lenB = b.length;
            var retArr = [];
            while (i < lenA || i < lenB) {
              if ((typeof a[i] === "number" || a[i] instanceof Number) && (typeof b[i] === "number" || b[i] instanceof Number)) {
                retArr[i] = a[i] - b[i];
              } else {
                retArr[i] = b[i] === void 0 ? a[i] : a[i] || b[i];
              }
              i += 1;
            }
            return retArr;
          }
          return 0;
        }
        function mul(a, b) {
          var tOfA = _typeof$1(a);
          var tOfB = _typeof$1(b);
          var arr;
          if (isNumerable(tOfA, a) && isNumerable(tOfB, b)) {
            return a * b;
          }
          var i;
          var len;
          if ($bm_isInstanceOfArray(a) && isNumerable(tOfB, b)) {
            len = a.length;
            arr = createTypedArray("float32", len);
            for (i = 0; i < len; i += 1) {
              arr[i] = a[i] * b;
            }
            return arr;
          }
          if (isNumerable(tOfA, a) && $bm_isInstanceOfArray(b)) {
            len = b.length;
            arr = createTypedArray("float32", len);
            for (i = 0; i < len; i += 1) {
              arr[i] = a * b[i];
            }
            return arr;
          }
          return 0;
        }
        function div(a, b) {
          var tOfA = _typeof$1(a);
          var tOfB = _typeof$1(b);
          var arr;
          if (isNumerable(tOfA, a) && isNumerable(tOfB, b)) {
            return a / b;
          }
          var i;
          var len;
          if ($bm_isInstanceOfArray(a) && isNumerable(tOfB, b)) {
            len = a.length;
            arr = createTypedArray("float32", len);
            for (i = 0; i < len; i += 1) {
              arr[i] = a[i] / b;
            }
            return arr;
          }
          if (isNumerable(tOfA, a) && $bm_isInstanceOfArray(b)) {
            len = b.length;
            arr = createTypedArray("float32", len);
            for (i = 0; i < len; i += 1) {
              arr[i] = a / b[i];
            }
            return arr;
          }
          return 0;
        }
        function mod(a, b) {
          if (typeof a === "string") {
            a = parseInt(a, 10);
          }
          if (typeof b === "string") {
            b = parseInt(b, 10);
          }
          return a % b;
        }
        var $bm_sum = sum;
        var $bm_sub = sub;
        var $bm_mul = mul;
        var $bm_div = div;
        var $bm_mod = mod;
        function clamp(num, min, max) {
          if (min > max) {
            var mm = max;
            max = min;
            min = mm;
          }
          return Math.min(Math.max(num, min), max);
        }
        function radiansToDegrees(val2) {
          return val2 / degToRads;
        }
        var radians_to_degrees = radiansToDegrees;
        function degreesToRadians(val2) {
          return val2 * degToRads;
        }
        var degrees_to_radians = radiansToDegrees;
        var helperLengthArray = [0, 0, 0, 0, 0, 0];
        function length(arr1, arr2) {
          if (typeof arr1 === "number" || arr1 instanceof Number) {
            arr2 = arr2 || 0;
            return Math.abs(arr1 - arr2);
          }
          if (!arr2) {
            arr2 = helperLengthArray;
          }
          var i;
          var len = Math.min(arr1.length, arr2.length);
          var addedLength = 0;
          for (i = 0; i < len; i += 1) {
            addedLength += Math.pow(arr2[i] - arr1[i], 2);
          }
          return Math.sqrt(addedLength);
        }
        function normalize(vec) {
          return div(vec, length(vec));
        }
        function rgbToHsl(val2) {
          var r = val2[0];
          var g = val2[1];
          var b = val2[2];
          var max = Math.max(r, g, b);
          var min = Math.min(r, g, b);
          var h;
          var s;
          var l = (max + min) / 2;
          if (max === min) {
            h = 0;
            s = 0;
          } else {
            var d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            switch (max) {
              case r:
                h = (g - b) / d + (g < b ? 6 : 0);
                break;
              case g:
                h = (b - r) / d + 2;
                break;
              case b:
                h = (r - g) / d + 4;
                break;
              default:
                break;
            }
            h /= 6;
          }
          return [h, s, l, val2[3]];
        }
        function hue2rgb(p, q, t) {
          if (t < 0) t += 1;
          if (t > 1) t -= 1;
          if (t < 1 / 6) return p + (q - p) * 6 * t;
          if (t < 1 / 2) return q;
          if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
          return p;
        }
        function hslToRgb(val2) {
          var h = val2[0];
          var s = val2[1];
          var l = val2[2];
          var r;
          var g;
          var b;
          if (s === 0) {
            r = l;
            b = l;
            g = l;
          } else {
            var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            var p = 2 * l - q;
            r = hue2rgb(p, q, h + 1 / 3);
            g = hue2rgb(p, q, h);
            b = hue2rgb(p, q, h - 1 / 3);
          }
          return [r, g, b, val2[3]];
        }
        function linear(t, tMin, tMax, value1, value22) {
          if (value1 === void 0 || value22 === void 0) {
            value1 = tMin;
            value22 = tMax;
            tMin = 0;
            tMax = 1;
          }
          if (tMax < tMin) {
            var _tMin = tMax;
            tMax = tMin;
            tMin = _tMin;
          }
          if (t <= tMin) {
            return value1;
          }
          if (t >= tMax) {
            return value22;
          }
          var perc = tMax === tMin ? 0 : (t - tMin) / (tMax - tMin);
          if (!value1.length) {
            return value1 + (value22 - value1) * perc;
          }
          var i;
          var len = value1.length;
          var arr = createTypedArray("float32", len);
          for (i = 0; i < len; i += 1) {
            arr[i] = value1[i] + (value22[i] - value1[i]) * perc;
          }
          return arr;
        }
        function random(min, max) {
          if (max === void 0) {
            if (min === void 0) {
              min = 0;
              max = 1;
            } else {
              max = min;
              min = void 0;
            }
          }
          if (max.length) {
            var i;
            var len = max.length;
            if (!min) {
              min = createTypedArray("float32", len);
            }
            var arr = createTypedArray("float32", len);
            var rnd = BMMath.random();
            for (i = 0; i < len; i += 1) {
              arr[i] = min[i] + rnd * (max[i] - min[i]);
            }
            return arr;
          }
          if (min === void 0) {
            min = 0;
          }
          var rndm = BMMath.random();
          return min + rndm * (max - min);
        }
        function createPath(points, inTangents, outTangents, closed) {
          var i;
          var len = points.length;
          var path = shapePool.newElement();
          path.setPathData(!!closed, len);
          var arrPlaceholder = [0, 0];
          var inVertexPoint;
          var outVertexPoint;
          for (i = 0; i < len; i += 1) {
            inVertexPoint = inTangents && inTangents[i] ? inTangents[i] : arrPlaceholder;
            outVertexPoint = outTangents && outTangents[i] ? outTangents[i] : arrPlaceholder;
            path.setTripleAt(points[i][0], points[i][1], outVertexPoint[0] + points[i][0], outVertexPoint[1] + points[i][1], inVertexPoint[0] + points[i][0], inVertexPoint[1] + points[i][1], i, true);
          }
          return path;
        }
        function initiateExpression(elem, data, property) {
          function noOp(_value) {
            return _value;
          }
          if (!elem.globalData.renderConfig.runExpressions) {
            return noOp;
          }
          var val = data.x;
          var needsVelocity = /velocity(?![\w\d])/.test(val);
          var _needsRandom = val.indexOf("random") !== -1;
          var elemType = elem.data.ty;
          var transform;
          var $bm_transform;
          var content;
          var effect;
          var thisProperty = property;
          thisProperty._name = elem.data.nm;
          thisProperty.valueAtTime = thisProperty.getValueAtTime;
          Object.defineProperty(thisProperty, "value", {
            get: function get() {
              return thisProperty.v;
            }
          });
          elem.comp.frameDuration = 1 / elem.comp.globalData.frameRate;
          elem.comp.displayStartTime = 0;
          var inPoint = elem.data.ip / elem.comp.globalData.frameRate;
          var outPoint = elem.data.op / elem.comp.globalData.frameRate;
          var width = elem.data.sw ? elem.data.sw : 0;
          var height = elem.data.sh ? elem.data.sh : 0;
          var name = elem.data.nm;
          var loopIn;
          var loop_in;
          var loopOut;
          var loop_out;
          var smooth;
          var toWorld;
          var fromWorld;
          var fromComp;
          var toComp;
          var fromCompToSurface;
          var position;
          var rotation;
          var anchorPoint;
          var scale;
          var thisLayer;
          var thisComp;
          var mask;
          var valueAtTime;
          var velocityAtTime;
          var scoped_bm_rt;
          var expression_function = eval("[function _expression_function(){" + val + ";scoped_bm_rt=$bm_rt}]")[0];
          var numKeys = property.kf ? data.k.length : 0;
          var active = !this.data || this.data.hd !== true;
          var wiggle = (function wiggle2(freq, amp) {
            var iWiggle;
            var j;
            var lenWiggle = this.pv.length ? this.pv.length : 1;
            var addedAmps = createTypedArray("float32", lenWiggle);
            freq = 5;
            var iterations = Math.floor(time * freq);
            iWiggle = 0;
            j = 0;
            while (iWiggle < iterations) {
              for (j = 0; j < lenWiggle; j += 1) {
                addedAmps[j] += -amp + amp * 2 * BMMath.random();
              }
              iWiggle += 1;
            }
            var periods = time * freq;
            var perc = periods - Math.floor(periods);
            var arr = createTypedArray("float32", lenWiggle);
            if (lenWiggle > 1) {
              for (j = 0; j < lenWiggle; j += 1) {
                arr[j] = this.pv[j] + addedAmps[j] + (-amp + amp * 2 * BMMath.random()) * perc;
              }
              return arr;
            }
            return this.pv + addedAmps[0] + (-amp + amp * 2 * BMMath.random()) * perc;
          }).bind(this);
          if (thisProperty.loopIn) {
            loopIn = thisProperty.loopIn.bind(thisProperty);
            loop_in = loopIn;
          }
          if (thisProperty.loopOut) {
            loopOut = thisProperty.loopOut.bind(thisProperty);
            loop_out = loopOut;
          }
          if (thisProperty.smooth) {
            smooth = thisProperty.smooth.bind(thisProperty);
          }
          function loopInDuration(type, duration) {
            return loopIn(type, duration, true);
          }
          function loopOutDuration(type, duration) {
            return loopOut(type, duration, true);
          }
          if (this.getValueAtTime) {
            valueAtTime = this.getValueAtTime.bind(this);
          }
          if (this.getVelocityAtTime) {
            velocityAtTime = this.getVelocityAtTime.bind(this);
          }
          var comp = elem.comp.globalData.projectInterface.bind(elem.comp.globalData.projectInterface);
          function lookAt(elem1, elem2) {
            var fVec = [elem2[0] - elem1[0], elem2[1] - elem1[1], elem2[2] - elem1[2]];
            var pitch = Math.atan2(fVec[0], Math.sqrt(fVec[1] * fVec[1] + fVec[2] * fVec[2])) / degToRads;
            var yaw = -Math.atan2(fVec[1], fVec[2]) / degToRads;
            return [yaw, pitch, 0];
          }
          function easeOut(t, tMin, tMax, val1, val2) {
            return applyEase(easeOutBez, t, tMin, tMax, val1, val2);
          }
          function easeIn(t, tMin, tMax, val1, val2) {
            return applyEase(easeInBez, t, tMin, tMax, val1, val2);
          }
          function ease(t, tMin, tMax, val1, val2) {
            return applyEase(easeInOutBez, t, tMin, tMax, val1, val2);
          }
          function applyEase(fn, t, tMin, tMax, val1, val2) {
            if (val1 === void 0) {
              val1 = tMin;
              val2 = tMax;
            } else {
              t = (t - tMin) / (tMax - tMin);
            }
            if (t > 1) {
              t = 1;
            } else if (t < 0) {
              t = 0;
            }
            var mult = fn(t);
            if ($bm_isInstanceOfArray(val1)) {
              var iKey;
              var lenKey = val1.length;
              var arr = createTypedArray("float32", lenKey);
              for (iKey = 0; iKey < lenKey; iKey += 1) {
                arr[iKey] = (val2[iKey] - val1[iKey]) * mult + val1[iKey];
              }
              return arr;
            }
            return (val2 - val1) * mult + val1;
          }
          function nearestKey(time2) {
            var iKey;
            var lenKey = data.k.length;
            var index2;
            var keyTime;
            if (!data.k.length || typeof data.k[0] === "number") {
              index2 = 0;
              keyTime = 0;
            } else {
              index2 = -1;
              time2 *= elem.comp.globalData.frameRate;
              if (time2 < data.k[0].t) {
                index2 = 1;
                keyTime = data.k[0].t;
              } else {
                for (iKey = 0; iKey < lenKey - 1; iKey += 1) {
                  if (time2 === data.k[iKey].t) {
                    index2 = iKey + 1;
                    keyTime = data.k[iKey].t;
                    break;
                  } else if (time2 > data.k[iKey].t && time2 < data.k[iKey + 1].t) {
                    if (time2 - data.k[iKey].t > data.k[iKey + 1].t - time2) {
                      index2 = iKey + 2;
                      keyTime = data.k[iKey + 1].t;
                    } else {
                      index2 = iKey + 1;
                      keyTime = data.k[iKey].t;
                    }
                    break;
                  }
                }
                if (index2 === -1) {
                  index2 = iKey + 1;
                  keyTime = data.k[iKey].t;
                }
              }
            }
            var obKey = {};
            obKey.index = index2;
            obKey.time = keyTime / elem.comp.globalData.frameRate;
            return obKey;
          }
          function key(ind) {
            var obKey;
            var iKey;
            var lenKey;
            if (!data.k.length || typeof data.k[0] === "number") {
              throw new Error("The property has no keyframe at index " + ind);
            }
            ind -= 1;
            obKey = {
              time: data.k[ind].t / elem.comp.globalData.frameRate,
              value: []
            };
            var arr = Object.prototype.hasOwnProperty.call(data.k[ind], "s") ? data.k[ind].s : data.k[ind - 1].e;
            lenKey = arr.length;
            for (iKey = 0; iKey < lenKey; iKey += 1) {
              obKey[iKey] = arr[iKey];
              obKey.value[iKey] = arr[iKey];
            }
            return obKey;
          }
          function framesToTime(fr, fps) {
            if (!fps) {
              fps = elem.comp.globalData.frameRate;
            }
            return fr / fps;
          }
          function timeToFrames(t, fps) {
            if (!t && t !== 0) {
              t = time;
            }
            if (!fps) {
              fps = elem.comp.globalData.frameRate;
            }
            return t * fps;
          }
          function seedRandom(seed) {
            BMMath.seedrandom(randSeed + seed);
          }
          function sourceRectAtTime() {
            return elem.sourceRectAtTime();
          }
          function substring(init, end) {
            if (typeof value === "string") {
              if (end === void 0) {
                return value.substring(init);
              }
              return value.substring(init, end);
            }
            return "";
          }
          function substr(init, end) {
            if (typeof value === "string") {
              if (end === void 0) {
                return value.substr(init);
              }
              return value.substr(init, end);
            }
            return "";
          }
          function posterizeTime(framesPerSecond) {
            time = framesPerSecond === 0 ? 0 : Math.floor(time * framesPerSecond) / framesPerSecond;
            value = valueAtTime(time);
          }
          var time;
          var velocity;
          var value;
          var text;
          var textIndex;
          var textTotal;
          var selectorValue;
          var index = elem.data.ind;
          var hasParent = !!(elem.hierarchy && elem.hierarchy.length);
          var parent;
          var randSeed = Math.floor(Math.random() * 1e6);
          var globalData = elem.globalData;
          function executeExpression(_value) {
            value = _value;
            if (this.frameExpressionId === elem.globalData.frameId && this.propType !== "textSelector") {
              return value;
            }
            if (this.propType === "textSelector") {
              textIndex = this.textIndex;
              textTotal = this.textTotal;
              selectorValue = this.selectorValue;
            }
            if (!thisLayer) {
              text = elem.layerInterface.text;
              thisLayer = elem.layerInterface;
              thisComp = elem.comp.compInterface;
              toWorld = thisLayer.toWorld.bind(thisLayer);
              fromWorld = thisLayer.fromWorld.bind(thisLayer);
              fromComp = thisLayer.fromComp.bind(thisLayer);
              toComp = thisLayer.toComp.bind(thisLayer);
              mask = thisLayer.mask ? thisLayer.mask.bind(thisLayer) : null;
              fromCompToSurface = fromComp;
            }
            if (!transform) {
              transform = elem.layerInterface("ADBE Transform Group");
              $bm_transform = transform;
              if (transform) {
                anchorPoint = transform.anchorPoint;
              }
            }
            if (elemType === 4 && !content) {
              content = thisLayer("ADBE Root Vectors Group");
            }
            if (!effect) {
              effect = thisLayer(4);
            }
            hasParent = !!(elem.hierarchy && elem.hierarchy.length);
            if (hasParent && !parent) {
              parent = elem.hierarchy[0].layerInterface;
            }
            time = this.comp.renderedFrame / this.comp.globalData.frameRate;
            if (_needsRandom) {
              seedRandom(randSeed + time);
            }
            if (needsVelocity) {
              velocity = velocityAtTime(time);
            }
            expression_function();
            this.frameExpressionId = elem.globalData.frameId;
            scoped_bm_rt = scoped_bm_rt.propType === propTypes.SHAPE ? scoped_bm_rt.v : scoped_bm_rt;
            return scoped_bm_rt;
          }
          executeExpression.__preventDeadCodeRemoval = [$bm_transform, anchorPoint, time, velocity, inPoint, outPoint, width, height, name, loop_in, loop_out, smooth, toComp, fromCompToSurface, toWorld, fromWorld, mask, position, rotation, scale, thisComp, numKeys, active, wiggle, loopInDuration, loopOutDuration, comp, lookAt, easeOut, easeIn, ease, nearestKey, key, text, textIndex, textTotal, selectorValue, framesToTime, timeToFrames, sourceRectAtTime, substring, substr, posterizeTime, index, globalData];
          return executeExpression;
        }
        ob.initiateExpression = initiateExpression;
        ob.__preventDeadCodeRemoval = [window, document, XMLHttpRequest, fetch, frames, $bm_neg, add, $bm_sum, $bm_sub, $bm_mul, $bm_div, $bm_mod, clamp, radians_to_degrees, degreesToRadians, degrees_to_radians, normalize, rgbToHsl, hslToRgb, linear, random, createPath, _lottieGlobal];
        ob.resetFrame = resetFrame;
        return ob;
      }();
      var Expressions = function() {
        var ob2 = {};
        ob2.initExpressions = initExpressions;
        ob2.resetFrame = ExpressionManager.resetFrame;
        function initExpressions(animation) {
          var stackCount = 0;
          var registers = [];
          function pushExpression() {
            stackCount += 1;
          }
          function popExpression() {
            stackCount -= 1;
            if (stackCount === 0) {
              releaseInstances();
            }
          }
          function registerExpressionProperty(expression) {
            if (registers.indexOf(expression) === -1) {
              registers.push(expression);
            }
          }
          function releaseInstances() {
            var i;
            var len = registers.length;
            for (i = 0; i < len; i += 1) {
              registers[i].release();
            }
            registers.length = 0;
          }
          animation.renderer.compInterface = CompExpressionInterface(animation.renderer);
          animation.renderer.globalData.projectInterface.registerComposition(animation.renderer);
          animation.renderer.globalData.pushExpression = pushExpression;
          animation.renderer.globalData.popExpression = popExpression;
          animation.renderer.globalData.registerExpressionProperty = registerExpressionProperty;
        }
        return ob2;
      }();
      var MaskManagerInterface = function() {
        function MaskInterface(mask2, data2) {
          this._mask = mask2;
          this._data = data2;
        }
        Object.defineProperty(MaskInterface.prototype, "maskPath", {
          get: function get() {
            if (this._mask.prop.k) {
              this._mask.prop.getValue();
            }
            return this._mask.prop;
          }
        });
        Object.defineProperty(MaskInterface.prototype, "maskOpacity", {
          get: function get() {
            if (this._mask.op.k) {
              this._mask.op.getValue();
            }
            return this._mask.op.v * 100;
          }
        });
        var MaskManager = function MaskManager2(maskManager) {
          var _masksInterfaces = createSizedArray(maskManager.viewData.length);
          var i;
          var len = maskManager.viewData.length;
          for (i = 0; i < len; i += 1) {
            _masksInterfaces[i] = new MaskInterface(maskManager.viewData[i], maskManager.masksProperties[i]);
          }
          var maskFunction = function maskFunction2(name2) {
            i = 0;
            while (i < len) {
              if (maskManager.masksProperties[i].nm === name2) {
                return _masksInterfaces[i];
              }
              i += 1;
            }
            return null;
          };
          return maskFunction;
        };
        return MaskManager;
      }();
      var ExpressionPropertyInterface = /* @__PURE__ */ function() {
        var defaultUnidimensionalValue = {
          pv: 0,
          v: 0,
          mult: 1
        };
        var defaultMultidimensionalValue = {
          pv: [0, 0, 0],
          v: [0, 0, 0],
          mult: 1
        };
        function completeProperty(expressionValue, property2, type) {
          Object.defineProperty(expressionValue, "velocity", {
            get: function get() {
              return property2.getVelocityAtTime(property2.comp.currentFrame);
            }
          });
          expressionValue.numKeys = property2.keyframes ? property2.keyframes.length : 0;
          expressionValue.key = function(pos) {
            if (!expressionValue.numKeys) {
              return 0;
            }
            var value3 = "";
            if ("s" in property2.keyframes[pos - 1]) {
              value3 = property2.keyframes[pos - 1].s;
            } else if ("e" in property2.keyframes[pos - 2]) {
              value3 = property2.keyframes[pos - 2].e;
            } else {
              value3 = property2.keyframes[pos - 2].s;
            }
            var valueProp = type === "unidimensional" ? new Number(value3) : Object.assign({}, value3);
            valueProp.time = property2.keyframes[pos - 1].t / property2.elem.comp.globalData.frameRate;
            valueProp.value = type === "unidimensional" ? value3[0] : value3;
            return valueProp;
          };
          expressionValue.valueAtTime = property2.getValueAtTime;
          expressionValue.speedAtTime = property2.getSpeedAtTime;
          expressionValue.velocityAtTime = property2.getVelocityAtTime;
          expressionValue.propertyGroup = property2.propertyGroup;
        }
        function UnidimensionalPropertyInterface(property2) {
          if (!property2 || !("pv" in property2)) {
            property2 = defaultUnidimensionalValue;
          }
          var mult = 1 / property2.mult;
          var val2 = property2.pv * mult;
          var expressionValue = new Number(val2);
          expressionValue.value = val2;
          completeProperty(expressionValue, property2, "unidimensional");
          return function() {
            if (property2.k) {
              property2.getValue();
            }
            val2 = property2.v * mult;
            if (expressionValue.value !== val2) {
              expressionValue = new Number(val2);
              expressionValue.value = val2;
              expressionValue[0] = val2;
              completeProperty(expressionValue, property2, "unidimensional");
            }
            return expressionValue;
          };
        }
        function MultidimensionalPropertyInterface(property2) {
          if (!property2 || !("pv" in property2)) {
            property2 = defaultMultidimensionalValue;
          }
          var mult = 1 / property2.mult;
          var len = property2.data && property2.data.l || property2.pv.length;
          var expressionValue = createTypedArray("float32", len);
          var arrValue = createTypedArray("float32", len);
          expressionValue.value = arrValue;
          completeProperty(expressionValue, property2, "multidimensional");
          return function() {
            if (property2.k) {
              property2.getValue();
            }
            for (var i = 0; i < len; i += 1) {
              arrValue[i] = property2.v[i] * mult;
              expressionValue[i] = arrValue[i];
            }
            return expressionValue;
          };
        }
        function defaultGetter() {
          return defaultUnidimensionalValue;
        }
        return function(property2) {
          if (!property2) {
            return defaultGetter;
          }
          if (property2.propType === "unidimensional") {
            return UnidimensionalPropertyInterface(property2);
          }
          return MultidimensionalPropertyInterface(property2);
        };
      }();
      var TransformExpressionInterface = /* @__PURE__ */ function() {
        return function(transform2) {
          function _thisFunction(name2) {
            switch (name2) {
              case "scale":
              case "Scale":
              case "ADBE Scale":
              case 6:
                return _thisFunction.scale;
              case "rotation":
              case "Rotation":
              case "ADBE Rotation":
              case "ADBE Rotate Z":
              case 10:
                return _thisFunction.rotation;
              case "ADBE Rotate X":
                return _thisFunction.xRotation;
              case "ADBE Rotate Y":
                return _thisFunction.yRotation;
              case "position":
              case "Position":
              case "ADBE Position":
              case 2:
                return _thisFunction.position;
              case "ADBE Position_0":
                return _thisFunction.xPosition;
              case "ADBE Position_1":
                return _thisFunction.yPosition;
              case "ADBE Position_2":
                return _thisFunction.zPosition;
              case "anchorPoint":
              case "AnchorPoint":
              case "Anchor Point":
              case "ADBE AnchorPoint":
              case 1:
                return _thisFunction.anchorPoint;
              case "opacity":
              case "Opacity":
              case 11:
                return _thisFunction.opacity;
              default:
                return null;
            }
          }
          Object.defineProperty(_thisFunction, "rotation", {
            get: ExpressionPropertyInterface(transform2.r || transform2.rz)
          });
          Object.defineProperty(_thisFunction, "zRotation", {
            get: ExpressionPropertyInterface(transform2.rz || transform2.r)
          });
          Object.defineProperty(_thisFunction, "xRotation", {
            get: ExpressionPropertyInterface(transform2.rx)
          });
          Object.defineProperty(_thisFunction, "yRotation", {
            get: ExpressionPropertyInterface(transform2.ry)
          });
          Object.defineProperty(_thisFunction, "scale", {
            get: ExpressionPropertyInterface(transform2.s)
          });
          var _px;
          var _py;
          var _pz;
          var _transformFactory;
          if (transform2.p) {
            _transformFactory = ExpressionPropertyInterface(transform2.p);
          } else {
            _px = ExpressionPropertyInterface(transform2.px);
            _py = ExpressionPropertyInterface(transform2.py);
            if (transform2.pz) {
              _pz = ExpressionPropertyInterface(transform2.pz);
            }
          }
          Object.defineProperty(_thisFunction, "position", {
            get: function get() {
              if (transform2.p) {
                return _transformFactory();
              }
              return [_px(), _py(), _pz ? _pz() : 0];
            }
          });
          Object.defineProperty(_thisFunction, "xPosition", {
            get: ExpressionPropertyInterface(transform2.px)
          });
          Object.defineProperty(_thisFunction, "yPosition", {
            get: ExpressionPropertyInterface(transform2.py)
          });
          Object.defineProperty(_thisFunction, "zPosition", {
            get: ExpressionPropertyInterface(transform2.pz)
          });
          Object.defineProperty(_thisFunction, "anchorPoint", {
            get: ExpressionPropertyInterface(transform2.a)
          });
          Object.defineProperty(_thisFunction, "opacity", {
            get: ExpressionPropertyInterface(transform2.o)
          });
          Object.defineProperty(_thisFunction, "skew", {
            get: ExpressionPropertyInterface(transform2.sk)
          });
          Object.defineProperty(_thisFunction, "skewAxis", {
            get: ExpressionPropertyInterface(transform2.sa)
          });
          Object.defineProperty(_thisFunction, "orientation", {
            get: ExpressionPropertyInterface(transform2.or)
          });
          return _thisFunction;
        };
      }();
      var LayerExpressionInterface = /* @__PURE__ */ function() {
        function getMatrix(time2) {
          var toWorldMat = new Matrix();
          if (time2 !== void 0) {
            var propMatrix = this._elem.finalTransform.mProp.getValueAtTime(time2);
            propMatrix.clone(toWorldMat);
          } else {
            var transformMat = this._elem.finalTransform.mProp;
            transformMat.applyToMatrix(toWorldMat);
          }
          return toWorldMat;
        }
        function toWorldVec(arr, time2) {
          var toWorldMat = this.getMatrix(time2);
          toWorldMat.props[12] = 0;
          toWorldMat.props[13] = 0;
          toWorldMat.props[14] = 0;
          return this.applyPoint(toWorldMat, arr);
        }
        function toWorld2(arr, time2) {
          var toWorldMat = this.getMatrix(time2);
          return this.applyPoint(toWorldMat, arr);
        }
        function fromWorldVec(arr, time2) {
          var toWorldMat = this.getMatrix(time2);
          toWorldMat.props[12] = 0;
          toWorldMat.props[13] = 0;
          toWorldMat.props[14] = 0;
          return this.invertPoint(toWorldMat, arr);
        }
        function fromWorld2(arr, time2) {
          var toWorldMat = this.getMatrix(time2);
          return this.invertPoint(toWorldMat, arr);
        }
        function applyPoint(matrix, arr) {
          if (this._elem.hierarchy && this._elem.hierarchy.length) {
            var i;
            var len = this._elem.hierarchy.length;
            for (i = 0; i < len; i += 1) {
              this._elem.hierarchy[i].finalTransform.mProp.applyToMatrix(matrix);
            }
          }
          return matrix.applyToPointArray(arr[0], arr[1], arr[2] || 0);
        }
        function invertPoint(matrix, arr) {
          if (this._elem.hierarchy && this._elem.hierarchy.length) {
            var i;
            var len = this._elem.hierarchy.length;
            for (i = 0; i < len; i += 1) {
              this._elem.hierarchy[i].finalTransform.mProp.applyToMatrix(matrix);
            }
          }
          return matrix.inversePoint(arr);
        }
        function fromComp2(arr) {
          var toWorldMat = new Matrix();
          toWorldMat.reset();
          this._elem.finalTransform.mProp.applyToMatrix(toWorldMat);
          if (this._elem.hierarchy && this._elem.hierarchy.length) {
            var i;
            var len = this._elem.hierarchy.length;
            for (i = 0; i < len; i += 1) {
              this._elem.hierarchy[i].finalTransform.mProp.applyToMatrix(toWorldMat);
            }
            return toWorldMat.inversePoint(arr);
          }
          return toWorldMat.inversePoint(arr);
        }
        function sampleImage() {
          return [1, 1, 1, 1];
        }
        return function(elem2) {
          var transformInterface;
          function _registerMaskInterface(maskManager) {
            _thisLayerFunction.mask = new MaskManagerInterface(maskManager, elem2);
          }
          function _registerEffectsInterface(effects) {
            _thisLayerFunction.effect = effects;
          }
          function _thisLayerFunction(name2) {
            switch (name2) {
              case "ADBE Root Vectors Group":
              case "Contents":
              case 2:
                return _thisLayerFunction.shapeInterface;
              case 1:
              case 6:
              case "Transform":
              case "transform":
              case "ADBE Transform Group":
                return transformInterface;
              case 4:
              case "ADBE Effect Parade":
              case "effects":
              case "Effects":
                return _thisLayerFunction.effect;
              case "ADBE Text Properties":
                return _thisLayerFunction.textInterface;
              default:
                return null;
            }
          }
          _thisLayerFunction.getMatrix = getMatrix;
          _thisLayerFunction.invertPoint = invertPoint;
          _thisLayerFunction.applyPoint = applyPoint;
          _thisLayerFunction.toWorld = toWorld2;
          _thisLayerFunction.toWorldVec = toWorldVec;
          _thisLayerFunction.fromWorld = fromWorld2;
          _thisLayerFunction.fromWorldVec = fromWorldVec;
          _thisLayerFunction.toComp = toWorld2;
          _thisLayerFunction.fromComp = fromComp2;
          _thisLayerFunction.sampleImage = sampleImage;
          _thisLayerFunction.sourceRectAtTime = elem2.sourceRectAtTime.bind(elem2);
          _thisLayerFunction._elem = elem2;
          transformInterface = TransformExpressionInterface(elem2.finalTransform.mProp);
          var anchorPointDescriptor = getDescriptor(transformInterface, "anchorPoint");
          Object.defineProperties(_thisLayerFunction, {
            hasParent: {
              get: function get() {
                return elem2.hierarchy.length;
              }
            },
            parent: {
              get: function get() {
                return elem2.hierarchy[0].layerInterface;
              }
            },
            rotation: getDescriptor(transformInterface, "rotation"),
            scale: getDescriptor(transformInterface, "scale"),
            position: getDescriptor(transformInterface, "position"),
            opacity: getDescriptor(transformInterface, "opacity"),
            anchorPoint: anchorPointDescriptor,
            anchor_point: anchorPointDescriptor,
            transform: {
              get: function get() {
                return transformInterface;
              }
            },
            active: {
              get: function get() {
                return elem2.isInRange;
              }
            }
          });
          _thisLayerFunction.startTime = elem2.data.st;
          _thisLayerFunction.index = elem2.data.ind;
          _thisLayerFunction.source = elem2.data.refId;
          _thisLayerFunction.height = elem2.data.ty === 0 ? elem2.data.h : 100;
          _thisLayerFunction.width = elem2.data.ty === 0 ? elem2.data.w : 100;
          _thisLayerFunction.inPoint = elem2.data.ip / elem2.comp.globalData.frameRate;
          _thisLayerFunction.outPoint = elem2.data.op / elem2.comp.globalData.frameRate;
          _thisLayerFunction._name = elem2.data.nm;
          _thisLayerFunction.registerMaskInterface = _registerMaskInterface;
          _thisLayerFunction.registerEffectsInterface = _registerEffectsInterface;
          return _thisLayerFunction;
        };
      }();
      var propertyGroupFactory = /* @__PURE__ */ function() {
        return function(interfaceFunction, parentPropertyGroup) {
          return function(val2) {
            val2 = val2 === void 0 ? 1 : val2;
            if (val2 <= 0) {
              return interfaceFunction;
            }
            return parentPropertyGroup(val2 - 1);
          };
        };
      }();
      var PropertyInterface = /* @__PURE__ */ function() {
        return function(propertyName, propertyGroup) {
          var interfaceFunction = {
            _name: propertyName
          };
          function _propertyGroup(val2) {
            val2 = val2 === void 0 ? 1 : val2;
            if (val2 <= 0) {
              return interfaceFunction;
            }
            return propertyGroup(val2 - 1);
          }
          return _propertyGroup;
        };
      }();
      var EffectsExpressionInterface = /* @__PURE__ */ function() {
        var ob2 = {
          createEffectsInterface
        };
        function createEffectsInterface(elem2, propertyGroup) {
          if (elem2.effectsManager) {
            var effectElements = [];
            var effectsData = elem2.data.ef;
            var i;
            var len = elem2.effectsManager.effectElements.length;
            for (i = 0; i < len; i += 1) {
              effectElements.push(createGroupInterface(effectsData[i], elem2.effectsManager.effectElements[i], propertyGroup, elem2));
            }
            var effects = elem2.data.ef || [];
            var groupInterface = function groupInterface2(name2) {
              i = 0;
              len = effects.length;
              while (i < len) {
                if (name2 === effects[i].nm || name2 === effects[i].mn || name2 === effects[i].ix) {
                  return effectElements[i];
                }
                i += 1;
              }
              return null;
            };
            Object.defineProperty(groupInterface, "numProperties", {
              get: function get() {
                return effects.length;
              }
            });
            return groupInterface;
          }
          return null;
        }
        function createGroupInterface(data2, elements, propertyGroup, elem2) {
          function groupInterface(name2) {
            var effects = data2.ef;
            var i2 = 0;
            var len2 = effects.length;
            while (i2 < len2) {
              if (name2 === effects[i2].nm || name2 === effects[i2].mn || name2 === effects[i2].ix) {
                if (effects[i2].ty === 5) {
                  return effectElements[i2];
                }
                return effectElements[i2]();
              }
              i2 += 1;
            }
            throw new Error();
          }
          var _propertyGroup = propertyGroupFactory(groupInterface, propertyGroup);
          var effectElements = [];
          var i;
          var len = data2.ef.length;
          for (i = 0; i < len; i += 1) {
            if (data2.ef[i].ty === 5) {
              effectElements.push(createGroupInterface(data2.ef[i], elements.effectElements[i], elements.effectElements[i].propertyGroup, elem2));
            } else {
              effectElements.push(createValueInterface(elements.effectElements[i], data2.ef[i].ty, elem2, _propertyGroup));
            }
          }
          if (data2.mn === "ADBE Color Control") {
            Object.defineProperty(groupInterface, "color", {
              get: function get() {
                return effectElements[0]();
              }
            });
          }
          Object.defineProperties(groupInterface, {
            numProperties: {
              get: function get() {
                return data2.np;
              }
            },
            _name: {
              value: data2.nm
            },
            propertyGroup: {
              value: _propertyGroup
            }
          });
          groupInterface.enabled = data2.en !== 0;
          groupInterface.active = groupInterface.enabled;
          return groupInterface;
        }
        function createValueInterface(element, type, elem2, propertyGroup) {
          var expressionProperty = ExpressionPropertyInterface(element.p);
          function interfaceFunction() {
            if (type === 10) {
              return elem2.comp.compInterface(element.p.v);
            }
            return expressionProperty();
          }
          if (element.p.setGroupProperty) {
            element.p.setGroupProperty(PropertyInterface("", propertyGroup));
          }
          return interfaceFunction;
        }
        return ob2;
      }();
      var ShapePathInterface = /* @__PURE__ */ function() {
        return function pathInterfaceFactory(shape, view, propertyGroup) {
          var prop = view.sh;
          function interfaceFunction(val2) {
            if (val2 === "Shape" || val2 === "shape" || val2 === "Path" || val2 === "path" || val2 === "ADBE Vector Shape" || val2 === 2) {
              return interfaceFunction.path;
            }
            return null;
          }
          var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
          prop.setGroupProperty(PropertyInterface("Path", _propertyGroup));
          Object.defineProperties(interfaceFunction, {
            path: {
              get: function get() {
                if (prop.k) {
                  prop.getValue();
                }
                return prop;
              }
            },
            shape: {
              get: function get() {
                if (prop.k) {
                  prop.getValue();
                }
                return prop;
              }
            },
            _name: {
              value: shape.nm
            },
            ix: {
              value: shape.ix
            },
            propertyIndex: {
              value: shape.ix
            },
            mn: {
              value: shape.mn
            },
            propertyGroup: {
              value: propertyGroup
            }
          });
          return interfaceFunction;
        };
      }();
      var ShapeExpressionInterface = /* @__PURE__ */ function() {
        function iterateElements(shapes, view, propertyGroup) {
          var arr = [];
          var i;
          var len = shapes ? shapes.length : 0;
          for (i = 0; i < len; i += 1) {
            if (shapes[i].ty === "gr") {
              arr.push(groupInterfaceFactory(shapes[i], view[i], propertyGroup));
            } else if (shapes[i].ty === "fl") {
              arr.push(fillInterfaceFactory(shapes[i], view[i], propertyGroup));
            } else if (shapes[i].ty === "st") {
              arr.push(strokeInterfaceFactory(shapes[i], view[i], propertyGroup));
            } else if (shapes[i].ty === "tm") {
              arr.push(trimInterfaceFactory(shapes[i], view[i], propertyGroup));
            } else if (shapes[i].ty === "tr") {
            } else if (shapes[i].ty === "el") {
              arr.push(ellipseInterfaceFactory(shapes[i], view[i], propertyGroup));
            } else if (shapes[i].ty === "sr") {
              arr.push(starInterfaceFactory(shapes[i], view[i], propertyGroup));
            } else if (shapes[i].ty === "sh") {
              arr.push(ShapePathInterface(shapes[i], view[i], propertyGroup));
            } else if (shapes[i].ty === "rc") {
              arr.push(rectInterfaceFactory(shapes[i], view[i], propertyGroup));
            } else if (shapes[i].ty === "rd") {
              arr.push(roundedInterfaceFactory(shapes[i], view[i], propertyGroup));
            } else if (shapes[i].ty === "rp") {
              arr.push(repeaterInterfaceFactory(shapes[i], view[i], propertyGroup));
            } else if (shapes[i].ty === "gf") {
              arr.push(gradientFillInterfaceFactory(shapes[i], view[i], propertyGroup));
            } else {
              arr.push(defaultInterfaceFactory(shapes[i], view[i], propertyGroup));
            }
          }
          return arr;
        }
        function contentsInterfaceFactory(shape, view, propertyGroup) {
          var interfaces2;
          var interfaceFunction = function _interfaceFunction(value3) {
            var i = 0;
            var len = interfaces2.length;
            while (i < len) {
              if (interfaces2[i]._name === value3 || interfaces2[i].mn === value3 || interfaces2[i].propertyIndex === value3 || interfaces2[i].ix === value3 || interfaces2[i].ind === value3) {
                return interfaces2[i];
              }
              i += 1;
            }
            if (typeof value3 === "number") {
              return interfaces2[value3 - 1];
            }
            return null;
          };
          interfaceFunction.propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
          interfaces2 = iterateElements(shape.it, view.it, interfaceFunction.propertyGroup);
          interfaceFunction.numProperties = interfaces2.length;
          var transformInterface = transformInterfaceFactory(shape.it[shape.it.length - 1], view.it[view.it.length - 1], interfaceFunction.propertyGroup);
          interfaceFunction.transform = transformInterface;
          interfaceFunction.propertyIndex = shape.cix;
          interfaceFunction._name = shape.nm;
          return interfaceFunction;
        }
        function groupInterfaceFactory(shape, view, propertyGroup) {
          var interfaceFunction = function _interfaceFunction(value3) {
            switch (value3) {
              case "ADBE Vectors Group":
              case "Contents":
              case 2:
                return interfaceFunction.content;
              // Not necessary for now. Keeping them here in case a new case appears
              // case 'ADBE Vector Transform Group':
              // case 3:
              default:
                return interfaceFunction.transform;
            }
          };
          interfaceFunction.propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
          var content2 = contentsInterfaceFactory(shape, view, interfaceFunction.propertyGroup);
          var transformInterface = transformInterfaceFactory(shape.it[shape.it.length - 1], view.it[view.it.length - 1], interfaceFunction.propertyGroup);
          interfaceFunction.content = content2;
          interfaceFunction.transform = transformInterface;
          Object.defineProperty(interfaceFunction, "_name", {
            get: function get() {
              return shape.nm;
            }
          });
          interfaceFunction.numProperties = shape.np;
          interfaceFunction.propertyIndex = shape.ix;
          interfaceFunction.nm = shape.nm;
          interfaceFunction.mn = shape.mn;
          return interfaceFunction;
        }
        function fillInterfaceFactory(shape, view, propertyGroup) {
          function interfaceFunction(val2) {
            if (val2 === "Color" || val2 === "color") {
              return interfaceFunction.color;
            }
            if (val2 === "Opacity" || val2 === "opacity") {
              return interfaceFunction.opacity;
            }
            return null;
          }
          Object.defineProperties(interfaceFunction, {
            color: {
              get: ExpressionPropertyInterface(view.c)
            },
            opacity: {
              get: ExpressionPropertyInterface(view.o)
            },
            _name: {
              value: shape.nm
            },
            mn: {
              value: shape.mn
            }
          });
          view.c.setGroupProperty(PropertyInterface("Color", propertyGroup));
          view.o.setGroupProperty(PropertyInterface("Opacity", propertyGroup));
          return interfaceFunction;
        }
        function gradientFillInterfaceFactory(shape, view, propertyGroup) {
          function interfaceFunction(val2) {
            if (val2 === "Start Point" || val2 === "start point") {
              return interfaceFunction.startPoint;
            }
            if (val2 === "End Point" || val2 === "end point") {
              return interfaceFunction.endPoint;
            }
            if (val2 === "Opacity" || val2 === "opacity") {
              return interfaceFunction.opacity;
            }
            return null;
          }
          Object.defineProperties(interfaceFunction, {
            startPoint: {
              get: ExpressionPropertyInterface(view.s)
            },
            endPoint: {
              get: ExpressionPropertyInterface(view.e)
            },
            opacity: {
              get: ExpressionPropertyInterface(view.o)
            },
            type: {
              get: function get() {
                return "a";
              }
            },
            _name: {
              value: shape.nm
            },
            mn: {
              value: shape.mn
            }
          });
          view.s.setGroupProperty(PropertyInterface("Start Point", propertyGroup));
          view.e.setGroupProperty(PropertyInterface("End Point", propertyGroup));
          view.o.setGroupProperty(PropertyInterface("Opacity", propertyGroup));
          return interfaceFunction;
        }
        function defaultInterfaceFactory() {
          function interfaceFunction() {
            return null;
          }
          return interfaceFunction;
        }
        function strokeInterfaceFactory(shape, view, propertyGroup) {
          var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
          var _dashPropertyGroup = propertyGroupFactory(dashOb, _propertyGroup);
          function addPropertyToDashOb(i2) {
            Object.defineProperty(dashOb, shape.d[i2].nm, {
              get: ExpressionPropertyInterface(view.d.dataProps[i2].p)
            });
          }
          var i;
          var len = shape.d ? shape.d.length : 0;
          var dashOb = {};
          for (i = 0; i < len; i += 1) {
            addPropertyToDashOb(i);
            view.d.dataProps[i].p.setGroupProperty(_dashPropertyGroup);
          }
          function interfaceFunction(val2) {
            if (val2 === "Color" || val2 === "color") {
              return interfaceFunction.color;
            }
            if (val2 === "Opacity" || val2 === "opacity") {
              return interfaceFunction.opacity;
            }
            if (val2 === "Stroke Width" || val2 === "stroke width") {
              return interfaceFunction.strokeWidth;
            }
            return null;
          }
          Object.defineProperties(interfaceFunction, {
            color: {
              get: ExpressionPropertyInterface(view.c)
            },
            opacity: {
              get: ExpressionPropertyInterface(view.o)
            },
            strokeWidth: {
              get: ExpressionPropertyInterface(view.w)
            },
            dash: {
              get: function get() {
                return dashOb;
              }
            },
            _name: {
              value: shape.nm
            },
            mn: {
              value: shape.mn
            }
          });
          view.c.setGroupProperty(PropertyInterface("Color", _propertyGroup));
          view.o.setGroupProperty(PropertyInterface("Opacity", _propertyGroup));
          view.w.setGroupProperty(PropertyInterface("Stroke Width", _propertyGroup));
          return interfaceFunction;
        }
        function trimInterfaceFactory(shape, view, propertyGroup) {
          function interfaceFunction(val2) {
            if (val2 === shape.e.ix || val2 === "End" || val2 === "end") {
              return interfaceFunction.end;
            }
            if (val2 === shape.s.ix) {
              return interfaceFunction.start;
            }
            if (val2 === shape.o.ix) {
              return interfaceFunction.offset;
            }
            return null;
          }
          var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
          interfaceFunction.propertyIndex = shape.ix;
          view.s.setGroupProperty(PropertyInterface("Start", _propertyGroup));
          view.e.setGroupProperty(PropertyInterface("End", _propertyGroup));
          view.o.setGroupProperty(PropertyInterface("Offset", _propertyGroup));
          interfaceFunction.propertyIndex = shape.ix;
          interfaceFunction.propertyGroup = propertyGroup;
          Object.defineProperties(interfaceFunction, {
            start: {
              get: ExpressionPropertyInterface(view.s)
            },
            end: {
              get: ExpressionPropertyInterface(view.e)
            },
            offset: {
              get: ExpressionPropertyInterface(view.o)
            },
            _name: {
              value: shape.nm
            }
          });
          interfaceFunction.mn = shape.mn;
          return interfaceFunction;
        }
        function transformInterfaceFactory(shape, view, propertyGroup) {
          function interfaceFunction(value3) {
            if (shape.a.ix === value3 || value3 === "Anchor Point") {
              return interfaceFunction.anchorPoint;
            }
            if (shape.o.ix === value3 || value3 === "Opacity") {
              return interfaceFunction.opacity;
            }
            if (shape.p.ix === value3 || value3 === "Position") {
              return interfaceFunction.position;
            }
            if (shape.r.ix === value3 || value3 === "Rotation" || value3 === "ADBE Vector Rotation") {
              return interfaceFunction.rotation;
            }
            if (shape.s.ix === value3 || value3 === "Scale") {
              return interfaceFunction.scale;
            }
            if (shape.sk && shape.sk.ix === value3 || value3 === "Skew") {
              return interfaceFunction.skew;
            }
            if (shape.sa && shape.sa.ix === value3 || value3 === "Skew Axis") {
              return interfaceFunction.skewAxis;
            }
            return null;
          }
          var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
          view.transform.mProps.o.setGroupProperty(PropertyInterface("Opacity", _propertyGroup));
          view.transform.mProps.p.setGroupProperty(PropertyInterface("Position", _propertyGroup));
          view.transform.mProps.a.setGroupProperty(PropertyInterface("Anchor Point", _propertyGroup));
          view.transform.mProps.s.setGroupProperty(PropertyInterface("Scale", _propertyGroup));
          view.transform.mProps.r.setGroupProperty(PropertyInterface("Rotation", _propertyGroup));
          if (view.transform.mProps.sk) {
            view.transform.mProps.sk.setGroupProperty(PropertyInterface("Skew", _propertyGroup));
            view.transform.mProps.sa.setGroupProperty(PropertyInterface("Skew Angle", _propertyGroup));
          }
          view.transform.op.setGroupProperty(PropertyInterface("Opacity", _propertyGroup));
          Object.defineProperties(interfaceFunction, {
            opacity: {
              get: ExpressionPropertyInterface(view.transform.mProps.o)
            },
            position: {
              get: ExpressionPropertyInterface(view.transform.mProps.p)
            },
            anchorPoint: {
              get: ExpressionPropertyInterface(view.transform.mProps.a)
            },
            scale: {
              get: ExpressionPropertyInterface(view.transform.mProps.s)
            },
            rotation: {
              get: ExpressionPropertyInterface(view.transform.mProps.r)
            },
            skew: {
              get: ExpressionPropertyInterface(view.transform.mProps.sk)
            },
            skewAxis: {
              get: ExpressionPropertyInterface(view.transform.mProps.sa)
            },
            _name: {
              value: shape.nm
            }
          });
          interfaceFunction.ty = "tr";
          interfaceFunction.mn = shape.mn;
          interfaceFunction.propertyGroup = propertyGroup;
          return interfaceFunction;
        }
        function ellipseInterfaceFactory(shape, view, propertyGroup) {
          function interfaceFunction(value3) {
            if (shape.p.ix === value3) {
              return interfaceFunction.position;
            }
            if (shape.s.ix === value3) {
              return interfaceFunction.size;
            }
            return null;
          }
          var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
          interfaceFunction.propertyIndex = shape.ix;
          var prop = view.sh.ty === "tm" ? view.sh.prop : view.sh;
          prop.s.setGroupProperty(PropertyInterface("Size", _propertyGroup));
          prop.p.setGroupProperty(PropertyInterface("Position", _propertyGroup));
          Object.defineProperties(interfaceFunction, {
            size: {
              get: ExpressionPropertyInterface(prop.s)
            },
            position: {
              get: ExpressionPropertyInterface(prop.p)
            },
            _name: {
              value: shape.nm
            }
          });
          interfaceFunction.mn = shape.mn;
          return interfaceFunction;
        }
        function starInterfaceFactory(shape, view, propertyGroup) {
          function interfaceFunction(value3) {
            if (shape.p.ix === value3) {
              return interfaceFunction.position;
            }
            if (shape.r.ix === value3) {
              return interfaceFunction.rotation;
            }
            if (shape.pt.ix === value3) {
              return interfaceFunction.points;
            }
            if (shape.or.ix === value3 || value3 === "ADBE Vector Star Outer Radius") {
              return interfaceFunction.outerRadius;
            }
            if (shape.os.ix === value3) {
              return interfaceFunction.outerRoundness;
            }
            if (shape.ir && (shape.ir.ix === value3 || value3 === "ADBE Vector Star Inner Radius")) {
              return interfaceFunction.innerRadius;
            }
            if (shape.is && shape.is.ix === value3) {
              return interfaceFunction.innerRoundness;
            }
            return null;
          }
          var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
          var prop = view.sh.ty === "tm" ? view.sh.prop : view.sh;
          interfaceFunction.propertyIndex = shape.ix;
          prop.or.setGroupProperty(PropertyInterface("Outer Radius", _propertyGroup));
          prop.os.setGroupProperty(PropertyInterface("Outer Roundness", _propertyGroup));
          prop.pt.setGroupProperty(PropertyInterface("Points", _propertyGroup));
          prop.p.setGroupProperty(PropertyInterface("Position", _propertyGroup));
          prop.r.setGroupProperty(PropertyInterface("Rotation", _propertyGroup));
          if (shape.ir) {
            prop.ir.setGroupProperty(PropertyInterface("Inner Radius", _propertyGroup));
            prop.is.setGroupProperty(PropertyInterface("Inner Roundness", _propertyGroup));
          }
          Object.defineProperties(interfaceFunction, {
            position: {
              get: ExpressionPropertyInterface(prop.p)
            },
            rotation: {
              get: ExpressionPropertyInterface(prop.r)
            },
            points: {
              get: ExpressionPropertyInterface(prop.pt)
            },
            outerRadius: {
              get: ExpressionPropertyInterface(prop.or)
            },
            outerRoundness: {
              get: ExpressionPropertyInterface(prop.os)
            },
            innerRadius: {
              get: ExpressionPropertyInterface(prop.ir)
            },
            innerRoundness: {
              get: ExpressionPropertyInterface(prop.is)
            },
            _name: {
              value: shape.nm
            }
          });
          interfaceFunction.mn = shape.mn;
          return interfaceFunction;
        }
        function rectInterfaceFactory(shape, view, propertyGroup) {
          function interfaceFunction(value3) {
            if (shape.p.ix === value3) {
              return interfaceFunction.position;
            }
            if (shape.r.ix === value3) {
              return interfaceFunction.roundness;
            }
            if (shape.s.ix === value3 || value3 === "Size" || value3 === "ADBE Vector Rect Size") {
              return interfaceFunction.size;
            }
            return null;
          }
          var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
          var prop = view.sh.ty === "tm" ? view.sh.prop : view.sh;
          interfaceFunction.propertyIndex = shape.ix;
          prop.p.setGroupProperty(PropertyInterface("Position", _propertyGroup));
          prop.s.setGroupProperty(PropertyInterface("Size", _propertyGroup));
          prop.r.setGroupProperty(PropertyInterface("Rotation", _propertyGroup));
          Object.defineProperties(interfaceFunction, {
            position: {
              get: ExpressionPropertyInterface(prop.p)
            },
            roundness: {
              get: ExpressionPropertyInterface(prop.r)
            },
            size: {
              get: ExpressionPropertyInterface(prop.s)
            },
            _name: {
              value: shape.nm
            }
          });
          interfaceFunction.mn = shape.mn;
          return interfaceFunction;
        }
        function roundedInterfaceFactory(shape, view, propertyGroup) {
          function interfaceFunction(value3) {
            if (shape.r.ix === value3 || value3 === "Round Corners 1") {
              return interfaceFunction.radius;
            }
            return null;
          }
          var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
          var prop = view;
          interfaceFunction.propertyIndex = shape.ix;
          prop.rd.setGroupProperty(PropertyInterface("Radius", _propertyGroup));
          Object.defineProperties(interfaceFunction, {
            radius: {
              get: ExpressionPropertyInterface(prop.rd)
            },
            _name: {
              value: shape.nm
            }
          });
          interfaceFunction.mn = shape.mn;
          return interfaceFunction;
        }
        function repeaterInterfaceFactory(shape, view, propertyGroup) {
          function interfaceFunction(value3) {
            if (shape.c.ix === value3 || value3 === "Copies") {
              return interfaceFunction.copies;
            }
            if (shape.o.ix === value3 || value3 === "Offset") {
              return interfaceFunction.offset;
            }
            return null;
          }
          var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
          var prop = view;
          interfaceFunction.propertyIndex = shape.ix;
          prop.c.setGroupProperty(PropertyInterface("Copies", _propertyGroup));
          prop.o.setGroupProperty(PropertyInterface("Offset", _propertyGroup));
          Object.defineProperties(interfaceFunction, {
            copies: {
              get: ExpressionPropertyInterface(prop.c)
            },
            offset: {
              get: ExpressionPropertyInterface(prop.o)
            },
            _name: {
              value: shape.nm
            }
          });
          interfaceFunction.mn = shape.mn;
          return interfaceFunction;
        }
        return function(shapes, view, propertyGroup) {
          var interfaces2;
          function _interfaceFunction(value3) {
            if (typeof value3 === "number") {
              value3 = value3 === void 0 ? 1 : value3;
              if (value3 === 0) {
                return propertyGroup;
              }
              return interfaces2[value3 - 1];
            }
            var i = 0;
            var len = interfaces2.length;
            while (i < len) {
              if (interfaces2[i]._name === value3) {
                return interfaces2[i];
              }
              i += 1;
            }
            return null;
          }
          function parentGroupWrapper() {
            return propertyGroup;
          }
          _interfaceFunction.propertyGroup = propertyGroupFactory(_interfaceFunction, parentGroupWrapper);
          interfaces2 = iterateElements(shapes, view, _interfaceFunction.propertyGroup);
          _interfaceFunction.numProperties = interfaces2.length;
          _interfaceFunction._name = "Contents";
          return _interfaceFunction;
        };
      }();
      var TextExpressionInterface = /* @__PURE__ */ function() {
        return function(elem2) {
          var _sourceText;
          function _thisLayerFunction(name2) {
            switch (name2) {
              case "ADBE Text Document":
                return _thisLayerFunction.sourceText;
              default:
                return null;
            }
          }
          Object.defineProperty(_thisLayerFunction, "sourceText", {
            get: function get() {
              elem2.textProperty.getValue();
              var stringValue = elem2.textProperty.currentData.t;
              if (!_sourceText || stringValue !== _sourceText.value) {
                _sourceText = new String(stringValue);
                _sourceText.value = stringValue || new String(stringValue);
                Object.defineProperty(_sourceText, "style", {
                  get: function get2() {
                    return {
                      fillColor: elem2.textProperty.currentData.fc
                    };
                  }
                });
              }
              return _sourceText;
            }
          });
          return _thisLayerFunction;
        };
      }();
      function _typeof(o) {
        "@babel/helpers - typeof";
        return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
          return typeof o2;
        } : function(o2) {
          return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
        }, _typeof(o);
      }
      var FootageInterface = /* @__PURE__ */ function() {
        var outlineInterfaceFactory = function outlineInterfaceFactory2(elem2) {
          var currentPropertyName = "";
          var currentProperty = elem2.getFootageData();
          function init() {
            currentPropertyName = "";
            currentProperty = elem2.getFootageData();
            return searchProperty;
          }
          function searchProperty(value3) {
            if (currentProperty[value3]) {
              currentPropertyName = value3;
              currentProperty = currentProperty[value3];
              if (_typeof(currentProperty) === "object") {
                return searchProperty;
              }
              return currentProperty;
            }
            var propertyNameIndex = value3.indexOf(currentPropertyName);
            if (propertyNameIndex !== -1) {
              var index2 = parseInt(value3.substr(propertyNameIndex + currentPropertyName.length), 10);
              currentProperty = currentProperty[index2];
              if (_typeof(currentProperty) === "object") {
                return searchProperty;
              }
              return currentProperty;
            }
            return "";
          }
          return init;
        };
        var dataInterfaceFactory = function dataInterfaceFactory2(elem2) {
          function interfaceFunction(value3) {
            if (value3 === "Outline") {
              return interfaceFunction.outlineInterface();
            }
            return null;
          }
          interfaceFunction._name = "Outline";
          interfaceFunction.outlineInterface = outlineInterfaceFactory(elem2);
          return interfaceFunction;
        };
        return function(elem2) {
          function _interfaceFunction(value3) {
            if (value3 === "Data") {
              return _interfaceFunction.dataInterface;
            }
            return null;
          }
          _interfaceFunction._name = "Data";
          _interfaceFunction.dataInterface = dataInterfaceFactory(elem2);
          return _interfaceFunction;
        };
      }();
      var interfaces = {
        layer: LayerExpressionInterface,
        effects: EffectsExpressionInterface,
        comp: CompExpressionInterface,
        shape: ShapeExpressionInterface,
        text: TextExpressionInterface,
        footage: FootageInterface
      };
      function getInterface(type) {
        return interfaces[type] || null;
      }
      var expressionHelpers = /* @__PURE__ */ function() {
        function searchExpressions(elem2, data2, prop) {
          if (data2.x) {
            prop.k = true;
            prop.x = true;
            prop.initiateExpression = ExpressionManager.initiateExpression;
            prop.effectsSequence.push(prop.initiateExpression(elem2, data2, prop).bind(prop));
          }
        }
        function getValueAtTime(frameNum) {
          frameNum *= this.elem.globalData.frameRate;
          frameNum -= this.offsetTime;
          if (frameNum !== this._cachingAtTime.lastFrame) {
            this._cachingAtTime.lastIndex = this._cachingAtTime.lastFrame < frameNum ? this._cachingAtTime.lastIndex : 0;
            this._cachingAtTime.value = this.interpolateValue(frameNum, this._cachingAtTime);
            this._cachingAtTime.lastFrame = frameNum;
          }
          return this._cachingAtTime.value;
        }
        function getSpeedAtTime(frameNum) {
          var delta = -0.01;
          var v1 = this.getValueAtTime(frameNum);
          var v2 = this.getValueAtTime(frameNum + delta);
          var speed = 0;
          if (v1.length) {
            var i;
            for (i = 0; i < v1.length; i += 1) {
              speed += Math.pow(v2[i] - v1[i], 2);
            }
            speed = Math.sqrt(speed) * 100;
          } else {
            speed = 0;
          }
          return speed;
        }
        function getVelocityAtTime(frameNum) {
          if (this.vel !== void 0) {
            return this.vel;
          }
          var delta = -1e-3;
          var v1 = this.getValueAtTime(frameNum);
          var v2 = this.getValueAtTime(frameNum + delta);
          var velocity2;
          if (v1.length) {
            velocity2 = createTypedArray("float32", v1.length);
            var i;
            for (i = 0; i < v1.length; i += 1) {
              velocity2[i] = (v2[i] - v1[i]) / delta;
            }
          } else {
            velocity2 = (v2 - v1) / delta;
          }
          return velocity2;
        }
        function getStaticValueAtTime() {
          return this.pv;
        }
        function setGroupProperty(propertyGroup) {
          this.propertyGroup = propertyGroup;
        }
        return {
          searchExpressions,
          getSpeedAtTime,
          getVelocityAtTime,
          getValueAtTime,
          getStaticValueAtTime,
          setGroupProperty
        };
      }();
      function addPropertyDecorator() {
        function loopOut2(type, duration, durationFlag) {
          if (!this.k || !this.keyframes) {
            return this.pv;
          }
          type = type ? type.toLowerCase() : "";
          var currentFrame = this.comp.renderedFrame;
          var keyframes = this.keyframes;
          var lastKeyFrame = keyframes[keyframes.length - 1].t;
          if (currentFrame <= lastKeyFrame) {
            return this.pv;
          }
          var cycleDuration;
          var firstKeyFrame;
          if (!durationFlag) {
            if (!duration || duration > keyframes.length - 1) {
              duration = keyframes.length - 1;
            }
            firstKeyFrame = keyframes[keyframes.length - 1 - duration].t;
            cycleDuration = lastKeyFrame - firstKeyFrame;
          } else {
            if (!duration) {
              cycleDuration = Math.max(0, lastKeyFrame - this.elem.data.ip);
            } else {
              cycleDuration = Math.abs(lastKeyFrame - this.elem.comp.globalData.frameRate * duration);
            }
            firstKeyFrame = lastKeyFrame - cycleDuration;
          }
          var i;
          var len;
          var ret;
          if (type === "pingpong") {
            var iterations = Math.floor((currentFrame - firstKeyFrame) / cycleDuration);
            if (iterations % 2 !== 0) {
              return this.getValueAtTime((cycleDuration - (currentFrame - firstKeyFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0);
            }
          } else if (type === "offset") {
            var initV = this.getValueAtTime(firstKeyFrame / this.comp.globalData.frameRate, 0);
            var endV = this.getValueAtTime(lastKeyFrame / this.comp.globalData.frameRate, 0);
            var current = this.getValueAtTime(((currentFrame - firstKeyFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0);
            var repeats = Math.floor((currentFrame - firstKeyFrame) / cycleDuration);
            if (this.pv.length) {
              ret = new Array(initV.length);
              len = ret.length;
              for (i = 0; i < len; i += 1) {
                ret[i] = (endV[i] - initV[i]) * repeats + current[i];
              }
              return ret;
            }
            return (endV - initV) * repeats + current;
          } else if (type === "continue") {
            var lastValue = this.getValueAtTime(lastKeyFrame / this.comp.globalData.frameRate, 0);
            var nextLastValue = this.getValueAtTime((lastKeyFrame - 1e-3) / this.comp.globalData.frameRate, 0);
            if (this.pv.length) {
              ret = new Array(lastValue.length);
              len = ret.length;
              for (i = 0; i < len; i += 1) {
                ret[i] = lastValue[i] + (lastValue[i] - nextLastValue[i]) * ((currentFrame - lastKeyFrame) / this.comp.globalData.frameRate) / 5e-4;
              }
              return ret;
            }
            return lastValue + (lastValue - nextLastValue) * ((currentFrame - lastKeyFrame) / 1e-3);
          }
          return this.getValueAtTime(((currentFrame - firstKeyFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0);
        }
        function loopIn2(type, duration, durationFlag) {
          if (!this.k) {
            return this.pv;
          }
          type = type ? type.toLowerCase() : "";
          var currentFrame = this.comp.renderedFrame;
          var keyframes = this.keyframes;
          var firstKeyFrame = keyframes[0].t;
          if (currentFrame >= firstKeyFrame) {
            return this.pv;
          }
          var cycleDuration;
          var lastKeyFrame;
          if (!durationFlag) {
            if (!duration || duration > keyframes.length - 1) {
              duration = keyframes.length - 1;
            }
            lastKeyFrame = keyframes[duration].t;
            cycleDuration = lastKeyFrame - firstKeyFrame;
          } else {
            if (!duration) {
              cycleDuration = Math.max(0, this.elem.data.op - firstKeyFrame);
            } else {
              cycleDuration = Math.abs(this.elem.comp.globalData.frameRate * duration);
            }
            lastKeyFrame = firstKeyFrame + cycleDuration;
          }
          var i;
          var len;
          var ret;
          if (type === "pingpong") {
            var iterations = Math.floor((firstKeyFrame - currentFrame) / cycleDuration);
            if (iterations % 2 === 0) {
              return this.getValueAtTime(((firstKeyFrame - currentFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0);
            }
          } else if (type === "offset") {
            var initV = this.getValueAtTime(firstKeyFrame / this.comp.globalData.frameRate, 0);
            var endV = this.getValueAtTime(lastKeyFrame / this.comp.globalData.frameRate, 0);
            var current = this.getValueAtTime((cycleDuration - (firstKeyFrame - currentFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0);
            var repeats = Math.floor((firstKeyFrame - currentFrame) / cycleDuration) + 1;
            if (this.pv.length) {
              ret = new Array(initV.length);
              len = ret.length;
              for (i = 0; i < len; i += 1) {
                ret[i] = current[i] - (endV[i] - initV[i]) * repeats;
              }
              return ret;
            }
            return current - (endV - initV) * repeats;
          } else if (type === "continue") {
            var firstValue = this.getValueAtTime(firstKeyFrame / this.comp.globalData.frameRate, 0);
            var nextFirstValue = this.getValueAtTime((firstKeyFrame + 1e-3) / this.comp.globalData.frameRate, 0);
            if (this.pv.length) {
              ret = new Array(firstValue.length);
              len = ret.length;
              for (i = 0; i < len; i += 1) {
                ret[i] = firstValue[i] + (firstValue[i] - nextFirstValue[i]) * (firstKeyFrame - currentFrame) / 1e-3;
              }
              return ret;
            }
            return firstValue + (firstValue - nextFirstValue) * (firstKeyFrame - currentFrame) / 1e-3;
          }
          return this.getValueAtTime((cycleDuration - ((firstKeyFrame - currentFrame) % cycleDuration + firstKeyFrame)) / this.comp.globalData.frameRate, 0);
        }
        function smooth2(width2, samples) {
          if (!this.k) {
            return this.pv;
          }
          width2 = (width2 || 0.4) * 0.5;
          samples = Math.floor(samples || 5);
          if (samples <= 1) {
            return this.pv;
          }
          var currentTime = this.comp.renderedFrame / this.comp.globalData.frameRate;
          var initFrame2 = currentTime - width2;
          var endFrame = currentTime + width2;
          var sampleFrequency = samples > 1 ? (endFrame - initFrame2) / (samples - 1) : 1;
          var i = 0;
          var j = 0;
          var value3;
          if (this.pv.length) {
            value3 = createTypedArray("float32", this.pv.length);
          } else {
            value3 = 0;
          }
          var sampleValue;
          while (i < samples) {
            sampleValue = this.getValueAtTime(initFrame2 + i * sampleFrequency);
            if (this.pv.length) {
              for (j = 0; j < this.pv.length; j += 1) {
                value3[j] += sampleValue[j];
              }
            } else {
              value3 += sampleValue;
            }
            i += 1;
          }
          if (this.pv.length) {
            for (j = 0; j < this.pv.length; j += 1) {
              value3[j] /= samples;
            }
          } else {
            value3 /= samples;
          }
          return value3;
        }
        function getTransformValueAtTime(time2) {
          if (!this._transformCachingAtTime) {
            this._transformCachingAtTime = {
              v: new Matrix()
            };
          }
          var matrix = this._transformCachingAtTime.v;
          matrix.cloneFromProps(this.pre.props);
          if (this.appliedTransformations < 1) {
            var anchor = this.a.getValueAtTime(time2);
            matrix.translate(-anchor[0] * this.a.mult, -anchor[1] * this.a.mult, anchor[2] * this.a.mult);
          }
          if (this.appliedTransformations < 2) {
            var scale3 = this.s.getValueAtTime(time2);
            matrix.scale(scale3[0] * this.s.mult, scale3[1] * this.s.mult, scale3[2] * this.s.mult);
          }
          if (this.sk && this.appliedTransformations < 3) {
            var skew2 = this.sk.getValueAtTime(time2);
            var skewAxis = this.sa.getValueAtTime(time2);
            matrix.skewFromAxis(-skew2 * this.sk.mult, skewAxis * this.sa.mult);
          }
          if (this.r && this.appliedTransformations < 4) {
            var rotation2 = this.r.getValueAtTime(time2);
            matrix.rotate(-rotation2 * this.r.mult);
          } else if (!this.r && this.appliedTransformations < 4) {
            var rotationZ = this.rz.getValueAtTime(time2);
            var rotationY = this.ry.getValueAtTime(time2);
            var rotationX = this.rx.getValueAtTime(time2);
            var orientation = this.or.getValueAtTime(time2);
            matrix.rotateZ(-rotationZ * this.rz.mult).rotateY(rotationY * this.ry.mult).rotateX(rotationX * this.rx.mult).rotateZ(-orientation[2] * this.or.mult).rotateY(orientation[1] * this.or.mult).rotateX(orientation[0] * this.or.mult);
          }
          if (this.data.p && this.data.p.s) {
            var positionX = this.px.getValueAtTime(time2);
            var positionY = this.py.getValueAtTime(time2);
            if (this.data.p.z) {
              var positionZ = this.pz.getValueAtTime(time2);
              matrix.translate(positionX * this.px.mult, positionY * this.py.mult, -positionZ * this.pz.mult);
            } else {
              matrix.translate(positionX * this.px.mult, positionY * this.py.mult, 0);
            }
          } else {
            var position2 = this.p.getValueAtTime(time2);
            matrix.translate(position2[0] * this.p.mult, position2[1] * this.p.mult, -position2[2] * this.p.mult);
          }
          return matrix;
        }
        function getTransformStaticValueAtTime() {
          return this.v.clone(new Matrix());
        }
        var getTransformProperty = TransformPropertyFactory.getTransformProperty;
        TransformPropertyFactory.getTransformProperty = function(elem2, data2, container) {
          var prop = getTransformProperty(elem2, data2, container);
          if (prop.dynamicProperties.length) {
            prop.getValueAtTime = getTransformValueAtTime.bind(prop);
          } else {
            prop.getValueAtTime = getTransformStaticValueAtTime.bind(prop);
          }
          prop.setGroupProperty = expressionHelpers.setGroupProperty;
          return prop;
        };
        var propertyGetProp = PropertyFactory.getProp;
        PropertyFactory.getProp = function(elem2, data2, type, mult, container) {
          var prop = propertyGetProp(elem2, data2, type, mult, container);
          if (prop.kf) {
            prop.getValueAtTime = expressionHelpers.getValueAtTime.bind(prop);
          } else {
            prop.getValueAtTime = expressionHelpers.getStaticValueAtTime.bind(prop);
          }
          prop.setGroupProperty = expressionHelpers.setGroupProperty;
          prop.loopOut = loopOut2;
          prop.loopIn = loopIn2;
          prop.smooth = smooth2;
          prop.getVelocityAtTime = expressionHelpers.getVelocityAtTime.bind(prop);
          prop.getSpeedAtTime = expressionHelpers.getSpeedAtTime.bind(prop);
          prop.numKeys = data2.a === 1 ? data2.k.length : 0;
          prop.propertyIndex = data2.ix;
          var value3 = 0;
          if (type !== 0) {
            value3 = createTypedArray("float32", data2.a === 1 ? data2.k[0].s.length : data2.k.length);
          }
          prop._cachingAtTime = {
            lastFrame: initialDefaultFrame,
            lastIndex: 0,
            value: value3
          };
          expressionHelpers.searchExpressions(elem2, data2, prop);
          if (prop.k) {
            container.addDynamicProperty(prop);
          }
          return prop;
        };
        function getShapeValueAtTime(frameNum) {
          if (!this._cachingAtTime) {
            this._cachingAtTime = {
              shapeValue: shapePool.clone(this.pv),
              lastIndex: 0,
              lastTime: initialDefaultFrame
            };
          }
          frameNum *= this.elem.globalData.frameRate;
          frameNum -= this.offsetTime;
          if (frameNum !== this._cachingAtTime.lastTime) {
            this._cachingAtTime.lastIndex = this._cachingAtTime.lastTime < frameNum ? this._caching.lastIndex : 0;
            this._cachingAtTime.lastTime = frameNum;
            this.interpolateShape(frameNum, this._cachingAtTime.shapeValue, this._cachingAtTime);
          }
          return this._cachingAtTime.shapeValue;
        }
        var ShapePropertyConstructorFunction = ShapePropertyFactory.getConstructorFunction();
        var KeyframedShapePropertyConstructorFunction = ShapePropertyFactory.getKeyframedConstructorFunction();
        function ShapeExpressions() {
        }
        ShapeExpressions.prototype = {
          vertices: function vertices(prop, time2) {
            if (this.k) {
              this.getValue();
            }
            var shapePath = this.v;
            if (time2 !== void 0) {
              shapePath = this.getValueAtTime(time2, 0);
            }
            var i;
            var len = shapePath._length;
            var vertices2 = shapePath[prop];
            var points = shapePath.v;
            var arr = createSizedArray(len);
            for (i = 0; i < len; i += 1) {
              if (prop === "i" || prop === "o") {
                arr[i] = [vertices2[i][0] - points[i][0], vertices2[i][1] - points[i][1]];
              } else {
                arr[i] = [vertices2[i][0], vertices2[i][1]];
              }
            }
            return arr;
          },
          points: function points(time2) {
            return this.vertices("v", time2);
          },
          inTangents: function inTangents(time2) {
            return this.vertices("i", time2);
          },
          outTangents: function outTangents(time2) {
            return this.vertices("o", time2);
          },
          isClosed: function isClosed() {
            return this.v.c;
          },
          pointOnPath: function pointOnPath(perc, time2) {
            var shapePath = this.v;
            if (time2 !== void 0) {
              shapePath = this.getValueAtTime(time2, 0);
            }
            if (!this._segmentsLength) {
              this._segmentsLength = bez.getSegmentsLength(shapePath);
            }
            var segmentsLength = this._segmentsLength;
            var lengths = segmentsLength.lengths;
            var lengthPos = segmentsLength.totalLength * perc;
            var i = 0;
            var len = lengths.length;
            var accumulatedLength = 0;
            var pt;
            while (i < len) {
              if (accumulatedLength + lengths[i].addedLength > lengthPos) {
                var initIndex = i;
                var endIndex = shapePath.c && i === len - 1 ? 0 : i + 1;
                var segmentPerc = (lengthPos - accumulatedLength) / lengths[i].addedLength;
                pt = bez.getPointInSegment(shapePath.v[initIndex], shapePath.v[endIndex], shapePath.o[initIndex], shapePath.i[endIndex], segmentPerc, lengths[i]);
                break;
              } else {
                accumulatedLength += lengths[i].addedLength;
              }
              i += 1;
            }
            if (!pt) {
              pt = shapePath.c ? [shapePath.v[0][0], shapePath.v[0][1]] : [shapePath.v[shapePath._length - 1][0], shapePath.v[shapePath._length - 1][1]];
            }
            return pt;
          },
          vectorOnPath: function vectorOnPath(perc, time2, vectorType) {
            if (perc == 1) {
              perc = this.v.c;
            } else if (perc == 0) {
              perc = 0.999;
            }
            var pt1 = this.pointOnPath(perc, time2);
            var pt2 = this.pointOnPath(perc + 1e-3, time2);
            var xLength = pt2[0] - pt1[0];
            var yLength = pt2[1] - pt1[1];
            var magnitude = Math.sqrt(Math.pow(xLength, 2) + Math.pow(yLength, 2));
            if (magnitude === 0) {
              return [0, 0];
            }
            var unitVector = vectorType === "tangent" ? [xLength / magnitude, yLength / magnitude] : [-yLength / magnitude, xLength / magnitude];
            return unitVector;
          },
          tangentOnPath: function tangentOnPath(perc, time2) {
            return this.vectorOnPath(perc, time2, "tangent");
          },
          normalOnPath: function normalOnPath(perc, time2) {
            return this.vectorOnPath(perc, time2, "normal");
          },
          setGroupProperty: expressionHelpers.setGroupProperty,
          getValueAtTime: expressionHelpers.getStaticValueAtTime
        };
        extendPrototype([ShapeExpressions], ShapePropertyConstructorFunction);
        extendPrototype([ShapeExpressions], KeyframedShapePropertyConstructorFunction);
        KeyframedShapePropertyConstructorFunction.prototype.getValueAtTime = getShapeValueAtTime;
        KeyframedShapePropertyConstructorFunction.prototype.initiateExpression = ExpressionManager.initiateExpression;
        var propertyGetShapeProp = ShapePropertyFactory.getShapeProp;
        ShapePropertyFactory.getShapeProp = function(elem2, data2, type, arr, trims) {
          var prop = propertyGetShapeProp(elem2, data2, type, arr, trims);
          prop.propertyIndex = data2.ix;
          prop.lock = false;
          if (type === 3) {
            expressionHelpers.searchExpressions(elem2, data2.pt, prop);
          } else if (type === 4) {
            expressionHelpers.searchExpressions(elem2, data2.ks, prop);
          }
          if (prop.k) {
            elem2.addDynamicProperty(prop);
          }
          return prop;
        };
      }
      function initialize$1() {
        addPropertyDecorator();
      }
      function addDecorator() {
        function searchExpressions() {
          if (this.data.d.x) {
            this.calculateExpression = ExpressionManager.initiateExpression.bind(this)(this.elem, this.data.d, this);
            this.addEffect(this.getExpressionValue.bind(this));
            return true;
          }
          return null;
        }
        TextProperty.prototype.getExpressionValue = function(currentValue, text2) {
          var newValue = this.calculateExpression(text2);
          if (currentValue.t !== newValue) {
            var newData = {};
            this.copyData(newData, currentValue);
            newData.t = newValue.toString();
            newData.__complete = false;
            return newData;
          }
          return currentValue;
        };
        TextProperty.prototype.searchProperty = function() {
          var isKeyframed = this.searchKeyframes();
          var hasExpressions = this.searchExpressions();
          this.kf = isKeyframed || hasExpressions;
          return this.kf;
        };
        TextProperty.prototype.searchExpressions = searchExpressions;
      }
      function initialize() {
        addDecorator();
      }
      function SVGComposableEffect() {
      }
      SVGComposableEffect.prototype = {
        createMergeNode: function createMergeNode(resultId, ins) {
          var feMerge = createNS("feMerge");
          feMerge.setAttribute("result", resultId);
          var feMergeNode;
          var i;
          for (i = 0; i < ins.length; i += 1) {
            feMergeNode = createNS("feMergeNode");
            feMergeNode.setAttribute("in", ins[i]);
            feMerge.appendChild(feMergeNode);
            feMerge.appendChild(feMergeNode);
          }
          return feMerge;
        }
      };
      var linearFilterValue = "0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0";
      function SVGTintFilter(filter, filterManager, elem2, id, source) {
        this.filterManager = filterManager;
        var feColorMatrix = createNS("feColorMatrix");
        feColorMatrix.setAttribute("type", "matrix");
        feColorMatrix.setAttribute("color-interpolation-filters", "linearRGB");
        feColorMatrix.setAttribute("values", linearFilterValue + " 1 0");
        this.linearFilter = feColorMatrix;
        feColorMatrix.setAttribute("result", id + "_tint_1");
        filter.appendChild(feColorMatrix);
        feColorMatrix = createNS("feColorMatrix");
        feColorMatrix.setAttribute("type", "matrix");
        feColorMatrix.setAttribute("color-interpolation-filters", "sRGB");
        feColorMatrix.setAttribute("values", "1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0");
        feColorMatrix.setAttribute("result", id + "_tint_2");
        filter.appendChild(feColorMatrix);
        this.matrixFilter = feColorMatrix;
        var feMerge = this.createMergeNode(id, [source, id + "_tint_1", id + "_tint_2"]);
        filter.appendChild(feMerge);
      }
      extendPrototype([SVGComposableEffect], SVGTintFilter);
      SVGTintFilter.prototype.renderFrame = function(forceRender) {
        if (forceRender || this.filterManager._mdf) {
          var colorBlack = this.filterManager.effectElements[0].p.v;
          var colorWhite = this.filterManager.effectElements[1].p.v;
          var opacity = this.filterManager.effectElements[2].p.v / 100;
          this.linearFilter.setAttribute("values", linearFilterValue + " " + opacity + " 0");
          this.matrixFilter.setAttribute("values", colorWhite[0] - colorBlack[0] + " 0 0 0 " + colorBlack[0] + " " + (colorWhite[1] - colorBlack[1]) + " 0 0 0 " + colorBlack[1] + " " + (colorWhite[2] - colorBlack[2]) + " 0 0 0 " + colorBlack[2] + " 0 0 0 1 0");
        }
      };
      function SVGFillFilter(filter, filterManager, elem2, id) {
        this.filterManager = filterManager;
        var feColorMatrix = createNS("feColorMatrix");
        feColorMatrix.setAttribute("type", "matrix");
        feColorMatrix.setAttribute("color-interpolation-filters", "sRGB");
        feColorMatrix.setAttribute("values", "1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0");
        feColorMatrix.setAttribute("result", id);
        filter.appendChild(feColorMatrix);
        this.matrixFilter = feColorMatrix;
      }
      SVGFillFilter.prototype.renderFrame = function(forceRender) {
        if (forceRender || this.filterManager._mdf) {
          var color = this.filterManager.effectElements[2].p.v;
          var opacity = this.filterManager.effectElements[6].p.v;
          this.matrixFilter.setAttribute("values", "0 0 0 0 " + color[0] + " 0 0 0 0 " + color[1] + " 0 0 0 0 " + color[2] + " 0 0 0 " + opacity + " 0");
        }
      };
      function SVGStrokeEffect(fil, filterManager, elem2) {
        this.initialized = false;
        this.filterManager = filterManager;
        this.elem = elem2;
        this.paths = [];
      }
      SVGStrokeEffect.prototype.initialize = function() {
        var elemChildren = this.elem.layerElement.children || this.elem.layerElement.childNodes;
        var path;
        var groupPath;
        var i;
        var len;
        if (this.filterManager.effectElements[1].p.v === 1) {
          len = this.elem.maskManager.masksProperties.length;
          i = 0;
        } else {
          i = this.filterManager.effectElements[0].p.v - 1;
          len = i + 1;
        }
        groupPath = createNS("g");
        groupPath.setAttribute("fill", "none");
        groupPath.setAttribute("stroke-linecap", "round");
        groupPath.setAttribute("stroke-dashoffset", 1);
        for (i; i < len; i += 1) {
          path = createNS("path");
          groupPath.appendChild(path);
          this.paths.push({
            p: path,
            m: i
          });
        }
        if (this.filterManager.effectElements[10].p.v === 3) {
          var mask2 = createNS("mask");
          var id = createElementID();
          mask2.setAttribute("id", id);
          mask2.setAttribute("mask-type", "alpha");
          mask2.appendChild(groupPath);
          this.elem.globalData.defs.appendChild(mask2);
          var g = createNS("g");
          g.setAttribute("mask", "url(" + getLocationHref() + "#" + id + ")");
          while (elemChildren[0]) {
            g.appendChild(elemChildren[0]);
          }
          this.elem.layerElement.appendChild(g);
          this.masker = mask2;
          groupPath.setAttribute("stroke", "#fff");
        } else if (this.filterManager.effectElements[10].p.v === 1 || this.filterManager.effectElements[10].p.v === 2) {
          if (this.filterManager.effectElements[10].p.v === 2) {
            elemChildren = this.elem.layerElement.children || this.elem.layerElement.childNodes;
            while (elemChildren.length) {
              this.elem.layerElement.removeChild(elemChildren[0]);
            }
          }
          this.elem.layerElement.appendChild(groupPath);
          this.elem.layerElement.removeAttribute("mask");
          groupPath.setAttribute("stroke", "#fff");
        }
        this.initialized = true;
        this.pathMasker = groupPath;
      };
      SVGStrokeEffect.prototype.renderFrame = function(forceRender) {
        if (!this.initialized) {
          this.initialize();
        }
        var i;
        var len = this.paths.length;
        var mask2;
        var path;
        for (i = 0; i < len; i += 1) {
          if (this.paths[i].m !== -1) {
            mask2 = this.elem.maskManager.viewData[this.paths[i].m];
            path = this.paths[i].p;
            if (forceRender || this.filterManager._mdf || mask2.prop._mdf) {
              path.setAttribute("d", mask2.lastPath);
            }
            if (forceRender || this.filterManager.effectElements[9].p._mdf || this.filterManager.effectElements[4].p._mdf || this.filterManager.effectElements[7].p._mdf || this.filterManager.effectElements[8].p._mdf || mask2.prop._mdf) {
              var dasharrayValue;
              if (this.filterManager.effectElements[7].p.v !== 0 || this.filterManager.effectElements[8].p.v !== 100) {
                var s = Math.min(this.filterManager.effectElements[7].p.v, this.filterManager.effectElements[8].p.v) * 0.01;
                var e = Math.max(this.filterManager.effectElements[7].p.v, this.filterManager.effectElements[8].p.v) * 0.01;
                var l = path.getTotalLength();
                dasharrayValue = "0 0 0 " + l * s + " ";
                var lineLength = l * (e - s);
                var segment = 1 + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * 0.01;
                var units = Math.floor(lineLength / segment);
                var j;
                for (j = 0; j < units; j += 1) {
                  dasharrayValue += "1 " + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * 0.01 + " ";
                }
                dasharrayValue += "0 " + l * 10 + " 0 0";
              } else {
                dasharrayValue = "1 " + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * 0.01;
              }
              path.setAttribute("stroke-dasharray", dasharrayValue);
            }
          }
        }
        if (forceRender || this.filterManager.effectElements[4].p._mdf) {
          this.pathMasker.setAttribute("stroke-width", this.filterManager.effectElements[4].p.v * 2);
        }
        if (forceRender || this.filterManager.effectElements[6].p._mdf) {
          this.pathMasker.setAttribute("opacity", this.filterManager.effectElements[6].p.v);
        }
        if (this.filterManager.effectElements[10].p.v === 1 || this.filterManager.effectElements[10].p.v === 2) {
          if (forceRender || this.filterManager.effectElements[3].p._mdf) {
            var color = this.filterManager.effectElements[3].p.v;
            this.pathMasker.setAttribute("stroke", "rgb(" + bmFloor(color[0] * 255) + "," + bmFloor(color[1] * 255) + "," + bmFloor(color[2] * 255) + ")");
          }
        }
      };
      function SVGTritoneFilter(filter, filterManager, elem2, id) {
        this.filterManager = filterManager;
        var feColorMatrix = createNS("feColorMatrix");
        feColorMatrix.setAttribute("type", "matrix");
        feColorMatrix.setAttribute("color-interpolation-filters", "linearRGB");
        feColorMatrix.setAttribute("values", "0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0");
        filter.appendChild(feColorMatrix);
        var feComponentTransfer = createNS("feComponentTransfer");
        feComponentTransfer.setAttribute("color-interpolation-filters", "sRGB");
        feComponentTransfer.setAttribute("result", id);
        this.matrixFilter = feComponentTransfer;
        var feFuncR = createNS("feFuncR");
        feFuncR.setAttribute("type", "table");
        feComponentTransfer.appendChild(feFuncR);
        this.feFuncR = feFuncR;
        var feFuncG = createNS("feFuncG");
        feFuncG.setAttribute("type", "table");
        feComponentTransfer.appendChild(feFuncG);
        this.feFuncG = feFuncG;
        var feFuncB = createNS("feFuncB");
        feFuncB.setAttribute("type", "table");
        feComponentTransfer.appendChild(feFuncB);
        this.feFuncB = feFuncB;
        filter.appendChild(feComponentTransfer);
      }
      SVGTritoneFilter.prototype.renderFrame = function(forceRender) {
        if (forceRender || this.filterManager._mdf) {
          var color1 = this.filterManager.effectElements[0].p.v;
          var color2 = this.filterManager.effectElements[1].p.v;
          var color3 = this.filterManager.effectElements[2].p.v;
          var tableR = color3[0] + " " + color2[0] + " " + color1[0];
          var tableG = color3[1] + " " + color2[1] + " " + color1[1];
          var tableB = color3[2] + " " + color2[2] + " " + color1[2];
          this.feFuncR.setAttribute("tableValues", tableR);
          this.feFuncG.setAttribute("tableValues", tableG);
          this.feFuncB.setAttribute("tableValues", tableB);
        }
      };
      function SVGProLevelsFilter(filter, filterManager, elem2, id) {
        this.filterManager = filterManager;
        var effectElements = this.filterManager.effectElements;
        var feComponentTransfer = createNS("feComponentTransfer");
        if (effectElements[10].p.k || effectElements[10].p.v !== 0 || effectElements[11].p.k || effectElements[11].p.v !== 1 || effectElements[12].p.k || effectElements[12].p.v !== 1 || effectElements[13].p.k || effectElements[13].p.v !== 0 || effectElements[14].p.k || effectElements[14].p.v !== 1) {
          this.feFuncR = this.createFeFunc("feFuncR", feComponentTransfer);
        }
        if (effectElements[17].p.k || effectElements[17].p.v !== 0 || effectElements[18].p.k || effectElements[18].p.v !== 1 || effectElements[19].p.k || effectElements[19].p.v !== 1 || effectElements[20].p.k || effectElements[20].p.v !== 0 || effectElements[21].p.k || effectElements[21].p.v !== 1) {
          this.feFuncG = this.createFeFunc("feFuncG", feComponentTransfer);
        }
        if (effectElements[24].p.k || effectElements[24].p.v !== 0 || effectElements[25].p.k || effectElements[25].p.v !== 1 || effectElements[26].p.k || effectElements[26].p.v !== 1 || effectElements[27].p.k || effectElements[27].p.v !== 0 || effectElements[28].p.k || effectElements[28].p.v !== 1) {
          this.feFuncB = this.createFeFunc("feFuncB", feComponentTransfer);
        }
        if (effectElements[31].p.k || effectElements[31].p.v !== 0 || effectElements[32].p.k || effectElements[32].p.v !== 1 || effectElements[33].p.k || effectElements[33].p.v !== 1 || effectElements[34].p.k || effectElements[34].p.v !== 0 || effectElements[35].p.k || effectElements[35].p.v !== 1) {
          this.feFuncA = this.createFeFunc("feFuncA", feComponentTransfer);
        }
        if (this.feFuncR || this.feFuncG || this.feFuncB || this.feFuncA) {
          feComponentTransfer.setAttribute("color-interpolation-filters", "sRGB");
          filter.appendChild(feComponentTransfer);
        }
        if (effectElements[3].p.k || effectElements[3].p.v !== 0 || effectElements[4].p.k || effectElements[4].p.v !== 1 || effectElements[5].p.k || effectElements[5].p.v !== 1 || effectElements[6].p.k || effectElements[6].p.v !== 0 || effectElements[7].p.k || effectElements[7].p.v !== 1) {
          feComponentTransfer = createNS("feComponentTransfer");
          feComponentTransfer.setAttribute("color-interpolation-filters", "sRGB");
          feComponentTransfer.setAttribute("result", id);
          filter.appendChild(feComponentTransfer);
          this.feFuncRComposed = this.createFeFunc("feFuncR", feComponentTransfer);
          this.feFuncGComposed = this.createFeFunc("feFuncG", feComponentTransfer);
          this.feFuncBComposed = this.createFeFunc("feFuncB", feComponentTransfer);
        }
      }
      SVGProLevelsFilter.prototype.createFeFunc = function(type, feComponentTransfer) {
        var feFunc = createNS(type);
        feFunc.setAttribute("type", "table");
        feComponentTransfer.appendChild(feFunc);
        return feFunc;
      };
      SVGProLevelsFilter.prototype.getTableValue = function(inputBlack, inputWhite, gamma, outputBlack, outputWhite) {
        var cnt = 0;
        var segments = 256;
        var perc;
        var min = Math.min(inputBlack, inputWhite);
        var max = Math.max(inputBlack, inputWhite);
        var table = Array.call(null, {
          length: segments
        });
        var colorValue;
        var pos = 0;
        var outputDelta = outputWhite - outputBlack;
        var inputDelta = inputWhite - inputBlack;
        while (cnt <= 256) {
          perc = cnt / 256;
          if (perc <= min) {
            colorValue = inputDelta < 0 ? outputWhite : outputBlack;
          } else if (perc >= max) {
            colorValue = inputDelta < 0 ? outputBlack : outputWhite;
          } else {
            colorValue = outputBlack + outputDelta * Math.pow((perc - inputBlack) / inputDelta, 1 / gamma);
          }
          table[pos] = colorValue;
          pos += 1;
          cnt += 256 / (segments - 1);
        }
        return table.join(" ");
      };
      SVGProLevelsFilter.prototype.renderFrame = function(forceRender) {
        if (forceRender || this.filterManager._mdf) {
          var val2;
          var effectElements = this.filterManager.effectElements;
          if (this.feFuncRComposed && (forceRender || effectElements[3].p._mdf || effectElements[4].p._mdf || effectElements[5].p._mdf || effectElements[6].p._mdf || effectElements[7].p._mdf)) {
            val2 = this.getTableValue(effectElements[3].p.v, effectElements[4].p.v, effectElements[5].p.v, effectElements[6].p.v, effectElements[7].p.v);
            this.feFuncRComposed.setAttribute("tableValues", val2);
            this.feFuncGComposed.setAttribute("tableValues", val2);
            this.feFuncBComposed.setAttribute("tableValues", val2);
          }
          if (this.feFuncR && (forceRender || effectElements[10].p._mdf || effectElements[11].p._mdf || effectElements[12].p._mdf || effectElements[13].p._mdf || effectElements[14].p._mdf)) {
            val2 = this.getTableValue(effectElements[10].p.v, effectElements[11].p.v, effectElements[12].p.v, effectElements[13].p.v, effectElements[14].p.v);
            this.feFuncR.setAttribute("tableValues", val2);
          }
          if (this.feFuncG && (forceRender || effectElements[17].p._mdf || effectElements[18].p._mdf || effectElements[19].p._mdf || effectElements[20].p._mdf || effectElements[21].p._mdf)) {
            val2 = this.getTableValue(effectElements[17].p.v, effectElements[18].p.v, effectElements[19].p.v, effectElements[20].p.v, effectElements[21].p.v);
            this.feFuncG.setAttribute("tableValues", val2);
          }
          if (this.feFuncB && (forceRender || effectElements[24].p._mdf || effectElements[25].p._mdf || effectElements[26].p._mdf || effectElements[27].p._mdf || effectElements[28].p._mdf)) {
            val2 = this.getTableValue(effectElements[24].p.v, effectElements[25].p.v, effectElements[26].p.v, effectElements[27].p.v, effectElements[28].p.v);
            this.feFuncB.setAttribute("tableValues", val2);
          }
          if (this.feFuncA && (forceRender || effectElements[31].p._mdf || effectElements[32].p._mdf || effectElements[33].p._mdf || effectElements[34].p._mdf || effectElements[35].p._mdf)) {
            val2 = this.getTableValue(effectElements[31].p.v, effectElements[32].p.v, effectElements[33].p.v, effectElements[34].p.v, effectElements[35].p.v);
            this.feFuncA.setAttribute("tableValues", val2);
          }
        }
      };
      function SVGDropShadowEffect(filter, filterManager, elem2, id, source) {
        var globalFilterSize = filterManager.container.globalData.renderConfig.filterSize;
        var filterSize = filterManager.data.fs || globalFilterSize;
        filter.setAttribute("x", filterSize.x || globalFilterSize.x);
        filter.setAttribute("y", filterSize.y || globalFilterSize.y);
        filter.setAttribute("width", filterSize.width || globalFilterSize.width);
        filter.setAttribute("height", filterSize.height || globalFilterSize.height);
        this.filterManager = filterManager;
        var feGaussianBlur = createNS("feGaussianBlur");
        feGaussianBlur.setAttribute("in", "SourceAlpha");
        feGaussianBlur.setAttribute("result", id + "_drop_shadow_1");
        feGaussianBlur.setAttribute("stdDeviation", "0");
        this.feGaussianBlur = feGaussianBlur;
        filter.appendChild(feGaussianBlur);
        var feOffset = createNS("feOffset");
        feOffset.setAttribute("dx", "25");
        feOffset.setAttribute("dy", "0");
        feOffset.setAttribute("in", id + "_drop_shadow_1");
        feOffset.setAttribute("result", id + "_drop_shadow_2");
        this.feOffset = feOffset;
        filter.appendChild(feOffset);
        var feFlood = createNS("feFlood");
        feFlood.setAttribute("flood-color", "#00ff00");
        feFlood.setAttribute("flood-opacity", "1");
        feFlood.setAttribute("result", id + "_drop_shadow_3");
        this.feFlood = feFlood;
        filter.appendChild(feFlood);
        var feComposite = createNS("feComposite");
        feComposite.setAttribute("in", id + "_drop_shadow_3");
        feComposite.setAttribute("in2", id + "_drop_shadow_2");
        feComposite.setAttribute("operator", "in");
        feComposite.setAttribute("result", id + "_drop_shadow_4");
        filter.appendChild(feComposite);
        var feMerge = this.createMergeNode(id, [id + "_drop_shadow_4", source]);
        filter.appendChild(feMerge);
      }
      extendPrototype([SVGComposableEffect], SVGDropShadowEffect);
      SVGDropShadowEffect.prototype.renderFrame = function(forceRender) {
        if (forceRender || this.filterManager._mdf) {
          if (forceRender || this.filterManager.effectElements[4].p._mdf) {
            this.feGaussianBlur.setAttribute("stdDeviation", this.filterManager.effectElements[4].p.v / 4);
          }
          if (forceRender || this.filterManager.effectElements[0].p._mdf) {
            var col = this.filterManager.effectElements[0].p.v;
            this.feFlood.setAttribute("flood-color", rgbToHex(Math.round(col[0] * 255), Math.round(col[1] * 255), Math.round(col[2] * 255)));
          }
          if (forceRender || this.filterManager.effectElements[1].p._mdf) {
            this.feFlood.setAttribute("flood-opacity", this.filterManager.effectElements[1].p.v / 255);
          }
          if (forceRender || this.filterManager.effectElements[2].p._mdf || this.filterManager.effectElements[3].p._mdf) {
            var distance2 = this.filterManager.effectElements[3].p.v;
            var angle = (this.filterManager.effectElements[2].p.v - 90) * degToRads;
            var x = distance2 * Math.cos(angle);
            var y = distance2 * Math.sin(angle);
            this.feOffset.setAttribute("dx", x);
            this.feOffset.setAttribute("dy", y);
          }
        }
      };
      var _svgMatteSymbols = [];
      function SVGMatte3Effect(filterElem, filterManager, elem2) {
        this.initialized = false;
        this.filterManager = filterManager;
        this.filterElem = filterElem;
        this.elem = elem2;
        elem2.matteElement = createNS("g");
        elem2.matteElement.appendChild(elem2.layerElement);
        elem2.matteElement.appendChild(elem2.transformedElement);
        elem2.baseElement = elem2.matteElement;
      }
      SVGMatte3Effect.prototype.findSymbol = function(mask2) {
        var i = 0;
        var len = _svgMatteSymbols.length;
        while (i < len) {
          if (_svgMatteSymbols[i] === mask2) {
            return _svgMatteSymbols[i];
          }
          i += 1;
        }
        return null;
      };
      SVGMatte3Effect.prototype.replaceInParent = function(mask2, symbolId) {
        var parentNode = mask2.layerElement.parentNode;
        if (!parentNode) {
          return;
        }
        var children = parentNode.children;
        var i = 0;
        var len = children.length;
        while (i < len) {
          if (children[i] === mask2.layerElement) {
            break;
          }
          i += 1;
        }
        var nextChild;
        if (i <= len - 2) {
          nextChild = children[i + 1];
        }
        var useElem = createNS("use");
        useElem.setAttribute("href", "#" + symbolId);
        if (nextChild) {
          parentNode.insertBefore(useElem, nextChild);
        } else {
          parentNode.appendChild(useElem);
        }
      };
      SVGMatte3Effect.prototype.setElementAsMask = function(elem2, mask2) {
        if (!this.findSymbol(mask2)) {
          var symbolId = createElementID();
          var masker = createNS("mask");
          masker.setAttribute("id", mask2.layerId);
          masker.setAttribute("mask-type", "alpha");
          _svgMatteSymbols.push(mask2);
          var defs = elem2.globalData.defs;
          defs.appendChild(masker);
          var symbol = createNS("symbol");
          symbol.setAttribute("id", symbolId);
          this.replaceInParent(mask2, symbolId);
          symbol.appendChild(mask2.layerElement);
          defs.appendChild(symbol);
          var useElem = createNS("use");
          useElem.setAttribute("href", "#" + symbolId);
          masker.appendChild(useElem);
          mask2.data.hd = false;
          mask2.show();
        }
        elem2.setMatte(mask2.layerId);
      };
      SVGMatte3Effect.prototype.initialize = function() {
        var ind = this.filterManager.effectElements[0].p.v;
        var elements = this.elem.comp.elements;
        var i = 0;
        var len = elements.length;
        while (i < len) {
          if (elements[i] && elements[i].data.ind === ind) {
            this.setElementAsMask(this.elem, elements[i]);
          }
          i += 1;
        }
        this.initialized = true;
      };
      SVGMatte3Effect.prototype.renderFrame = function() {
        if (!this.initialized) {
          this.initialize();
        }
      };
      function SVGGaussianBlurEffect(filter, filterManager, elem2, id) {
        filter.setAttribute("x", "-100%");
        filter.setAttribute("y", "-100%");
        filter.setAttribute("width", "300%");
        filter.setAttribute("height", "300%");
        this.filterManager = filterManager;
        var feGaussianBlur = createNS("feGaussianBlur");
        feGaussianBlur.setAttribute("result", id);
        filter.appendChild(feGaussianBlur);
        this.feGaussianBlur = feGaussianBlur;
      }
      SVGGaussianBlurEffect.prototype.renderFrame = function(forceRender) {
        if (forceRender || this.filterManager._mdf) {
          var kBlurrinessToSigma = 0.3;
          var sigma = this.filterManager.effectElements[0].p.v * kBlurrinessToSigma;
          var dimensions = this.filterManager.effectElements[1].p.v;
          var sigmaX = dimensions == 3 ? 0 : sigma;
          var sigmaY = dimensions == 2 ? 0 : sigma;
          this.feGaussianBlur.setAttribute("stdDeviation", sigmaX + " " + sigmaY);
          var edgeMode = this.filterManager.effectElements[2].p.v == 1 ? "wrap" : "duplicate";
          this.feGaussianBlur.setAttribute("edgeMode", edgeMode);
        }
      };
      function TransformEffect() {
      }
      TransformEffect.prototype.init = function(effectsManager) {
        this.effectsManager = effectsManager;
        this.type = effectTypes.TRANSFORM_EFFECT;
        this.matrix = new Matrix();
        this.opacity = -1;
        this._mdf = false;
        this._opMdf = false;
      };
      TransformEffect.prototype.renderFrame = function(forceFrame) {
        this._opMdf = false;
        this._mdf = false;
        if (forceFrame || this.effectsManager._mdf) {
          var effectElements = this.effectsManager.effectElements;
          var anchor = effectElements[0].p.v;
          var position2 = effectElements[1].p.v;
          var isUniformScale = effectElements[2].p.v === 1;
          var scaleHeight = effectElements[3].p.v;
          var scaleWidth = isUniformScale ? scaleHeight : effectElements[4].p.v;
          var skew2 = effectElements[5].p.v;
          var skewAxis = effectElements[6].p.v;
          var rotation2 = effectElements[7].p.v;
          this.matrix.reset();
          this.matrix.translate(-anchor[0], -anchor[1], anchor[2]);
          this.matrix.scale(scaleWidth * 0.01, scaleHeight * 0.01, 1);
          this.matrix.rotate(-rotation2 * degToRads);
          this.matrix.skewFromAxis(-skew2 * degToRads, (skewAxis + 90) * degToRads);
          this.matrix.translate(position2[0], position2[1], 0);
          this._mdf = true;
          if (this.opacity !== effectElements[8].p.v) {
            this.opacity = effectElements[8].p.v;
            this._opMdf = true;
          }
        }
      };
      function SVGTransformEffect(_, filterManager) {
        this.init(filterManager);
      }
      extendPrototype([TransformEffect], SVGTransformEffect);
      function CVTransformEffect(effectsManager) {
        this.init(effectsManager);
      }
      extendPrototype([TransformEffect], CVTransformEffect);
      registerRenderer("canvas", CanvasRenderer);
      registerRenderer("html", HybridRenderer);
      registerRenderer("svg", SVGRenderer);
      ShapeModifiers.registerModifier("tm", TrimModifier);
      ShapeModifiers.registerModifier("pb", PuckerAndBloatModifier);
      ShapeModifiers.registerModifier("rp", RepeaterModifier);
      ShapeModifiers.registerModifier("rd", RoundCornersModifier);
      ShapeModifiers.registerModifier("zz", ZigZagModifier);
      ShapeModifiers.registerModifier("op", OffsetPathModifier);
      setExpressionsPlugin(Expressions);
      setExpressionInterfaces(getInterface);
      initialize$1();
      initialize();
      registerEffect$1(20, SVGTintFilter, true);
      registerEffect$1(21, SVGFillFilter, true);
      registerEffect$1(22, SVGStrokeEffect, false);
      registerEffect$1(23, SVGTritoneFilter, true);
      registerEffect$1(24, SVGProLevelsFilter, true);
      registerEffect$1(25, SVGDropShadowEffect, true);
      registerEffect$1(28, SVGMatte3Effect, false);
      registerEffect$1(29, SVGGaussianBlurEffect, true);
      registerEffect$1(35, SVGTransformEffect, false);
      registerEffect(35, CVTransformEffect);
      return lottie;
    });
  }
});

// node_modules/@selfxyz/common/node_modules/poseidon-lite/poseidon/index.js
var require_poseidon = __commonJS({
  "node_modules/@selfxyz/common/node_modules/poseidon-lite/poseidon/index.js"(exports2, module2) {
    "use strict";
    var F = BigInt("21888242871839275222246405745257275088548364400416034343698204186575808495617");
    var N_ROUNDS_F = 8;
    var N_ROUNDS_P = [56, 57, 56, 60, 60, 63, 64, 63, 60, 66, 60, 65, 70, 60, 64, 68];
    var pow5 = (v) => {
      let o = v * v;
      return v * o * o % F;
    };
    function mix(state, M) {
      const out = [];
      for (let x = 0; x < state.length; x++) {
        let o = 0n;
        for (let y = 0; y < state.length; y++) {
          o = o + M[x][y] * state[y];
        }
        out.push(o % F);
      }
      return out;
    }
    function poseidon(_inputs, opt) {
      const inputs = _inputs.map((i) => BigInt(i));
      if (inputs.length <= 0) {
        throw new Error("poseidon-lite: Not enough inputs");
      }
      if (inputs.length > N_ROUNDS_P.length) {
        throw new Error("poseidon-lite: Too many inputs");
      }
      const t = inputs.length + 1;
      const nRoundsF = N_ROUNDS_F;
      const nRoundsP = N_ROUNDS_P[t - 2];
      const {
        C,
        M
      } = opt;
      if (M.length !== t) {
        throw new Error(`poseidon-lite: Incorrect M length, expected ${t} got ${M.length}`);
      }
      let state = [0n, ...inputs];
      for (let x = 0; x < nRoundsF + nRoundsP; x++) {
        for (let y = 0; y < state.length; y++) {
          state[y] = state[y] + C[x * t + y];
          if (x < nRoundsF / 2 || x >= nRoundsF / 2 + nRoundsP) state[y] = pow5(state[y]);
          else if (y === 0) state[y] = pow5(state[y]);
        }
        state = mix(state, M);
      }
      return state[0];
    }
    module2.exports = poseidon;
  }
});

// node_modules/@selfxyz/common/node_modules/poseidon-lite/poseidon/unstringify.js
var require_unstringify = __commonJS({
  "node_modules/@selfxyz/common/node_modules/poseidon-lite/poseidon/unstringify.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = unstringifyBigInts;
    function unstringifyBigInts(o) {
      if (Array.isArray(o)) {
        return o.map(unstringifyBigInts);
      } else if (typeof o == "object") {
        const res = {};
        for (const [key2, val2] of Object.entries(o)) {
          res[key2] = unstringifyBigInts(val2);
        }
        return res;
      }
      const byteArray = Uint8Array.from(atob(o), (c) => c.charCodeAt(0));
      const hex = [...byteArray].map((x) => x.toString(16).padStart(2, "0")).join("");
      return BigInt(`0x${hex}`);
    }
  }
});

// node_modules/@selfxyz/common/node_modules/poseidon-lite/constants/1.js
var require__ = __commonJS({
  "node_modules/@selfxyz/common/node_modules/poseidon-lite/constants/1.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _default = {
      C: ["CcRunsaOm9T+H6q6KUy6OKcaoXdTTN0bbH3A29Cr16c=", "DANWUwiW7sQql+2TfzE1z8UUKzrkBbg0PB2D/6YEy4E=", "Hiih2TVpitEULlEYK7VM9KAOpaq9Ymi9MX6pd8wVSjA=", "J68tgxqdJ0gICWXbMOKY5A5XV8PgCNuWTPnisSuRJR8=", "Hm8RzmD8j1E6ajz+Fq4XWkEpFGLyFM0Iear0NUW3TgM=", "Kmc4TTu9XkOFQYGctoHwvgRGLtFMNhPY9xkgYmjRQtM=", "C2b981YJOmEWCfjhL7/s8LmF44HwJRiJNkCPXVyfRdA=", "AS7j7B541HCDDGEJPCreNwsmyDzFzr7t2qaFLb2wniE=", "AlK6X2dgv739iPZ/gXXj/WzRxDGwmba7LRCOe0Rbsbk=", "F5R0zOyl/2dsa+w871QpY1Q5Gok1/3HW71rqrXypMvE=", "LCQmE3mlG/qSKP9KUD/U7Zwfl0omSWmzfholibvtK5E=", "HMHXtiaS5j6sLyiL0GlbQ8L2P1AB/A/FU+ZsBVGAGwU=", "JVBZMBqtqYuy7VX4UpeelgB4Tb8X+6zQXZ7/X9nJG1Y=", "KEN746wcsuR54fXA7M0ys66iQjSXCoGTsRwpzn5Z79k=", "KCFqRC8uH3EcpPprU3ZusRhUjaj7T3jUM4diw39fIEM=", "LB9HzRf6Wt8fOfTnBW3QP+7h784DCUWBEx8jdzI0gsk=", "B6utArel68SGMrzJNWzrfdna/KJ2Y4pjZGuFZqYhr8k=", "AjAmRgH/3yknWzP/qrUd/pQp+QiAppzRN9oMTRX5bDw=", "G8lzBU5R2QWg8WhlZJfKQKhkQUVX7iiecX5dZomaoKk=", "Lhwi+WRDUAggbDFX6GNB7dJJr/XC2EIfKmsiKI8KZ/w=", "EiTzjfZ8U3gSHB1fRhu8UJ6OoVmORsn3pwRSvCu6hrg=", "AuTmnYulnlGSgLS9ntAGj9e/6M2d/toZadKYkYbN4g4=", "Hx7Mw0qroBN/XfgfwE/z7k8Z7jZOZT8HbUfpc12YAY4=", "FnKtPXCaNTl0JmwwOamnMRQkRIAyzRgZ6suKTUKE9YI=", "KD4/3CxuQgxW9Er1GStK6c2mlh8oTSSZHS7WAt+Mj8c=", "HCo9EgxVDs/Q2wlXFw+gE2g3Ufj9/1nWYU+9af85S8w=", "IW+Eh3qsYXL3iXpzI0Vu/hQ6mkN3PqbylstrgXdlP70=", "LA0nK+zyp1dkun6OPijRK86qR+phylmkEaH1FVL5R4g=", "FuNCmYZcDihITuenTEVOnxcKVICr4FCPy0psPYlUb0M=", "F1zrpZnpb1s3WiMqb7nMcXcgR3ZYAikPSM2Tl1VIj8U=", "DHWURA3EjBb+rZ4XWLAoBmqkEL+8NU9U2MX/u0Sh7jI=", "GjwpvDnyG7XEZtt9frb9j3YOIAE8z5EskkeYgtkZ/Y0=", "DM/dkG80JuXAmG6gSbJTQAhV00kHT1pmlcjuq80i5o8=", "FPa8gdnxhvYr20dc5slBGGanqKP9Bls84OaZtn3Z55Y=", "CWK4J4n7PRKXAspwsvbFqswJmBDJxJXIiO3rc4a5cFI=", "GogK9wdNGLO/IMed4lEnvBMoSrAe8CV1r+8Mj2oxqG0=", "EMuhhBmmozLNXnfwIRwVSyCvKST8IP8/TDASu3rpMRs=", "BX5iqaj4mz69x2umOp6sqPontzGcrjQGdWooSfMC8Q0=", "KHyXHekdwKvUSt9ThLSYjLlhMDu/Zc/1r6BBO0QoDO4=", "Id8ziK8Wh7uzvKnaDMqQjx5WK8RtSrpOb395YOMGiR0=", "G+XIh9JbznA+JcyXTQk0zXid+PcLSY/YPv+LVg4WgrM=", "Jo2jb3blaPtoEXF1zqLNDdLLXUL9pazqSNWcJwag1cE=", "DherCR9urlDGCb6vVRDs7MXYu3QTXr0FvQZGDMJqXtY=", "BNcn5yj/oKZ67lNasHSkMJHvYtjPg9JwBA9cqh9ir0A=", "DdvXv5wpNBWBtUl2K8Ai7TNwKsEPG/2GKxVBfX45ym4=", "J5DrM1FiF1J2gWLoKYnGwjT1sNHTr5tYiinEnIeJZUs=", "HkV8YBpjtz5EcZUBk9ilcDlfPZq4sv0JhLdkIGFC+ek=", "Ia5kMB3KliVjjWqyu+cTX/qQ7NDEP/kfxMaG/EbgkbA=", "A3n2PIzjRo1NopMWb0lJKIVL6eNDLglVWFhTTu2NNQs=", "AC1WQgNZ0CZqdEoICAngVMoOSSGkZoasjJ9YoyTDUEk=", "EjFY5ZZbXZsdaLPNMuELvtqNYkWeIfQJD8LFr5Y1FaY=", "C+KfxAhHqUFmHRS79svgQg+7K29Sg21OYMgOtJytnsE=", "Gslpkd7CuwVXcWFCAVpFPDbbnYWcrV+aIzgC8k/fTBo=", "FZZEP3Y9vMJfSWT8YdI7Pl4SyfqX8YqSUcozVbywYn4=", "EuC802VL36drKGHU7Drq4PGFfZ8X5xWu1tBJ6uO6MhI=", "D8krTxu+qCuepz1K+a8qUM6rrH83FUsZBObHbHz5ZLo=", "H5wLFhBEZELW8uWSqAE/QLFPfHciI29PnH6WUjOHJ2I=", "Dr10JErnJnX4zeBhV6eC9AUNkU2ji0wFjRWfZD279NM=", "LLfw7Tnhbp9pqfr9SrlRwDsGcelzRu45eoOYOdzPxtE=", "Gp1uLs/wIsxWBUQ+5BurIM52HQUUzlJmkMcrynNS2b8=", "KhFUOWB/M1peqDw7xEqTMdDBMyapp7owh9oYLWSOxy8=", "I/m2UptdBA0VuPp67j40EOc4tWMFzUTylTXBFcWkwGA=", "BYcsFtsPcqIkmsa6SEu5w6POl8FtWLaLJg65OfDm6Kc=", "EwC97gi7eCTKIPuAEYB19AIZthUdVbXFK2JKfN7d9qc=", "Gbm2PS8QjhfmOBeGOo9sKI160pkW2YyxBy5Oe31Ss3Y=", "AVvuE1fjwBW1vaI3ZoUi9hPRyIcmtexCJKIBKEgbT38=", "KVNzbpS7a58blwek8WFeTv4eHOS6shjL6pLHhbEo/9E=", "CwaTU7oJFhiGL4BhgMA4X4UbmNNytF9UTOcmbtZgjfw=", "ME901GHMwTEV5OC8+5OBflWut+uTBrZOT1iKyX2B9Ck=", "FbvxRs6bygnooz9ed9/k9arSoWSkYXpMuO5UFc3pE/w=", "CrTf4MJ0LN5EkBAxSHlk7ZuPS4UEBcEMqf8jhZVyyMY=", "DjLbMgoETjGX9F92SaGWde9e7f6lRt6pJR3jn5Y5d5o=", "ChdWqh83jKSydjWni2iI5meXczqCd0iWoweO+lFtoBY=", "BExKM7EPaTRH/RcXf5Uu+JXmHTKPhe+pQlTWoqJdk+8=", "LtNhG3JbinC+ZVtTf2b3AP4IedeaSWiR03sHtUZsS4s=", "H5uk6Lq3zkLI7MPXIqouDq3965z900e12DOepxIIWKo=", "GyMwQwUujCiPfukHqE5RiqOOgqxFAgZtt0BW+GXF09o=", "JDHhzBZLuNB0Axq3K9VbTJAgU7/A8U2wyi+XsCCHWVQ=", "CC+TTJH1qsMwzWlToKfbRaE+MiCXWDMZp5Hyc5ZYAf0=", "K5oKIj51OLCjS+B0MVVCo8dyReKufL6Zmta7kwxImXw=", "DhzZHt0s+izOuFSDuIepvoFkFj51qKAOsLWJzHAhTn0=", "Lh6sDyv9/WPJUfYUd+NpiZl3TxmFTQD1iNMkYBzr4vk=", "DL+pXzf7dAYMdhWOdp1tFXNFeE2O/bM8I9dIEVtQC4M=", "CPBbO+kj7UTWWtSdimHppnbZkeOndRPZmAwjLfpKT4Q=", "InGeKgcLzQhSv44hmE0EQ+coSSXcB1ijJaLdUQwEfvY=", "BB9Zap7hyyvAYPf8w6GrTHvb8DYRmYLA9B9isvJoMMA=", "Iz/TXeG+UgqHYo6wb2sdTAIb4cLQ3EZKGfzdCYaxD4k=", "BSS0bRqoel5DJeCkI+vIENMeB4qhtHB+78tFPGHJwmc=", "LDT0JMgeVxbOR/ysiUuFgkInu5VLDzGZzESGI3xRUhE=", "C18qS2M4eBkgfv/CtVQfty3SAltUV8yX8zAQMn3kkV4=", "IiB4VggszFTFty/kOdLP1sF0NdL1evbOrvrEH+BcZZ8=", "JNV6i/XaY/5OJBWbf4lQtc37IQGUyvefJ4VASM4sgXE=", "Cvqxgf3V4Fg7Nx11vWk/mDdK1wl7sBqFc5Gbsjt5OW4=", "LbqbEI8gh3KZilLvrHy9VnbABXGUwWwL8WKQ1isRKO4=", "JjSbZu24sW9W+IHHiPU/g8u4PeC9WSslWv8T5rzkILM=", "Ja984OXhA1doXpX5Izl1OtgaVtKOzBk7I1KIo+bxN9s=", "JbTOe9IpQ5DAlNalXt1ouXDu16roiyv/H3wBh/41AR8=", "IsVD8Q9siew4flPxkIqI5d6c7yjr3zCxjLnVTB4CtjE=", "Ajb5PneJxHJPx5CKnxkeHkJekGqRnXo032aOdIgvh6k=", "KTULQBFmygEOfSfjfQXamWUr2uEU6wFlnLSXr5gMS1I=", "Du14fWWCDT9r0xu6tUf3WmXtt12ETruJ7hJgkWZSNj8=", "B8wRcPE7RvIDanU/Ugsykf3NDpm9lCl9GQb2VvTeb60=", "Irk5IzsdcgX0m89hOj0wsZCHhtf59dEMIFlDVonorOo=", "AUUXYqCquByKrR3IvDPocHQPCDpaqFQ4rdZQrOYK5aY=", "I1BrtdhyfURh+r8QJdRtH+MuqmHex9pX5wT+wIkvzok=", "LkhMROg4rqC6wGrj9xvdCSo3CVMeHv6pf4vWiQc1VSI=", "D0vH0H66/WQ3nnjFC9LkK69KWUVFztwlRUGNomg1tUw=", "H008j2WD6eX6dmN4Yvqu6FFYI4hyXfRg5iCZbVDY504=", "CTUU4McHEfgmYNB74OSpiPrgKrx7aB2RU+uby0j+c4k=", "GtqwyOKzutNGaZorXzvANkPug+zkcijySljgo0fhU9g=", "FnKxcmBX2Z3RRwnrtHRkGjeMG5S4ByusGiLb756A2tI=", "Hf1T1Fdq8uOPRPU/3KtGjMXY4vrgrMTuMNR7I5tHnBQ=", "DGiIoQt1sPOnCjYmOjfhf+bXfWQPb8PevH8gd1MgXGA=", "Gt25M6Zb53CSs0p+d9Ev6GEaYeAO5oSLhQkezKnR5Qg=", "ANdUDc0mioRcEK4Y0d6TPPY4/1Ql8K//eTVijimdF5E=", "FAwOQmh+nq0BsoJ6VmTKnCb+3eSs2Z2x0xaTnSC4LA4=", "Lww6EV1DF9GRuom40T0YBsIKD5sk+MXtwJHirlZWWYQ=", "DE7neP98FFUwBu0iDPnIEAigz/ZwsiuC2MU4odyVjGE=", "FwTydm1G+Cw2k/AEQMzDYJQk7SbArMZiJ8PXSF3nTGk=", "Ly0ZzD6l146noCwbUdJEq/B2nJ+FROQCObZv6QCcPPo=", "GuA4U7dfyrpQU/ES4qjo3N1+5suc/tnH1sdmqAb8Zik=", "CXGqv3lSQd9R0THQ+mGqXzVWkhstbwFOTkGobdrwVtU=", "FAjDFuYBThqR1M9rbg3nPtpiT4OA3xyHX1wp97/i9kY=", "Fmfz/i7b6FAkir5CtUMJO2yJ8fdz7yhTQWkfOYIu9b0=", "E798XQ0sQ3akiwoDVXzfkVuBcYQJ5cEzQkxpV2UA/jc=", "B2IKbfsLbOwwFq3z01M8JAJLlTR4VreXGbwLp0OmLCw=", "FXTH7wxDVF82qMoIvb3YsHXSlZ4vMitzFnXePhmCtNA=", "Jp5LW3oushr9VnlwpxfO7FvUGEVxwlT9wG4Dp/+DePA="],
      M: [["Bm9vhdb2ioXsEDRTUaI6Oq8H84r4yVKnvOynC9KvetU=", "K51LQRDJrpl3guFQmx0P2yCnwCu9i+pzBUYrn4Elseg="], ["DMV827CFB9Yr9npEk8wmL7bAnVVwE//x9XP0MSIfj/k=", "EnTmSaMu01WjGm7WlyThra3oV+hutcOhIbzRR5QyA8g="]]
    };
    exports2.default = _default;
  }
});

// node_modules/@selfxyz/common/node_modules/poseidon-lite/poseidon1.js
var require_poseidon1 = __commonJS({
  "node_modules/@selfxyz/common/node_modules/poseidon-lite/poseidon1.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.poseidon1 = poseidon17;
    var _poseidon = _interopRequireDefault(require_poseidon());
    var _unstringify = _interopRequireDefault(require_unstringify());
    var _ = _interopRequireDefault(require__());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var c = (0, _unstringify.default)(_.default);
    function poseidon17(inputs) {
      return (0, _poseidon.default)(inputs, c);
    }
  }
});

// node_modules/@selfxyz/common/node_modules/poseidon-lite/constants/2.js
var require__2 = __commonJS({
  "node_modules/@selfxyz/common/node_modules/poseidon-lite/constants/2.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _default = {
      C: ["DumlkrqalRjQWYbWVvQMIRTEmTwRuymTjSHUcwTNjm4=", "APFEUjXyFIxZhlhxafwbzYh7CNTQCGjfVpb/9AlW6GQ=", "CN/zSH6KyZ4fKaBY0PqAuTDHKHMLerNs6HnziQ7Pc/U=", "Lye+aQ/a7kbDzij3UysTyFbDU0LIS9puIJZjEPrcAdA=", "KyrhrPaLe40kFr6/PU9iNLdj/gS4BD7ki4MnvryhbPI=", "AxnQYgcr737MperAb5fU1VlSwXWrawPq5ktEx9vxHPo=", "KIE9yuuuqoKKN234evSmO8i3vyetScYpjvezh78oUm0=", "JydnOyzLyQPxgb844cHUDSAzhlIAw1K8FQkord35y3g=", "I07EXKJ3J8LnSr0rKhSUzW771D40BYfWuPueMeZcxjI=", "FbUlNAMa4Y9/hiyyz3z3YKsQqBUKM3sczZn/boeX1Cg=", "Dcj61tnks19e2aPRhrec444Oio0bWLEy1wHU7s9o0fY=", "G82V/8IR+8pgD3BfrT+1Z+pOs3j2Lh/sl4BVGKR+TZw=", "EFILCrchyt/p7/gbAW/DTcdto2wleJN4F8uXjQad5Vk=", "H21IFJuOf32bJX2O1fu69CkySYB1/tCs6IqeuB9WJ/Y=", "HZZV9lIwkBTSngDvNaIIm//43ByBbw3JyjS9tUYMhwU=", "BN9aVv+VvK+wUfexzUOpm6cx/2fkcDIFj+PUGFaXzH0=", "BnLZlfj/9kAVGz0pDO2vFIaQoQqMhCSn9uwoK25L6Cg=", "CZlStBSIRFSyEgDX/6/dXwyancwG8nCOn8HYIJtcdbk=", "BSy6IlXf0Ax8SDFDuo1GlEjkNYaptM2Rg/0OhDprn6Y=", "C4ut7mkK246wvXRxK3mZr4LeVXByUa13Fgd8uTxGTdw=", "EZsVkPEzB69aHuZRAgwHx0nBXWBoOoBQuWPQqOSyvdE=", "AxULfNbV0XslKdNr4PZ7gyxKz8iE707lzhW+C/tKjQk=", "LMYYLF4UVG488ZUfFzkSNVN077g9gImKvmnLMXyepWU=", "AFAyVR5jeMRQz+EppASzdkIYyt7awU4rktLNcxEb8Pk=", "IzI34yibqjS7FH6XLry5UWRpw5n8wGn7iPnaLMKCdrU=", "Bcj09OvUpuPJgNMWdL++YyMDfyGzSuWk6AwtTCTWAoA=", "CnsdsTBC05a6BdgYoxnyUlK8817zru2R7h8JslkPxls=", "KnO3H5shDPWxQpZXLJ0y2/FW4rCG/0fcXfVCNlpATsA=", "GsmwQXq8yaGTUQfp/8kdw+wY8sTb5/Ipdqdgu1xQxGA=", "EsAzmuCDdII/q7B2cH70eSafPk1ssQQ0kBXuBG3JP8A=", "C3R1sQKhZa1/WxjbTh5wT1KQCqMlO6rGgkZoLlbpoo4=", "A3woSeGRyj7bHF5J9ui4kXyEPjeTZvLqMqs6qI1/hEg=", "BaaBH4VW8BTpJnRmHiF+m9UgbFyToH3BRf2xdqcWNG8=", "KaeV59mAKJRulHt11U6fBEB26Hp7KIO0e2de9fOL1m4=", "IEOaDISzIutFo4V6/Bj1gm6Mc4LIoVhcUHvhmZgf0i8=", "Lguo2U2ez0qU7CBQxzcf8btQ8neZqEttSipvKgmCyIc=", "FD/RFc4I+yfKOOt8zoIrRReCLNIQkEjS5tDdzKF9ccg=", "DGTL7LHHNLhXlo273PgTzfhhFlkyPby/yEMjYjvpyvE=", "AoowWEfGg/ZG/KklwWP/WudPNI1iwrZw8UJs75QD2lM=", "Lk71EP8Lb9pfqUCrTEOA8mpry2TYlCe4JNZ1W1254ww=", "AIHJW8QzhOZj15JwyVbOO4kltPbQM7B4uWOE9QV5QA4=", "LtXwyRy9l0kYfi+t5ofgXuJJGzScA5oLuoqfQCOguzg=", "MFCZkfiNo1BLvzdO1ari8DRIoix2I0yMmQ8B8zpzUgY=", "HD8g/VVAmlMiG3xNSaNWufChEZ+yBntBp1KQlEJOxq0=", "ELTn86td8AMElRRFm24Y7sRrsiE+jhMeFwiHtH3cuWw=", "KhmCl5w/9/Q93VQ9iRwqvd2A+ATAd9d1A5qjUC5Dre8=", "HHTuZPFeHbb+3b6tVtbVXbpDHrw5bJr5XK0PExW9XJE=", "B1M+yFC6f5jquTA8rOAbS55PLouCcIz6nC/kWgrhRqA=", "IVdrQ45QBEmhUeTurxexVChcaPQtQsGAihGr83ZMB1A=", "LxfAVZuP55YIrVyhk9YvELzoOEyBXwkGdD1pMINtSp4=", "LUd+OGLQdwinnoqulGFwvJd1pCATGEdK5mWwsbficw4=", "Fi9SQ5ZwZMOQ4JVXeYTyka+6ImbDj1q82Jvg9bJ0fqs=", "K0yyM+3pukgmTs0siuUNGteoWWqH8p+Kd3enAJI5MxE=", "LI+8st2Fc9wduvj0YihUd22y7s5thcTPQlTnw14DsHo=", "HW80dyXkgWry/0U/DNVrGZ4bYen2Aemt5eiNuHCUnak=", "IEsMOX9OvnHrwtiz31uRPfnmrAK2jTEyTNSa9cRWVSk=", "DEy53DxP2BdPEUmzxjw8L57LgnzX3CVTT/j7dbx5xQI=", "F0rWGhRIyJmiVBZHT0kwMB5cSUdSeeBjmmFt3EW8e1Q=", "GpYXe89NjYn3Wd9OwvPN4uqqKMF3zA+hOpgW1Jo40u8=", "Bm0EskMx1xzQ74BUvGDE/wUgLBJqIzwagkKs42C4owo=", "KkxPxuwLDPUhlXgoccbdOzgcxl9y4CrVJwN6Yqob2AQ=", "E6stE2zPN9RH6fLhSnztyV5yf4RG9tnX5Vr8ASGf1kk=", "ESFVL8omBhYZ0k2EPcgnacGwT87Cb1UZTC4+hprMapo=", "AO9lMyKxPWyIm8gXFcN9d6bNJn1ZXEqJCaVUbHyXz/E=", "DiVIPkWmZSCLJh2Lp0BR5kAMd21lJZXZhFrKNdijl9M=", "KfU23LnddoIkUmRlnhXYjjlaw9Td6S2MRkSNuXnuuok=", "KlbvnyxT/rrf2jNXXb29iFoSTieAu+oXDkVrqs4Ppb4=", "HINhx461z13s+3otF7XECfKuKZmkZ2Lo7kFiQKjLmvE=", "FRr/XziyCg/ARzCJqvAga4Po5op2RQe/09CrS+dDGcU=", "BMYYfkHtiB3BsjnIj3+dQ6n1L8jIts3R525HYVtR8QA=", "E7N72A9NJ/sQ2EMx9vttU0uBxh7RV3ZEnoAbfdycKWc=", "AaXFNic8LZ31eL+9MsF7eizjZkwqUgMskyHOscToqOQ=", "KrNWGDTKc4Na0F9desuVC0qaLGZrlybagyI5Blt8OwI=", "HU2OwpHnINsgD+bWhsDWE6yvavTpXTv2n37VFqWXtkY=", "BBKU0sxITSKPV4T+eRn9K7klNRJAoEtxFRTJyAtlrx0=", "FUrJjgFwjGEcT6cVmR8ASJj1eTnRJuOSBClx3ZDoH8Y=", "CzOdisyn1Pg+7dhAk671EFCzaEyI+LCwRSRWO8bqTaQ=", "CVXknmYQyUJUpPhM+6s0RZjw5x6v9Kfdge2VtQg5yC4=", "BnRqYVbrpUQmueIiBvFavKmm9B5vU1xvNSVAHqBlRiY=", "Dxj1oOzRQjxJbzggxUnCeDjleQ4r0KGWrJF8f/Mgd/s=", "BPbuyhdR9zCKxZ7/W+smHku1Y1g+3nvJKnOCI9b3bhM=", "K1aXM2TExPXBo+xNo83OA4gR6xFvs+RbwXaNJvwLN1g=", "Ejdp3UnVsFTc12uJgEsby44TkrOFcWpdg/62XUN/Ke8=", "IUe0JPxIyAqI7lK5EWmqzqmJ9kRkcRUJlCV7L7AcY+k=", "D9wfWFSLhXAabFUF6jMqKWR+bzStQkPC6lStiXzr5U0=", "Ejc6glH+oATfaKvPD3eG1Lzv8oxdu+DDlE9oXMCgsfI=", "IeT06l81+FutfqUv90LJ6KZCdWtq9EID3YofNcGpADU=", "FiQ5FtadLKPftHIiJNTEYrVzZkkvRekNioGTTxvDsUc=", "HvvkbdeleLT2b5rbyItDeKvCFWbhoEU8oTpBWcrASsI=", "B+pehTfPXdCIhgIOI6fzh9Ro1VJb5m+FO2csyWqIlpo=", "BajE+ZaLiqO3tHijD5pbY2UPGadefOEcqf4WwLdsALw=", "IPBXcSzCFlT7/lm9NF6NrD94GMcBuceILZ1Xtyoy6D8=", "BKEu3tqd/WiWcvjGf+4xY23NjojQHUkBm9kLM+sz22k=", "J+iNjBXzfc7kTx5UJaUd7L0TbOUJGmdn5J7JVEzNEBo=", "L+7Re4QoXtm4pcjF6VpB9m4JZhmncDIjF2xB7kM95NE=", "HtfMdu30XHxAQkFCD3Kc85TllCkRMSoNaXK4vVOv8rg=", "FXQumbm/oyMVf/jFhvVmDqxng0dhRM3K3yh0vkVGaxo=", "GqwoU4f2XoLIlfxoh930BXcQdFTG7AMXKE8DPyfQx4U=", "JYUcPIRdR5D53a29tgVzV4MuLnpJd19x7HWpZVTWfHc=", "FaWCFWXMLsLOeEV9sZft81O367osVSM3DdzMPZ8Uamc=", "JBHVekgTuZgO+n4xodtZZtz2TzYEQndQLxVIXyjHFyc=", "AC5vjWUgzUcT4zW4wLbS5kfpqY4S9M0lWIKLXvbLTJs=", "L/e8j0OAzemX2gC2FrD80a+PDpHi/h7XOYg0YJ4DFdI=", "ALmDG5SFJVle4CckRxvNGC6VIfa3u2jx6Tvk/rsNPL4=", "Ci9TdouOv2qGkTsOV8BOARykCGSKR0OofXetvwycNRI=", "ACSBVhQv0Dc6R5+R/yOelg9Zn/fpS+abfyopAwXhGY0=", "Fx1WILh7+xMoz4wCqz8MmjlxlqpqVCwjUOtRKisrzak=", "FwpPVVNvfclwCHx8ENb612DJUhct1U3ZnRBF5Ow0qAg=", "KaujP3mf5mwu8xNK6gQzbsw344wc0hG6SC7KF+Lb+uE=", "HpvBeaT911j90bsZRQiNR+cNEUoD9qDotbplA2nmSXM=", "HdJpeZtmD61Y9/SJLfsLWv6q2GmpxLRPnJ4cQ72vjwk=", "Is28i3ARetFAEYHQLhVFnnzNQm/oacfJXR3Syw8krzg=", "DvBC5FR3HFM6n1elXFA/zv0xUPUu2Up81bqTucfazv0=", "EWCeBq1sj+Lyh/MDYDfohRMY6LCKA1mgOzBP/KYugoQ=", "EWbZ5VRhbbqedT7qQnwXt/7NWMB23+QnCLCPW3g6qa8=", "LeUpiUMahZWTQTAmNUQT2xd/v0zSrAtW+FWoiDV+5GY=", "MAbrT/x6hYGabaSS86isHfUa7lsXuOiddL8Bz19x6a0=", "KvQfu2G6ioD9z2//nj9vQimT/o8KRjn5YjRMgiUUUIY=", "EZ5oTeR2FV/lprQajryF24cYqyeInoXngbIUus5IJ8M=", "GDW3huLokl4Yi+pZrjY1N7USSMI4KPBHz/eEuXs/2AA=", "KCAaNMWU36NNeUmWxkM6INFSusKnkFySbEDihasy7rY=", "CD79eifRdRCU6A/vr3iwAIZMgutXEYdySnYfiMIsxOc=", "C2+Io1dxmVJhWOYc7qJ76BHBbfd3TdhRngeVZPYf0Ts=", "Dsho5tFeUdlkT2bh1kcalFiVEcoA0p4QFDkObuQlT1s=", "KvM+P4ZncScawMmz7S4RQuzT50uTnNQNANk3q4TJhZE=", "C1ICEfkEtefQm12WHGrOdzRWjFR91oWLNkzl5HlR8Xg=", "Cy1yLQkZoarY21jxAGKpLqDFasQnDoIsyiKGIBiKHUA=", "H3kNTX+M8JTZgM6zfCRT6Ve1SpmRyji74AYdHtblYtQ=", "AXHrld+/fR6uqXzThfeAFQiFwWI1oqao2pLOsB5QQjM=", "DC0OO1/VdUkym/aIXaZrm3kLQN79LIZQdiMFOBsWiHM=", "EWL7KGicJxVOWoIotOcrN3y8r6WJ4oPDXTgDBUQHoY0=", "LxRZtl3uRBtkrThqkegxDygsWpKonhmSFiPvgklxG8A=", "Hm/zIWtojD2ZbXQ2fVzUwbxInUZ1TrcSwkP3DRtTz7s=", "AcqL5zgyuNBoFIfSfRV4AtdBpvNs3CoFdogfkyZHiHU=", "H3c1cG/+n8WG+XbVvfIj3GgChggLEM6gC5td4xX5ZQ4=", "JSK2D06jMHZAoMLc4EH7qSGsEKPV8JbvR0XKg4KF8Bk=", "I/C+4AGxAp1SVQdd3JV/gzQYytT1K2w/jOFsI1VyV1s=", "K8Gui43buB/KrC1EVV7VaF0UJjPp35BfZtlAEJMILVk=", "D5QGuCllZKNzBFB7jbo+0WI3EnOgex/JgBH81q1yIF8=", "I2Co6wzH3vpntymY3pBxThfnWxdKUu5KyxJsjNmV8Kg=", "FYcaXN3q2XaATIA8uu8lXrSBWl6W34sAbcu8J2f4iUg=", "GTpWdmmY7p4KhlLdLzsdoDYvT1T3I3lUT5V8ze77Qg8=", "KjlKQ5NPhpgvm+Vv9PqxcDsuY8itM0g05DCYBed3rg8=", "GFmVTP64aV8+i2NdyzRRkoks0RIjRDuntBZuiHbA0UI=", "BOEYF2MFDlgBNETby5nxkCsRvCXZC73KQI04GfT+0ys=", "D9slPe6Dhp1AwzXqZN6MW7EOuC2wi16LH15VUr/QXyM=", "BYy+ippQJ72qTvtiOt6tYnXwhobxwImEqdfFuum08cA=", "E4Ltzplx4YZJfq2xrrH1KyO0uDvvAjqw0VIotMzspZo=", "A0ZJkPBFxu4IGcpR/RGwvn9huOuZ8Ut34eZjRgHZ6LU=", "I/e/yHINwpb/8ztB+Y/4PG/KtGBdsutaqlvBN663Clg=", "ClmhWOPuwhF+bpTn8OnezxjD/9XhUxqSGWNhWLuvYvI=", "BuxUyAOBwFK1i/I7MS/9POLE66BlQgr49MI+0Adf0Hs=", "EYhy3IMuDrVHa1ZkjoZ+yLCTQPenvLG0li8P+e0fnQE=", "E9afoSfYNBZa1cfLp61Z7VLgsPDkLX/qleGQa1IJIbE=", "FpoXf2PqaBJwscaHenPSG94UOUL7cdxV/YpJ8Z8Qx3s=", "BO9RWRxurZfvQvKHrc5A2Tq+sDK5IvZv+36aWnRQVE0=", "JW4XWh3AeTkOzXynA/suOxnsYYBdTwPO1fRe5t0Paew=", "MBAtKGNqvV/l8q9BL/YAT3XMNg0yBd0toAKBPT4s7rI=", "EJmOQt/NO78cBxS8c+sb9ARDo/qZvvSjH9Mb4YL8x5I=", "GT7djp/PPXYl+n0ktZih2J8zYur01YLv7K12+HnjaGA=", "GBaK/TTy2RXQNozoC3szR9HHpWHOYRQl8mZNeqUfC10=", "KTg8AevTtqsMAXZW6+ZYtqMo7He8M2JuKeLpWzPqYRE=", "EGRtLyYD3jmh9K5ed3GmSnAttuhvt2q2AL9XP5AQxxE=", "C+teB9GycUX1dfE5WlW/Ey+QwltA2ns4ZNAkLcsRF/s=", "FtaFJSB4wTPcDT7K1itciDD5W7LlS1mr3/vwGNlvozY=", "Cmq9HYM5OPM8dBVOBAS0tApVW7vsId36/Wct1iBH8Bo=", "GmefXTbre1yOoSpMLe3I/rEt/+7EUDFycKbxmzTPGGA=", "CYD7IzvUVsI5dNUODr/eRyakI+raTo9v+8dZLj8bk9Y=", "FhtCIy5huEy/GBCvk6OPwM7OPVYoySggA+ustcMSxys=", "CtoQqQx/BSCVD31Hpg1eakk/CXh/FWTl0JID20feGgs=", "GnMNNyMQuoIyA0WimsQjjtPweoorThIbtQ3bmvQH9FE=", "LIEg8mjvBU+BcGTDad2n6pCDd/6rpcTf+9oQ71joxVY=", "HHyIJPdYdT+lfAB4nGhCF7kw6VMTvLc+bnuGSaSWj3A=", "LNntMfX4aRyOOeQHenT6oPQArYtJHrP3tHsn+j/Rz3c=", "I/9PnUaBNFfPYNkvV2GDmaXgIqwyHKVQhUriORiiLuo=", "CZRaXRR6T2bO7OZAXd3Z0K9aLFEDUpQH3/HqWPGAQm0=", "GI2cUoAl1MK2dmDGt3G5D3x9puqinT8mim3SI+xvxjA=", "MFDjeZZZa3+B9oMRQx2HNNun2SbTYzWV4MDY3fTw9H8=", "Fa8RaTloMKkWAMqBAsNcQmzq5UYeP5XYnYKVGNMK/Xg=", "HabQmIVDLqmgbZ83+HPZhdrpM+NRRmspBChNozINisw=", "J5bqkNJpryn1+KzzOSESTk5PrT2+ZYlF5UbuQR3aqcs=", "IC190doPa0sDJcizMHdC8B4VYS7I6TBKfLAxngHTLWA=", "CW1nkNBbt1kVapUromPWcqLX+ceI9Mgxop2s5MD4vl8=", "BU76H2Ww/OKDgIllJ12He0ONojzlsT4ZY3mMsUR9JaQ=", "GxYvg9kX6T7bMwjCmALeudiqaQETsuFIZMz24Y5BZfE=", "IeUkHhJWTdb9nxzdKg3jnu3+/BRmzFaOxc63RaBQbtw=", "HPtWYujPWskiaoDuF7Nqvstzq1+H4WGSe0NJ4Q5L3wg=", "DyEXfjAqdxu65tjR7LNztiyZrzRiIKwBKcU/Zm6yQQA=", "FnFSI3RgaZKv+w3X9xsSvsQjau3mKQVGvO9+H1FcIyA=", "D6PsW5SIJZwutM8kUBv62b4uyeQsXMjM1BnSppLK2HA=", "GTwOBOC9KYNXyyZsFQYIDtNu3OhcZIzAhejFexq1S7o=", "ECrfjvdHNaJ+kSgwbcvDyZ9vcpHNQGV4zhTqKtq6aPg=", "D+CveFjkmFnipU1vGtlFsTFqokv73SOuQKbQy3DD6rE=", "IW9nF7vH3tsIU2oiIIQ/Ti2l8dqp69796KXqc0R5jSI=", "HaVcyQDw0h9KPmlDkZGKGzwjsqx3PGs++I4uQigyUWE="],
      M: [["EJt/QRug5MmytwyvXDansZS+fBGtJDeL/ttoWSuoEYs=", "Fu1B4Tu5wMZq4RlCT928vJMU3J/b3upV1sZFQ9xJA+A=", "K5C7oA/KBYn2F+fcv+guDfcGq2QM6yR7eRqTt042c20="], ["KWnyfu0xpIC5w2x2Q3nbyizI/dFBXD3e1ilAvN4L13E=", "LiQZ+ewC7DlMmHHIMpY9wbiddDyMe5ZAKbIxFoex/iM=", "EBBx8AMjebaXMVh2aQ8FPRSNThCfX7BlyKrMVaD4m/o="], ["FDAh7GhqPzMNX55lRjgGXObNeeKMWzdTMmJE7mWhsac=", "F2zAKWla0CWCpw7/CKb9mdBX4S5Y59e2sWzfq8juKRE=", "GaP8ClZwK/QXun/uOAJZP6ZERwMHBD93cyec1x0l1eA="]]
    };
    exports2.default = _default;
  }
});

// node_modules/@selfxyz/common/node_modules/poseidon-lite/poseidon2.js
var require_poseidon2 = __commonJS({
  "node_modules/@selfxyz/common/node_modules/poseidon-lite/poseidon2.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.poseidon2 = poseidon23;
    var _poseidon = _interopRequireDefault(require_poseidon());
    var _unstringify = _interopRequireDefault(require_unstringify());
    var _ = _interopRequireDefault(require__2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var c = (0, _unstringify.default)(_.default);
    function poseidon23(inputs) {
      return (0, _poseidon.default)(inputs, c);
    }
  }
});

// node_modules/@selfxyz/common/node_modules/poseidon-lite/constants/3.js
var require__3 = __commonJS({
  "node_modules/@selfxyz/common/node_modules/poseidon-lite/constants/3.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _default = {
      C: ["GbhJ9pRQsGhI2h05vV5KQwK7hnRO3CYjiwh44mntI+U=", "Jl3f4SfdUb1yOTR7dY8KEyDrLMdFCswdrUf4DI3PNNY=", "GZdQ7EcvGAng9mpUXh5RYkEIrIRQFcKqPfw2urSX2Ko=", "FX/z/mWscggRDwal90MCsU10PqJQZ/D/0DL3h8fxzfg=", "LknEPEVp3Zxf01rEX8oz8QsVxZBpL4vu/hj0iWrJSQI=", "DjX7iZgYkFINSu8rbWUGw8svC2lzwk+oJzE0X/otHx4=", "JRrUfLFcTxEF8QmuXpRPG6nZ54BtZn/+xv5yMALguZY=", "E9oH3GTUKDaYc+lxYCNGQfi+tW/dBeXzVj+jnZwi304=", "DACbhOZQ5tI9wAx9zO90g6VTk5aJ01DNRue4kFX9Rzg=", "AR8WscY6hU8BmS45VvQtiwTrZQxtU16wID3sdL79ygY=", "DtaeXjg6aI8gnZpWHap5YS8/eNBGetRUhd8HCT82dUk=", "BNupSnsM6eIhrK1BRytrvjrsUH9es9M/RjZyJkyfeJs=", "Cj8mN9hA86FusJQnHJ0je2A2dX1LtQv3znMv8dT6KOg=", "JZpmbxKe6hmPihxQL9s4+jmx8HVWlWS25UpIXRGCMj8=", "KL90Wcmy9MbY59BqTuOkf3dF1CcQOOUVejL99+3g1qE=", "ChypQfBXA3Um6iAPSJvo1MN8hbvM5qKu7JG9aUFDJEc=", "DG+PlYvg6TBT1/1PxUUShVU17RU58FHctDom/ZJjYc8=", "EjEGqTzRdXjUJugSisnZCqnooAcI4pbghN1X5pyq+BE=", "JuG6Uq2Shdl906tS+OhACF6PqD/x6PGHewdIZ80t7nU=", "HLVcrXvRM94YpkxcR7nJfL5Ni3v54JWGRHFTfmpK4sU=", "Hc1z5GrNj44OLHzgS95/bSpTBD1QYKQccUPwjm6QVdA=", "ARAD4y9tnGb1hS8FR0pN7wzaKUoOtOm5sSubtFEuVXQ=", "Kx6AmsHRCrKa1fINA6V9/rrf5ZA/WLr+18UI3SKHrow=", "JTneF4W3NZmftNrDXuF+0O+ZXQWrL8X66qaa6HvOwKU=", "DCRsWi747gEmSX8iKz4KDvThw9QchtRuQ5gssR13lR0=", "GSCJxJdPaOlUCBSPfAYy7bsJ5qatGhwvPwMF9dA7Uns=", "Hq4K2KtosvBqDuNu6w0MBYUpCX2RCWt1bY/cL7WmDYU=", "F5GQ5dDiIXnkb4KChyq8iNtuL9wN7pnml2i9mMXQa/s=", "KbueLJB2cyV26agcesS4MhRSj32wDzG/bK/nlKmzzRw=", "Il05TkIgdZlAPv0MJGSpDVJlJkWIKqw1sQ5ZDm5pHgg=", "BkdgYjwlyM91PSOAVbREUyvhNVdFHAh94J79RUsj/Vk=", "ELo6DgHfkuh/MBxLcW2KOU1n9L9Cp1wQkikQp49rW4c=", "DgcL9T+EUbJPnG6WsMKoActRG8DCQuudNht3aT8hRxw=", "G5TNYbBRsE3Tl1X/k4Iac8zWyxHSSR2Kp/khAU3iUvs=", "HXyzm6+4x0ThSHh6LnAjD51OkX1XE7sFBIe1qn10Bws=", "Lskxib0atPaRF9D+mAyA/4eFwpYYKfcBu3SsHzA7F9s=", "LbNmv9020nemkruCW4YnW+rEBKGa4HqQgupGvYNReSY=", "BiEA60hdsGJpZVzxhqaFMphSdUKEUDWa3JnOxpYHEbg=", "B2HTPGZhSqpXDn8egkTKESAkP5L6WeT5AMVnv0H1pZs=", "IPxBGhFNE5ksJwWqA04/MV14YIoPfeTM96cuSUhVrQ0=", "JbXABKS9/LWt2exOmrIZuhAsZ+iz7/tfw6MPMXJQvFo=", "I7GCLSeO1jKklOWPbfb17QOLGG2EdBVa2H59/2Kzf0s=", "InNLTFw/lJNgbEupASSZvw8U0Tv8/MyqFhAqKcwvaeA=", "JsDI/gnrMLfienTcM0kjR+W9/0Cao2ECVEE9P615XOU=", "Bw3QzLa9e7rojqwD+h+7Jhlr4wg6gJgpu9Ym3zSMytk=", "ErZZW9sym2+wQ7p4uyjDvsLApt5G2MWtYGfE6/1CUNo=", "JI2X1/dig9Y77DDnpYdsEcBvypsnXGccXjPZW7fo1yk=", "GjBtQ51GOwgW/G/WTMk5MYtF63Wd3eSqEG0V2b2bqqo=", "KKj4Ny48ONrO18AEIctGIfTxtU3cJ4IbDWLT1ux8Vs8=", "AJSXVxf5qKi7NRUvJNQylAcc4yDIKfOIvIUhg+Hizn4=", "BNXuTDqnj32A/eYNcWSA01k/dNT2U66D9BAyRtsujWU=", "Kmz16aoD1DNjSa1vuO0iace+9UuIIsx20ISVwS794Yc=", "IwTTHqq5YLqSdNpD4Z3et/eSGAgI/W5Duq5I1+/Lo/M=", "A/2ayGWksqbV5wCXhYFySb/win4HJvy04cEdOdGZ8LA=", "ALclje1Su9oiSEBNVe5QRHmK/DogkZMHP3lU1NY7C2Q=", "FZ+BraB3F5nsOPyi1L9l67E9OnTzKY2zYnLFymXpLZo=", "HvkOZ0N/vIVQI3p1vCjju5AAEw6iXwxUceFEz0JkQx8=", "HmX4OFFeX/AZa0mqQaLSVo33ObwXawjslaee2Cky4w0=", "KxsEXe86FmzsbOdo0Hm6dLGMhE5XDh+CZXXBBoyUwz8=", "CDLldTzrD/ZAJUOxEJIpwWXcLXO+9xXj8cbgfBaLsXM=", "AvYU6c7fs9xrdirgo31BurG4QcLotkUbxajjw5C2rRY=", "DiQn04vUamDdZAuONiytlnNw67d3vt/0D2oL4n5+1wU=", "BJNjC3xnC23rfITUFOfOeQSfDsCYw8fFB2i74pIUpTo=", "IurRAOjkgmdN7NqxcGbFomuxUVNV1UYaPcBsyFMnzqk=", "JbPlbmVbQs2q4mJu0lVNSFg/GuNWJtBN5QhOC20qbxY=", "HjJ1KtqINu9YN6bN6P8T27WZwzY0nkxYS0/cCgz2+dA=", "L6KoccFaOHzFD2j288NFWyPACZXwUHj2cqmGQHTUEuU=", "L1abippEJMknjh23MR6In1TMvxBmG6t/zRjnx6fYNQU=", "BEy0VREKj91TGt5TAjTFGKffk/czL/0hRBZTdLJGtD0=", "IngI3pOQbV1CAkYVfy5CsZH+jJCt/hGBeN3HI6UxkCU=", "AvzKKTTgRrxiOt6thzV5hl0DeBrgkK1KhXnS56aAA1U=", "DvkV8KwSC4dqvMzrNEodNrrT88Wrkajdy+wuBg2L76w=", "F5cTD0t6Phd363V7xvKH9qsPuF9r5jsJ87Fu8rFAXTg=", "CnYiXcBBcK4zBshaurWeYIx/SXwgFW1NNsZoVV3sxuU=", "H/+57BmS1muh53p7kyCa9vj6dtSKy2ZHlhdLUyajGlw=", "JXIcT8FaPyhTtXwzj6U42F+Pu6bGucYJBhGIm3l7nF8=", "DIF/1C1fekEhXj0HuhlyFq20w3kHBdqV62O5gr/K91o=", "E6vj9SOZFdOffhPCwklwtt+M+GzgCiIAK8FYZuUrWpY=", "IQb+6lRiJOoS7385mHpGyFwbw9wpvb16ks1grLTTkc4=", "IcqFlGinRraqp5R0o32rSfHKWijHSLxxV+GzNFuw+Vk=", "BczWJVwebwxc8fDfk0GUxikR0U0DIWYqjxpImZ40GFs=", "Dw40pktwpibkZNhGZ0xMiBbE+yZ/5E/m6ihnjLCUkKQ=", "BVhTGk4lRwxhV3lMo20Olkfb/P41DWSDj1saii3g1L8=", "CdPcqRc+0vrO6hJRV2g9GJJMra0/ZVpgty9YZJYfFFU=", "AyjL1U6MCRNJP4Zu0D0hi/I/ktaKrsSGF9THIuW9QzU=", "K/ByFuKv8KIjpIexpwlOB+eee8yXmMZI7jNH3VMp00s=", "Ha80WlgAa3NkmcWDy3bDFtb3jtam3/yCER4Rpj/kEt8=", "F2VjRyRWqqdGtpTGDhgjYR7zkDmy7cf/OR5vIpPSxAQ=", "LvHg+tnwjoeju15H1+M1OMqWTSt9EIPU+wIlA1vT+Ns=", "ImybGvlbq88XsrH1fHMQF5wYA97Fro8KF3ntNsgXrio=", "FLzjVJzD23QoEmtMOhWuD/gUjInxP7NdNXNOtdStDe8=", "Lev/FW4na7V0LDNz8mNbSLjpI9MB83L45VDP1ANCEsc=", "LUCDz1qH9bb8I5WyLjVrZEGv4baynEet19BDLR1HYMc=", "DCJbe80Ev5w0uREmL9ycG5G/eaEMAYTYnDF8U9cWHCk=", "AxUhadTz0G7DOnm/rJGgLJmqAgDbZtWqe4NSZfnJyPM=", "C2GBGpIQvniwWXRYdIbVi93I9Rv9/ru4ev6LeqfTGZw=", "ID4ADK0pjar366alxZIYeLiuSKz3BI8WBG1jelM7b3g=", "GkS/CTfHItE3ZnK2n2yWVbp+44b9oREsB1cUPRv6kUY=", "A3a0+uCMsD01AK/sGh9WrLjg/edaIQbXAC9ZxWEdTao=", "AHgK8socrWRlohcSUP38Mtb8JB0yFBd/PVU+82MYIYU=", "EHdNmrgMJb3rgIvt/XKo2bddvhjVIhyH6dhXB5vcMdU=", "ENxunABuo4sEseA7S9lJDA0D+Ykpyh1/tWgh/RnTtug=", "AFRLgzh5FRiyx2RaUDknmLIfdbtg41lhcAZ9ABQcrBY=", "IiwBF1cYOG8uLoLrEieJ41LhBaO4+oUmE7xTRDPuQow=", "KEDQRem8IrJZz7iBGx4PRbd/e9t/fitGFRoUMPYI48U=", "BidS+G7r4RoAnJN+RowzWwRVRXTCmQGWUI4B+lhgGGs=", "BgQb2sSCBayHrbh8IKR4pxyZUMEqgLwKVajoPqrwR0Y=", "BKUz8jbEItH/kAo2iUmwAix6KuCS8wjYKx3Lv1H1AA0=", "E+MdemcjL9gR1qlVs9TyXf4GbR59wz3wS95QorLQWyo=", "ARwmg66R6037wT1jV+hZmpJ50WSP8sldL3mQW7E5IPE=", "Cw0hk0a4V0UlsaJw4LTLpdVsko4+LCvQoeyu0BWq9q4=", "FKveyNucbclwKR7mOGkCCbZQgHge+f0T2Ex6cmtfE2Q=", "GgtwtLJv3Cj80yqj0mZHiAHrEiAu9HztmI0DdmEL4QY=", "J4VDch+W0TB7aUP5gE5/5WQB3rLvmcTRJwSILnJ4tgc=", "FutZSUqXds9XhmIU29FHPz8HOKMlY42Lo2U14BHVglk=", "JWemWKgf+0RPJACI+lUkxpqeU+6ra3+MQcNHnc+MZEo=", "KaodfBUemtCnqznxq9nPd6t44CFaVxWmuIKt6EC7E9g=", "FcCRIz5g7+DUu/zis2QVAGpPAX+ahTiM4ga5H5nyyYQ=", "Fr19Iv+Fjl4IgsLJmVWNd+dnOtXxkV+f62eagRXwFM8=", "AttQSAoHvg6ywuE+1u9AdMAYLZtmi44I/+Z2klAEICU=", "BeSiIOajvJ97aAbsnWzboYYzDvK/ettME7qGY0O3MRk=", "HdoF68MBcLyYy/Kl7jtQ6LX3C8Qk05+kEE038cvPekI=", "AYS+9yGIgYf2Rbb+42Z/PJHaIUQU2JulzTAfIrDeiZA=", "FJijB+aJAAZfXoJ29irvHDdBS4RJThV3rRptZDQbeOw=", "JfQPgrMdrMT0k5gAudLD6s73N7j6sfhk/jNUitRr1J0=", "CdMXzGcCUZQ/b1hiow0uqegwVs5JB7+7yx/zHOW7llA=", "L3fXd4bZebI7pM5KTBs70KQRMs1GeoarKbkTts8xSdA=", "D1Pa/VNan0Rz3CZrb8zGhBu9M2lj8lTBUvieeF9ym78=", "JcH9cuIjBFJlw6CZ4XUm+g5pduHAC68W3pbehd7vL6I=", "KpAsiYDBf6rjaNOF1S0WvkGvlchOrqPPiT5l1s5Kj2I=", "HOFYCjRS7PMCh4yJdrgr6WZ23RFNHcjSVSdAV2L4NSk=", "JKYHP5Gt3DOkmh+jBt8AiAHF7FaWCQNNL8UPfw9NAFY=", "JeUtvWEkUw2fwn/jBtcdRYPgfKVUtdFXfyVsaLC+K3Q=", "I9/648Qj+nqTRo28z7AphVl0vk0KeymUZ5blts1w8V0=", "BjQto3DMDYxJt3WU9rAnxIBhXVC+NiQ6mVkbyZJO1vU=", "J1QRQoEoZUa3XwnxFfx1G0d4MD0EBcG0zH3w2On2OSU=", "FcGehTTFwaiGLCvB0Rnt3qvyFBU4M9e9tZ7hl/gYfPU=", "Jl/gYnZtCPq0x40NnvPKvjZvO+CoIQYWebSz0td9Xz4=", "E8z2idZ6PsnyLLfNCsOjJ9N3rFzQFG8Ejev9CY0+x74=", "F2YvdFZ4lzn4HNOXSCeoh9kqXgW98/5rn7zMpFJKrr0=", "IbKcdjKbMcjvGGMeUV9/L4LKalzKcM7k6An9YkvnrV0=", "GBN0eDgqrbpEHrl/4nkBmJwGc4FlIVMZk56xewH6l1w=", "K8B+or+taOjcck9f7ys3wtNPdhk1/9O3Oc7sRmjzfog=", "LdsuN29U1kpWOEBIDfmT/rQXMgPCvZStDmAgd675oD4=", "J361DyuqcGEGtByyTGAmCeiiD41y9hNwitslNzWWw/c=", "DU3kfhq6NCadDGIJBPAaVrM/xLRQwNtQu3+Hc0yaH+U=", "C4RCv+nkobRChnO2vT7qb59EVpcFjxNKrpCNAnminww=", "Ef5bGPu+oahuBpMMuJ99SibhhqZZRelldCR/3bcg+PU=", "IkAm9t+vceJNJdj22fkAId9bd03K1NiDFw5K2JwzoNY=", "CyymqZn+aIfgcE2tWNA0ZalryeN9EJH2G8n5xiu+uCQ=", "Ihtj1m8LRfnUDFQFOiigax0KTOQdNkeXoafgyWUp9CE=", "MBhcSLey8dU9QSCAGwR9CHSTvOZNTSSu3OL0g2u4StQ=", "I/XTcqPw48upieIjBWIn01MzVvD6pI8n+CZzGGMqYfA=", "JxZoOzLHVf0b+CNeoWKx84jh4AkNBhYujm375DKPPjs=", "CXdUWDaGb6IEyh2FPsCQnj0UB3DICsZ9yTDGl0jV1Lw=", "FETo9ZK9v9gCXZGrSYLdQl9RaC0xRysF6BxDwPlDSzE=", "JuBLZenKgnC+t0ocXLj+6L4/+/5YP3ASoA+HTncY++M=", "IqXC+oYNEf407kelzZ+GmAD0j0/r4prW32mBb7GpFNI=", "F0tU2ZB9j1xq/Wcqc49Cc37DOPOglkxin3R03UTFyNc=", "HbHbiqRSg/MRaPpmaUzygI0hibh8jIFD1WyHGQezm4c=", "FTC/D0ZSfoiQMLjHt9/eEm9l+vjM4KtmOHNB2BPRv9E=", "C3P2E5kyKfWfAcHOyHYOmTbq2e3I8oFIiTMKLyut5Fc=", "KcJaIv4hZGBFUqrqN39EjVh6uXf8gid4e9LcDza89B4=", "KzDVPtF1m/uFA9pmySz0B3q+gnldwnKzd99X13yHVSY=", "EvbXA7VwKqt7e35pNZ1TonVsCMhe3nInz18KKRZ4fNI=", "JSDhgwCv2j9hpAoLiDcpOlWtAQcQKNSEH/qaxwY2QRM=", "Hsna6oYJcezdqO1PNG+pZ6ybxZJ4J3OTxo8J+gO4uV8=", "Cpmz4XjbLi5DL1zVvvj+RIO/XL9w7UB8CKriS4MK1yU=", "B82p5j22458Ia4m2AcK75AfuCrrDyBehMXq618V3hJI=", "CMnGWk+VXolS1XGxkbsK20m9gpCWMgOzXUiqs4+Pw6M=", "Jzf4zh1aZ7NJWQ3b+9cJ7Zr1Sio/JxnTOAHJwXvdnJ4=", "EEmmxl/wGfDSh3AHJ5jot5CUMr0MEpgTqfF5umJ/fWo=", "GLT+locyxGLA6lqb6yfOy96IaJRP32TuYKUSI2Ha7ds=", "L/K2/SLfSdJECy6u7vqMAqb0eM/PEfGypPdHNIOIXRk=", "LsXy8ZKP6TLlbHibj2u8s+i+QFfL2NvRihs1L1zvQv8=", "JlpezNi5KXXjOtn3W/NCbUJKTGp3lO4/CMHRADeOVF4=", "JAXqpMC94RKdYkK7WtoOaHeOZWz8s2a/IFF9od/UJ5w=", "CUyX2MGUxC6IAYAEy78rxf21GVXYstZrdt2Yotv2BBc=", "LDDV8zuzLFwiuZeaYFv2TVCLcFIh5qaGMwyWJcKv4Lg=", "AadWZvYkH2gl0BzG3LFiLUiG6lg+hymeaqL8cW/bbPU=", "CjKQ6DmBE+pNEqwJHoe+fG01mrmmaXn89Hvy6H04L8s=", "FUrenKNuJo3+s4RhQluw2MMSGdj6Dfx17NIb9pqgzHQ=", "J6qNPiU4DAsbFy15xvIu7pkjHvXcadjcE6S1CV0Ch3I=", "LPQFHmyrSDAaiy47ymCZ11a730ha+h9UnTlbvL2AZGE=", "MB5w9ynzyUsdP1F93/nyAVEx/quK+l7rsIQ9f4SyPnE=", "KYvrZPgS0l2LTZYgNHqwIzLcTO8ROuYNF6jXpMkfg7w=", "GzYucqX4R/hNA/0pHDxHHtHBShWyIWgKzxGj8C5GqpU=", "DciiFGEQwLN1QykCmZIj1aoe9ueOHl68vB2bpB3Bxzc=", "CkhmOzTOXhwF3JMJLLaXeMshcppy3cA6CK+h65Iv8nk=", "Coc5H7HNjN9glrZKgvnpXw/kbxQ7cC10VFuzFIgQmO4=", "G1spRvfCiXXwUS/45so2L4gm7dfqnCnzgrqKKgiS/V0=", "AQAc9RKsJB1H6+Ijkhm8ahc6i7y4pbmHtOrB9TMxW2s=", "L9l3xw9kXbT3BPp9dpPacnrAk9P7X1/rxyvrF9g1ijI=", "I8ADmj+rStPC18xogWTznnYdU1XAVETZm+djqXeTqcQ=", "GdQ+4MYIHAUsnA32Fh6qwa7DVs9DWIjnnyfyL/A/ol0=", "LZsQwvLnrBr93M/9lKVjAovym2RtAggwkZ+dXKHO/lk=", "JFfKbC8qow7Efkr/Wmb1zieZKD4Wb8gc2uLyufg+Qmc=", "Crw5L+he2oVYIFkkRQlAIoEe6Gdu1vDDBE37VKfBCzU=", "GdLMXKVJ0dQM68038+pU8xFhrDmTrPMQHSwrww6sHrA=", "D5euMDP/oBYIqvsmrhPNOT7g5OwEG6ZEo9OrVG6Yycg=", "FtvHj9KLf7gmDkBM8dQnp/oVU36k4WjoihZkluiM/so=", "JA+vKPEUmbkW8IX3O8TyLu+DROV2+K09GCeCA2bV4Hs=", "Chuwdao3/wz+bIUx5V4XcOq6gIyP222/RvjKtY2e8a8=", "LkfhXqSkf/GmqFOq86ZEyjjVsIWsEEL9xKcFp84In00=", "Fm5b8HM3g0iGDKSpwJ054Wc6sFmTX03zX7FFKDdXcrY=", "GLQtf/3S6k+vI1kC8FeidAyszNAnIzAB7RD5ZTjwkW8=", "CJyxsDIjj15JFHiOPjx+rU/DaAILPtOCId6rEFHDdwI=", "JCrNPrOi9yuvfHB23RZa34n5M5x7lxkh2ecIY0Ud2NE=", "F0+7EEpO4wK/R/K9gvzolurJoGgoPzJkdK+GBFckXDs=", "FzQOcdlvRm1h8wWM4JLGfSiR+yuzGGE/eAwnX+ERbGs=", "Ho5ArIU7fULwDy44OYLQJPCYufj9RVlTov04DE339rI=", "BSmJjcBkmQfh1NXihLjRB1GYxVytZuipv0D5KTji6WE=", "IWJ1TbC6oDC/feW7eXNk3OjHeqAX7h179l8hxNTl348=", "EsdVNpjEv2886yUK4AxYwqn5KR773kyEIb70R0F1LsY=", "KSZD47ogJq/8uMUnkxO9UaczyTNT6dnHnLcjE2UmUI4=", "AMzxPgy2+dgdUpUb6pkL1bbAfF2Y5m/3HbbnTVuH0Vg=", "GF0eIOI7CRfdZUEozy86qrZyOHPLMPwisPhsFatkW0s=", "FMYcg21V0990K98Rxg76GGd4494PAkwPE/5T+Nh2Th8=", "DzVoQbP1Vvzl2+RoBFdpHCkZ4q9TAIGE0D7hGV1yRJ4=", "G4/Z/zlxTgdd8ST4h79As4MUM3T9IIC6DAprbo+ls+g=", "DoaowgCcFAyj+HOSTiqqFPw8iuBOnfCz6RA0GHlvYCQ=", "LmxeiY9VR3cOVGKtky/N0jc/xDggyisWsIYUIeeRVcg=", "BdeX8as2RyN8FPnR3wMryf+f4aDs03eXLOX9WgwBRgQ=", "KaMRBGOlqudsPRUodZgdDB2vLc1lUZ71yokphR2owAg=", "KXTae8B0MiJzw6S5HAU1TNxxZAqLvR+GS3MvgWOIMxQ=", "HtD7BmmbokmyowYhwF6xLKKcuRqggsi/zOnFIoibR9w=", "HHk+8NzFESNlT/JtjYY/7q4p6MVy7KkS2AyK425A/ps=", "HmqsHG090xV5ViV9PSNO8YyR6CWJp4Fp+7Sodwl33C8=", "GiCtp1diNO7mJz3W+piyXtA3dICApH2Uj82jMlb7a/U=", "GRAz1thc6qb8epojpv2ZlmQtdyBF7OUTNdSTBnKK+Ww=", "AG5Zedp+fvU6glqm/dw6v8dvIAs3QLiyMu9IH10GKXs=", "Cw1+acZRkQu+8+aNQX6foPvVf1lsjymDHv+MAXTNsG0=", "Jcr1sMG5O8UWQ17AhOLs1ErEbbuwM8URLEsgolyc350=", "EsHqiSzDHg2a+LeW2WRYcvf3dELWL9TICFsvFQ9yRyo=", "Fq8paVFXq6m4u+Ov6yRf7uWpKdn5KLm4Heba3HjDKq4=", "ATbfRXyAWI3Wh/svO+GGkXBbh+xaTP3BaNMQhCVrZ9w=", "FjmijFtMgRZq6phPum5xR54Hse+8dENNuVooUGDnsIk=", "A9Yvv4L9HUMT+OZQ9YfsBoFsKLcAvcUPfiMr2bXKm3Y=", "Ea7rUn3IzkS00Uqt3KPP4vd6HkD8bal8JJgw3h7f3lQ=", "E/m5pBJ0EpR5xeYTjGyO42pnDmvGjHpJZCtkWAe/yCQ=", "Dkdy+j11F53ISEzSbHwfY13e7tepOUQMUGyui3680Vs=", "GzmgDLyB5CfeS97Fj+vo2LWXF1IGemErOfxGpoxdTbQ=", "K+22bhrVodVx4W4pU/SHMfZkY8LrVKJFRE0cCjolcH4=", "LPCgmlXKk6+KvQaPBqcof7CLGTtghYKic3nONdqRXew=", "LRvXj6kOd6qIgwyr/vL40n0aUSBQun2wdTyPuGPvs4c=", "BlYQxvT5JJH0I9MHHrg1OffA1JwThwYuYw1/0oPcM5Q=", "LZM/8ZIXpVRQE7Eoc0Ur68xfmWkDPxXsZC+0ZL1gc2g=", "GqnT/kxkSRD3a5Kz4Tsw1QDa5TVOeVCMPEnIqpngJYs=", "An7wSGnkgrHHSGOMWREcaycJX6dz4aygeM6h8chFC90=", "K31STFFyy7sV204AZoqMRJ9nomBdnsA4AuP6E2rQuPs=", "DHw4JEPGqnh8hxjYZ0fH90aTriWx5V3xP3w8Hdc12w8=", "ALRWcYa8P3xip7Vqz092IHofQ8LTDQ/kpifc3ZvXkHg=", "HkH8KbglRU/m1hc3/gi0f7B/5znkweYdAzdJCIPbT9U=", "ElB81Va3u8xy7m2vxhZYRCHhr4ctjA6JACro07oGU7Y=", "E9Q3CDVTAGvO8xLl5vUqXZfrNmF+82/k130+l/cctds=", "Fj7HMlH4VENociJIfdqaZUZ9kLIvCzhmRoYHfGpEhtU="],
      M: [["I20TOT74XMSKNR3Xht16HeXjmUIpYSf9h5RyI65RCK0=", "J3aGSU92RLvEqbGU4Qck65Z/HcWHGOWePO3IIbKnrhk=", "Aj22h4Tj8MwLhWGIJqmzUFEpwWR5lzsKhKRSnmawnGI=", "HTWdJF8obBLVDWY7rnM/l4rwjNvWMBfFezp1ZG/zgsE="], ["KnWhcVY7gH21Jb4llpmrKP6bx/sfcJQ/8Em8lw6EGgw=", "CDq/9eEAUfB44oJ9CS4a6Ai03T4VzMNwbzjOQVe2dw4=", "GlrXG7vs2Kl9xJz9uuMDrSTVxHQeq4t1aKn/glOh628=", "DXRf0A3RZ/uGdyEzZA8CzpRQBKe8LFnoeQ9yXF2E8K8="], ["IHBnnnmHgu9ZKlLKnO+CDUl60u7Lqn5C82az5SHE7UI=", "LhjIVw0gv134AHOaU9p12Qbs4xjNIkq2s6K+l54tfqs=", "D6hvDyfk091/M2fOhvaE8fLkOG0+W584+ig8aqcjtgg=", "A/Pm+reR8WYoFo5LFNuutlcDXuPaayyoPwwkkeC0A+s="], ["L1ReV4ICyXMkiFQOQfeDto/wYT/Xk3X4uos9MJWOdnc=", "I4EL+Ch3/Bm/9+7+rj+vS7gQTDK6TNcBWWoVYj0BR24=", "AU/NXrC+bVvur8SUQDTPMhwGjvkw8QviIH7VjSo0zdY=", "AMFfw6HVcz3YNerggj43f4ukqLYnYnzCu2YcJdIPtSo="]]
    };
    exports2.default = _default;
  }
});

// node_modules/@selfxyz/common/node_modules/poseidon-lite/poseidon3.js
var require_poseidon3 = __commonJS({
  "node_modules/@selfxyz/common/node_modules/poseidon-lite/poseidon3.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.poseidon3 = poseidon32;
    var _poseidon = _interopRequireDefault(require_poseidon());
    var _unstringify = _interopRequireDefault(require_unstringify());
    var _ = _interopRequireDefault(require__3());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var c = (0, _unstringify.default)(_.default);
    function poseidon32(inputs) {
      return (0, _poseidon.default)(inputs, c);
    }
  }
});

// node_modules/@selfxyz/common/node_modules/poseidon-lite/constants/4.js
var require__4 = __commonJS({
  "node_modules/@selfxyz/common/node_modules/poseidon-lite/constants/4.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _default = {
      C: ["DrVE/uKBXdp/U+KcysmO19iJu069R8OGTzwr2BptqJE=", "BVTXNjFbhmLwL9un3XN/vKGXrrEupkcTunM/KEdRKMs=", "L4O53yWbK2i810gFYwfDd1SQffDA+wA19Qh8WNXowtQ=", "LKcOLo1/OaEkR6yDBSRRtGHxX4tBp17zGRUgj1q6loM=", "HLX5MZvmpF6RsE1yIicclJlBlvEu0ixdTscZy4Ps/qk=", "LrT5nGn5Zuv4pCGS3n/2FiHHu0e5N1DCueoI0YRGwSI=", "Ikoo5aNThafFGYFp5AXZ6g/H2ouT7hO21ffQmeKZUg4=", "D3QRtGXmAO7Yr91q/KScMDbzPsvZoPl4I3lrmTu9gvc=", "D50NWq0slVWivnFQOS2NmBmyCK4zcPmaBib5/12Q5OM=", "HpqW3IKSu1lvUqWVONMpIpcyslJZz3RLahLTBwLW+6A=", "CHgFFMzZA4CIfVeMRVVeWTz+Uuq0uUXGws1NUo+z/jw=", "JySY/O1obHrIFJ+j9z74ws7WRxfjVW1aWfEZ1inMtfw=", "Ae+PndfJOqxLfLgJML0G60W9NQr/WF8Q49Dvingu998=", "BFufWbZZXmFNwI8iK0abE46IbmS/PECql+oK51STTTA=", "CsHpHFfZ2pGf1vWdKkD/jqPkHiTiR6OHrfJYQpXWHGY=", "AooWIalAVLDH+aQhNTzYnQ/WcGGu6Zl50S5o8E5i0TQ=", "JrQYAsBx6kyWMmR+0FkjblDBnD+zyW0J0CquKg3Nnbw=", "L7XdqAcrtyy6rC9j5GghXgXJ3gZ1jbapSvNDhK7bRis=", "IhLToPX8yvJE/zVH/YIySa2KuLoqGNOD3QXFbuiU2FA=", "GwQa1bLwaEJY5N+u6gm+VqMnb9sZ9EwBXNDH7tRl4uM=", "CgF3a7IvS2uOzP8z52/e0xRPt+OsFOhGqR5kr7FQDv8=", "K3tWdKrsw8vzTT8nUGbVSaTzOujBXPgn95NkQIEKzkM=", "KdKZuAzUSJ5M91d57VS0jGCwQiV7ePwATBuAM4Gjvf0=", "HEaDHZp0UpNXZBwhnXIadKQnEQAyteHdGd3jBCS+QB4=", "BtdibJU8y3LzcUHcNNV44DYpbAZXZ0+Ac5rh2IPpEmk=", "KP/dyG8YwTbFQAJ0jgxBDtxcRAowIs2WDxCMcc2ikww=", "Lmf37l5KopX4Xe7QnkALF75n8bftKratuOwGGfb7xek=", "Js44+mNskGMOl/JRFKeaLcpWhZ73WeU856vyLCToDyc=", "Lm4Hw8lb98NN16AdAKf/7ELLPRah9ychr6y0xM/TXbE=", "KqdPdZfwyfRfkdeWHDpU+4iQ0nZhLhJGOEsUcNok2Mw=", "KH1oGkai+q4sfAkPZoq0W4pxMTwVCRg+LsDKY5t/c/4=", "ISvRnfgS6q70pAYAUo89faXTEG/1Zao7EeKfMwXnPAQ=", "EVT3z1GRhr8ar7FLNQ64YPl/2XQJJtq5OAnChARxNQQ=", "Hf9jhcsx8cJGN4EKS9Gxb79RUpBb42WD2nR+eWYfwgc=", "DkRFgtIrTnbAgdNMRMGOQkARo01UdiUoY+o8YGtVHlw=", "AyPJ5DO6ZsSrq2Y4Mo8C8YFXc+nChGMj/3LTqrfk7/g=", "EnRrvXF5EFkZO7p5zexEjyW4zwAnQBEttw8saHapwp0=", "EXO30RLCp5j9m503UYQsddRmyDfPUNc+/QSetEOKIkA=", "E9UcEJChrUh20eVV1/7RPajlcTslAm6+X9tICHAyQ9o=", "AIdME0SkrVH/jct8vS2XQ8tydD8DlO/n9KWOvrlWuqE=", "It8iExqquFhlziNrB/JE+g7qSNNUbpfWoypWIHT+8I8=", "C/lk0tvSW5CHCLQ3pEX8PphFJKWRAebBi/XrBakZ8VU=", "CbGNm5F6VbyjAr4ffxgeDmQLnXOpqymMabQ1tfxQLzI=", "CU9VNERPrjakv8HVvz3AW/u7xwpjZTZt1nRaUGconkM=", "KZm6saXyUhBRn6ZiKvU6FaPiQMDaVwHLeE/dwNwj8B8=", "L2iYwHWB9jccqU23NxDogIQwG86Kk9E2aVdaEbA6PSM=", "ByaOqroIvBnsFtfhMYpHQFZd6x6OV0L4YhdLGmhm/Ms=", "GGJ5sANFTbATOf93ETvJ62JgPgeOHGaJpslYLEGgUp8=", "GKP3NlCRl9bkkVvdBNPl3bZ+LMXemiJ1B2jlUkc3Fyw=", "CiH6GYjPONh3zB4u0kyAjHJeLUvLLToAe1mHuHCFZx0=", "FbKFy+JsRn8fr172pkYlIoMowYSixDvACzahNeeF+6I=", "FktwYsRnHPCMCLjD+YBtVgt3dbfJAvV4jNKN4+d58WE=", "CJC6CBmsCm+G2YZf5+UO82HGHT1DtuZdeiT2USSbqnA=", "L76k1l1+1CWkJxLlpyHk6qYnrFyw64eMzC7grtVD6SI=", "BJK/ODw2+lVUAwOjtTb4XntwpY6FSrm5ED1/Xzeauqo=", "Bekf6UTpRBBOICUcVlFC1h1hhanOhWdfapadViktwk4=", "Ev5cICnksziT1GPLBBrK0JlbliHm5Jw7fjgKduNubBw=", "AkFUrfAlXUeVj3cjkhR0Ex8mKfrciUlpBs0B3G+geE4=", "GIJKCeavr0o27SRiqGvQuteYgVZE8rveiBPBNFekVVA=", "DItILboK1Rvp8lXeDD293d+EpjCvaNULuwaYPj1dWKU=", "FzJf0KtjWHE2PgoWZ9O2fFpPpn/Naq+GRBOSh4/bBeY=", "BQrpX20vFRkSL1r2e2kPMeVQdz+o0Yv3HMbQ6RH6QC4=", "Dw0Tmg6B6UMDjLKI1iY2dku7YpXwdWmIV3HshO3FDEA=", "HA+Gl3lWic33D9LywPk9Gnmznrx6GxxUnbvKe450fNY=", "K9D5QK2Ta3ltK8LgSLyXnkm+I6SxNZj5/lNqFtwdgeY=", "J+sb4nycTpNHeMCaAFMzf6BuuydeCW0WfOVNHpbuYss=", "LkiJ2DCmflqPlr3TFVp8oyhPvTB9H3Gw8VG+YlSOKuo=", "GT/j2wq0fTxdLsXpxb2Zg8mJHyytwWXbYGS75vzB4wU=", "K/MIbpbDbHvOQVkHrQxA7W6WYcAJZ55ON8sTAnyD5SU=", "EvFuLebUrUapjNtpfGytXdXn5BP3Qczyn/LqSG5Zuyg=", "KnIUfSMBGfOgJi42U93RnzPz1dbsbEvwrZGbA0O5LS8=", "Ib4OLEv9ZOVtxH+VeAbcXwotm8wmQS4pd995rMELqXQ=", "Di1+HclG1wsnSaO1Q2eyWnG4T7kRqleuE3/UtsIbREo=", "Jmf3+1pPoSRhcKdF2KQYjMMa2w6uMyXcnz8H1LkrPi4=", "LMxvQx+3QAcwp4O2YGRpehVQwSsI3+tygw4QfaeONAU=", "CIiKlPxaLKNPAgFGJCAAH65tvunoygwkLsUGIeOObl0=", "Apd7NO6qPLatQN1Cybb916DS++dTr4izas/NPMvFPyo=", "EgzM4T0ot1z9b7bJ6hOmSL/P4Nfm/46WELXp+XHha5o=", "CfrSJpxKjpPIHhuXcOoJjJJ4ekV1sr1zoL8q8y+G/zw=", "AmCR/T1MRNUKSzEOSsbw+g3r23B3XuuK9jDP+2AJLW8=", "KUBKorpWW3e7f7qd+2/DISVDzFavrWr8uQT9K8qJOZQ=", "J0lHXDmarznU6HwlSGlbTvH/2GWQ4IJ95yATUbfIg/k=", "CYyEIyJHn3I5kStQQkaFy6Lr4twuTacKx1V9q2X/oiI=", "GM71gSIrZH4xI45X/q19XHWKzhTJPE2kAZHQwFO1GTY=", "Exd4OcaKUIDU50Z0XkNxHTy8DKShCPmNY7KqaBaY3mA=", "AgymlvUx5D7AiPVvS3QyVibMTfcSwOXwqQfYjl8N7/0=", "JyMO7enMz8n6gFow/FSNtpPRNwjGRoQdFuAoOHx6wCI=", "AWRZEcEZiwHWT940o0KheGSXwFlpoBVDkFfS/nW7KBw=", "LDI/4WSBv0luQ5yINBziXxmJceFEhwVs/cpKRRpdhkM=", "D8CC3+cHKOhFC9IHTD4i4bAiwSTTv/6LWviK5ttQhcg=", "IFLBdIANsgnYzcpWjcwls76WQhFqxMd+/opIi0I1Ie4=", "KOQg4Q3y+7WvltYh1VQjGQvjUc6BKQZajdn9BbPs6cA=", "JWmMpeJKG3mfeDxEYqJNtlXWrhvazRy1SdbgvDrlBpo=", "FgqZgaXImlfPj/v6V9UQSaKXthB0QirBNNm4V9aYTTU=", "IckaOeFFw7w02baUuEPzv4t86/Wd27CgZGQrBpmX89Q=", "GsjYDc1e6HbSsJNF7xEjRdbqoCnZPwO20Ql1Rh5Bc0w=", "CrPmrQ7Pi458FmKkF0xSIl2CKJXidVVEuNvOpWV84Cw=", "HGdRglEmIK4n47C5F7OiHKUu8+9ZCbThxbIjfL2rM3c=", "LNvJmN/Xr/09lI0MhbrS4uN6Sj4Hp9ddDIqQkqwr7UU=", "I7WEpW4hF7B3S/Z8wN7jMyQzc1Awnf+DPkkaEzu2Oy4=", "Hp4rMQ9gup+MtzAwo8nSoQ0TO8a6TsEVLz0g3hRl6aU=", "DgHjZbpbMDGrw+cgFArnRsmrXauYdSDEYLzU8fpbIts=", "BAiEzc/GS/x7cSc0BJjVxEM4IBG2HJpLE4fYW8EmTmg=", "GQse4SBeuVAMdKOZjyvqNjU/FyTWBn7QoKF94xHvlmg=", "FkfHKuxsQ4jQT1L8I82cCMHfz2XOYeFl/CjR+DK9Oyw=", "JDAAY0agFF95mIDMTIc2Jp9UlNiftIsChC5ZW3HkVB0=", "F3uaCDQ5F+E2UQej2jrn9p2FOQK7FrrLMiGFAlK3V68=", "BKQg5kKxGulOWIYqaPXjJgnNU9CuKUI0ObEdBGZt9Pg=", "JdDg9zn7OfwQWoj6sK/YEN4kYYWOlWzMzfq+3baiXI8=", "BEdtkbfv8v2FkFy/WGUe3DIMsVYQ6u1FLE1P+gx0Cic=", "EJDAtos9fXuLycokGeuN6hwo9tXhJQy16XgP2coob64=", "JTk847klbVBEinJcXHzVrTdvLUNYVcEOvyiZy1xmF74=", "JZMcDHNx9PH8hi8wbm5YMO2CQ4jWuTQml9FE8Pq0ZjA=", "I5bLUBcAu+bIKq1RsPt5z4pNNTGF1YCCA/c/Iq+/YvY=", "JqNjSDNItYlU6nSKcSmnsKPckGjDzKe1s/DOA7hySIQ=", "J8oQfKIE8qGNbxU1uSxUeMmbiTM0IV9rp6DltF/NaJc=", "Jtoo/Al+13zkZiveMmsszqwV9zAReFgdjS0Cs7LZEFY=", "BWqzUWkdi7NwPjBVBwrJzGVXdMG7NdV1cpcbpW7gy4k=", "Jji1fyO3VK7HbRCaL0gao8IlR6Ef/FAVLXKa9jI3apA=", "MEdUu4xX1gcy9JLCYFGE/cM+RqUyveyA6nvFUZ7efO8=", "ANFyf4RX7gNRTxVbWAbL90jsaFf8VUAQdSrJOpt2Gaw=", "AO4fPGb7wFxDuilaMDxy+rW8qGgF7JQZxYjlCUd2H6M=", "Cvr63PW03UpKdrWh2CQV/RChn7z8WQeMYfkpfrZ12XI=", "CyRJ85dGCF6GzkXo7tEI7mWiNINaCmpeqJltEk3QTQo=", "IGsM4vGyxbfJ83sARSJwlfbG8HHsO92nan3fSCPdXdY=", "D+uk+4eDTHy2luZ0M2KM1sr/w6TvIP6oUsfhApRZQJw=", "JU2/rHTEmwuJJnUuCE4CUTsG8TFebXDhgXPpcjNuVdM=", "Ct2xNyzuThZGVRaMNnVZ4ZYGxb0XkQrrN3Ge36DKh2I=", "JrJbfiV/PpfHmQJPsBn2XGyk2NgbGuFiIaWJ1ogx11k=", "CQmVt5rOwkBBO41MZYeH5aRle5qwC9tbGWCxBZ4RO6M=", "CNvcLiHvEfLFcploeEPOo+sNjkDpkTH0KXQXjUT3O3s=", "CeirpnFIEZdnn691Kg9440L+nEkVlqtnWPFwk5eFF58=", "HesFGA6DPkVlkFKn66+BbH79Eqf57slLe8fGg/E2PVw=", "GacOxr38kJipJu+8wEqp7iSJl+iywkrzNf1lI+UlCHk=", "IddzZgra+4qHmYb5qrSJBWY1Ojd32KPx65Or4Qu/H2Q=", "CfGJD3Lp3HE+ILpje4nV05emsB/NZnNH9vRmF4QcOQE=", "Ba9Fk2HrRU0qMAxh5EaZjUj6H4l78hnWCMIUXDOxEcM=", "D6Gh1oKfA0VmSmbcdaZXM18zbxXzQHVs+hL8hQzItRM=", "AuR6NbzAw6C9oLHAMHrVQ/QoD8+H9jb4U2Vc+Xpii7A=", "FPdz6YNMa964+Q54v0wktyA0EUYBEkkQNmIYlSBNDxI=", "EC2Yz1Au2EMlXPGdKbx9jmQqvnz9Y5mS/7CRli/I98w=", "BD3V9Kpadt1MR/bGXafKIyDUxzrTKUc4y6aGp+kTc8I=", "IYM4GcMzcZSmwNKaSNTyZ28OfHl0OjBvTP2ysmvRHvo=", "DygZJc9e5km0dKaBnRFso+tOyiRsMR7K3FMmKjz/K1M=", "DT4kd6exC+tEcJx3RtaCTt9iXdYFBNXck85mLxXCONY=", "LNf2Qb7b9mlW/4oBvpzeNdgPgKtR5ztJrL/D7/Wu/EQ=", "KelbSSvy+V9NCTgPmLdOOJFJ0kBFgR16ht2GExBGPPg=", "ItpmvGLo8BEmbvyoamyBD5rkxRr2/+tX+LPFDfg8wT4=", "D+bTDeeoLRYwI0kXlPSsoyINt56BKd82QwcthBklVUo=", "AFDoQqEpmQkSPEbv8YXCOtMS0D/vGt/sx+B+yymP1n8=", "ITCjp7MiEiK+NMxTpC13M2Zvnd9xTtfFiFy722MQjCE=", "LfnuKU7fmePY1Yg/4FZsJKpmcx80qTKA4dMo5nszyfo=", "G/fW5ImtjAzybraMwh/1QVgTI5bcJQrrpLb8X8M3J2I=", "DGAvoVW+lYdh6vc5YXqxNs97gHcov3/jXUd40xF4DlQ=", "LlDixbNqogUyQH2GuNItfVFUCAokly+utj+vASHtfyE=", "F8JRCYKntYJXENYpDsT3gvZ0mV7oQJtCtFkSOxgDMuE=", "Cw1S8DyK9ydoA+zyRluIWyEze1OOq9L2sqslXzdrQqg=", "D1Yz3xlyuUVZU9iKY/gGR6msd8bA+F1FYZct2Pq4vRQ=", "Dr960pyhOAThQi6TloEVUSR4D/Q+dukpA1SYEwp/FXI=", "Gv8TyBvaR+gLApYhc7ujQ+GPlL7ifIpXZhsRA6cg/+I=", "IQRJ2/XPMGHaJGW+hVBYYtPzHeGjtY/zVxO+V++sbAc=", "CIIwwnlOUMV9dc1tPHudvhnR4vHTABBEuTrRw+5imBc=", "HECMJWSQsKHaCNxGQTjfx4zOmp4Wx3BWF6TW27IOfjo=", "B0UX4IHrTB8i0XcSAPsHZY98d2VNWEQEkN1vVX6eOQM=", "AtBOnCHfHb2IUkvbIDaRtM7lUwVZ1s8PoFrfYeEv3L8=", "LregEbi86RCC4T69dd47WOubRlDa6fEaqB2zLPG2exM=", "Lv2nftNfSvApn3XW6KhJtU0qxr+VNoME5gMMGPDPF7U=", "CRmdyv1QzmQu3b7aZSBtT2GnPRCFK4EUxRskQBkq4GQ=", "Joxc/ERtOZxN0xnbZmp1tctlXYwXl+n6dhgctCFuFWI=", "IwOmUslJBxgmsOmjbIBXhpe0TpEszmaHAShU7aEaGNw=", "J8U1Y7EqbuLD8EHzHcRZIrxTU+sRCGjSNwc/Tvs1+98=", "EgGofq9K5hjwK9gtClEJBJlptSSM/pD0LCePImFdKw4=", "LEMWlDn81p6tghSZe7Bpvsr8sbosUeVwbLS0PasqRD0=", "BoNZcxU1kEDqA8RdaYTGiU9Gy7NtcC48T7mEfmME2UQ=", "A1RXBnBuqzavuTsSj+vRb7BCXhWDFBl7d3la06eY0YM=", "GjPCVOwRdhnTXx/AUbMXKHQL7SOmo3hw7bOTtxoMDms=", "H/5paKRHDNVnsMACKByvmW6I9x51m4fm8zjlF/FpDHg=", "D9ZuA7qICP/ssFnImf2A9BQN3V0qXESDEH9OAuNVs5M=", "Jjq2nxO5ZvgZc5RVKQaxfmyGF6e91ddKe+M5a3/gE6s=", "FqQl5H0REGJQVNWhZd5BPjvYfVqjlY/dbrfgPjm6QEY=", "LcUQpHGewQytdS8DxnPw4lPMMdE+OekJ/MX3OvkTjZo=", "JN+OjYVsW14b0crSPQfdo0I8UXkym3qCy0qnCalFduU=", "K8yU/0/Dx2881caJFaBC6HYoJJoBsJVhvfJKbNzlYg8=", "B2weiNxUDI2N5U40PffEKdMpX1LDjP/mtIvoaFLal98=", "CbXyCaRRrEMcBR+xLZpeT+QO4WARIJR9qZD7jhLLRuE=", "IF8XsNhyni6qiNakQTWmq2TpQk9VsPHqBoOvdetnfAc=", "KBxcaIg29s+RJjjDi+BGzQkWgfCkF2FyDN0e358jcCk=", "GgU+aHjpAPRfTWdEjEcc8wCaROegLqUOSvpE8lkmIfU=", "EA3H1CbevjAH+3zqyE5PVGjvy4l+e77pgXQoOdWeBkw=", "FwImcqAWqVe7h+LPrci3X7KJBb22LILICxyzG0EeScg=", "EIbbfidg/ItxBTqH6+FRI5+4tUcYKxcN4MJyA/lU9NI=", "FThP451ztjMCRgrkwpQvrCtB+2WhhVNvuF3ST9dYQGQ=", "LrtZn+kTbUJL9KvFNCxsdEexqFMgX8+1UZ5VE1dwkAg=", "G0teh8+5Jiz+w8DwVC5MWkzyeCkrTOPu2Zb6xvTTcog=", "JGUFOuULaIWAHz+C4wLK+7tKdYG7T7pgtjf+vmWeUFc=", "EU8y7c3qCc0JXFu1048bl9qfBeGLNwi/bgq509VIWe8=", "K8cN/rK6qy9rOHzXe+d5rC5eVRnz0YEj7ijYwlQ8cUg=", "Acm/eiA84it3XjphrX53tqeDSLn27GikEuSb/jLAVBU=", "BRSw/lkJ6oh77bApX7vOw1XPtXX/apfNn0rQDMtX7ps=", "Jnx27IGTTMgaEyqLBYkQoSCSUgsSogGvA+MgLXtsG34=", "KRcOMyKz2NXHjIS6u7RwrfFiJJPOg+lc+xUc91e95dY=", "AZ9qgSSxnjOvM+XThz+cM1xvCaRUhsq1Nt1ZbKQdlRk=", "GQSqTWkIVEqLNI6dsZgcJwCe2OoXFRiuVAXQNiQrYOk=", "JvF4c5Sbxnn38EOVZpTkIrPO4d6d1vZHO5MqR2RV/xo=", "GsZo9hK4JDwZOzNyC4qlQEDEdgMRlxMevcrJsYvEj3U=", "CZbZYadcDQcZba5Fv2JHZsz7+FVb6XltpS+BVo7wZj0=", "AwyX4bjK0dT9UNG0OD++ZnTRcfmcY/67VCWzlcJPyBk=", "BuOtakaQDi05UzcCVbaPibPlI/H+UCZC7iJvLYvQhI8=", "HWs3VTMc0CFraIDkL5iA9WXLlLDgRVFToymJBYjMkW4=", "KOTcukuW8SpZsEFTXnMKyMNRidwLhawDPdOMCLrlMfI=", "CLYIYEaoNVCMz0hPKXS2prBxKkdiYDdsejs+S8SkehQ=", "FizSyn/jtfFES87JeBIBm7b9hfumoFNqiWQ+Fbm7O1I=", "KPHgO6rqm7wFr1sRk35PXLXJqcEZIGPRmYwBxk1IOnY=", "G9sGJ3jXwV2jla8nNMJfqgEn0qq0qnE2YDGgu2eRzhA=", "I3WDlQLgmJDLKRToKWJ+Dg/JiHCyMkqLUDKevdJHScs=", "H6hmL7y2H7OtfFVmjclCOjMtyHz7LfRW6S0zYR7Xu1A=", "Hk+tLdawpvH4cH9yFxbIpEbi+yxHpROPP3+XNgeddpQ=", "IRJW0Wxyaf1t9vX83R+niLo70FAFn1PSYbD18Tcx/+c=", "LkkISzNuzqpPjiouavCDGPQgYOV03aNB9KEHmxK8xaU=", "DOGfVM3Dn38781GSrGgIIRrs6gjf4UyrdY0liR+wC7k=", "ABHF1Ww5Dok8w5QiEmHYdI3GBFHkrk4chKhGi6ssFMs=", "F9ef8GtjrCqKngXuavPbt8pg4Xv6ObR1FKjNgFFXm0w=", "GafTpEbLU5PcdFYAk1krBrGos1zWQWouyrABc2OQFfo=", "AwwAoJM9zboqgIsuG5KC8zHwRZbYko2nqmw8lyNwN6Y=", "Fry0R84tUPOuJa0IBpU4LpNdLQAYTErMk3C+iqtkE5w=", "EjQbRrAVCqJepOyHFTEpl+YhJPN8q3ttOSVbfNZv6x0=", "DobRORf0QFC3Kpeyv2EMhAAvwo4pbRBE3IkhLbakn/Q=", "CObrQInTfWbTV+ALU9fzDRBSoYH48usU0FkCWxEMcmI=", "LqEjhWJF9shHONFd0UgaDAQVzLNRoeDO4QxIzpfKexg=", "LcpysuvKuMI0RuADMLFjEEGVeJAlQTq/Zk2w+chN+m8=", "Bv+e1Q0yfoRjMp9YXskks/L2tCNfA2+kxkomy9Qrams=", "JGoQt+PgCJlH98m9o9VN+OKmDgzKhOoqxjCkU1r79zA=", "IqY1AcXwS5AYcZ7ZnXAO5S+EanFa5nrXXJaznWiLZpE=", "L0xQR39/2cZxeZrF0uIkzbkWT1g1HYqhQOwH5RT66Tc=", "EP+3qtH1HH0TsX9Nh22aHjjwuopKI9S1DNoyythRVn4=", "Dpzv3cPC076k05ciUy1UIHhAJzUhh+evGgVpNcNYA64=", "B6+EpNMUHnrCM1Lm3G6kr6Flb5ajPIl4o+g73UumK0E=", "LZ4xoQrrx2H43gDRSx5WbRo5Mj1uibY46UDz7Ioiw8U=", "J/GaZTLma1Mz2xr9WS9m8dNgNLMU2thEdlZ0e+J+ZMc=", "AFj6PIRU1jNUsgJMO0pXehgO2Z+PMVXNfk1hfUfQf/0=", "BBYntnFbeAlnlXwIBpk0PrBBSiBdOhddcIlklWgWpdU=", "AGrEndklPtx/Yy5XuVjM7NmCAUcc8fZliYiPErcnxS0=", "ATGt/9i9clSx2MNha74zhuwMnA1tJamk7EamvxgwE5g=", "HEpvUsn8z3pBOOQT72Kig3eXetfiXkmjzwMOHNj59bY=", "A/KmvlHsZ3+UZVGzhg6kef7gSK4geK630feVjSwmRfY=", "LadwqtLC6wk5Ggy3jvOpZIoTcthUMRlWTXN2OWuN3GI=", "FSeEY2ZfdM3cGAL+v6sCzsnUX+hmw1nHOAYq+3XWSgM=", "Ev4niqNlROrJcxAnCQUY1DTjjqlmoIpvjVgGOKxUx3M=", "FJucgCGCVYpMRdEZ0/TMf9hYdgTKTw1uIbBv8wtqI7Y=", "CBLntNhHvIUX0ZMZdy88mFXgRP1g26yaCtxJWbaR3+Q=", "Au2Njd6v49nY338ooL+qf1VYE8fnUDrqKmaXNwOgxhs=", "Dr0HO6BTe1FN62Ap+SECnlXl5NmgPWtroTBAOGYtTbg=", "FcdU1bFLLEIFxrqNLM0CglWz55LGr6CLRO51ti7/n1k=", "FpUVyJrFR52w7Y+m+jEbORzBI1Jw9MvFwp58vDDocyo=", "JUefv7Omj5gjiPJiEAEQFgi9wp9v8DdpbZFh9c2aT+8=", "FEdcS9UgRR88hSywMRpXjKf45ulyGCGWzglIbpS+YHE=", "BFppEGbMZr7JuvJ5iDOh39OoR1Aq7I1fXE5zNj0Jd5k=", "JgKcDCZ8eZ+4M6yKEeOj8BR6jKA3IhuQATuLyzfrpoM=", "Fj+ss0/1cvv3yUaWnBwmCHPOEqapSj5FuBAdW5SNFkE=", "LHFOluGROzUdlpMgzGnV7BPgamJ15YaIr47gDEJA7ig=", "HBZh4qfOdLdauoRmXs0r+d3WJo8G3r/i1SuATv8dX6Y=", "Bqaa55Xum/5eWvPmYZpH0mY1s0wqCIn+qMPAaLfcLHE=", "ET1YU12JIRXF0otMGaNgk3Tb2631QZXHMUFshdcx1Go=", "KriRAuK41eY4/5fXYdpgQuU08f9H95F6LKGnQGO0YQE=", "A8Ecp55B/f6WJzDEXmmVRjSQMYk9orT9OYBP1qFa0bM=", "JwlsZyYhQDiIAU3bu/ydoff2e01M/oRsat8ED6ryZpw=", "LeMq0VSXrvTVBNTe61OxPGbbeQzkhhMMqp3CtX71vg0=", "DcEI8rCigNL9XTQTEHIqLSjHON3a7J89JVdURI7v0AE=", "GGnzt2P+gWTJaFihu5761bzcPuvECb58fTTKUDZdgy8=", "Ai7Totn/Mcv4JVn+apEYQ7YWlF4WpWjUjG0zdnEpaC0=", "IVXWAFIQFp45RO0TZb0OcpL8ofJ8GcJmEMauwHfQJrw=", "DeG6elYqj3rK6TJj9fG0u+wMBVbJGvPbPqWSjIyuroU=", "Bdu0QGAkvqvPzlv0bsfaOBJvdAvOjWN7Y1Hfp9qQJWM=", "BdQUm6rEE77U2NyK13jTLADnieP81y3MyX5UJ6No/V4=", "Ac34tFLZfCub5QRuc5fnb/C2gC+pQceHkhLiIXLCey4=", "H8anGGcCf1avgIX/ga3OM8TXxQFeztjHGwoiJ51GwHw=", "EEC+9MZC0DRdTVmlp6OkK6nhhbdTBtnDVo4P2paqr8I=", "FrecOmvzFuD/LJGyiTNKTSsh6VZ2QxkYqAgUdauPrQ0=", "IN/xvDD222tDSzoTh+PIxqNAcOUrYB/BPL4c3NWfR04=", "AhKsKrem6q7CVJVQMKlw+AYt1BcacmqL37f9hRKuBg0=", "Lyk3dJFHREKGmhCckhVjfLAtwDE08ARCE8gRn2mWrgk=", "CYTKal+RhdUl7JPDP+pgMnO+nzhmqihMWDfZ8y2BS/o=", "DQgKa2s7YHANKZvW+oEiDeSRNhyKa9Gc6w7pKUsk8Cg=", "DmXNmehLBS9niVMGOMsK2CGsyFtkACZNzpKe18haRUQ=", "LiCIdbx6wSJICPcscWzQXuMOPSA4D/amVZddoSc2kgs=", "KYnzrkd8L9N2oLD/PX36wa4uO4lK/Sn2SmDRqoWSutU=", "ETYc5UTpQTeSItEB5vrAzpGBBqRjKQo+OnTDzqcYlFk=", "Ho0BS4bLWn2lOeEMFz9qddEiqCK4+zZsNMi9BaIGFDg=", "Fz9lreyN7uJ7qBKtKVWOI6DCMkFn72yRIS7iwo7phzM=", "AcNtqvnwHxuv7ovQx3msPl2l33rUVJnQmRvWlTEO3dk=", "E1OssIwFrbSqmrHEhbuF//J30aPy/ImUSm9XQfOB5WI=", "Llq9JTcgfK0YYOceoRiO5ACdM960+TrrIPHIejsGTTQ=", "GR1cXtrvQtPQLu27erhWJRPetOs0kToTQhcmuo9pRVw=", "Edf40fJpJkKComP+ptdZnYKgTHTBJ96d7nk53S3NCJ4=", "BCGP3jZoKe2Q95rV5nmXlzRFy0zWvG+VG60IUobKyXE=", "AHB3L3z1JFMEg5fKX0eiAgJ7c7SJMBwyJ7cccw121t0=", "A4o4m6712afIZbBlaHodm2doGpjNBRY0wdwE2+PSuGE=", "CaXu+rizaoDNpEaytLWczQ850AlmpQvq8ZhgeJAVpuU=", "AbWIhIuLR8i5acFFEJtLWD2eyZ7frLdInRYhLHWEzYw=", "C4RuSjkOVg9uGvbfwzQUGVReWr+jI9gX/tkeMNQpVKY=", "I6ZnnH2a22YNQ6At25AAQOsVE7w5T8T5hcq/6FznL+M=", "LgN0ppkZfjQ+XKo18TUen0w0Avt8hezM9y8x1v4IklQ=", "B1LNiZ5S3E1/egivTN4/9kuMwLEXa7nsN9QZE6eie0g=", "Bo+IExJymdrDSaK21XOXpQJ1FCtmS4AsmeKHPdeuVac=", "K6cKECNV1UlndXQWdDSz+YaHLQSilbW4s3QzDy2iArU=", "LEZ6+IdIq/ajNNHfA7VSEwn5CZuCXdKJuGCecKC1CCg=", "BcXyC+8b2CcBAJorRIrogeOlLC0aMZVyltKeV2Po9Jc=", "DcY4X9xWe+WEKjgfYAbixgzQg6LGSdnyOsjJ/mG3OHE=", "FC05g/Pcf34Z1JkRuGcPpwN41bhBUNJe0lW6qBFLNpw=", "KaAe+y9qqJT9fm2YyWoPoPNvhqepmqNcAPoYwbLfZ78=", "BSX/7nN9YFE4xKUGZkTsYwq56K/GRVW30qGvBOthOnY=", "HoB9yoHXlYHwdmd8oOgidn4WT2FJECZO8XfPQjgwHcg=", "A4X7P4nHTcmTUQgWRyR000wCI+D3M6Uv26VggtvYdXw=", "A3ZA3Br8AUPhpimOU8rln8+r1wFv1u8a9VjzN7qw6gE=", "E0GZmh7YaRnxKmxSYIKe7l/VbPAx2oBQt+TA3olgdLQ=", "Bp6wdYZrCvNWkG1Lr7EK13Ov1kLv3MVleyRPZb7Y7Oc=", "FxwLgeYhNuOVs46OCLPmRtJyYQHTr6oC6hkJphkDNpY=", "LIGBTJRT9Ry261XDEXU+hMu9yzm/5pb5VXUQdQKsztg=", "KdhDwEFdNdnjsz+tzydLKrBLOQMq3Kks45uKhqfDpgQ=", "CF1qEHDzUT2ENrzNq7eHUNjhXqWUfyzap2ac8/rncos=", "EYIDY+1UHaoQpEumZb8wLNvx3U5nBrAsnipc2kEvw5Q=", "IBk1pY9cV/wCtg1hqDeFvd/TFQ4F8d9dEFhAt1GhYxc=", "CowoIMVpcariepUqvTOgPUZ5Tu3Whs2Oz+1hDofALpo=", "GAY4/zAaZMoEq9bQvXUAtmULZf8z5r4f1Q28FjooGHc=", "CVxxYmbx3lkET5cRSkFYo/hcqKk3z77GPpsyGoEt02s=", "F8MeoC+8N4Mg2G/+1sfKFYO2GMXBpoeBjUCHpJfXNJA=", "BbhsS7jvMYtqcifkGS0UnTwXqXZMzWYN5NUKd/GSqRs=", "JlvJXfSkxIdv9w1+ov3ix6sV9KauDSN81s50uphsens=", "JHUrR7xsa8jZu+SPX+8vaQhwFznF9bSz1siG1HFceSk=", "FIFKHg9JKk6g2G5SepZIIXjWJLmNqW7l5YO5Mk2XTv4=", "EN75MQc7ZHm9YFdzePKTgZl8jgQdPPs9x1I7ypBvAL0=", "FPeudwv36V9/cGwNirTtA/oLiA0oxp0DG0WSyYYQF18=", "Gu9QoM7nUbWfkmr0DoA10Z3sydQo6+TndcXMnc4c5Yk=", "BBk1YHFy9o66ZcpgBo3+OwhsKi1X0JYClRIUtX5zz1o=", "JoY+ndJCVdFXO9CDlZuFbAST++/oPIGYN6FR079FLLg=", "IDbvtvmDCWXrPXoGi9CHyfWt8lG6YgUsZSc45j/4s68=", "DHEql1t03J12a2OaAplpyjC+T3WnU/hUsA+k8bT07ps=", "CAFNqzzRZn4nr8mb+sHmgHr9/2RWSSyjN1cx04dTlpk=", "GY0HGS20+sKoKkp5g51qK5fE3U03tOjztTAJ95s05qQ=", "Kesd5Co604GyO0ExQmiXoycJsp1Tu5Rt/RV4TR9j5XI="],
      M: [["JR5/35lZEIAICwrxM7nkNp8i5XrOPNf2T8b9vPONfaE=", "JftQtlrPT7BHy9OxwX2Xx/4m6pyiONbjSFUEhukcd2U=", "KT1hfX2nIQI1Xznr9i+RsG3rUyXzZ6RVbqHjHtV2eDM=", "EE0ClasAyF6WARGsJdpHQ2ZZnldam37fYUXxS6bTwcQ=", "Cqo14shLrxF96j4zbNlqOXkrOBOVT+m/PtW5Dy9pyXc="], ["KnC58dS7zNvAPhfB0dzbAgUpA9xmCeppafZhsut0yDk=", "KBFUZRySHnRjFamTTxuKG7qfkq2O9Ll5EVuOLpkczXo=", "KMK+L4Jk+V8LU8cyE076M4zNj9ue4rRfuGqJT32zbDc=", "IYiAQeb+vVRtQnyJCxiDu5tibYy03BjcxOyPp15TChM=", "FN21+toBcduAGVuVktjPK+gQkw4+pFdKNQ1l4sv/SUE="], ["L2mnGY4fvMfepDJlMGo37VW5G/9lKtaapPqEeJcNQB0=", "ABwe3WJkW3Otkxq4Dje7sme6MSs0FA5xbWo3R1lNMFI=", "FbmM6T5HvGTOLyyWxpZjxDnEDGAwSUZvp/mksii/wys=", "EsfirfpSTllY9lvi+6yAn8uoRYso5E2SZQUd4zFjz5w=", "LvwrkNaIE0hJAYIi57iSLq9nznmBbvRoUx7C3lO70Wc="], ["DD8FCmv1rxUZgeVePhopoTw/+kVQvSUU8a/Wxfch+DA=", "DexU5tv3UgX6dbp5kr008Isu/i7NQkpz7ad4QyCho24=", "HEgqJacp9d8gIlgVA0sZYJg2ShH02Yj7fMdc8y2BNvo=", "JiXOSKezmkJScyYk5KuUNggSrC/JoUpfuLYHrp/YUUo=", "B/AXp+vVbdCG981P1xDFCe1++OMAuai7n7nyivcQJR8="], ["KiDjpKDlfZL5fJ1hhsbD6nxeVcIBRiWb4veMLMwuNZU=", "EEn4IQVmtR+q+x6aXWPA7nAWc67YINnEQDsB/rcnpUk=", "AuysaH71tLVoACvZ0blrS+81emnj6GtVYbkpm4LWnI4=", "LToa6i5tREZoCPiMm6kD073La1i6QEQe1OvPEbvh43s=", "FAdLsUyYLIHJrRceTzX+SbOcSnpy27bZyY2AO/7WXmQ="]]
    };
    exports2.default = _default;
  }
});

// node_modules/@selfxyz/common/node_modules/poseidon-lite/poseidon4.js
var require_poseidon4 = __commonJS({
  "node_modules/@selfxyz/common/node_modules/poseidon-lite/poseidon4.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.poseidon4 = poseidon42;
    var _poseidon = _interopRequireDefault(require_poseidon());
    var _unstringify = _interopRequireDefault(require_unstringify());
    var _ = _interopRequireDefault(require__4());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var c = (0, _unstringify.default)(_.default);
    function poseidon42(inputs) {
      return (0, _poseidon.default)(inputs, c);
    }
  }
});

// node_modules/@selfxyz/common/node_modules/poseidon-lite/constants/5.js
var require__5 = __commonJS({
  "node_modules/@selfxyz/common/node_modules/poseidon-lite/constants/5.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _default = {
      C: ["FEhhRZjgD5jnrn3qRfvYO9loZT74OQzeLoa3Bq1AxlE=", "CreykTiOXJ5DwNwfWR+4Ps22UCLhtwr0O4p7QMHf98M=", "K3y7IXiW9SyajAiOZUryHoTN51SjzvWxXE1UZmEtat8=", "K8aw3b4dcBtlcEKL3Byhvw2ln/O7u5X8K8ccDG5nplw=", "EjpVoxmAOE89ILLOy8RO1gw4wR99IOknHvq5qQXu/Tw=", "A3UBzIydyBkwmnafTfCY5YiwGFi8jrfieeKIO+n7jFM=", "HCEW5H4DqGuxFpWwpfbatrmkYLHrlRqwHCWeyj/UfVE=", "LBghNIkDLoWpyMuOmmWDm/rtE+V7wPrknb2uv1T1b5M=", "Luj+09TSxxoEKer9jl2xcY8p4iJ5hf3yrYcDyDW54DE=", "KMZNj17XqsAEySAp2em/kbqUNtHM6UuTFtERxwoMFxQ=", "GKAdn/t0euDePoPHB/iyT2gshPFav1cbNCVKA0eGZeA=", "HCHZK+8ZfnOyNOR3e2DbFOZCpWzucVFdVOGscc3nK9M=", "CtQEzLyx4ZWJfLYMgJgeu51mpmd9u+2ti2RV/mLYB7E=", "Cptt6DMGT5O2rbma9sAFlFy2VMt70UyLl6+LYMwfs4c=", "ExKeP5MK7W1HaQMx/wncUWDvpY3c4sPmGA1FvsOqOm8=", "DXphTImRUIqxzkiVgTuxyC8Yv3v8nigMzKGAeYOTh/E=", "BTL37DbjAEGwSGmGh1yROkm93y9a9f6+jDHy9AlP/qU=", "BrvLjo4YAgEpPnEvSVDxsLvugIydZCY8hNnYrhVcuJI=", "D1WKTbGjrAf2Hi5r7pR/c1hr9A8hHOtPaHylZ4qdyzM=", "K+FApgtbXy+O3XioGKlpsgxkPkGbzwtXfCSg0Oes/pg=", "HEnEuanwn3ua1fdOusxxBRK46Ge6zifLDeoG6JuW9jE=", "FwwacychsSzefzPkdqOaGqd6gcBuLqxQOEewDVl2Uts=", "GcJ9DlL2XKNPTjGgaOSTMca/w52SQfnUwwIEFhXPJ/E=", "LxvcUlT5Igwacx/FJ2lk2rJrOF+kC2sEvtmWDiVDugg=", "BbQtL7zL9NOdK+kznKvp0Nxtkh6FXNkRVLY50o1KHPA=", "EiAEBxWkGtWfT0EODAWkLF/TKsUv6dBviBiNcfYeCTU=", "JflSZSYVW4OUZgn3u5UH3Ukl74cd7pFtkUTrtOzhNDw=", "AXv+QoQpmud0C20OIElR4xSopdBFJBkUeXipWzR0JEQ=", "Kl1HZAIcpx14qWdMtnCPFYjSzq81eMQRHPizWe7wic8=", "F/Atq3RfvjwIEyH+XO+EXnuNBwslFNKbKnt9icwIFdo=", "GdpiYm23GZtl9K3PV/pKPbqhdkp70VVwjubzeMie8BM=", "D4jilfou2BtCbJH6aTZqc+33Xzm/GGNM0mbsQDiCngU=", "H+McVUhUbHlI/k7hvXQS4ygO/30gywmqhfSfJ2YUgBc=", "EP3BYTvb9n84vd5WGy+R5MxItZ+Y1kNjj9wK+tv+Em4=", "HyYYwuvpV0UIucUvAADjPr/drRoD/da8pu9/AJMSe+8=", "Ep/n/D76xqirI9um2IbzlNoR9ZU8+Y4oJpoNuip0XdM=", "Fa/UzfHk+CDBYx1KuFykujuvz+5yvq3p+uYFIxAkSOM=", "Hyx0ulw2fjcNco5x4VsmiFGnu4tFUoy3NJVgeayZsBI=", "ETDhhy128vk2nPWble35zhnwH6icnDaybgne9nhtrTw=", "E1I9Fz9+a623O2P8HJu9vuJCxhvGhlZJMydTOlwbHco=", "FNpA0K9CemXxhBta3JZThlM2j3JUy1Zn3a27rXpXTNQ=", "AJH5ZADkKX6oW7GGwXswToJjjlf9Yx/2MVl24aXdi4Y=", "MDMpv5AxxVFbmjTUmmS7agJnvHtUoN7KXEUCd6ACzcs=", "FO1H5VwdocLwXTwaGy5sGFCfyDNuz+nbc3kW4oP6ghs=", "EWHxCzV3ddgQrVO8xKINWt0rAyUcdH3rBO6UxWXljWs=", "F6ilCucs5wfyK8Bw65koUcqRTrlMxo6vu4qWpxTrgiE=", "Gmxh15Xbr2L5klCzfsXfiGRaHBU3kdtjErky3CUOT2I=", "H4vSq4qoQGZMTu4ZjEaE3EsFdyuyoIadpnIrFfRHoTM=", "H/y4UqTwAnqXmfExzXS5jM+4y8BjSdj+/MYvEMj7Pi8=", "A150LsUvGbNtSJxyD0Z/+td81TvC213dskayMCH3nxg=", "Hfqu5BvflNeDqin8Yrfse1VnOqgY0wX9QtF1oF8uPYY=", "KCE3hHegLplQBaVjUIhUCUW9Mz8tFFXwOKIZuMR5azo=", "HbSk0PI4pXCxBhxu7IHALzH/3Up8GedjF08jjQSJdCE=", "FL94iUV7ILehNns0o6U4IX1pO1JCav9ApLtyiTsXhMo=", "LO1Swr8pb4fldBDD7JqUg6eW0WT2BJEnEJ/w06nAhGU=", "Hd6sWAWn9K2k0EQe0QjjFJ1M5lhPSa5b39RtZ2buozQ=", "Lja05enJe0YjBOjitfnciOHJ8hYboEBnP5ERI/BCrnA=", "DGhA0csGZtxZ6JsYZSddihZLRHxe1kNHyu5jUCwjjV4=", "E34uPonnHUYfTJvD6PEhgyYqTR21XFibLK6qwBI49Yw=", "JQky57CtzyyE7Uv7YKNra4LlWqlHURV7HUV5Swgciq0=", "FwpykvVjTAbdO/CatcnE7NSwDVzi81+XK0VVOR8WtC0=", "DWjLvnconnjVy/UdcPG3W6IV30570BSdELLFDypPO4E=", "DK90VjuQUl9kWm0gNuzRMG+h3GgLSdnOTtJMl0mXMXg=", "IKfRwKJ/zOeP/jcvTFgwaxZvlFbtRs3rJV45W30w1Co=", "BiPzImtUcLJ4m4pTBA5ERDOF6Wuc+gvk01AVFYpGhGU=", "FjIwhojCXnkPV9aKU1AkEkKlYwU0feSlAJzka4zcuR8=", "LeR5Om+ZzRTj9mQiEfTQt7z6NhWXxUT/y1pWfpB29H8=", "HU0G0Z6hsJyteQhtUb3hFyWlVPqZVZyi8J87tz1yjGY=", "BIDnR5pmp82ephyLKJdDiZCDUKvEqvwYzXXjPdEwwUQ=", "MEMLAzaOvKqRJGlgSQvPkX14aBRj4ufXRL+0QzXawk0=", "C1ezcyASfUxQ8mkSSw29yysfE1IkGl0SEDKD4InAx0I=", "LPSJBlDSckDhlfYKT2mO2iSbjdYUsjN2tQF40t9tK48=", "HiIcVSaJi/0S3oaFGg2XA3UaLyOQCKtfm307aRHGQYQ=", "KOB0ha19mS7RpY8ynKEq3OTsaT6927KVLlTTOfLuvaU=", "L0TWT4TeFtxnvV6tUe+x3IOByEUgwShU3V7zoHms1OA=", "BQp2vDLr0d/ivjMPME7ces5xZ6t7oVFvQCHGLPDU+sI=", "L1jEXl1lmmfXgTZyQfbDXYy0Y2HZeyiUfSlCHCcFlKk=", "JejamuDkLoQOBLIwNw54K9tnU0hEMlujb8fl4WDGanQ=", "L+xzTaIP4yAD6gTxJ/hEck84o2i6EMKVRCUr55YED38=", "KIpnePOoOYio7Rcn8V6TtMsU9OOju7kd1tH6yv/9Xu8=", "INzGx1/Yklm+f0BnULPbZ5olqM0nFdJFuRdTkKySLIQ=", "F/QroQlC3yXLilQXgqGLb9Mc+WXREXjHsErEW03qXdM=", "Ao7rhdEVqQQCDgxhSO7GYD6c7avGZKvudkqv1FWYa6U=", "Cx187POnmyrT+imPbOp66V2AwCmezJGOn4ycPTjVnUA=", "BEAznJdkzsecFu/bg0omJh244/Es4c9yLSPA4R/0zwc=", "BspkfClyfBlioAIXfaLVBPSwel9+tXx5uI5reru9rVw=", "LqEgqGT1xAk90ali6PATx7jvd4sE0rpb/DyrKGGbqeM=", "K7c3VGxK7nwMwrqHwRV+KnfEeev7Xcdq27Oc+Gl2M/0=", "DjDaZJBiXTPnnNUBdvVo+aLCjC9EmivVGiXRVoaAOpM=", "DffKcnihNlC5GdhUl7LrsPcQNafCBDDUEx2QOrf1dSE=", "J8xYn1v1hXlKus5Yn7inSi94TAmQuA/KppRAl/hw4tU=", "IlXDajjIc13kXO30Uq+oQjMtMwQveOYMQ8dFVCGzJb8=", "Ez2WAr0zeNafaBwnsFvf/Ji32GzKY9c6YMrtSFeE0Ic=", "DhVI6UKunT4mhgaZuTcnyBeplIYWyT70rM2YGx3D14o=", "DyDw5V2TaJ/gnsMS9q9HYnSC5L3goWAqjiyNboTopq4=", "LlIyhIPLW3/y605FsS5RsmIyybwXtykpVMCp9r+lG7k=", "ArIWLVM+BZpu2iq7dHEu2zp4YL7qld2KSr/JV2YIBPQ=", "GeCSdxXRzG04lCmUf7Nzfa1zOXTGsuE+Wz1DJRlRbHQ=", "DTqABFfXd4VjYwO4uU8X3P/LRgSIcqyfdO9/J+5XNwU=", "LJdNGVJVehqsX3uuSZZhbaYZtz9EHE5QTcj+nPtVnjI=", "B2a/7u3izPNwjhtP8wcUwiwdQ0zb6PVVFLq8LdXZe+8=", "I9rI6lQIL8Ex4XOuVeRjDNTKfIcbKgpHnB505/GR5iw=", "F9X7bCyzcBDj41irLVdTdocO0zGGuOrkmtO0fjQKjX8=", "F13Kx22KgSYTm1g644hTKQJG5D54P6aQPsgAfxeMACM=", "DE/Qj+3l0iGtt6v1SYmMkeW+foW/H9KmEb8YLMLnFlU=", "J3k0uQnnLTo0dbsex2arejitWbEoMD/FAC8Cplvf5yk=", "Dog0mZjf5wPxsYRST5w5TWAEzKz5y5UolujP2wsHi2g=", "HxsgeLYLD84Hgk4qK8jK6O5nNRSwBwqLRXEMx4y7mUI=", "LrFVlWbFNt28MW9kgtUfo0BVdldwD1uKhG6BKg7TNNE=", "HE29wzXPZ2Q1Ugi0ydJD00VB1iPGad7Cw7oGa76vZ3M=", "I3SmstpvjKuOXP6NgF3Tot/KHot+ul3IV0Ah/RJB47Q=", "Gd00JTPMxgOplzjj+1pWm5TvcbPkn5D7h09hYXMwcvQ=", "IX1m22x/s+/6UIgAWH0us8bQPYOFEy8vzOfzXycFzM8=", "CBX7hZH+AQOM06OziyNvnvynfGGNO/xsKn+okpbH5k8=", "K7lDtAwr1FamwXhTscqI6w/zb1l0sv+aX1CT6b9joW8=", "EaUVP85llRPufLmXSubLpYHjtM0UVwxXCf7D2NP8guk=", "G3K/0HY12FAbLv+HhaJJW650x2U8+Q5tXJ8URCaDbfQ=", "FJAsBwDuyJeuF4uoyvhQ15Px2HUSvqDs6jnPax/uIz0=", "CcE4xuCmFqSf+Q1DprBD87dFt4hlhW3EwaReL9hMs/Q=", "BbWKPc5XsoGicdaYlQUtiHRYpxV4PoMX4CSmGjXsELw=", "K+jSlSXAz91eazEl473jv1WOVfvoZ/AkRXqWdlR00Dc=", "Bh1y948bqdxrTX93hCJdaoG9/Bta1sJDafnAVgUj2a0=", "C/GK78rP+r30ES7drcphRXOLSAOzYUW7lRbbUBoGkuk=", "LnPdEF+osuyTHYzfKexnnjqYAakwcafV6jBlklXwO8Y=", "D4RA72Z8mugTN7pdjJJ6U0fecpaGCyEcrR7L+101mO8=", "AE0wOy3qYnsnMb6D+TrDTn0U0XihOABVjKc5Y5XrEY8=", "I0VBrXIECnDaKZajUmkjDJRpnu8xOk1IBQgAjLw9N8E=", "DRI/HnLSa5K92P1z0UKGwxKtTCOstGsuCMFXEEQJ4XQ=", "L7Ngd28N551wmO56pBI8Be5rBai+Rgp3TzoEjhOFRbs=", "A2hcB5Q04WcnbFfTzHlwO339xBwVbqHot/mbaValUyY=", "Jgrw4P/8yXcsFjGxeTRFZrR6qto2geuQNMb3XDcFwcc=", "KGK0E3T4m2lSdLM7dz8lVJFuK/+f9nJUX8L0lWP2J2c=", "AqmRL+FwMQInGJ6h5pHQNi8Ys4tACw7/GSyllRPrqNU=", "COUTreaUoNisHz6/GpZEDTLHE9UFjhIk4HA0jCgfSm8=", "FApKQx4u55QA7XRll42EdzITxigmT/gPIax6a2c9Cas=", "KWr00BnLXffZWbKdVJw/BxICtOuotT3F7pee0UM3eSc=", "AYMuKEp/TIFhSIK2k5/A8YVXO9ICPj5QV2VHC7gSs0k=", "GoTVame/3T2WWr3NMpqnjU/pNDRJby0QOGH9GdZtcmA=", "BAy4KEd3OSfSrv3AdIkDep0fdjHsp1yfsN2gy5294UM=", "AQ3PCEzCnLfK7PJqpjO85O0rAZ8oh87nsaePidP6vi8=", "B+3CKgkR6iFEJe9UK3dtsjsP5YF4ENQMcsqYqr2a+oM=", "LupKsIrsd18hSEeeo2+7lpNtpYuki9HS06zUgXOqq+c=", "HkDA6CV/5KYQBc3PrRSM9/R9G1z936oIJzhpVRgkXxk=", "I6J4CVg70epR9DbeVEPhCPadRM31HcHwPiGUi0mAuHY=", "LkZSsETb/kDmO2sjL81fPzmr+9IFHuaK3HVAgNSSUKk=", "Eeer227Lr8Ln2M3v6ce5xQR160dds8LK9/fWf0hXdfI=", "GZ1SNQzDDoxzgh+AIJbw5UehNVGye/a4mTlvY6xc+Oc=", "D1ddbuZ8vs2YNFYk4DKjfIWafL7zCz/dyUnNCXhIQQE=", "HEtvmiritBjmJlrLqclrBhhNBwKOX7eE80da53cv8Fc=", "Lctc+Ilt458ijhV8DFWT9GJvubwiUgY4PbIDYKvwySU=", "E0CrufThExhr3CbL30vMpQtTGhB/hjylRFdePPhw+OE=", "I2jmkrcnh8uIcOqIjnFOAG9Z0rRGDPt0xIqMxzsdGls=", "H6ua3ZuqSk9W8jFld1xvLZIqdjKpT5Y3S33IUnVvVLY=", "DH97gjANPGzj+JV7oeSt1UxMAV4g2XZdIgVxwWq4aA8=", "FdY+hr6s2Txgg2iOXZyPPGlHkp+fH5mrV4pMOpIu/wM=", "C+hDrl+bB+UlcheK99ro7QXTaxLAYHhikpNV6nQCPZ4=", "EzJ0nFI2lMtpNeCWOgfoGwWWfOHZUMC3MQWOySp6DJo=", "JUOUCIEOB0wL3UWYuYFf7okruVylECns8Am/+lubloI=", "BX6NGd2ZmpGNopsJQLODup/RXbCw9kmW3/Z/61X5p0I=", "HgFON+mxF887SHDZmfK1XTU00Ka+mOnjV/pD8B5wop0=", "Gk7STm4DrrzWvbEAUz3JZll6/hXIUbS4Y/boiQhMZHk=", "JTQgAHCD8aqGOtR2CQXBA57UERyfBT8ncQRS+DzjapA=", "InahRBlxcJr/5tKpkyAAHsRexyFVxXXd7srA4ydZqwY=", "KJV90SGOp5n9NBHrGTJYU633rorhKB91MwL+fTHfp7A=", "L9klcmq3lMiL11eWqj5/HmaS8pFM+AImfd8B43kCoAg=", "HPilycdqhLFHyCONklPNVbR8DEPYKWbEY2ooZ0cF/Zo=", "A3PLvDBuG6uecHc2hxXmIwtLLi5KHbnGdLjDWaQekQg=", "BgKD0v5/I9/1E9kRCz3GJEi8SPUxzgweq1kgvyMpCkA=", "DatGXW2RB0DzPvbMDq3HG/gRm9/Vo1J9yLv636pAJjw=", "DLp7y8giSyqOSroXl3IwpobNZCHcDKU0bzRGtiQ5xMM=", "HkNl2weQycT0RbBlPEZv8h25bDi0B2uovWi8tN6mkR0=", "G7LbohmamrO8hu9fnef2xcoT1g6rQs7WjemPxkOACo0=", "CtPBhwxtbvQO661SEjzRopE9nWLoC/usroEuCCAh+co=", "AbCYyR57DLtcNFiAd8Dd+VMA3fYUk1YwwM46JickUwg=", "Gf1cDqwU+udZi9TO6jseKZiwwWhJO21yrkG1duVbnD8=", "DUdJ15zBY/FxEKQEpG/kJ8ZDTz/me357TM+mq5W9fhg=", "Hrv+gRSkG7gJ4LMzmSQSMuuUCthyjIpRbUCtpEDb/c8=", "JwTlthM9l2TW0/F9SdgzIj45N/gOufrqu/upuvS0wbg=", "IWXhyAJzBbGuDjI1cWNeXVQNE9cQw/mjkLaRPxTQNeM=", "LjSX5NNf2llsBq+mO8Og8uVdTuukrOtg5lCBrWOqi4o=", "Ax2kNF7s1ttsD3sHx4Fdet0f4FRtc49NeatcV6qEHt8=", "CJ7OVOR6pckI5D5fCHN8FDaWcIkAasqxyc0Z6sSiCHY=", "L1PBXire0zxH9VoHBIPmzH84Ifv4qkBnfQVS7Z0Q2Ec=", "FCqjT0suitDfeiGz45wAyLCqKFcJSAHqr9cr7+0Hf5M=", "F66k2kx7zw11iLAU64tAl53Scl7aTmrOMxmCRnx/8r8=", "DpcMGdGXSNjEZRBNjwIgA2P5pBeG8C8YJ3QrINwNFyc=", "BLytnlU3lWQvWbr3FKa9tDL8RaCgt38aujqYI0dt+bk=", "JCwL+82qdvcV29S6glxx/P7WccGxkB+khMh/gQMV0M4=", "JdsTQ8JBBAcQI/tu002ZCQeDEeHv6FrwoRsZEU+p55A=", "L/5NnEIKWenNx8Masr81GHyhR8uJijlC3rNnd4YDaoA=", "EluwOvPizxi75vW1kOs7+NDRumO+aWSD6Y8oO8fNB6M=", "CBa+QnRbfbtM7/5bjiTqYP2LcZ3rpQA3rHt1lIdFxrw=", "ERFg+az27DYNG2pxIxOg28viPmRCAFVHHS7kxd7bNdQ=", "E3eXjhsfaokl+o57eUG9+PtZq5VCNCQZKD2CA0Nck5E=", "De/B2IghZu88zeU6TyNvuoPThGIZN87lfkIaUT0NM5c=", "L4+lx4xwbjpdSgPyp6OVMEbX6Uy4in7zUOZ7W6Dw3r8=", "GiqVfsCnI9phwhNLqwvxe+sA5tzYRpDCMNy55Y2pSCc=", "HN+HEJlfXgNBK0p/aZUy+f0B8OoWeo38Hd834oBa3e8=", "Jv0xRxgow2rjbCe3SAVLDAxP5SObMBaZ43Ze6+zBiUY=", "B3XZlswsRFbzA6LB+QB2R+Eakh2f6j97kmFDuZ0voL4=", "AW+5M3cIymOM39qRvQ2uprlyJO97IGJnKt3RvRi7iQA=", "LDkvvn0/3kL8pPlHi7Q5MxJYJVNW8YSvb3bxGQVBF9c=", "GHoqO/eaafo+UInvnx/Vb9tHxV7s53qiKKo94bSGvLE=", "AnGoY6KAoyZB/6M1ELLt0njJhjA1lTLz5Qaydf1dIM4=", "FVdFnJx0yUqgDlr2mh4xEvtpU3zol+wMcYlY2WUW8qs=", "Ko4myo1kfZpjiFFuqdz/iQg9U55YFowqUMba4w8QnyE=", "Ict1IZTPQ/O1GULrAEDrqd4rz7HCo/rpeSS3EPJoMs0=", "LCba+Za+JHrNbdSsrWDTi1pHHmMiGI0CwTfny0hDd+w=", "AkAXbuDnmC7r6Spo0+OjjCaCGswPXQWM+ME3vKLSbxs=", "JjbglzyGXBvZdN142qqNCoTNr2vhrUfs8qDRjxFzGPI=", "GehPTyWnmUlgQWYdxdl1toH24GdEzuibe+XZ/eF0SsA=", "Dr+JBko68kfKHzb281cBiOJx4LMmxPsmZk6J4UVMoRA=", "Jcfpe0db4A6LVZo4xFI2T0ycUx/suKxpj3/XPOIucew=", "BETJnlkjU+WuyqMCrdkBwU2MVScKFgr+1EKe9VmK108=", "E424iHgwVl8mk9Dg8C5OeeFEln8LpTsDUZq6dktcmUo=", "JNQPRiEU/p7gKq/PdLT8ok4a42XcdcO1K7E8u7LyHt0=", "IeZdbY7kN2C8pA5zC130xM86inMtsUj0spUbTGHWjow=", "JI3XlmnsCdvwNQoV1sdcapvarO/KFNUTAJePE9GrbRw=", "K4I4wVSPnL4p/TXPkee0jw69p+Y57faf6NWrp5JNU2I=", "JDn9I5JX84GBx7489RPxv3I166lPa4lCqUy93s9vYvc=", "IAlYI1KBphuixL4KoygqGMdLbSYvXefC4z0rs+iT3+w=", "Dh7KXfiO5fYM+n4f5b77txn62CEfqbLQL8wjMZDBfxI=", "JrU0J/mz6ix2nZxmD8YIgaFpwScy0AG3FY7ksbhCyiQ=", "IPOz9Kyv6fivPgZmGzqPd4+igSUiudcKZ0As/42ysbQ=", "IR5dKznWJSCnpifs6MrLrJ+XUG3vTsKGkoumwn1GOxc=", "C7dD7jSAISnFVnMa7Z0wLc0IUxPOVy9iQtE4MuU2tLQ=", "I8smYbSI7nHkx1P/I65L0l2KRAlPZrZTKXfiIUDrpcs=", "A6NaoxI5Ec20U1uu0zWfX2pSBbnJPvMdNTI6R4B7i8k=", "J4A4SKCu2WqT+pQ7ZjXkUCF+E39K3nSmLXkXMicUtpc=", "DLN4OcLJp/95iEy+x19B6b5eR8dtYVOCMb2BYpltb2c=", "HwAm0L8fjh3VQjzC/sH7XNqh7NxMPLIY287vd8ANL5M=", "AqfXu5cLim7S7mb6u7qVa22jsQD1tfuSju9C+XCCc8k=", "DP1/QhXkNMjaF+wyWLC8YFrRqy6QqklDUeTuQLvEkfo=", "GAsRtyBiKhVoSdxvf25/VxZZvmloIjDF7ZrDOXAKfN4=", "BOlqllvOPToKJKSkV8lRWCyHE0nOfu4aq/5XipTGUBE=", "FZMfeCtF9/tlbyzb0fdwXDU6I/4dMKWkahUi7RYN860=", "LiluV8l6Uwms0m/r9VrJY6VETBxfcDrYig17l7ndOLE=", "JhV7zreOhGu7Ji+aHgbUJxveWlvOjwQZlS+X/9E+rKg=", "IZTriYR9aw8Yl/Z18ZwMVrYbEySO/zyjbjT7nRx57kM=", "I1C/NUd2VomRUa193pbqeFfhVQFEcAjatrPSfI/6J08=", "GkhvCuWRys2vCcWKScTReVQFQ1NAgZ4APwRp0RC3dSs=", "G1bc92+yPMSoNNRVpAZeEzVxQCt98wnVm8MQXUKowwE=", "GnSdeWSvC3ICkT7yBMZT8rS/tlzqt7aFIzq1nOO7aSU=", "GK5ZAHP5aWlq92L/pOjw67+X+Mx4fjfN3R8yG+O+rbs=", "IcR7J12C3eZGDV52mplCEUSxxanaWSlK3py7MXED8kk=", "BHPdvVLnN+UnNk6OtjIHl1w41f1swysnIQKwgs0VGPs=", "CxL6yVttOogdiSZXyEJOZFrE5rAFFfkC1ZRXQwKybgI=", "CK52FqJgz2ZX+Pc6woRYjSxfB/9CXYN6p83O9j4+IQM=", "A52vaHYoC4Doc78qMv0oNKg8aXV7rdWKiI74Gekmzig=", "Jeex10cKPHXxPwtWVGyOCfLY7+/wbvdm+ceDyoadEw0=", "Ho/TY0w/92QYTQNDX5hYSxG1sVrrnHUmLaPx6iwqnno=", "JB3MUaw3gIpBXdHjwoHwWv8ReJ3Ayv3XejVITgmT+aQ=", "H/wxU8Vu+XVZMs6ivgVzdJva/hxPoHgaS4tAeM6ddUc=", "F2MNYtmj5RDIik1Dw2D5K8D6ALZgMa3sKb2VQ/06F+4=", "KYBADt0ddOPWnbVFjSzNX6vbI27BaoKkMBoKtZ6kpuk=", "MDT7JDZhI+xtyvytNXJtv7FhlMA23NZI+mlDm/zQDNQ=", "Gqfo9Bicqd/z2yq3ZIvgojkplc5GBB4EaA3KitcjLfA=", "H6GV+DSmnmI3L2DrSX2hZ2RurhQVPYA7OdxdEfXXgAs=", "DyPxx01fv2GVrVpq7l5WmTxUd+hFP1uToNe6/TMwNtM=", "AWVW+sk0inNatQqgiclxUbPKrwogo0+52TcFBaFRVyk=", "I9kreTZIEQ/Fru8GM/DHfKyw27yhh5uKb25d9EXl9ws=", "LkwQ7F5l4vI5u8Q8EwMd8mhqtA/XmjBLBdYRuCPyO3M=", "EkGLv9d7Y61eFoZK2cMv+/xaPdm3jsK3kyn+XgqNKVM=", "HkqKrOFavB1bdqnoSEMdLAanj3K2vrsSk+bFjlGFaW0=", "Dz6WEH3s29aHLCDqCaz5LN8Xo+4dEzFIgJLZYXbet1U=", "ASw3gCB/OVzCHesKvZUWge6jJJjdumzol6j58MI1cGc=", "E+qxtOZyuhscG7kBdpMB8eVlnQPqEMYd4kd/8KwiFCE=", "INxmSrsgt0VsBmKc43oeyxonpOiyTjG0i5xGNaowMj4=", "LGseLP6njiw2eF52qM+xsFfpRx8k9bORF1w97LAeAA8=", "GIySYlX1t689qWNVcpwqhnCrTCxwQASBsqyQN0Dgxas=", "L5kTII4J49bp5vumOE/QdquJ8mYpduPjDghwuzDrVPI=", "KzOAPZCIlwbnFPcgtWKNJvtgtUWh8+nOSaaukSsCQIY=", "JsyrwQ6wQyfLXMPd4quzbwlwhsl+c4wTPJ9XB350iwk=", "GxauDXxUQIy3X9kx8kZ1HysMPcINeegqJTG3bCK01d8=", "EdC7RhvYryhE9J8PhAyU75UYslETRHQtH1Q4/j1BWuQ=", "IzAxhHtHa+rQEY09szjokTPsQg1nPlBK1kclnfZVVx4=", "H4TpeJW+5DjrPJLcmxhGya0pwWQ4ewautu0YQe2MTco=", "J39/m1QvDCu19FvtBU8JYkU2AQw8+UUtInMZMyf4AdY=", "HvyckGnlBouqwT0uZkVkG30n6A/CMHcWFTXERoLuV6k=", "DW7Ed3YeLvusTxSzvz1SV6meZMPyX+EE+vmIsg/l/0Q=", "Dg59fFUBmZt9Fhc7WbfK4fIDvvIa6/ACUYgUOcz5MBM=", "IXvvL08SxtzJHCBYojORy3feU8puRNzcbqPTb+oybqY=", "BXgMiK3wFTG1D4F+P+RER9KbNaqKOJxx6M8SJqzvaLo=", "GHM4h6ays7TJDY5JkBluI0ReR9fqWTnr+4mj7j1ntL0=", "ILrOY6z8rgscnyvuJLjp2oW6WX03sJBXIMTxXbIxsHo=", "Fm6llTdaZ4asUn7p7O1z7Wv1UIdqvK86yStCyAiwDY8=", "MEJiqe/0BArPQ+Mi1vUmdq4vhT7C56gNsAxIjPkXx04=", "ImuscFAWbl9tt4zQsS028wW26MmgVRFK13Ceb1ckW2s=", "JrL1OcVzgp9qypG6qVRQW8XD604d8dY4WCcX+98jiMw=", "BqD79M1S6Tul5MbEr2XbAu6WKX+K0gDy8c/yUudptVE=", "LLnCQRLTU0Gs6siDYPtSiSTli27KwyG5+ynmqjNo/yM=", "IOiKTWB1Jt0H/gijVSpEZpEp64f8wLE6rI/or9kwFSE=", "FURkmivXPjunLzlt+R3WVAHdj69R3jJfuu251TatlPw=", "GYAHdFeZVxLETafhdxMljj+Os1S/2A7Z6vPsuvaWAQU=", "JdHSL/E+dwXTwIX5f8Tk9pFLgv+qXSCR7GTaxCN2Xvc=", "L+yZDvVW7+EDWkZP9VgedAZ0Rc1Uq8r2uMA5n+DSTPw=", "G9lWNQbZVE7z5IMOE1RQEsV5N5wtzBMwQWxK5JvE7GE=", "AK/80XumADxW36hVcfwpc3siWoDUgOfdft7AHxTyMBA=", "I2cNuu+WaIHwf5GaLYgxKMeyPPdnpHeysuB2K8DbwYs=", "H5OlMpFzlMfiL9F6vupjicZv164t2fAvhg9tlpR/Dt0=", "LeQun1N7fWGwITdxwOdPVVUSvge2pQk0c04sW+tAvjc=", "JcVX9FuZeBzTfTuyKTFmKmf3izd4LIhbRWu5bVXohAQ=", "IHTItwlwXJiIU4p/ijxK/2R3Mb0W+OJU+nTqnyvnZiw=", "Jzg1WVYpgTiUnkQhcdak5LdO8gZXQNt8/DoLYP1XOss=", "E9Nq0KTr64GWl3hkllnGXLfQxBzFGYcf23Gp6moMqlY=", "CKLBi6QTgTSMGs+/lhdxaAa0YqFpG8LjQ7ebgIXjdrA=", "BZCS/Dla7ShYB7v1V62aEEH1nAeYIrEIhFeIL+57YSw=", "FhkkFRtaWtLYysEZUiqZGpBvFehTHccFZ/ayg3HMJOM=", "HGjKj3qhdlkHVAXvY0G45popi5pNcvO7hUswnkuoehs=", "J/XQO8ocggf3I5pLLPc65VmhWqN+e93fOqsF7sXOVZI=", "Dsv/SEaWKpddNH6pqPxGX7RoYVV2IvLCVkp+Y5gzwWk=", "J3xN4jY9i1tFbPxaf/jkb/LsjapZhV9a1kvAUh86xWc=", "GxGGLFKs01G3pGR5P0+7V/7Jn4MrYyJvldF1yNL8CLI=", "BqcZxYTHT/vdchjrVly0yL2GyS49+zxz4VJyAapRI04=", "Iw5K3uy3mYd/fOmljINrmdUzWEoZXB13oxOr4cfRJr0=", "ELEJuGSAnEdnoTPM5sutbIhigXO46lHozKhYMMp95SI=", "DiEReXDc+9SxUmslNjbzd1ONO0+q61qLJL9iANFMxZE=", "Jmc0mXhAE2L2sXk57rDmT/VWB+vbNccHHbRrs+e6R3g=", "BQAPpf2lBeApoTv+MEwmew2GxywDm6v20/8C7iRr4C4=", "Jk2eCUrtX0GmAkIiCjSihAiQh7JDapv86BdMyb6MLiA=", "CAdvnEdD3mEw/2Is9AHt0skvJL/hFPPF5ySJF0YxXEc=", "EyNwq927Cx3VfypSDCUza9fO3pS5W79cIVHW2I5kG2Q=", "CP8RFreiJ7/f1EZaZ4kIgrYVyMTBfyjY0klY7fYC3cs=", "K8sLDbi54+ArfpwclGD92cbNmFYjMuZI2KPgq5RZdSA=", "EupozmiBvsrX+KaxF7A6uXb3q9WX+QOwvyMNINIalDo=", "J0OcmKdmiAZ6CXsZtv3X141fiOJ04Nj+peprdAb92n8=", "AvQNCtBfVlLjHvlECtcevIQZ45NJOTfwXwBJnQKpnjY=", "L78EKEMn7k9oDwa9OQ4wnQ0TrMdLnFsUtjBZuMx6v/U=", "G+aG1T4qitV6gosGUUJc/Gl4xwJ+2/JH9rZyPCHfhuc=", "JoO0JehaUI+WhS8UtCIPz+n3rYsXv+/A40jEfKeLtX8=", "FtrOmy6AEuMdscfr5nLYa75hoao+FpPg7d/A3gqd2VE=", "J6Mh+MfTyQIuli9/7y48hItFOdu3WqE58wQw/lRbzts=", "BszXIQ3uHWsOIreeEtGQgtgHi3iNcQB7leendO2GplE=", "CkHdQiIWU3Ur7zUPbXSpF7bLsf12o6EhZvTQvpeOQCY=", "IgoCiB5NR6yU2VDN+DhidNF4LifL0NhFl43uyRKY8WU=", "DiFVpUX+Xzy7Y5dgZYnqwZzZJjkznGsBcpikrTQItLk=", "Dw8ZxikeUVRqJnxgzHdOX7nQiLrFMHgtiR7Br0uEcHM=", "DpJbzRxt20o6HGfsje771AxTwNM+eu7xtGeVrtWUPJ0=", "KtAAsXSKu4Es1uVBEoa5/z7wpb09JZo25F7wW561vus=", "CmWqIy0y7W6N5j0c3/68Lz+mFkZcJ6r5fozT3P9khlI=", "AmPYRwq0scYddNjoliQvTyYdyxZ6OgaSOJPXyyyT1qE=", "KQHZRq3clLBA/VgATZpfjNGSZUDHqGEs7BxYy2DCs6U=", "GInPqCCfSVLfkCLbncWDtXF6BpbaQc7mSTfQzWMh5pM=", "I2Bk1xy2xkyEdHrCX8+NiBUC5fA7/4dWG4WhFrHzmso=", "L/ehdP/Owphi4E9dvcc+vzZhVwAzV2KQwMH2zYztJ64=", "GeckoddCyrEDRV8AQO33RaJpanEITJPjInFUUN1Nb1s=", "A+7TiStvDmxdoQWcXzeTmFg1qig1AKgSmQSpTIfxYb8=", "COK4Jzv6MMGshQMG2R5Gip6NBQkq7ky8gMaHJIRjujA=", "B63Mp22DN3KIOaG2rDs+1Cr7h9cq+Y9S9Bby7FiyjOw=", "Fx7zeJa64rECCgpYOb1ReEzhG7QjfVSMFxFp0y+hm0A=", "IP/fy4b00AUGTtvClpGMMy0y++/xcp3lBWomq7w6Nfo=", "COzXpvFzXu2GuqCU5gj0iPONuzmPz+1LmUODoMqORkc=", "HD9dhuWSH96YkBifHYxhh1QohgDmkovBgqxNXkyfDMs=", "KcYRhO2dRg8zdVihr2Oap+PAl15AFO2OvK1KJdUeq/M=", "De/UWyiVhygiituy29rval6bGmSQKnNPQCuM77irO1Y=", "CnTqItigkzYGBhAXmsHYL/+pSS33be7U6mDgEzsIEag=", "A6N78S2vFADSl6xKwTuiTBfcJi2xbIUj3u5ODM3ppoA=", "Ef4XkNWrv1k1/yIxjk9//mmWatovkTa1T4MOrLCmU2g=", "AYFlhC9AY3XyNGaGkVr7FL8f4FZMiFjuO94Kuj3l9o8=", "Jh2yXnz/Wp+3LydrH5JgtmcwD7fTYbUP1cDotplbBfk=", "KjrDMUsrZueW++Nt93jF5GlyMgzEPsgHBIgmtnBLp8Q=", "I8qkuA7PqZ6dP+orvB2782nRv8iTfQPQdAYcMP2M12s=", "J9smAIXiJImN8UXyP2NfIGbY5OEk5YHoxiYZKbHf4Qc=", "J09sX9NKeE1rkV7wXUJO5sC6u/Np55qxOLgWe1YY7H8=", "LDop4TqE0moJEckona8apM9YQKraBwHVfiPfx5babaE=", "HqIQ8gAaM00+gB9OUycNQtp6rzF6VTtCgqp46qIoLm0=", "JU2+tSiEtpnBun+g1ugNYQkDsYo+UJw2NRzMOwJJRuM=", "BZ54HWWJbr4OS6JtwvKZB/R7ze2kososcT2FBeox/V0=", "C1sc7GPULV5hXcJpuIWiTO8wPseMly3RfNuz6RXMT/s=", "KnwBXpw7LFfKi30m05obzIXW/6y32fvWbSqPHWTtDJI=", "Kbc2uRHXGnnPY9im94bxG9Wr7iQWHcVnp8hR6uHkO1E=", "KFdFqQp/49Ca9agIcEvGnG8XAeVzkS31zB4mXVlsQUE=", "LZAbgZXDyWyMNuuZ/sATTsK4MEroEL0w2lVOMICCZxU=", "GQXTUYNV6rp4WbWR7XuMnCU5gPBFDb31TXp3groFg5I=", "I+gTAm/AuABk0ZtcVCiUL99+/qgL+o7ECVJyv9t7TJ8=", "I8ChmiUsh+axwcIbGnmAAgDD+/8+MwDn5VaAcd6e+4E=", "EcSuYHuuSSQTv2LNqiwoaO0f7G3AYxsGfKYPqxJbnio=", "LNBV67fuRoY2XepFDwRv9iQF+uGxr8n7AXB8+B2g47k=", "BTyf7y4CH6miD62iL96hUFtYoxWbu0czfb95GyFbFFI=", "CjW9dOh8urqr6JrRMZ0snoY7TGMcIZOMmlOVv5eHKp8=", "HBFQVlOc4gzVoE0aXEPisA++g7JZAb429d3EZm/Dg/4=", "JClUBH5Xcv073tWQ7IvrTFQvLiZMjD4oTNxHNQXFGpA=", "Diq9MVtHwNyThJwM3yZ+gRy9vbIApufCtn7ffLAXQhQ=", "KCs3AgwIkNdRw/12lQ2AaGaOHf6uYh3VUtLeiH2i6nU=", "KJM4UiZrUtnqa1u5I9nZTy5aW+XHeOdeB5QsI0tkO9k=", "CZq2dlUFuhGY7xQOd7eVTU++eaBWznK6zjnASMANo88=", "KvIR2OCsLY/af4SbjyKaIlxhhrVXYsensq4tHdhcV8s=", "DNBw8jQBSigJq5DHHB2mHpipYyL+3Zm2qq4coQTz+s8=", "Jnk+KryNPDDGBib7qhWPJjWH1r0Vgz1EixFiZLkwJWo=", "IlvjbtDuheH4Ra2oTldIpWaZFSET/2G1BWtti95gwZ0=", "AhdPSe2wLVFU0r7KLckrnMWVOD2h/ejwnkte4+paBl4=", "D2SJHCyLAg5Gw1lMt1jwvdzb0JvQMIgW+0FzSoaYcsM=", "GSqEyi+Z02mR4tKx3v85idHBVsI54Q6fVhQOGFRXYGc=", "Kd/Ne2PwWr8nU6jDQda3pgxiQ7BMmhuLMyC7oEpNR4c=", "HuJ61rm1qGdzOvxhorPnalK6PkvV5let6R/AOIGduls=", "CrR3PxUMP4rTvJU49DzsOVp+NzGulz/v62I6CSF+ZMc=", "E8NSoC9ZUYYgLLC5n6WMVUKrZ/m206Cv0QPe7/bYD0E=", "KpfPLBDEv7/SmfZ8UqFp+SwFt9rFakHE3U/ofIJGzhQ=", "AL7LtHBCvX+Mn2u0IhYtGu0ImihIL3/RarBqEyhf5wI=", "AI5E2iHXOGkbiBdX7zftKcW9n3pEUPz1MpCpLMLKIXY=", "KyBai21LcGPZMfO7XTRkBThD/n++S4PBeIP4ZSeIKhg=", "LZ4yp8kFVv4QjSVawB513zOPzWOyv4TBkoDUJymIY/w=", "KaMiqEwlvS3fbi5CACKNlavWNJoCJmrB27pSBzjOypc=", "BnjJv8by3wEvT+VeM7torBTO0d8NAhUnkgidBG2CjEM=", "D6/zpedCV5T+IKfg62FbixdgOUt/IwQoajrkAJEk2yM=", "H49bYRr5/rnOqGwIQFgSBVPkBBA67iE/WkHR0CVBwNM=", "Fgh12EeWAvlvQKzC0ELuUsFYi2op3kKEllptxskw6gc=", "Fth6UYOjFqHXCvyVHv4s1mfHcyj8/aRYy/X+MEX0bZ4="],
      M: [["EkZm+AVh7VkW8vBwsb0kjG1T9E0nPZVqDIe5F2kqTRg=", "EZJPAv0ZsJJVqqHPRuoFGOPXv+70dCFglJEBHbC9CwI=", "JH+n8CIwShmU/1BUVsIgHvm3FzaUmNP/zkRmAe2d+EU=", "A/17Ge8shh8i93/4EPVOJ3vJTrdsAtedmGvj3N8FHD8=", "GL1BI5w+cVeaZ3RD7P+9VVqB7u6mk1Kmi2fIVjwMKgY=", "LXjDpdKN6f81vwoldjUZblcwyn9ASTJ3B4zXXai069w="], ["ClFKXCJ/TOyV36Ap6N0STDSJWqRrsnwJEfN4DVAVVAo=", "GS4W0X2VayV7haZS7v3y7glYnqxb6AkVd1cj0ssdoG0=", "KYzgweMRO7k1xwWOd3K1M7GqnbDAkmvciRflYFyjrBA=", "CUy06DYhr9Jx5BvHFyfwFY69YSI5rJ1pixf+S+Bbf8g=", "A9iAOVvpPCfWSa9f0ULnazORjLiEHVooFzvVz30yh5E=", "KO6ua1hmrWjkQ7uvkWgNt9fiswN+OP72G0LLzP/OyoE="], ["J4u0mntORK6kbrD4gstpKAGm5g/dW1wjxjzWXMzk/go=", "Bj7ewb7YMfUGr422SNb96hRTRYh+i9z/EJA1odm2dNc=", "G67xy1UJtSakIGH7U2V/mbMjJQDoVRksvoyUDgaMR18=", "EyRWSse9+eIhZOmFjX+o42ixZerqPa9Otn7lnA3y5dQ=", "AFdhuMauyxqMpOpN/CyDdgZKSoAEzu2iEKVSQFYt3BM=", "EMnigxWdWMtMsuNf3oOjuh/cKAAu2ZY9KpnxhheKFI0="], ["DDmen2eqQHB6ID/u+wuVi72tzsXKNJAdJT0CaiQZ9qI=", "CD8N8/GgNR0DMOw/9gLKjMNTt/bnYscQcYTNe0I0SfY=", "Gmdk1ZQ/xKcgtMChn9uMcRmEMHKHpYubX59dWCEssmM=", "ARpjom/qv4f6Zr3mbMJakiyWOC12xqf/SPFTe+rtaDo=", "CMp7ZGV8NUjzK+9bY60kKIpBwLJRCZrSf5Q0MH4+ZNQ=", "AZmCcEcek2GVVEawzbi+qRXsBnXxzWSN3LBDA1B6RIk="], ["HWs9X26jacJvgl0jYpM+qjHqNewKd8H72eAcoVI+RDI=", "EZ7xiLs90NMjBpdsGZQehmS+aH56aWkton2iFabwbUA=", "LZ4KtcBok9/f0DSBOBuoa25ikt9WCdcfLGSy2aefgJ4=", "JfFmMb93Bg9+o0CHwCW/E1eEMZ7wjNouMUGe4KUp5lg=", "FEx6EdpafF2rrj8z+9A8rYbRi8WUx5pJfsuYlO21VPE=", "D5cRYmJ3I/P+rayyiwwQTLj3TeUIdS+o18DbKvE96O4="], ["JL5RAJVDYgbdCr0LDLuVyIOrMEqlJZixppMG7JgaaI0=", "IRYQ4q1KN3Qm+t9waLDBpsKZoWTBwaYD6u2USHDQubk=", "FaZ9mBBBsfbwnz+evv2GTnedOvCBV3hqwHdQXlDsefw=", "BJMn+nnSjBKiyCQGlH938Gd1sCh0aLMTaHdwHb58lZg=", "IwlA3MUjJlj/nClpej/UFtFw6MmY8aqF3qDELXn5Uao=", "GxIcBJzRFZ4okAfgydqZlcxLq0wm+4iOw5cqii5laWQ="]]
    };
    exports2.default = _default;
  }
});

// node_modules/@selfxyz/common/node_modules/poseidon-lite/poseidon5.js
var require_poseidon5 = __commonJS({
  "node_modules/@selfxyz/common/node_modules/poseidon-lite/poseidon5.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.poseidon5 = poseidon52;
    var _poseidon = _interopRequireDefault(require_poseidon());
    var _unstringify = _interopRequireDefault(require_unstringify());
    var _ = _interopRequireDefault(require__5());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var c = (0, _unstringify.default)(_.default);
    function poseidon52(inputs) {
      return (0, _poseidon.default)(inputs, c);
    }
  }
});

// node_modules/@selfxyz/common/node_modules/poseidon-lite/constants/6.js
var require__6 = __commonJS({
  "node_modules/@selfxyz/common/node_modules/poseidon-lite/constants/6.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _default = {
      C: ["IZdwP860y/B8bb9GxK2T59FOVU22bQkQL/hIJHQ/5Oc=", "EyLw//x+SFS9i1/CPnEGtR9ZvVBh2LVlrKL9Pv5RL3k=", "GeQU+AOAqi0iITMRjDN9gqjFiUwviIYe5G9Ej6nWE1k=", "IiQRmaTfnLfWUknZViytbGXxZGDnmnk5y/3W17kgnZo=", "AwEGFzU4Tfzs+aMRwireMntRx4shFhX0HHf22F6KQbY=", "Ip4dhsHygQ9KJjO3tLW7YbfcXRmslf2NN5VI/ytoUO4=", "DjHc+cUyCagX7rKS6YlyfD9Wv/ZYg6/l/cKKw9++pnU=", "IixzGOvpYwbJ15rBEjcmPGuOslJy64hAfowpo1i0Dyo=", "DLQWtCxTqCnPT8gjvo9P7dElkzlM1SkFP/TjYEl0osY=", "CJJynQlZSo2LGt+/Li7XU5ne5hKEK22z0tLCqt22wKo=", "GOOemuRfFLqXoVvWcnEa4SQ3XZ9IKkSHoOM03uLSfHE=", "JWDJ/2cubqaduzOETQ0ihwRh0Y6vD4mS1NesZJ7dZhA=", "Ib7iuO1UtybvF/dzZrHc+9p8zx5If5kW5flj6BTFcxI=", "MA4bKNq+vcDUvbwZvimj3uTtqEJd0MfG6C/sFHywcLo=", "LESl/0Xe6mndKWHWcBGvSYK5QF+f443kpzLSrq6IzCM=", "DI1Z/ht/VQleaqrZ47Tnsck9h2ujI03RrF7GQQgpG/0=", "Bs+CvF/RFdNIowsMRTeNkMyhZgRGugSXWfpTED/NeLU=", "L4DtAaIRjQLiFFERw/5spw79+V2Kvq7ogpKTNH3JBhw=", "C9/n9oA+Te57Am4HkHWQjLhBTj1lHdEv2mffCN3tnkI=", "BsxI7YgkBVlbNNOROPULtbMaljoNumau8XwZrWIuKbE=", "Kmfzum0VlJkyrFYiz54rSTgBvxalAzakUYJYvMaGfJU=", "JXJyWmfGBxjfZWk0qnj764DI85WutqIM2DPEsU/vQSo=", "A7t/bKQ1RbEfGXISZbQWFmV5y3UzMLGHm3loXR3wv6c=", "JBKBXoY/jzvCi/y7lX+qXzkzALJRM+kiG46zFW7VwSs=", "Db9k1Y3yEuQweHGWbeCXpdsJqT5bwwXOvc0GMPQzr0U=", "J0wGwBFY4Ef/SnkeJbe7PbGQUp349Qtjhic/gQ8Vxqs=", "I89AaT9Sq/DtPYQve8hdGiER0Kvs/Bis0P45ke5f0z0=", "HaqpJlKPM2j05M+SQWa4vT/42u+8+QDm3MTuY8QJlpg=", "EBA3idyUca1xhle+u2eB45vZL9IO4aMtDePqKBegFVU=", "AAm8JQZQgObG6ZMuNL/eeNEIXxnp/8iWWkZgpNm21gc=", "ExLHJ8tUibsXTh3LgliO36sxopmbN32r7ORm6dzWr+4=", "IClKRix9DCWutTdGGOXncxZoKuPXJoJPFfAPfLmnAJ8=", "JeDGvom7sEvYORyQzzVYjw6dc/2wYln0egVROteiPpE=", "AISguH4LM2yakRBp+J2HWji+MT78Qg0ouewofyiBD9M=", "KKA+4p9hKqsmj3YkHVTUd6HZf1gHui4YEvTTUNfG99o=", "C2eUGCtyOhLgs192vVWn0QbuakA1UnxNMppvMwaNfto=", "AVuaaYRlQo/GhredtJWchJW5K4USL2ppMpQINvrOqG0=", "G/5SKJ+BH1w2GfFIZhOK6aEnm7dujOyaiTb9w29Z33s=", "HNV0/o1eTEKLkrI6lxc0IXbh0wmn4lkFLDG9ya8JH6M=", "IS0bvfqvAgBzW8WFGhVq3L+k9gf12hIuH2Ovrs04yrc=", "CwR54ogg6IPZA6lR+VsTCTeI6eHKZN3yq7lLE/7p7bw=", "ARD1JXwhyTedc7dunKlcUTx3oVzI7g73JthGDU+72qo=", "CMUulAGpdk8MJIff7TTiFcGGtsKDjjjrWlDMpPC8aZQ=", "LkIrQyPLTAr0b0sOUFL3V0TFOKvMx2Q/M5RA3Dqu7KM=", "LhJIK6FgRy1FVJ/3nNBK68SjJ8S7nXjCVzuDWwXFX+Y=", "Ek+l+cWpbWzOks/HPqJEYgLwkQDu0gOuQmeqY3oDLTY=", "C/ZR+C+Dyh+gN6lB1OKks+CPXhYD+TOhcjrfQTV5bec=", "IcZ06nuDR0HLrTmyGyQquaVVTGyfkugByx/kOCthlGM=", "IU+R1sSu9X6DGGtX/Z+kihk+HK8W1/bcFVnRRKJxs0E=", "ID4iGDiXKcJsb2YhPyJpwmJ4XsaMdZWZwtjj9oA1BVs=", "Gqk0GYcTzhdlj1EpP61EscIvyAORQFznbJKyNJt+s6I=", "EBTU5d3ZwXs8KyloRHav269/xW6LeZYWpnu8ZnjkU1E=", "AzwT7UW0dipH4dLUXX/I+/nU4kVG4g3FlpEfuZFxA1g=", "CbwcMnTFaeflxdd8Uf5psjt+Q1E49PMhcBai1wznHV4=", "GAMXHJ28BhDjjYMI2xAdapnKkBN/arjNqyqRs2tjMio=", "C6YHGqmK/sP73rRqiOSl0XvURUwOfajHSxWwhEiM/c8=", "F56Qq0sIpOrSgahwkFdIfgd7cQh5kR8hX71ujr+Djpc=", "HLyoi4qz8FiP+H3uqXjQAAitutgI5lEIlyOOoAf0kaQ=", "L1CyCzNpK7D2J3feXjGYN315I+8vqO3giDHhD36bn1o=", "FboDDo8e9vJgVm/W/P/80hoc/BIy9+xxSP8HbRumhwc=", "Db4FPaAapLfA+tg6PMlm8LgoG7SUD5elUWz7nc1UOm8=", "Ii7KXXVK/sqJl/Mdb8uUpdeZr7eV5o1Niwzm2Dn23X4=", "Kr/6Q9dW7yQtt/WEvWJAWZERJhg2Lxspoz7iExtGpEY=", "A8klJOvmcwDQ3QqsRk8Obs+WLWrUG/JoXwd7/XiOs/0=", "KCJBdYreTvj/OFgwUojTtKUiCSldGkvInYhbL13DNBo=", "AmNcuXPXG7PSE3vYFoDdO8YH/FSH6JjEwtg8HcKBdoc=", "E8hmqmbo1QYHncJMLfex5pGZSIfTViL0z88BS76iI+k=", "FR8AB8z0Kn75afG29jFZkuZZS7U0TSg5/uZiC2DiwCM=", "HBxqXrzO6Mqk3H7xjhlCdPbhmNKxQN3Ml8sVySuhQJw=", "GDMMnmfWL3hhqZbX7Wm7qQSw3UWfKyVPx8xT3SjkWmU=", "JrdHdAyVvxOcsRvfAvpjpL2ympDxWJM6GCLN3lOHKQ0=", "FHVnb7IFCEJG75vHI08xLCFPQmhS3LLsfcN3L1ea+LE=", "GwOtkIDSm3Cq8wu8MgDv/+c+4mncAy0uMr0ZB2e8OA0=", "IcF1+TfC+C6Zc1vHwgEoT4lXeyeh+E+iRkLs61UvRFU=", "EZLgJpprZqjFiHUnqkR0wt6Rz4xx69qDXfLNzN1KTks=", "DzoSwO5S8NNPK0oNzRNUG0ius9USHTERE7upeSpFpY0=", "B/tSGIO994szaJIFtF5SJpRYoGG8uH7rOx4YPG1+tbc=", "JI0OgFHBqWVkDJbG8BDEkx/mSLlvle9vW45HT2TPMWk=", "KrVT256tLILOkf6+GAUp7/NSGHX36Qqbi3o8TeSHfNY=", "IR7jvaPJXxlU7vIqCoLC7ehETkKnKoIAurahM4RtW1w=", "ER2ztRhP90EvecEpkEqcrE7mWlHCBi1mcy9UvN92e+Q=", "GnOEMmTPmjobtvto73YDfE+pgzflwQCWxjC0SexKX2c=", "HC5aLZMy9lEoyFNYZi1qfEQ1Ot0JwnzQfaAvkUTahV4=", "Dis1/hAhuHneW2enRY+mGIu96jniv0aKGiTjYlyv/5g=", "LlaFlOXfv63ycrjW6Mmb14XE+pTOnof6ipo34yx6KN4=", "BwQ8dXHLfcUgW/2kLWk1J6S8tYI47WpqJI55F92vDDo=", "I54YoMhbhF/9a4XpY0PxqDePPGkdrfsijab/eqee/h8=", "JeJHryUMVkwA9f8c8fK8hgZgDxc8tl7weAr59aG2dsg=", "AxujOFZkVE4+CAHxaYsVAzpgSbJQTpzcLG4+sv0SEA0=", "KjN3dzniqwrfscpWh9seBZsgNwy+7MrTLaXDYJQx/2U=", "K/1vDp6Za6E3STJ7nFzsaZA9QTst8pt3fQU4Sz56+VI=", "LUU9k/s2+/jjZ0fuktkMrZ4C5pLQdIwH/UPq/CzF6CM=", "GHvYBD+GQs2itrrYKVjRFYGIgOuA9rcwOB2XSsXVA34=", "IaymBfkqSKw1cI/lFAcp+zXD5IzOxEEhdxOwhklEOTA=", "Fz/RZPUiSsBsLpnz4uqmN53xE94wqkhei7zH8P0tHgM=", "BxxmpkY8P9QpK/HlrLbeYRFC1zzR21kOibYbV9RNab0=", "BEpA45aFW+VQ2MzOe4LuLKrvZnW+vpImbGZpgv9yu/g=", "EXbZ9S4S32fwhxEKFar5jR3tKT/9+ZWZ/t7y5RVp5PY=", "BujrfdAm0lexXGYkvuLzfVtntKZxz83+5Xl+hFe2ORY=", "BpaqSMHV/oTKXPWQCasLqu+7YS4yyR1e8wbe843FZzo=", "CFPDOpx6fDs1XJLHXeRENl24LSQe758/rEFwBKOhrMw=", "MBbAujRnjgpn9Zz5bOFukIFU9fmAJZFxfmbpW6Jat38=", "CvAIYB3JVSUX8wP/niLHk6aCyqkyVvLwmk90ZUJgOw4=", "BMttdrWielquOHy2R3kDGMJfwW+NfRhVo4dl+Ef3MbA=", "Ls9ww3LY5e3K1J5Y1Hh18mkz1iYU8mbmtPWGF3FIVl8=", "AfOTpu503WxNUrDnggpxMvjEiJdCMTwGyqbsxV891BM=", "Lk1M4/l7+W/4a4jpadE+QV4UchKCdp98+MOnNyPwlNs=", "MGAA7ySn9anGUuOpNnV4VU6lm/jvoL2LxXdkYMGMGt0=", "JuWNYodnjz25wiXB07k658Q6aQJOvySci95AYXwrPUk=", "Ce7gn4c9G/aDlx30185WyPC4uY3cBblhLAoNMXMQZVo=", "DwiHnf1PoNwR3tVW7wHG+UzG9NGFU7CLyx3WBDkuwAw=", "EUWffp8OPHJ3d+NNbZPsKKJb2GcXFSO61b4NWiACnrc=", "BOnLtvbo6AWiD72AGlO3I/eMH1rNIniA9/N/TlsFKK0=", "LS/zLregwCZt1GvVk5yamq6Is+mvXa0BpzBPmGj3x8Y=", "I7d+sPJ+lQIApZBEfWRacj2bQF+iU4pct2/F/a4W2Dk=", "LNbSxWWOwHktruIGfi+VjWhJiGMYpsHCcjOkaemZjC8=", "CuHapCC6yQeA0MgwJr/MhK+DlT4m7Kg52naGHnOYVec=", "K0lbhUVT0Cp1todjvabdjvDoH+MrXLBy0/WAqRSWe/A=", "BW+l184sMrxXNTUdLUivXWySVqS3LhKjVkC1PqlZ4pY=", "LsvhoGso7HjqfSLfEc0iSg4aCsejR2xcw8TlDalhqHs=", "FDBTwcOH+TU71nfl226ZdXkr/+7PAtaqD+j2J1ef5s8=", "BAZLJVhEmaAR6nSsBHqLN0lBibxjNCuxGC4jQhLUK9s=", "EA9h9rgVQhVnYKbSmvXdhkTILeq1uQ5qxm3otKBpVko=", "GNMxsugYC3qnBVwCn6d6/08CsOKiB4v/Z2iO1ltR1t0=", "D8+bieGbGlX5sDJVz4DMuftqr94rRiB9hz+sgMzvCFw=", "JU+AHzyJxiQ272PfZ9kSwfIxux92xse0l/dwjbz9wXs=", "FtjoXleBmhCmFGG82NPTyWPE+Vr7o+TY/Q1uyIK50WE=", "KclWWqcCCIvUQ+RiDYS7K/uTJTqPDwTlz0CMkoIK2oQ=", "KU+2gGRkPYvrI3vXBaVXhxtfFAhiTtpG1HtYOmDSnPk=", "LCbzCDFAwQS68kw9+SIxdYSqEXcEUeaoRt59x5UZcxM=", "IxgRJ5hUcH26pTfLJyQecCGpSaHZZxOAp9aUTIOJBMs=", "FBk2Wtu5Hx99G7CqiktdEcetBXDMbPNji+nFoqJ1tJU=", "FnRCXy6fyqZusAH+ykjd1LKinobUUfANF26jW04C+4Q=", "KR+Vbe9ZuHgCgADO8D17VNzC/h3Vp13BgNbVvtiYzTA=", "LxMCiU/momtbwD+6ppxNlQEjlNeN5JRUnHBXt++WW8w=", "BifW1tlNChmhfbRcB5b3243hPSeKKyTJmsXZLQoaHOI=", "LuKXZiuv68sB345ivV9Q8DAlUVsQRl1Z86KU8L+7L8U=", "EYAplF33c/Uv71Qp2nZrkC7q59lnBi/dh5xgob+rp1s=", "MGBC0mL2JounietDI8IWknl1L/7GuFNsxotTvU3w6Fg=", "BHKhOsfanr4RMuBfnvYJE1yCoOvZJ43vKzT4znCa7ko=", "Lo92sntHQYDwDFpsLWWFC7+WAZvw1227R0OpcPQqEw8=", "HjOYQWX0fCBKM/7jH2E1RLfYRqfV6kUoDt5LNiwyqqQ=", "F/IuJyUr3PkacrWesnamZs5P6nrfussuqf3yhSS3tD0=", "AFR+fHDuTj+0pNOGyLqlXYI6DwK8ljtDA5uIR8/25sk=", "COpMy/gVvjJczRVJTzjz+XFTqwnFSoeoUrKplIByTiU=", "J3y0Xz5jJxhnO6BdSMcS/nQE357/VAHOvkXRlMZ/qNs=", "AVnsfqSarbOosKI8HboAI4B7DQmdPEC2nfhmqS3Iezc=", "DDNIkpfiRJVt5XnFwRKrQMf7LYmGaihBj2YKhu4YUk4=", "AbtPy64oovM5lWjGs4Sdon1t30/mrau1kRUWee030h8=", "KiM0PSSpz6O49BP1LuGyM85MHVub80sD28bXM9UjBck=", "Bwem1RWzutA6mwbWvgSN76hQE0qs0SDzj6kyZAFrd4Y=", "GDfbVAHdbsMLprhmGE2lbo20Of/QQVTsRptiEgzjXLQ=", "JEhyoNJ2a4VH5ralr+q/GY4UCaDwAm3jbBAXk5UvbPs=", "IE+xeSfOhzx2EZY5X32kb2ecozGDKln93SrjHoTrofU=", "BW9TA31djvx89qb+uhjRAr+Bi7unC4bdm3Y6EgcvTC4=", "HfS8XXMjn17DuJ761T35zYrY/KVDvgH19A/qKVIHG9Y=", "H/tsy7oAEVXUbhZ9H60cE78okqyHzZw0fHNKte9lg2c=", "CO426IFJZTmwq9ZH01PlG2P++R/JRIgABvLCbC7PKiQ=", "HDCAwlREMzKj5ig9W6tvf86KqmhIe57k43LLxswXJmU=", "LcYEBQDnMp91o876TbSfm0cIWxZg+Ic7PoG3sa+Cr1M=", "LIvKndKTu2fbH2b/LoIEeuk4XOZ9fzNWjNTCFqiZlLc=", "KhV7l4b5Ikz2Nkiq7BufYcenCH7W64qyDGxUadQBt98=", "Hg+wzdilRZHELnwmuQJ7d0F+TmUitHK/5h/4nDm8QOk=", "JQFE0c6gM/14vXPuTqTP3NakL3wA4tfuZ5TUZCB9Kz0=", "C2s/6aelJcpgRDxLeKjoMJV6rgQDEW0imDouaA7t/2U=", "L99hPmfRdlafR0O0lj+MU+Ukgvoy5wUkfrZQvHvWFuk=", "BI9ksUJ1+4b8VbPARpzYkwZ1KCfDwERjvlvqZvvXs4w=", "DyAnt4HCxSSQ4R7Ut7SU1mzcFuaQtqSzySTcnW6FSDI=", "KWUnhRYLJhwcIMdBUkomFHzDGR8zt06/F9RM4viLD5E=", "EXaQngKls3v9R4EPy+c6+H/qEwRwqkS99rBYxNNZ4Xk=", "GA8mxs4qOkd7rw2ljQaXacK/AVbWNvIlXhvDXAHpiZM=", "Kv7tzCzsVyha0i5zT7f+PdZfYmAcHKSISobHpqBfCD0=", "DdIah+4iYmmY281z3XUa/7SdR6AumVpBvKJjmRAwh9I=", "HSG6oJ1/UPAVn6igtuDWFEbRx9tdFWZGnaaoWqciSWI=", "LcWcTJ4nXNjCUGKCzFu4QsAUvqQjaxvCeoVjUbSK+AI=", "LPYtCFQd/wkZumiml/RPR5HELRRHpBUTq51fdV6x84o=", "L1uIU+LNLkep/t7qQEfkYIPJes1LaHrr0iZOeg6zVLE=", "BYZTKKmy/UaRcMORxbqNtcZu75k45NpbrjPycDxHBzA=", "KXYcn8PSxMwbEmvh3ARwqXuPJyXTJ8bRypI8KqgJKx4=", "HT+x+Nw8d8tRXDe8gQ06XjuWVS1Lu1f9sBwq7rHZoEg=", "BfL763yuCjXuLzpNKWTSQaDO60ez98TIe7OwUshwXZA=", "H0RQFKDyZggqUCVxUmCcwhkGIVT018EyiHRpVLl5mPg=", "LTWRfLHQymEe43z9kHjJJPyEvRpL/X2zzjngWzj2mLE=", "BaiaTrQDh7hRLy85i2Um7+dnFpUcUA/I2ryDV3UzXO0=", "BOJqo/AmARdPRs7RVZQynk9OW9XX1T1d9shjOpTdAd4=", "IE1YfWFSbB4Efh3GttQDueuHMPLi37e8c1DZObrFuQ8=", "IcjKIT0vRERq6Qpr2uWEO3wstT7WmfNmdeqCgKKkIOU=", "EwO9kh8y+kxOc68hRXxGttaeLmosOWcWIXeHtG6CLr8=", "BhOCPFtqvu8UOHRlMX5xO0Ws55wORDPXxNNSCX5cg5k=", "DyfFMF7pePT3deIT47oSqQH1EUTOHqibtQRpMPXsVdE=", "LK0RxpPGpidTGVCjB+B7MOqKSVEV9aU4iCd5ISDHvbA=", "FrslaIPETPNzZmGORsbbTj2pep1K59XFhZWd4ycvgrE=", "Ka/lC9ePcsx2NpWXZBAyS/1nFXpczbeuRbAAMuHVelE=", "CTKZAuWeUkOnJq5co1QIogcUhgmrNpgTlyWu/imusWc=", "BLGADmAMkOxHdrxq8XZMy9wQv1XDMU9CrNBTGtU0IP0=", "KY0BELuQ5MNeKTx6fazt737pNCpZG0Mw4nJ2qhO2etE=", "Ak6m5oyxqmtAfgImSaoy0bfqSjUOUQwH7uQ5KTleT4I=", "Iq46GoHEVQ9foBFuE10t8r2faDWg8NA/Tdk04TIKPY0=", "Hw9e7p6auyovSuBNb+CTEf4BFcHhmcKOInBeaBRC7Tc=", "AjyGYGYW8xevAiRk81C0vugML8oyBkvL+D6M012sBsc=", "KonE5bB0++Z9BMsD7+GMS/kEvsR1mzPa1rLIbr/SudU=", "BLD0jE8uBb2kuc+AYHX5wnXfLPYLX9EUcOqnOUqCcn4=", "Dt3losATJ60EKmhvRDQXvY8QfJnrfAKQDJMae9jLNJ4=", "LKysycnYsABNiTIID5N4tgZ1qL2FOq0dxQZy8TchLME=", "CBbzNQhiHy1WNxFWsKP3cxAw5LIY5EyQqIzsrwcXDew=", "LvjgpFXUcrSb/9qTXI077hrpJIYI4qUtU/S3YxPJeSA=", "FxhKivkZmrpgXdHy3RjrwC4wVc5AgGjsyq8+p8CjNK8=", "FjleFTk3qDZg2294RGy5lYNkNmAnd9gfBgcTC0SIFEg=", "DhdAiCI8OOlED8dzB9ZyCsMnhMnS9ZHiQ36uqbj14rs=", "GecPqTd4j3ohJ1c9VsgZe9DdCWFA85BkhlxlwxtH1AI=", "DkNMMp1SQq29qyR4BJX/lyML6zRLkY9vjWvX0hsDaS4=", "LIioLrh8gbpCohG/LvPBWHWsFXx/OGj/81r59VqMIrw=", "ER3CI+PJ/HRSqcLeRpODkV8zrfTPW0n9LgHFHQnM9DY=", "EGRzU94xl7nLSPRTm1B+RTk7AAhC6LqhIYrwl/hxuuo=", "DlPWQSHAqFHBs/B0I1ggNKvOaYUl0KR3JDVMBxUvcDs=", "KJGTisuD7hk3VJafSqWmKlMQgdvKTewiYljqkphLQ0g=", "BBBvleS6P7dNvkvFOrwXAmK6AMfGPtjEV8MidTLBLOM=", "KnPmG48bq/uzixhvQB7tDZLFYTuiXdL/TQmffdPBn+U=", "GOFrJGQvGRk7eYuSO43SX25IVtayG3Ka7SKBqxVPfF8=", "DV+EmxZqufb8GmRGfFVXAp81mi0PGUAwxN2HXhKuNIU=", "DiUlDFc2WinGOk8VMbiw71I+qpPB1wrNCqfNeETdBEI=", "D4E9FK8Mhbzt+/SAs9gLnzNYU8YBiFJtgHYSdAdKWZo=", "DSNWqS26rowkqM6+1kKAg+8vRpRg8Wam53Q3fngFVDU=", "H7bc60lb+Q//Vsiq1wtAv3c+oQA83Qkv13pDlh6dfcc=", "LApwzteZUadeI8WjI/1wbCq4fDgc/DwmkIFid0HCu+g=", "E9xrO9sFFn3OtLEQNwZKxf0i214inkxrpV6DgjIdxe4=", "IQ+ot3eQfsMLuI29fA5sqQBOs0JdSYAl2myQpHw1Alw=", "DFz6lXE5tFpy+7+ApBCqtUVKmCZouvJLDdPATk1ZnNk=", "Hx87xMIdYzQA/Pi9t75Zt/Zc7cBrsvyTqHO27xLg9Ss=", "GI8O6Vqd+wPNXj+zCCcFfpM3EWRO571XSQN0wNZ1MuE=", "CCOHfr+KhCt36ODztEhz6UCXJxAbGGyuK4DQz6cm7Iw=", "D+gWA945zPFIymOQ1vi9yTlcovP1CHgoPZjx8OYbGv8=", "LvYf4ZL1Kp186/QcE0CY8syuNcq8qhKWNWZ2j/G4NwY=", "DbbQdrLdG59NVtL2b6tNe/xqOP73+a4dTC+MRLFRD1E=", "KhlKSuhYPygYn5wBHRB7gvJ55qD4yovJywqlgYMcfQY=", "CuU5+pymfUr0j7KS+RiMnnLy7qri5QC35yAXGMjajek=", "I/ZqiUsd9NJqi6ptBbGs5RH6/9RgWzbP0Su0xtwrtNc=", "E3zvUirylCrumk+4AXvzMOZGAfRmtW0yJFZp2f5bpwc=", "GHqvy4eEGy351kwXZ3iaayIXZ+RjTw1VAGOgv5J4jDI=", "IyEudfS4mZKjZHA27jbXSTi7mphR4T17blLa9mxMvSU=", "D1TL6Wd3DfqdBosvxTq8lkibt9JmISZU0ybea5rxbWM=", "I9g6YLmIerQ1m4Vp/zohm7gTZ5Vf3nKmIALTzVEQH8w=", "LqZ2/n8h/Fg6sLDhiQINQssi8ERgfuFb+sfdZtpevnY=", "FvN/NXoMWEgho1arVqFtQfBFApy1FfWO3gAfBagHiQs=", "E5CTt4/JYDpCiK5YEe0TEb6RbkyX01pc8Y5LfkfROwM=", "Cqul/K0cBHAwyL8kb0FhC2jWC60oXMFfVZAPUneKEbo=", "FhGCeVbzQ1wfxn3T03lUolXqoBls3cXVphh/oKKDnvs=", "I9tWNi8kiRJCHl8IetFuDJ5tK7WdswpSgY5Blkt9gSY=", "LyFeZAIHqIsCmZyY8a+PoXMx0Z6j3h3s/o8uR4IkIJw=", "KyomGRfA/s8rzhkCH4UG43jp0+GvtFHp0WKz2T7thhI=", "L2YuTN/vX4IsuVbfdbF7RvF7CPkw9UurQySgNj4jOEs=", "CHDuqy57segsQmwqsdZf2iXUJnSaU4tOpmnqox9mGgA=", "FpQY3/yZ8u9dxrEBNxfBNECTSdhGRXmFclsVrGoVL6w=", "Ah08skDWQAM5rVvFNbT7tAkZzmuQFi5R7GiVp8q7Q3U=", "EuRcRsRbZgtq3cFJ5CFu62+xlHTIzOTXjjTDzBgCSvs=", "DHyGOUt61h2MNI0YVAPcdxUv0xC10FlwN1oRtavQNUg=", "MCTniyF/hdjv62AAj/cNM8PoTCONnCGgQSG0mKL7sTE=", "I1l3EBtWBxztMWPB7HGHkJo+12ebtUrUCBG6MY4a/IE=", "FL+IXmb3wB/ZdO/cC8LWKO15rW/GulEcWo7Dg+GnOnA=", "IjMlrn5zzwk+HViRqpLtQ/gmEPEoPyZfVlSLOAcvONM=", "I5pa4Tjc5qAZ9EVg73wZ0rgCXa3wQFWSJvVIcNMYpX4=", "AdzDURXZBX769GjXyKfUYEjgE1nJdIVbyZc48LJHZy4=", "E1mkABLFMyWHpN61YEpDbiacKCuiQMygptd7ND52u/M=", "Cp7jlxIiPUwMN8JqlvJnyF/I4xrK7gwHNU03mNxQA+c=", "EYEtHKNnGuaIqYdyM+617CmGj3zXxeEydTkahBZ+AjE=", "JDXNaZvJSYWUXYeJYHcPkpjUDA4otrWXkGngWQlS8Lg=", "K/AgeF5BF6HqWTDNU1UwO/mqsqHqDWaFOR9A7qsq8KA=", "LO9seFd8npenaFUpLKkuQmmsU+m3Q53/usLtpcZ1gCQ=", "CaMOAMnw9vJg8F8CnNqnx6/KUGpc5WLId7O41UMTVCk=", "H9hZKPjIBTybJkp08SG5C7+a6AY+DolnAWW5umaj580=", "JEgiednvpXhips1FJKoonmlQYG34zfj7yu1LZ0/a3pE=", "ECYKOc+w2CrYGCppUfnHgKRV/B3kjEF9bOayfzZGIYU=", "JSB4J6dgUtSJuyaYcw1cP8lxkqRCBXjSR0o3rn1+MUg=", "KONrY07L33uOT54aNH35XXcfFdl/LVxAHt9qbjdYdL0=", "Bz8N6m+D1EPuO6J8W38AZKt8wNNLq66Fn2v2bUah4WU=", "FMZhhWn3SP9lUUQ3rbz6l/h7mw0WkEjoTFU7qYiMRR4=", "DHZ1oEK6bMdPpYigsm/cTy0fEZoP5u8RG+ai1FtLvK0=", "A9+tfbPzLG7YEwxDz/YE2+HCnb/yUMaEyVXwnklfs0w=", "IBFCgfvjXBiBZPxtQUQgD8HZ7EM+/Gd0gL0s3LNbZOY=", "KeQvUhix6j+tBqSOIpLA/j3wiixKgjo75LmYlV2ooh0=", "E79AOUiNlLG2pn8lYpba62x8gPrScm1um+EeF8I1KBY=", "GEek42s+rOE95Y+kZiqfiMnBekZObb0gg8KTjCJ+4/o=", "CnogVse3k4Svn+PGgmgwFF9R9vjKXRo0Tilcp2Y62ic=", "GBJ4yqFb37WUDP8rwyFv8GpFli1Jed/A1slJk7t96G0=", "CopvT7ui7gmjbTkPuxSF+3ic8/n2QdrgEVIMjxDlekM=", "CPa0wNe9XkyH+8aHRSDjMpwGe2hB/IM6o3UUQ16YfOo=", "IgaywY8ykuepqRA5aDpV2BPdkUsMfVIyEEJP8PKBffc=", "AYbO9cBLOmwy2iZAWhbN01nfV76Okykay+uj9IcynPw=", "B1r/Z1cOoXx8eckRTHoQ1TPGCAttFaW+vRIE/c3ncvA=", "KwbYOJupYhw4adLoslrBXiyXOJyq9/l6NXAL5mwWVag=", "BPxtCmtndEQoFhy1IoqU58DpXe3oBLK0ehgFWs1zeus=", "JeSilbTnotxxOU1B7CqPSxJOWMI0RIoCiiw7xq0l5ps=", "AJTCSrAcbbWU/akHtjmns6VDAUOTQOiJtsqctsugZ7A=", "J1GCGm47IgbNa8PNXZjLrohQdF7Gy76kE+clTSpRRUk=", "FFquzCTjh425qNdxSbJBntW0LfAl7L0ajpfYuBeQS7k=", "DSqgDMblFn2EXuGHe3qgWbXlFRxX5MFj2jQD+alXVfI=", "JCM7aYYccMRJ69NuRCDd/DwkK2n/bj1MYJDCvQinZMI=", "LFX+GnUUfJyCb3Yvg21WRaxBhLoZJ91Wp23AVqmJVmc=", "GXebHLFqnHllQBZnSXi4tu4aeLZFed6T7S1nueSfCY4=", "GAdyG6YPuuR2/2ASDB9H7AvOaSz8ABAq5QvZN2xaIqE=", "HAII9auhJ1CAL73DvxLqyeAK2nCPFn1LFnvX1LA9dvE=", "CQtuKP9UHMOIaavi9dv7n76IjSECHynSvduRJ9PCc74=", "GT1sfnatlOtZogAQp5nHv5ao3ajJCIfWUhTIZl7NoBs=", "Cd3VvAsfjUxPGnoQLBuhLsfnVAzaKFpWTqfEdTr4qNE=", "MAod1f2hXRqc/iooeAGBcWhyHaL5cBOVSeFoEfVVvh8=", "FSCQjfLu+6B1u0HP4HQOHloe4YHOSSAW4VJwbkk89HA=", "Cz8hXVLoXsPGgmmOvLYigjOulRj5RQ9IBonnzzATeEY=", "BQmWoHr2dlxWqO4vc2ZQ3rSXK/zdsZSg7+sZVNqopNc=", "I6WTJtr1+U87UZLBjtBsxYzZYI5EE4aGOZ3E8e6Aet0=", "HSILmt0FkoZomM6DSxvcIAOXboFcDPfT9ri/lnrVZJY=", "GbScTaPZ46JtNlZnOGWJI0d8UE52o4qCsbEkcQT2geE=", "E53sxWewa0lb1vPPAGwFt+HyXVt6xVREXDfdKFvqrno=", "Glp9i8qNTwfUzW6bzQDACeMJnpmvMIDeu7IfkPjltCU=", "BiHjgR09y5WE0Ki+QeQx1YjJMnTIVJ5iX5j9FZg6gJ4=", "AqQcLSvPFGZKATCgIdqm79SjsMOt7ThjW/+X43he1r0=", "Ic+1S6cvwGeUlHzDvaM9gVNVQW4qrhkITYRHHu3KOZ0=", "BRFQk4lAiaICpM+NCuoynYPL4OznQRYPmXXPAbfIXcY=", "LkBUHKynZTISgnEpVZq0IqHAam9IyXQpFHDGX8Bw37Y=", "B+6t1zAoT1q2B3iQC2AwDSeXAAGqY+Ruu3+c2hFXYA4=", "DPM+SWTTUK3yBR+OLoRI0zJNJNP0hYQH9P1g0zM72Y0=", "KHxgSD4tsxPxor2pLB4cKLZe8Lmd9Kz7dXCe32o7/Lk=", "KJRA9Lf9uLKyJmHQdC6WlROcGh7O9Tw/694LX22btKU=", "KRvaLDf6yWKiRVWnq+s22Oi56yUiL5f0gX7y5bC8cgg=", "DhBUSViUEkBM2nuC8U1SdZT/mdBM6olNbswxURn0K3M=", "DmCX8K1BiscSOufrps1FIrf/qNyM9gofg2viPkHsJeU=", "Iv22dnJAF6+oqAacYtMHqk/1LBRFrUG5TD5AbjPg3vE=", "AgTVlK14Va0PaVB0KxnmDCxTOIF6q37nv2McOqkhYPE=", "C2pkPa0/lTh3EQUX97M2UYyPwR2Gi8cuds12w7L33Bs=", "BBiepsK9SwD6Y0mt3hcCfrfXY1OhC9B9CUJjlEfLQ9M=", "I7yESdiYp1JLLf3iYwNsrC4Uk1E0+MO69/HhPqLe7Dw=", "ABfvpgjZlBvGTTngslk7dCV226JX+rMj1MmcekIQehY=", "AvBhR16diIizh3+TCOd1ihb5Hjo0pYVvFa0Lny+S4rQ=", "HyV9TW8yd2dKBhMw1z1roTXafLDLoxhoaHL+HvbVLiU=", "GVNA9sH3tfYViIS9I3cVFJzqSI7b/YD8m5zGHDhIU6s=", "Jz4gAXnFxF2GCyaiCywIU8EAj5QkWdXNvtYz7eAxqh0=", "JL0OzqHh35evDylsDnktZ24sjgLoCKFYvb4BQxxeSkg=", "DG5vD3wggR9ARZnUWK9cbLQatnFZnWNQ3zjoIQS8aDU=", "He4TUkcCNc2OEptWEfqVNwa8CNWPaj7z2ANw2NGWg6I=", "G+DMMDQ6Fo/afHV6wMfl4Wr92/tyZYeAgHJaEvoSrUw=", "GkSav2RPaKZMIXxqBCojEQfKjZxhkghYDrdrvZIV2YQ=", "CAEX3eWPIopFn1nZDmS6vi2vR2qaLKAY+qPF/sqsF4k=", "JKuaFnthhV4PLGC/8JjV630VFm+rUfK2LICd4xjW0XY=", "K1asqdWVRgUDNjKSvM3IDoIyAfcbVL2mhMk+sIk3hPY=", "BXNh7CPIezAID/HN80Z9V8laEq+/xIq14eTeAWKkG1o=", "G67Rdxd6Jey7+vTyBNmSHq3jaJuhN4zZNizBQUUIn5U=", "AMzbbV9JE9dlaInDEpdf2+DgMJqEGEn9gI119ZOnFIE=", "LFL14e9X3l3eUoRxzB8O54OZKd+Y7nQ9nv+WJRVWGRA=", "AjSkoy92fy4cpI2tOi/dP/VLLKPVPOE/yQUkFK1/dVU=", "GCtMDFUasM4ZkLRyJ495S6nMYqvMkKie/dgHdlWONDM=", "ABqyu9vQQ9LX0aTrdttN5x/d8Z7fENfNuVUOGEblP9U=", "IG5s0eMVTBE6dipijiSUCQe0HpDnwtQ6olbqUkmXg1g=", "J4Fsq0vsGFd70zW9r4KYeYomG7F1E3F31GupXdA9yLs=", "FoC2MqBL4+se1k71iUQLP5Umsq2CzwuIOdPnsPWFvIw=", "GWsswObgdijfgjT1jAJ8GQx1sDQlEe/qTDckxP7dbnU=", "KasLYGXrvvxoRgisxr87X8aTdww4v5G0vjj+b3JkdIY=", "IkzoFNOcOC2i1l7M2d60gFbt4Yxe/LjiVRW3J+VAqFk=", "GV4cso84qctXsscZtQT1/dHUJVm2o2gmT9D7/vpmVZ8=", "Dp5etw9EkLptvRwO4dZyTM3Vis3xOHhc6Y7jhI/7eEA=", "GZXJyOUgAU5EEuxlODnXgVSM9x9G++tRkZWCImy9WyE=", "CIYJXMN2yH+mUwACg6bq4RAImC8nEEr+4Zj8N38m4yQ=", "E3YeIGs+ibI94jQr/Khg+bDZo21IaqEVVl+fUjacEk0=", "IqjGz8DjilAKR1FcUZrWpyUG7A1QjeJZQsEPUfDfq4E=", "GJhenH6m8aFpYuTifPGqSqMIaTixP47pRlpex7697gM=", "IVtSPOPwVckusUjAACfRrUBqKr1kCBBD4NFUkoRbMaQ=", "AQL3jHUTsJO4hXJrffLnApiAGz5AGc3UIjnXZEhYjDE=", "C86IYC/ToPCriIWJGtRARQWPms4R/avSTo36GwpK5yc=", "B0X3YPjUZvwhBD4ikubLsgtiJ1F/UgAlESnFSB9S+ks=", "BAbeOAdEXG08vfexdMQQqZihUw/MqZFTWiomLeTi7lY=", "Jneec0Y0kGjbumb3hPh+JDzCfKtZ6If37XoBF4h9Gs0=", "JRUGUqCK+MpXTHxcd//Zixclmh2RSm6kHbdQFCZ5Sdg=", "ALuNE0OAQPZ0p57UIgLFv25n3m/D9rZcqDfOq3lfzG8=", "DB6/QO6qw9Shkt1Q7iXABn9m7/YinQRdWoAQZ2Oczyw=", "GjlzHrMv21HdeTdU92EDtcq4aUeq0S1JDUlRky/yByc=", "K6rT1BsYrhDEY68WYuyyjGmIUk7d7TaUNnKg6Fe5YPg=", "LneNoVGLak+tLoM+QUZvsv6C9PjfG1whjN07fkmvZ+E=", "FW3HF5MNZJAWd0ORHpv01GNK4Em1OtqygWmGRfixbcY=", "EX8u8XEmkqudvcUdtJaLRfXgEE+eUoEyk0nZCLI+Ixw=", "CygbXZ3SyhqS4tg7UIe2oI1qsIMw9HUSqgR7L4i6aMw=", "HCgDdm3ZCWVnozZgYXZPjJFvKi3WQLbuwJQsy3XUB2c=", "EgF01TulfRoUG/QOTHBWg2aL1VgAAAqrbzR2a3tldaI=", "DDeyUCD4x26lU23lTHIuR9AXldMbXtc0ZufYuK03bUY=", "ClCPNFzJqLDDC6J2UbocOtg5gCWkAApcJQAijET6kbg=", "Eq+kn/TYtMbDcvfgZYQHg8uUl+6syEejQPYfGCPLKo0=", "Kfw3617HzQBICVFreqPHFvT39ud3L0Q+BzCwHdUHGlU=", "IEj7nB/aztD9xRWUkNspd+V9vL/3UUrR5SonG/hN0ag=", "AKbEIjqr5YPombvNAxSkdDGB8dXgPbwRyKTQJVD6tk8=", "FfRiq1shwxVX4l2cItjcagzKk8jtaKNWVc/3RWhnZNA=", "J7wcmvaO3443MBlxJL5VnxRy5+O7oNNeB5stG55Cce8=", "Gi7BSPkA7q44wNPW79pk4UaSnHHrgtoxOaOoWWjsbrw=", "BP9By1U8phbQYWVFki8gMLcbI1S80cVdfqvK6okEwi4=", "LyxOexioRfzWrdZwCfwjexSphGGSYKez04cS4DoISbc=", "IpJcYGofCRwdXHEi+OGo/+pqFAAxEGgmrFOpxp2EwKs=", "EOKox7Er9wJmwldXPKJZTYgRYz93gi18IysynFtOcnk=", "FxIxlZWuRkmSUkv45Ii3g/pFs1SM0/Fi1Ya84x7HGEw=", "LpYWmH0zMziOpaHLVrTBYfJ5/xlFSmSt5D2u1NzaXAs=", "LGghDXVmDfXZqDkqKAXqFhL8YTfPWzWmj8HwOs+/5Mo=", "BTzzcHKD34cwtuH2N9I8Z7CzUzBho1vLDLD5u+TorcI=", "B1d0kUg9A9d2nazHlge5iXCBwAld7Nzj0ifAWd3t22Y=", "BWObIyTAsK+BxbJWymstRrler4Vfwmztv5BBExLeShI=", "DskJROuPw2xS8/0TdjcU9BzqH/SH6jnXC9lOm3+PFtU=", "HpbNOsNFuy5b0+dVki+Er68wPW+yJ/xo9wO5NmX16pY=", "BAhCVAXGa6p9SYWObVhx5bQv/rsN+IWoJJQtoeLjbVg=", "KE13VmtC85E9QeuwUouJlCbggFqtuZV6U0sCKwgaqXc=", "CwROWYSIfNozf1jHylCngSbetWJPZEUWI5QnlI19Brw=", "BIaXIXnuNJZ5W97RwvyWdMDD9xtYFQycUlBjpvKzQNg=", "JbdWgxbEsv75tyVDtgM7MXp7/kBmI+R8to5ceSlua+4=", "DOyedMNEGYcDzv8opNESdfbFwVc4qlpUoZJpJh7GqKg=", "K8w0qZNFF0yXpl6JeBlEhqmVfJ1zbwyjm5gTCAHRoRQ=", "LdsuvArJj2SYwPK+LXPoanhpQKHoxVjY2+2Nb0SwJVE=", "JkK0ogjlA+NIBxjU0gU1H0PaGD7ShO16OF73zcqAvqg=", "I/q9sJtIG8dkECroXM8eb/ccd2L4utBKLeP3oCXLUIc=", "CuTtDqatt0udMn+80B2/N/X2xGdIDIql9JUSTPcLgj4=", "CQNOGmRtZnS+8EGvp3TjY0+vitzHxxvC7W4DsLRJIBY=", "KBfqILRxpL8Tjex52E+fbAAV4MoUe2UGg99LM3K1XvI=", "Lft/gUJcLe9r+k6DPlHpEimDl954/Sqhf20d0vE3nKk=", "E3tb23RlI8BR1oC+CNqmsNVMn/cJnyv1zolMJKjvHzc=", "A5AOx63I4or3BGgz260/oQJOOCrr4CvLU1JD3cohqoU=", "KyhbbCOyXFLyB5hjx1nmoQwz348ZFVHq1T6lCFEctVU=", "EkIGe+IgLRssMrecRk4tbJd+b9EtizUoHoTDdYZGE9g=", "HoaQ9bCocpuVNu8pIKvn5vPu6AUjexWNmX22OxdSXu8=", "BH9RE+Eoe1VyyC7bNp+w9xepHyYe+dgXZKWyea2cE7o=", "LYgA8hzWd01aaqWK4s0yWTWT0XO2hxIqTWHER0OQIQU=", "J0uhUh1bxcWAZH8Q0aTEyt7vCIaF0ZdpebrYE3VvhLA=", "F4lbfBDWpHUxDTSgc3767d3Kjx7unY1W5/5JNMi1ZEE=", "Bu7RGun3DfXO0JsabbJYl4z1vsrS9m0Vdhv2Hn3BNEA=", "MDa1IcYxzl01meN/al2vkohCzvy80sa/hOLbXe10jwk=", "H1LW6awol2xab78WjIGEeGRckNcuNnYJ19eAWmNnSC0=", "Kg5gNWh11qzhBVkys92e85w92HEJHpajI8FZbO2zXms=", "AgiWM6YZTz7Tju7CyPVNDH9DSTj967nA4YMNvlMRw48=", "F4xz0naXZdhTgyg/2w12lFfP7wYSuqljM2usEkC2BMI=", "L8ILyrqePZbrzdcQ47NBg31dDbhJ54nyjEvlAEr6GaA=", "FRpCO+5n+xTVrSefQlIT234PIUlJgt+HI1TAHw9Kciw=", "JdYWGeE1aQxOEOSv609VeK0PjiXCBzU2aJWzHuvN9H4=", "Fd1Xm70HVCkwHXKV0+aF2DK/nzbFEnfQnyw6ZksEXNc=", "I2+im4FnjIoQn9NhwcqQrfRCPBPPW4zBAytyg7zJWbE=", "KoDLrJuITiA2hpG/FWfLcyBTepd9oQ5TxbrqNEbAHR0=", "EdTLiVeTezYoo7P00n8nbMDBebDCKywT//vehf2RI3g=", "Eom/jsUHv3UqB8m3HvwPgApS++sWN8UBD6VOratAKUY=", "JvhCsamTlCl9JXmfLwPcnkkD530t3APsL7FVRm2m8wM=", "FZRLmVS2GCMU6Hj6L54JHcxA6txI0305vdXwmQXDo2k=", "B0IWbc2OvYV2pr/g8f7RN5OSj4RELHRloAEvWEQm+t8=", "CGA9Wg6Te1NTtWsFdo/VC955LnL9YcBjRMvXNXB7aP8=", "DKoXEcZukwG28l4hoxaD2Av1jYYDLQO/0luXd+23SnU=", "LWUG2mldIIff+HtfY27mdvqwDDKuRcdbPbNF8/50oxE=", "DZJEsHr5turv9vhAScsuAdddxMtoUzYG6Xa4swB1jIQ=", "JDq8PDOC+qXd4/HDtDIELT8DDvah9UAao3rNFcscjEY=", "FoQW4KbSddMO2jmJJC4HIwJHJ9OweRsG+OG/6O/kAZg=", "G83u8DaT0a0OqAxlaIZUr/5jSqFMsRrjpJFoHZxfjus=", "AvZr/aPSob3tsKuL9+scTlUb71jZT61/fCMRB+VlOQk=", "AZ9oAhcauCpZIvAj/ezAl+uKwf0KHtNJr+mnuUKYl1o=", "GVocc4OY/u2MdgRooFVsIyZFod2GLYfB9QjJSa1Sw64=", "CjajpG5uwWVn364fhT82Dm8kkkgQ6DjLJO0bD8438eM=", "ACEjwp6of36ns1wl+ejdPoG7w5dMPBfGB82EDAnzdK4=", "AqcXSZy2wx9x8PA1Kw9b/vMAW4DpOlILbkKzmFeJ4tM=", "D8BTWEsKRgeiKT4YuqMJxS/ckz6bqQ/TJ6qoyM/E2qE=", "ExDRlCEpc3sy6HqG9FcwMrG5muPG1xuv73tJR5SFVUE=", "G/ra5T/IKQD1dhxVj+5eEhjmsqZlfnS1QJae60nguN4=", "KMCKaeXzZBRg/yxgt1eTlWUMW2r7OS2hQtMt6Gd1Vuo=", "IjIi7kK2ypl/RNZD7Wo/KwQPR/6M2SIWPZ2diyYi2Qk=", "Bk2tR1LnCP8puwhC0sRSpxRItDlJNFaQAxyxJViIdqA=", "LV3cIXlwQ5lrItyruaG6bIK3HpobxZGduL79NUEQVqU=", "JjFfzZteGiZuyOn2YA9abgvNsi+SbWFZHoP6IQacDgs=", "B1knOkF3/N6rI9o4tHj68tTyLoLzRqp1SwoTMbyDce4=", "CeEzAOrecFaPoKhA6pcpiW3dhMNk1iedNKC50UePzyo=", "E+l+08FvrWy1t7uVTyePJDSyL4zAVEY6FFy+AkDU+Lw=", "Bc00htylj06yIbwsvtuKowJ83ldllxux9hwnLFqlGtA=", "AFzlI/a8Idrx30aLEv0+hmXhwWl4FqmmcaOythScfeQ=", "IQMGbMXfVeZ815FAKBRftx8InWccg8W1N6vqSCstjLs=", "A5+Ad72bcfkcoFAurMwWcsU59yMpMXqvgXPS7ddjaSg=", "Ike8DMQ3NwW4lnKiIFNG5q86ZCLoG09Ihdw698rcxcU=", "J7zHaL0xudAGh6flPDzlPEJnYnBhiHkOogsugZY434A=", "DZHO9Rp296YsUcc6KAlzLXmsNQFZgU6lNkhzaM/f1wg=", "IKns3GSaJjiNxo3AI0Og8We61G1qoc0AhTf2J7oUBzA=", "IxNBSaDUVnxt/JEdXLgMGhAWIg054MIwMl2uKUH1KLs=", "KgdQfp8DCkLG8pzPHJzE8+WlsNvwWHTV7a3AP+dLlHQ=", "G99mux1X/XiOVO8p8G81/bJym3GM6BFSzzqvxklmEQs=", "J1wz0H+eczjd9QeDvxWNUb5hm/d6EgIM9WMLeOfg0Lk=", "FkEVVOVf5gSh/xs7W3r7aiv9DzLEBwtVvxrSNOiygRY=", "Bz5qx+avInVXJJyhpcVSIqNsZBvChRoN/Ptggx9nWag=", "EKb96IxfYh10hUPHaiGPlcICu8O6ygaDjzEzGwVW4S8=", "KcWGWiZYjKiogSigcshDTMl6G87CPhNvA40p3PlrDrY=", "Iz4O9q0TLtIRsZEc3VaVdv6owXymTk1d1Rb8ygchLBo=", "CW+bkrnPLH1mRAiimGA2X1tq3CONh4pHa97T5NLguEA=", "L8eI/oqtTCi5Q7tXy5Dt9tex8eg13h+/MZLjldt4VVQ=", "G6wO1gkjMUhQN5X8XhFAdu98nXIrxkjdAzjZaJ9uAjo=", "ABw1JoqgMNbNFI4Qbj/CMJTlYVc9jHKmn8ODZD4q3II=", "K7H4/l2ZjQuLkoN/+ye/56Oc45/5T8Fn3cyVpyAuNLI=", "GphXZFCkPl5wW5r2jNDBRUItojlFYwsQuOgh3WH5orI=", "JxTTfuUG77wrqZQQQ/sj8Wr5ZvEj1lPzg4i8vdUOYDc=", "F10EgLoUq/C8uAdaA/SioB/37XVBORe1PlDqAMwqStA=", "ID3kWgN7de9jdhdQ3OCNor53CXAeyBWMF/wCb9CE1UE=", "Jlqr/Hi3DKmFwykIDWMpoSVg92sBzD1DGnKDAiGTq/g=", "E1Ro3763Dowu2v+shlimwisq0VIKwIGcEnry6l86h6g=", "IWpB4kMp3tplqKggAchM6ChsYXWER/8b+p2Sk7ZxH90=", "KIftSXl71mUr7Yu5muNFrXDRonzbIblGC7b9DU/kguY=", "A+K/gmkMgEu27jx52r0YkupTqYEeJCShn65Ea4rknK0=", "Dm3OG75unkZcvhTcxhVhGGdBRnbdiozplGZJscToERY="],
      M: [["Kr2eFre0gomqGc3+xyb6P6FcwWJRAq5RG8pF850zfp0=", "G0vFiF0c/I62kYdTANtaDHNirjgYmKyvi2PK0E7LNsY=", "CKcvu1Xd4+k8WBhXGkJKVJU2lQKe7bz5Hq6wEnUcf4M=", "D5U1mh9oRdSSGJL4PlALuxs9N2PY/HYkAK8Dmwq7g/U=", "FvAXUc6YUyiv3jTYFhne+0Pmx7Xa31LQ+CRy+853cNk=", "HDkWJjKEV/yvpinz5tM+JVXo2IXjwHzsyK8fTVZZZBc=", "AJcPZxubo14+PGQtHguAMgI+1brJHCwQVvA5ZaQsUpc="], ["H+n+tcf3x6Qmv/AyzWoxWCeLbGssxXqHEhP8r9ZCeYk=", "DMfquxVKp5VerEehn2Q3orjewP6eVoYVD/boixp7S8Q=", "A5Pv2WOZqgcm75r3m+i2xxXkKZBsoNFQdrWpkP6nWs4=", "CHEjODW3UuoDDPik9DdxKW7rM/aX0bCCXbR9OayeWVU=", "GgJ5jwR6Ubquo0/Psmymr+lqX60dLbQnBJe25lBIkcs=", "BVZl123zzQ/LcTwjTqedBqMdbj5MO8xlfbpMZk1aDaA=", "Ju6WkaY47cfJGIfjAvxV6Od1goakSEWtiP1947sQUsE="], ["AM2y255PnXMtIXxeMRSCEWXUnlotQVVrzVPQxNQzIkw=", "AS87spyXJ5MYISP1xJMG4Wo6eHxLzZx5ihMbcIVtHL4=", "C7qQBkBMXt6CtSdnfa9ETtQ/0eDb3FUo3SzR8XrXNIE=", "F+TnO/cB+I0hms8cpjkMweF8n4SxcTggg3ygcL6Eotw=", "I0uKB371K1OjQ7jaWyDMNYrWB2DdYCdtSFAV9z1T0gc=", "LcP9dzlLe1rBy9G0bm3tW4NdchekxQpIeumjWn/UXZ0=", "FmhHdkD6sUxyscFv8BkuSM+ILxIna9Evl/gsbuLmHkg="], ["CWZCFspWXBpE/CuYNH6os2kEs4d/IVncyZmJWt601ws=", "ER/Y384r07e6DPqT4g+2hav3bXcwWFe43zCRTkhJ7O8=", "GfU8ClkrPqk0l6UR5W9mdTWYJlsatndNpI7sBOTZNCY=", "GbaDw507AC/DUjt77lpgFIsdvfGN0cMY5qVB6M9moXQ=", "JUcROoGHefE+NEhxnH7xALgDa7Pogt1eZFbDUxHBvVs=", "AM8Uj4BFzb57sQE/cuvUEmo+NcupqXBEG6jVvHaUOws=", "MAhCHu12egkzIqCcNzOXOgOBaMsozS4fcJB2wAuGlZk="], ["FGP1HUpMseuhbbwRVWaqSP53tDwkTJmIo8ZY0vVkk9Y=", "Fq/Y9MOQOLgAalnSkq6oRzHA+DgyphuCJQ7ZARjo/sI=", "IpY2HzvxVO+6uZaSGTbpsd/4NScR+VhjgXIFUzPgdXk=", "HDFg666xD4CfaYQ8+NW7rKGY0fjjQ5vim+uS2QnsiRw=", "CUxmvc/1Q4LNkhOr5DMS7bW01BTG4JrMokkSp2NUBMY=", "Log71AjEyCbQBP93fXwJOENKtbuE80IOXZS4U7F0b4k=", "Ior21CXpGng90Y/Ymms4vaBT8vI8CUuHXyfLOruiAws="], ["IU5BeIvSuZA0fH8qj0dhLU386xoebaOBZYc99mzlH1k=", "A/uoLT94NiCHPalOn06EyLUp129U5LXX1IBScq+bl3U=", "BmeC/j6GneLOvX679g+0NXhTKd+xKtm9G05G7TYolRE=", "HFzWsj7zNr4B76N6J+a3quXRZD/O6yEs3/UViINftTc=", "LztL8PEF+I4nJIrwlOKf7tn/P62aeU4VgwvSsxFTlFM=", "L0CF6qn4Cmm3Ofwj8v5AV/ZHKbMReD/PqzoKNvwf9DI=", "I2NgM0npT1IPofmP4lB/aq42GTQHiqWaFiFMCIGFY4s="], ["BUhUFyT2TiASgmCJmr6PvN/xhKGVepOF+3FZI78Px50=", "IcXiWmmRNk5ZogXlsByBHe6wlWgKcpKDac/S3nGxT5g=", "EcXMU/YzjIJYF6/3eSou+86P/xcTANQUVaLtrDdmPQI=", "J6CUn9yfEElcTuchSqDt0q2O72j1d9qLlvnYejlQS/k=", "HH/Gjz+95KI8RV7w0NvODOVWoBlObVUsBFXLtbDCMOI=", "EdD1b8AOfYWzopOf0zmR3Iq8HO0MPzxTDL+0UA1j3pw=", "AbLp0g2bVd6wSMq+Fjbw6WNjvsiGZ5y9kfMy+yut5E8="]]
    };
    exports2.default = _default;
  }
});

// node_modules/@selfxyz/common/node_modules/poseidon-lite/poseidon6.js
var require_poseidon6 = __commonJS({
  "node_modules/@selfxyz/common/node_modules/poseidon-lite/poseidon6.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.poseidon6 = poseidon62;
    var _poseidon = _interopRequireDefault(require_poseidon());
    var _unstringify = _interopRequireDefault(require_unstringify());
    var _ = _interopRequireDefault(require__6());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var c = (0, _unstringify.default)(_.default);
    function poseidon62(inputs) {
      return (0, _poseidon.default)(inputs, c);
    }
  }
});

// node_modules/@selfxyz/common/node_modules/poseidon-lite/constants/7.js
var require__7 = __commonJS({
  "node_modules/@selfxyz/common/node_modules/poseidon-lite/constants/7.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _default = {
      C: ["EjmS3zudqmUTnsE/u1L300jhNDM2hMFZb+sOjYw61ZY=", "L6RvXbqZCc6ZhKAeKvMLVQ3+yXi+krSRGaOVnH9iNwM=", "Idj5TTvZjwtjp6rLF1ssyhOy3YqM9o/DbZSuKUAbLSw=", "GowGxhBG4Pjcajm8V66g0H/X2zTmj3NXnaieEWr4frg=", "KYzXBG9YwMq3dSOlim/f0UAbieeuXu9JlEQtFn960dM=", "DqxzeWZxXfSiCzGraT7ahqB/PoMPykdaZXTWf8Xxn2M=", "Brm3GLs7bUXgy+bV2aLwlqd76wVoIXUNByJirypwoz4=", "C8za1uix/fuoRqlVP8eQWz+W5DXWU+7DlyVl4fu8MCo=", "Gz/0pryEkJk6u3oAI5PNHBwAf0kkD/wq4fEFfPzYx60=", "AX8MlFLXDuzfXMi2sLIF7C2h3ll1DW0XCXUYMbfkziY=", "DPGrgFvEehA0mudxNeqVpBRKbtBxj97tQpccFgeRsmk=", "GNysrGExivZEqw8uYe9IwpqK7PoCgun8MltcAocQPOA=", "FvuzvfQGbisvBQuJtoXUCHEWhdt+RjjeyQqxzHlDUP4=", "Du/QuGF6Hs13Ef/V9sTNBJZIehsRRunz1TJ1rxj8bG8=", "A8cH0YNQZvow5ylaCXpv9GO4W3eMoR2b0piNQbYAquI=", "BjrT9uP4RD4JCK+ZzjLSwJYG6EquXjrTDtYNemYHOMs=", "LPZ8yc06UxPZkuMVAQ2Qy1AfeQu+NaFmOSpR2Q0Rc1M=", "Km56e/fBkNTk9/JY2JDdQXgOKPa3Hok3FvcBQPRAazQ=", "JhQEIACbbYxzFHI+ZpJbrc+YRA2mwrl7ZqUrmMvfHUE=", "ISxhEUnQV7L/78mTirFJjTsmU5LHNIC5ywInaQbkRbo=", "CJGKtobBoWClXbEgELIBUPgmMt1ZM+J80BEpUYzZ6VI=", "Fz73dndJoySbAE6seqfpTasg1GXGXr9Lq0IvdD8X2LA=", "BJ2Q+1SeDiV5D1plcHVcaME8l7GNZ7uRmdx2U1X8sf4=", "DRqnz+bKngSKxs4s2kDG1kr7uMFafNngIiVm+ZIqFUc=", "LYLizNi9Y7K6RLwPTLXsiBQqRAis8drUUqZughn2Z8k=", "Krc6hC4Lv+Ip6hFUv4rrSM8vwom5OUcda0ZbcgLrI1Q=", "Iz82uyBd1Z0EUxAGRAjG6vcQFzoRj57SEVPJmmsHg/w=", "GMFKUFlbjfMhJL9X+LjfQwRJ81mGJCov95pkT1EM7yc=", "GGUI1rdceQLtahlI+RCIx83flz2M/NtOWlsMrGtbItA=", "EL9CmQEEw5sn7wukUbUQy7AB+Ow5oxPSWb5DCdZCm9I=", "Fj6HX9ngSyVZcQcsDS52FO4fPH0rk3maoVcL9zFT86w=", "KSWln4LBRyuBIJiOOvbPJMLr7JqfD4MLtcgmBhxl64w=", "Jcr5/2VD3MNOLQuMKvOzbr7z1MP+YuKTfOWQo43y2hs=", "FMxBf9Z0CDCQ9EY/ZhgOSj84yluof0iJ5RCtqST2t5k=", "GCVQrtf7O32S7wuR9JFqx/fbO5QxA657ouCewPSghRc=", "IWMFhSRnR1qfk007ETKplkL7eftruR2UjzkayeHD8cg=", "BCO3cfchVxbPl7OnLM/+FWu5+Al8d6K23Ge7WEhom40=", "IkfNWvi1zgqYOu3pSfgdx9P8Wiy7640WrUP6LDqIJTc=", "BJkM5JEj7R7Kkt97yisnHQe6SuWjDGoBGfd7UcNkPS8=", "Bk6LspzAcq9yevG3mvUIlqZUjexBusEPAxn778G/750=", "Bfm+gzUaA39XT9D1TU6a5crbkwzrUckbB4lPAWD4+kI=", "ICzhfpbLJOiYbNCTUauVdtWlFnFo+dXzh3xMXOA2KbY=", "CYovtcsBhozeZCTEIRuVSbj1UKfwPn/Ni1EhUWs/RS0=", "LL2UflMs2g+PG4mf+83V4LawhFHmN/5T87So6ngyqic=", "Dg+kYgz8lD2oG0C2tC+G/nTlWQD4AGRbpmE3trfHKKA=", "LhyggcltWr8sxAs3l8OLCuio71125tA+m7BnQcIYQSM=", "Jxzz6nsGtOdDWFrmiZfAFDVC5AXHCFV4cYEWPkrCC0U=", "Cd6hJ5ctIQnK236Wq7p1d8CsAHcxK5VQ+Bt3FqkvXqs=", "GYLMcW2iCxGVJcZKP+hfXjG6qXx2yCN2mZY32O8cigc=", "ImYA3ou2Wzjs+Zbluyb9YojGkPFqXu23MNk5MR0MP/E=", "Ag97d/u8rZmOd0TKJ8D3wMJVCj25D+KJROc9AdJK5ss=", "HC5EXPyYY3quvCwat7bXkOusUCcHHRBXqUW8kEN8ScI=", "JEs0lQLfSjNWOzAjfudQ55veE18LCJbw2c3gTxAEFx4=", "EIYKh12AvXHGJnwdVLAvtYyJCxz/w1+nB/5qlJQSgc0=", "Luxa3ezE4kZQ276lMaD+8NwyfcaU8imyUm0vMLLEmcE=", "GIu3FQtuQGJLAuooIa62tSsehbW3JLwOxRL4+mQRgso=", "BeVgB9q94syD1Jg3HpmtqVPs1p4TXvAgTS07bMH0mqE=", "JVN1WzbeYR7VV3aLtVE3MUdKCozcbbqPBPMDGwdoexY=", "HPJn3Zv7bmeKgsd0WFemPitXBmqGJrUsD9X/QkGKpl0=", "EGsqQAhzdeopiLjgcA/dcdNxavK/0Lawym4kq0tMJeE=", "C5eOShDbzcvH6QquLKGWFd9nSBnLYR2TtMv18v+aChY=", "LtaP+6amRuUEdma4rWn2yzWtCW1tNP4cpn5TK1GGu/Q=", "I8Yywv5o1PCnGx7mOVHHK300l5fwcFPfLtM1IOo+lM0=", "J/2l+CbOaoNA0SpYTUuchPCk6jydM+ro1sDiOlqYl+M=", "LSSqTAdyJW6QNE0g1G3727Xp3BMqT7B/r47dqjDadnQ=", "BI1SxOPXFIXOavEi6hNuYAU+OH13Np7t+Nm7xmP7mPc=", "DgwfAFoXWd0WEwL9sjPLrF/hUbXCGSJVvXV7PO2Jn5I=", "Iw1kHEVS5eVUFuNg6qMpAHUd5cpT6GVK+NQi7sYn77I=", "Av9vqDZKjPsZ4wvofUze7Z+VfdAk+BONU1xjgKi104o=", "FomgR2KlqxOI9qclfnxyg4UTxX2n9UaiAX/xKK/hYXE=", "KI2McyUgQlDoYy9C3r7ooxpHAxKrL9AK+8dpT5W4J80=", "I5lhNa+fOkKm2zP9VTGafK7Y2i5uM4Bo149UCFUsg8E=", "FdBS2tzhRQb8zSaQwzP47Kw4LStnNHJiNs+ce+J4u+Q=", "FJT7ZeWZPZbDC/C84/Vtzmii3lIpm0gJzBGeN9jgQuY=", "C4AO+HSfkbMHlHxYEJXskoPDsTG+WtW9pCAJkvv/BTw=", "C6wfU9Wn05gRuufBp53Jl/3V8ScPcoBfsF9cUtd8HLA=", "F5JJiT+obuBntHu+gzW4lCvJIa4OCCwwPjK4Cdk5eG4=", "CYWnybQoBdkQqJ4tyVY+fjRJ/VtAH/TV6sddzn/LQg0=", "LBkFtfAMknpXoVTEdEJ+MfPKq4GYHWIft/6lJczam/4=", "CyNQLOBMD0yzDAvbbE8qT4HC7yI5NvB+9XhW8Km7T3A=", "LcBRwbz2NyM+p8Xghq7X3N61G3o1JYIL3W62XleFGbo=", "Jz2KQWbcP1Ox/yTGHxo7MAeigrUmxyOe7IHpL1HHQa4=", "JXmIvn3CV6DF3XB4ty9pLHVfAbo8jlfYLZuWlWXb8Po=", "IT0P5aPnYI+mAvW1rVuCYGVERevXJJKjKtOZHzpaYhg=", "B6OD56IhvHb7FDcNSz7ujeUCYBpeTVSzNwxMUCsJeoo=", "GM57PmR86aOpDQ7ZqlfrmoldWWpUlYzJcC2NohliPoE=", "EjIO4Q78H4EY0+ppdXTq4t+vjynBg6vRIzkuPCgpkAo=", "CT0OEwTGYP3a/bSClZKPtqgxFIJ1ZsvN4m70yHyfqJ4=", "KTG5KV2W5blzZLN9rv2n3L89yfSKszZNqdxqcjTXFMY=", "H1M6HktIeML8LpcG5UHShIHOQ7FifQukZZaQbPMoFiQ=", "JRfLck0S7m6/p7Sw0lzwMVRm6Y2MrD/7+xobze4M8GQ=", "AOQ9yYO8j+vqrUATBESrf5GHGFYkFJp/J0SS2b2Dieo=", "GGvAmn/8Tt0pFXmHa3fC/T7tCxuD8h3fuJkDnOt383k=", "BdIqL0j2RljhgbiuXnLhqUJ5avK/5u90rJq/U6xl7rQ=", "HwBujSRjY2vKeH92X9ascjrSwuRmrmMk9dOfPu5Y8M0=", "KJE9Qr32gEeP/Rc3Tolf53mdnRABlvbMww3Ajzmkefc=", "EbVXyNfpe9ma5fSegjMIvW4iaUIl1AKd/c2DbLfArXs=", "B0S1OSbhoO85W7BJCLEzJq4YZqaJg8Qd5W+3zH3M4pc=", "K/svJFanCYmxZftqPub5RNKDYpNcq+UWEUmA8UFCKgM=", "MCcEeUTsgs72JA0WNwcMYixdKKdDAt4O/W1K3dTcLbI=", "HtC15LKa6wtbPrEozwMXWcs7xHzBKGZXzf6IxcQR1KI=", "JjR57nfkTosquVPoLvY6fkr/SPDnMPR4KyJcsid3EE8=", "GZBMhOVeGvMUfNt/OkKCZeIMG7zL7Cpci5UEF8ou5HE=", "L6hGj+oyBO0qk0oe73x4WAqNowxexZIvrImrkq2Bo6Q=", "JnwLSxlmLPCbhw4F90QeBC5bli9z39eNIzhNx+pxr6U=", "LxUEZ1BBdVQJlG6MX1Qy01hJunvqDRJRJUeuaEuDrC0=", "IEGZ1kmC9XQyf/P0AHBeClOyXVmukc4LnTH9u6HuKww=", "Cgh1VOVRFCZ4DkV3V8F1z2GHou+5Voo9OQ06UcIpfM8=", "Lvm4hChGX1NcsEEZ9RjRwgUiaEVfGrFFzPFpO+kkFqs=", "KpbJ8gC0d+ungxb8RJfgiypDhLJsl8e0zod8tl/1Y08=", "BDKT5h7xthSFC8AV3TFuLHxU8S0tt0b3wM3LDsVRz8I=", "HYHg4oBhG/MJicGnQIhJNQS4GLOF0E2WrSmNvtmnvfs=", "GtnPF7g2jZgALO0s9u+ThaB0xeOqCy4S9LdozEgEveM=", "GbMKJxGf9Q2ic0sSergymaSwmWlMMazBgqtFP8AA75U=", "Ey2B8Au+8oBJAcQHP82cgXpjgyww1lMGP2f9hkguGZg=", "KS6j7yMThjoSdrHw5Jc/p4Tep4oeyY9NWTlH9qTnOSQ=", "Aoz7XgxBsMd9mH5zelAYeHB58v+mUBAvL+tzXH2bzoQ=", "Ea/XXchDU+L5wvBdHzynNOtFVGuSOWIzo/KfTo9nkbM=", "Gq9D7W2jm0UxIL0DEvJZKU6hAbZ43/QnhDwPyBZAntY=", "GdsJ34M4ex5Bhc15QAYJ55835aRljb7geF2rXczjKGg=", "Apyz3K8uuw9bC5SehCeP7S0R24wfzzXjgYmvyhbAy/0=", "KIHfk1LSdPDP61Xfj/6x0Ngfzat5QILiEH4bBCanMKI=", "Biig+VlMFZIGx2J6jxB0ih3yzlgrdgSo5kpwFevdtls=", "ImVzk+t+2fRXLCLNe51RNNH7zilcKpXxr8ZEHeYNf7g=", "AGMl9QnwNicUxIUNrth0QGL8+AmGCABefQi1CbujNiQ=", "Fx1kmLQrOTRdVuhmHMwrV270SbH45b3FrHLZ+T3D3Zo=", "G+gvOxzJ2ElZXYXjOYMxGGtuS0y99Dzu7b8Ec1MVqNI=", "FUcRvmLyPNRghrkxGyjurajSYyP4hk3n425VQ7zXo48=", "Gezl2MC2zAf6ARl0bn82ycjUlqweHZXNW7jXaaZ0XNg=", "JtYWLY2cnGAkTLzBu3iBQmX++XpToWjGKkO55vTLLRY=", "KLuF/vn2WITkqZpjpZqQbVhs3Yi7p8USWbH+ajdf5K8=", "JnzKweNCcZceR0F5xYAFJs7vLxpv3arB3iKZ6S2djOA=", "LmtIaNFTkNgBQkjuwMfxDY7p7r+mQCX5Yezkmp/62YU=", "FwOQI7ok43vEzeSX6V0TT/Nd3m/gk+14jkg50rzs+EA=", "IURV2R/HR8aqmQitktGbLcdahGURg9z0O5olYyDDPlc=", "CgdAXwNtMOx37GSwNLn8XfLP9Yd8PGe3qyO58tja0qQ=", "KfaAcoS25DXMwvwUV5uu0KYGF+DuM6NYyzFoEbPYhko=", "JGiU9gcfyWMPaRh8tatQbAUIQRTS788jF4C11LXEoMY=", "BCJAgbkKZ3dNFf+Y5hNEk8AZJvfsJQU95WIVwUXl2mc=", "DZnP52SdHf0pLxF3O//xzjZFzkISeH7TacCga2ArqyE=", "H8dgIzM7pNwPKo26+7ob/zO3U/135rG9xMeWoDG3gVo=", "L2DgX6H3RGc1o3F6nXNyilsgFmU3/+tlcH5fdQPorPM=", "Git1CJIfoFT1jKTW7rEzRTZjyJedYhbsnuEkC4yJToA=", "CgrKSSS+ppeaVuR68L+hnB2311a7Sq3gpY5b3dfdy00=", "JiojZcx4D2JVfIVFZvosiCLm/f+OrbkJSfqlq9Y6f4I=", "Ga1aiC8dxJcUKVRd2j2xhXscoKJGdos6KwAUulowJDk=", "Jh4zYPsjwI6HuPWIvVnwjO8Hu0im8SJqZM3H1N5+lco=", "BpzGfK5G3tGP3HJcnK2d1k5EXJkCcbDi0szEL9zgv1k=", "Fi4hiWyNH2wrfsFvt65++MjuGSFq4Ymm7y1+vbHOYsg=", "Eo1CwIRE2JVoeZlaEFozbEJI/5WBE5Ei7ZydVUZO6bM=", "Euk5H38THxPDlyXEQUZpvMZMekG2dk5ofO6OUHQz4+k=", "HemI5GwsmhwA2F36+x2nUJvLNkIqq2BS/R+SffdBwXA=", "IALLinefk96LRNf7CM/1CCjgdx1lAR+ZVLQk5ngCzw0=", "KPblrydSx50Bo8bH0pMP37FkmJwg+QXM/AmCwpNl1jE=", "GeustTVPfycvXBLWxxs52J4UqqTvv5hzdzN/+jwCays=", "Bd1HxpXMbJXirNG/wM4zXLMEo8M4CpTot8BwaCyoaaE=", "JGvDwDejya4run5zV4sagl4WcqdBiAHMB0OVRTTZwMc=", "G37iVYFbpwIPDPeM65hggVwO66Jopyzs+eP9Gmhws64=", "HOBPZDvJUTMWIR/cC8I8mlK9r0vM2coYWQwXA6LRIOE=", "LjplMq+pU4i0GtWdfCcFRF184QyI1zQRtycfUu1MRMs=", "H5ESHyy9Hq0vcPT3RymiVyNyGolah9czlMycGAn8z7s=", "EQgkAziKmdoN4+19O4c/Wrz3H4vqbjWPWw8XylJ22SY=", "A5YqaR60LPXvd5vuglCGQTKe2e63hX8c7MRtyTBG4fY=", "CmeRDilFg3OcK20Y6lrXThQbsqNT/N2T/D74P0/Xhjo=", "HCD5vRMjcJ/aEk9x6IkBI19ExeSCh78PQ7RUQ93Lrlw=", "ERq1bhknTv1HOStwFx39qwyM71tt5XneZ/V56GtQb70=", "AG5riObwzfmC3kg6oEu50P4ojuWGOmiSkV0SXq7XhrQ=", "KbxZ1vum1pLipehbpQ1v2bz8zFfivL3d1liBr0Rf/4Q=", "Jh0TrEQbLzAJbB9/ZqbZcyRMLAcCESdaN9SbHXA0Dt0=", "B3+NknP/2jftHqaD9pNJcV+VmG0mFj8A1ByePDZsy/w=", "Fnj5/GxFAsI1Jn9LhB2VQyCFQjVe19tCCmCay46Ovc4=", "GmW0HcMCuQb9FEpZS+ptkJ9y+3B1ALJwg3yaJJWQB1s=", "JlNZvw6td3Jk0Y27TEZkMBojsQV5No9AtDNxC5f4B6k=", "LpRM4OtlN0WkVjLAcLkx0I7MSXPqCR5dxnElzJBF5B4=", "J+MCWi0+gmFKTdBVD1k1n1ZDuGg1kmrtLrCnqk8GIZo=", "DZhI4NO4vI1D5eaVTm8BgZhuV1BUhA8jjKtMtbA//8I=", "GsOq2BXY7BOwNd7PZ6aFSWqHsQS/V+84zahVh3/KfHU=", "DJEBhvkS7vlf1nPq0igf/Q1c6cgMxR9vkx0MdbnAo68=", "JItjp2oCTVzy5Cob9wqVTwGxhJ2sMf1UWnzXTFw6HlQ=", "GnH7pgzTY7C+PqNgSjhs0d9Ga15p+TUDhYxp9ahoaV4=", "FaKGm2NjzQKkcsvOxckb+hckLO3quDCE8O7fKDQxeLE=", "KBPBBzH3aUVA6s3oV3hqskQ/sYkWGSQ7jU2aUppzNUg=", "KqlpBe9CvB6EUgh/4T3D1VzpQGKTb95I/Cn4aY7V7FA=", "Dwk9Np+tCg0lW/wxHEpY3JihkAzzWbPn2WiPZZG404Q=", "Bo27xTCWd2XPfH5puL7k7gjUhrQg1TOWJshBHKmEAn0=", "HdDKtxVwlB7pYr1h2tHLaKjtgCKt/zVqZ/yrOm6vWu4=", "KahX8ISufytQbv1s+wZy1jrpYM0ZefeNf1XXgllVN3c=", "IIH3cT9Rs5MN+gpt+Og2EbyIKc0fhHG34uF/SA2FPDM=", "Luo3SmCrGiBkjLkI5gXG2FmbpgFThjXIzO4AyryFcns=", "GhtovSlREx5tcZUiM2R+QWW8QS2m2Zwhl6o5fY0+5bo=", "He/fFEFaeNXm8oeubknrsRgiuHNMnfkcgOCN5XstTys=", "EAQMxP0gusymniYocTi+TayUBAzGIk4r/cdmYRBqckk=", "IM5n8y6CO5iAEdDDOrsPclvpb8mrWy63EBL1+ApV/0A=", "IC7NUMgsnhx58P4TZRiyJVHAWMIbbuzkNYW80ozE6oc=", "EPulDAYPzrmJ11NsNpLwwyQzOCENFF1hh5JnmLdHCH0=", "AmgJNuQCdl3WzP3+LepxnTxQenxVESPA+d1ZpYv43LU=", "ECvrSlxMkD6u+eyw1XlBVGINfp3oQ2T+BYO+ebTefPs=", "CNAdsY+uzRomwoW+ZUFL8YqwEtfvsmdfSuHW9eE3BiI=", "ES/l0hfzPC0tGXYtKGhBNmungrS936M72oNvot5BkBA=", "BkiF9FfPr+bs4pRKmpNe/ccXr/y0RJzrMaJ5LV7qZ2U=", "C73DcattQpbnPtIHi5n6R9AMRM9R7sCtStCqucCc2IY=", "C55ZtpmqaI3RIUPokLb9DjSADWtED19rbEJrMK0HiIc=", "ClqjHU+rjhCbD9/FXrFKXC2SZ9f5hrYQFwzlVDv7MLc=", "AyOdULSgEo45x2c/L5nYi1kD6xu3cExsDN1MMUCKems=", "EaaUWUmhgnWbbx2mDq2vLHMMzmbqBG+PXreB58RfjJ0=", "DFAv8b7YpocmgD4iK4fVkHSVbYNPLWOBfyqe/tPckx4=", "Ii2dqjhK4rQOQ+J0zAfS27nraYjQOJS2+/UTNmNMkX4=", "Hfj+DdqOUZcbkXsP8PPgXtSwDAlUU1GhF3gFxQ9rwAk=", "Iiu4KQQFxbM3PxsZmWnG0Pm6jrdy8kl8VcD1UXdbJjU=", "B5Ar7CPZ+RoAOpKOqv+WR6wDAondXqzYyv3TG5MmTRA=", "LHBvBZ1qhupJbC5Gk9FxfkCY/4fQWoLXOP2Ig6grnV4=", "Ba4mFpS+4kRqGBNgjt7GlvJSki0z6UKAqoBb/YQ3hvU=", "GG7iynecXCahk63w/0fZ8zO3UPmbd2VQEcZLPozN+T0=", "HCq26W9o47LM5to0ZbGePkpDex8gnFXm75mhrAc2vRE=", "L9F9t+GCcWnDLM/ArRTZ+Xx1B/jviNxdbwSwIgPDflU=", "JB+tdXBihBirl0jO1TZGwuEAruvWKmxzgE8IDeZtlyA=", "ABa1tTQD7m9H5hAMJ3jKlwtAr2vid+mLcQMviU5vai8=", "AAoJWEL3GOcWRbLoHJCz8IV8jJNbE1sMsl3xVB04x/8=", "MD8roE7t8UJbXXzEvixQiLnS7yv0eLnpuM5v8WaJCb0=", "FJRDUULJb8lOjWbZtkPgGRY8asLk4WIFb6j+7lGVZmc=", "Axzbua0o7FfE4ayP9mx5HQSyWiirytroOlVz4/PUv+o=", "DHh9/wEvE2uJzjUWwc+GeSjXEH0hjWLVGwstjMmFBJg=", "CyCzFJB/Ui4XqdXajBD8+Iy5VlVs8HdFfB5KmtXcCw0=", "EdXK39BBicbBSknoumeDVArcftcL8lr+Jd+eL/2bw18=", "CFIwnVDxRTjIt9NWWNibow4pqrZiZTGqoRhf8Mq4of8=", "JXOV58GQs83OX5NNvqkHcFAIowWTxpKT/XEFYiYCYEo=", "Cq43r1w6VCICk19ZC2Z/l5+0FCc8yHkxYQpLMUSuv7c=", "HBZUp3/q/Nf+66lMMmBfld7QPhPAimJ0xH7bQRNOJEQ=", "FIDMTLO52fyXuZ40D+wZgj3NLt8Zj3CV7lxwqSAJleA=", "GHEQV4aRiRJviFNqzOpIgqNHl6ndlqlMyHuOpGJBdlU=", "DpxHNe55e5xwgzp6a+fCz8uWLwcMqqZJRm/fm75YKM0=", "Li44zOp+9sKakisCfTHZhwrA+dJ94Z1wA5u9H5D/dPw=", "HWY2npXC52Aw44DWU4qTJ4+R6l3WDloxaz3O0n/BN6M=", "Ke+RArXmce3AX4e8zrbZAEhOfudAKjLMx3/eLnhmoIM=", "IQOwTBc191Eet3XHM0oLttYm+2CTe6N2Ha1zqER4490=", "DdG2uoSjwptikjdlBoz2PHEbwda7KO7+OKDkhhrROWM=", "HqtMf6q+xYq5tzsrqvIeQogLd7Dw39MNOOHJVendchs=", "AC4aP2ad/JKbnMhNltSJ7OEU1b5duFcUafd0z29sgCI=", "EhTKQk6hUXhRUNfbV7k8xrvI110ZKZOEYKfGfwx5HxE=", "LhdN1Kr/9hAxZNkWX/gxnZJgyGIYUQpNkQNB8LTgHTg=", "ILMvSkI2F/7xRtpfGiaV/P9kl/+row3s9v/mKulSxDU=", "KfTdRo2whzSRRotwCduvx5lR87g6tk77jdLlbMmzGo4=", "JRmAHeTljkFk9/DYaZQxHIfyeaOK/EyzxNJs9BxkKvA=", "LKEj+vh13k6q2A66c8sqAPIur1thCe9Bpl0tKG9gLME=", "Dv7WUaYfowtwk3venQK5tqMCoaq3Bmh7IjOumyAzEmc=", "E+Idu/1+VSa9xQdec97grvRaDtLIgLKbfb1cnmQ57j8=", "LCSG2FqtvDWLEGXdexSVfoz1v3RRr8s5Rll0HPa+WCE=", "LJel1bl1GUO8EeBMLWClbEPZRblrCYLIo/XmO3NVDWs=", "DTh2sFU2lDgK3AhsyScuF3Di+Gszb/eAQEGeXtzNjPU=", "EjZcfN1hbSWPmuNQSzfUTpWMgWoLujdCeOi3rXmrlnk=", "G2A1TRawGENUC4/Glh/4Sljr5eQrRtIq62GOLbSt5l8=", "A3ePxyPM0DrYyQwxHBQZY96mOdJSStly2EltEp4cJDQ=", "Luch3ehSh54SOMt6eSBxR7PYZObIoUoyfi5Vi531dmI=", "EQINBYH/jnnI9apNUL4tx5KgOLy2GuxMzqLsTfLQr0w=", "Hg6SEZPjWzxC3tAD3Lvtjq5GcS4V5jrscV8/cDHPT48=", "KmwT16/WY2wtTV029CwJrDKGtncDrE0sJNz1o63ZAg0=", "J73e3qfY05i0tukVLhfC0JIhdgmxCcFFdPkyuwLIhEA=", "LhP5y8NWco5tK3pcWTqp7Mm5ALuYkBWT0CHWHrplVaM=", "EJrzN3PkFhVohbqwUT3BmaAEXUBdgb0qFRaQva+6O2Y=", "C/ehIamF0g7r6/Yk84NzB0Fa5ICVS/SVUt2MXz5QMBo=", "D3i6fD5tFdESkt0SGq1FlIMnG1/i7lamOBTV2xkpBWc=", "FiXfA16qmS9CTdxtyIwbcArF5tWYHirQ35spCla9UAE=", "GsfR8zu1mP6VgaxzsKrU6azpnq0BmB/PLFAqca/VZ2I=", "LTcpbvDNVnbQgJYIujQM17IC4uHCVG2YlBfTA+wxkzc=", "AZyqYsUjjgPs33W7LCdr4YBb4/5EqVfYqjvwfKzxwRQ=", "DzLeoQQyDODwCRnZD5xsdtSWiCeRFGxSKorKzq4+Skg=", "LOXSRSwKWp+2WkpkgvNJmIZb6aKfJm+IqK/6hQ9exuU=", "E11ZDegKDnF9pzJceBqhZ6JeXDENkt+DEg6JHM7SSos=", "HTzpanzXnpRJLjK4mD1i+sc2SZhQci9/590ViXBqtpM=", "DqOh4fXco/99hnHy/s+0Z/ak5lFsgDipMGs23IGDIbI=", "HtCMTw4W0UQFkQDwX7RjCY49hp80Lg74tKR6/nSoOiU=", "Ct9hK8DCToJhNcfeDbqQ++G9JJ90JPGXC1LouyTZhu0=", "JAxCSgJOWb6joU/Kc9e2OGnrm2h0atnDVrk/tuqj4is=", "JN+rcjiwW/CPZvvlmXY/Y9XHChgafp/jXa8EeeKxy9Q=", "Fg15oDlZyWja+3bqPgj/0s4RfQlOgg1en3zh3r07sIw=", "G2UhYYehyhZ5ZC1MQKoFv/clv6UCSKqJ1X9XDC/pNFo=", "JDUDutitrxSo5WUBOGPBOnf296D/9XHBJ1sY9UvXc1E=", "BsKtR79N5XTKz7pRXRjdr3gqit360cGO5DkRY8VBpiw=", "IUNmZz04cUhXj++JQ0vPx+DOTrCGYZBAJrMLoQ86E0E=", "HbgdmLTU2DImrkExMByONiKjLit4hIYOhSV/X3t+beQ=", "KdK9vBmJbo+vDOFdfIg7y/qjiGHXySKZpr70L3xEPw8=", "GSlfcsWQfo2fjYzez30ZP6hkBMu3qFUi9/wzhXt6nIg=", "C/AVdgdwy+jm9pCA86yhgljyzQkuM9PtYtjRnRRLrKg=", "BsshqsC+jcJSjDl0cks41zqRhTCXb/EY0IdkzULgskA=", "Enb+LHUbpJ/Vt1yrW3H2SqBYjt6AfbG9WDw9auaUE1Y=", "Khf9gEHs12L1KNEgZ6CSBPkpbqVzdIBsOYlv6UmbmM8=", "GQTiv5wFEsclWecePxMvZSWQWPfWi519baGo+fXK9nQ=", "EVteuZIzqKIgAXBzPEdDuATGAbXY1GVqE4IS1m64nTg=", "AGtYiF8OCb5rqRF2/IphcrwW1oD4iKPZLzGjvyE+fvg=", "E8ZwTpBTU1KTTc3ASDtLuXTVC+t6W2vjCvDkb71zJc4=", "D7vLlsyvQ8dzuhznBhOJJUNzL+zMhyl1uOtz4/tNVKU=", "BZtN9j29K7ZuCyqCbFy9qWwzj8w42/npxGBBkYvdi/w=", "J9hZ54aMmdgPmdGB5u9+qTppRiOom75Xpsjn7lS+If4=", "IerO0I+dC0LG+lH1nWX5ZZjpylDWzR3Um4T9wGRu1o8=", "BoFbejuAlx0F/ebX3FzSgjNj840K9cD/ir6qcaMjoqc=", "Bqd40pqr67WjzZQLHDPwVVEhe2AFJI4OcWvVoQ1VjG8=", "FP6fsfFnxiV+oBAIgRV2nmK2DvOt0POiLJ/npJGOlMc=", "CQMF3/MUF04n7evldL2PDI/YWEPn0mJ9tgeygW41fcE=", "LOI9++uOGHS5uolMuF8Gi/sEl1Vc/T3684iKpJLSBEU=", "Gw/ZTdnP53TZFGvlhO0LJcssdJWnCCR/V2PCOA5cHNU=", "Bgu3FrpyOk5fX6oXk2OjZ3RhnR4M2Rv0eJoarbPmEqo=", "BDsQxQjoaBhD7dwF5zuVt/VNpak7cBy6TWgi+cnc9DY=", "Emc06VArqfrkoxS2et5s6IkOMEpDDmyfT9YMuK1plQ0=", "Ju3TXbl8KrLOJ7UDWShZtDF6JaaI+XQ+8N2cwmGdt+c=", "J7Il5KmBrzbOqGP1kci8WqlaS+ttXJq8XgO6kG7XIGI=", "EQJyiDL3UcMTrGYQ+uWLnL1RG1HWEhs7+mD0fbElGNo=", "GCdssBG9xtdescfV0GzOEMfJB5yMmSD6OJsRZiDuQUE=", "JQLX3s6M19egShcwv9KGj8ZPg13+FDzuGEgMfD/K2nY=", "BrIL6qV13YRiVGlQaEhGEbvuGuSChbosPZnBTmJYGiw=", "Bjq0oHj8shInX/X9BgQr29F6zq6ZTiwnobqHYTn47Bo=", "BjctWVK7aaRgvxMz70rGsgsHrUq0Ek3UBmps9m9AaZM=", "D0HU4+9V2nHPQDfEnUTApkH1KloXT3q+xSJHbjxiPOA=", "Dw7phBshubIjwdGpBpk71msOvLfa++K4AruBZcYBF3M=", "Ad8usvpCPwE5bgczkBBMrYAEpqXxQKKxjtZYBoFnUho=", "HOBbxVQHyIOlpBeS7zSG/yLkA9OEdM+pD17TDI0wGYw=", "A38fx5NLvV/cNDiL+9D5VGclTl3ytbYsrtBQCiWU3a0=", "G9amFABDmPMptwgP/mnT3/beBsgZ/t6iSu0W5MRxZOc=", "D8Llz/fp79Rv7mKqOz8ivMnxo72JF+Lhz1qjNNKdKgY=", "J0+k49hufviw/fGoGszo+e0vLrRifedXgagT8Qajd+c=", "GTrxxfoFfOaC7HKM6pBzWTWiK1r/RuovgDopQhqpUNY=", "DnLDPtYFVHGtrWHQJ8WsG/dURPxOFJiLQiaPB4fimHU=", "HHWASk7xyByDaE1ojEQpqxp+UX38YCyaJEPFnzLulhQ=", "CIA/adg+DDOX4J3UeoDPn05CNDcAjKutLlARBFbIxg0=", "LRIU7Re/gRYqXdQ6P9zxlfv0dCYETLIttThHjpQrB+Y=", "DIWyS3mrV1BEIhNfscsMXh46XwoGEDwkhu5qPu+scog=", "Lin1F90bMLeRv6sDznR/lQIC8OuCZ+8/cczsQOkdleY=", "EygclKZw/lqwl3OvQmBnQFA1Ce/XTB7Zk7xq+vPWQXQ=", "IaIRQHzvewRCFgrMnb/OGh4dWMnpjzgafrSPe9oPHgU=", "CF7x53+Sm8/60ak/kgwdjIs2MuHhoczU7LAWAnWeCH4=", "K295beNQnqcDyNpiduPqFUtQQXDFmo7EWB6XV9dLp1k=", "H9pQdPpbrl4W+08tGNWJpyMLmhweTQioBp/I1Fsd480=", "AtIqPA0yR1DTvjEhmvMqgoLDct/eSGHvhu8VwxVdzxQ=", "DCH09L2uB6ebs6mM+zUapinzI5xNJK75Lqeb+snC+iU=", "G3IewcHfgcg6zXqVrOFrPi/0KXqrtvWBALXasG09xAQ=", "J+yenpI+3uWBidbH8wPuPlJJxa73h1jH9RHPh7lTVh8=", "Hs8QYDZt6pUG/aDQHLoBbbliAJChYNWnYKddEtXXLng=", "JdQy3zEuAFxpoGofAE7ImVdQNNomOSdg0XrMgMOVBs0=", "F6DqUfmiAboqD4V8mWmn9rxvXVvA5JV+HA3+SyAuSiQ=", "AtNMR7hH1nybTcMTvHFP8iOrARJ4Bv9ski2HY/FCAks=", "Ag5Z5eW7CVGmYBIvwa7+opTnzNX5x5g5KC69nhGflso=", "JJychQFz26D/6jVowoQWAgEhw9mZDf4ukXN3RndZJns=", "AejsV7doHWMaAtUwya7vk3dYae8JPekgFM34XuLUWdo=", "APc53Lnz7m57VRl3S1QLKJi7bLo2KbtsYOQjt+trX/w=", "DgFvByT/+F14GusVSNdsVm5cJqp5lu31BOQWcoX9pm4=", "J1Jwgoud3JZLuNaKYlhUNWjIRJR+1e2UsxgMuHTGgyU=", "APHKP8KKrLisIaW0S76wrmTMM53hPgTHT86CD0+T5I0=", "IWsvickBBfVw4JEb0c4g4GZP/gGBHLd3+QN2cZwOIPM=", "GpHt+QlQyyaJ0sKcsi+N6mHsQfsGHxtgAvciZWlMeE4=", "LaM0Lq85orJCcTSERilxr+U99VvtX11Q1n2ROM14/oQ=", "KfechvWpyW/K8ilr42Qltyr6rUhly5CQhIJJFY4upLE=", "BRlCahWlmfINKXkwIGfb0UVLRlOclJnGX2GVtVx2Azc=", "D5xHXNcrfi44ZelrrviaFJ6s06s0AhCpxeDeb8CC6J0=", "FfHXEZed/hPkXuuXWaifUds9J1lJhYkLiMm/J2kiFzo=", "Hwg6wFSaGrANS8kGbwVJQUj2DJVp55iZQcP1D9as92A=", "FQXuT3m8gYeFbV8/WiTel6oIK41FLGOxesOlkUUbdH4=", "DyCHbXEvFH4vufe+alHzRuooRH31KetBNClI/C2PCWs=", "FpbRLZrneckhIO5xX2uNoR6pOvJnNxWi33cx25HjYNw=", "KEhfQ47sEzsL42sy+ugtpX+0AGvX9bsVomfndGs3utE=", "J4BDb52hJGH74x2Xllbm0aEzhuDmpTCbBQyoGeEK2UU=", "Jx6oY2czMt8r8kcebIk1sDfqgxjqWzI3lYP2EeBrPaY=", "KfG6SynB2uy5g5vcCEMbyr5oORylQPaLSEpPjpap3GE=", "KU9MxyjdQj/a83N34Gmrpm9NMADxpVm/TESRAzBgMeM=", "FGtSGxwIyRgSE+vbwqNPw+/Yfd6xv8Xl0XypUfVavRc=", "Da4K+XPqCw/N2BWOpRue/e7V62ZLhO9n6qJV/k5V8+I=", "JgTMzDcPClDz9ybt8SQrzBMd3fJpeFMnbAeev7iD2MI=", "KHOxnbHQOJbT1S1vk2Hj/a3l57Lmgz5NXORmEYa7u58=", "CwTQkLzEz6v6R/YAQ4Wa618zpt4gXf3w49CZ1Kg5Tgg=", "BQihlcDKWD7BAVbyBcobtvaRcxi47W67c0e3fXLc90g=", "CSYt+oCqoLxhxYkcI3pRnTgIxT/AXc49cfF8Dj8qXus=", "DObSWxxsG4n6AFwjYZ2Hfyqy/ecI0wkjZppJ/iWzx9w=", "LmloW0bIBQJo28EEDiPHOdchayxedhCBNtaJXe093EQ=", "Anj7PfP+kTZXvMzrVTE4+nuKtuBipd3q393dWzBf+CI=", "FtqJKt41dU5X2PA/Pm9BEKncFjnZtt5l5HkWXKSfek4=", "FZdUkk5zNIVP+AOheC/8BZkno8JtxD5mHgmhJhvXyUo=", "IhLKZIe4RbpNFsCeIkKX1LGhbjQebFk9f6utraOSnXo=", "LdCI3oMYUtFpruHWvmm1LF3uC3Phj8qRzc75uQOWoEc=", "JKtCrWdJoU/i9wfsU6w7AxXe7PQhuXUwMlM+KEkdsw8=", "L2Rm5Q7zxhoOZJOxjTSRFAbi6X01UYh6+AjWfhzpric=", "H1iG+4YYyHEewI3pR3Vx8OtuRiuPXlNJ+FYx8FlZRIA=", "Bbo0lTlZeEpXwAGekW4q3l1qUjEQQ3zqnCuURT3N8qA=", "J67mejxu94PLVZFRZaW7/dhrwGx3bxRQSLskAdzxc0E=", "D1fvwF6fl+f2jGlLorO/IW7vvVxxcQpW9GBoKmul1e8=", "HTXrSkCkHdd1BthypFisk9czbcty8VsYKmcCylO5Tu8=", "GKMwZFhtWnArxL9k9wtEtad5GCVcLf++/FN+QL1ZUf8=", "CwrlcW5CtEC3QjvYmTGciApKZ0VQt70DYgfgBqx6LSE=", "ETag9sAEosV9IaAMQN7G8CexQLNtNZTBzcGw6HB7YvE=", "Ic7FKsSyqn+A+Y63W04CgFkZd9ULZ3uP8QsKPQKFMqw=", "KEpjZ4b6Y1ebFUF0aQHUjkQM8MWG8bCJzEXouDD60i4=", "HUoKugysUcMmH3xIPYlijXZ0iwgzy6a7/KxSQ+S8tNo=", "BBCgZZJekPxw7RqqRkd6isgZOhDEi12E+16c8hI64k8=", "MBRTsj0FXBhKZa1qas/9n1IGN/51H/e3aUCdUS/JLw8=", "A3gnEEKH2Uu9wGWE021NXixGxOoiT04NwMO7VB8FO3k=", "KUZBuooCdoxeO39ULSgcadwsPy6AMvhkKVpksIqT2ZM=", "HBL5k/Dx7dgJ7u+uaTLluIc4sza75vl29fegoXj/6rA=", "DLLZSNOPuOF8YLpsZ2CMn/2RLgpifu51a40ir4ueXkM=", "JvH/cxJo2bvSarM+WIrOwJ/VpLcNYLVTkE9eLQXolMU=", "Ca74ogKfgrdtgK2KOSbLbhF02Li4nFlwfBI0cxILTH0=", "G+gMqxL0vRc3eWvHcPFwc8awBGwye8vzo24mQGx3XHQ=", "JHbnvGN/JD0j12LLPizYQw2tiXYldsvdkYQop1gog2o=", "GW1wfKWp7cwOMQOu38YKvdHJ5Xc1TZML4NW20DYXwgk=", "HSYkhyN+hQOQjVN1oaeYqbjA+szAVu3diqh9CmawfSQ=", "KiHgPUEVS/MZHxqDS5r2sj1AvAHQJ8K0hB+yPcn/cVs=", "ApxkeCKhrlZbK/EkntrroMuzrXMN620uZhj7+edNqtk=", "I+GXEXW4+7JsCYneqC2PSj9wh3TChuTtL4367a89teM=", "EwYYi3kjaOvaHy4x6EaFTLs08XXgHJJFeVnuHG2g/z0=", "En0PfrmAT8IKtPi5QJg0rlIWRf/6hrDCIdkiP6Dp0rI=", "JEGYW8rONagbH4H8ZiEhXfC6QkQeRQ/GXjUZoDk7EZY=", "LffU6xFRFFRKxPUvyjbWsz8J9jklPp41SdWYew4JcTY=", "D2xVGPku4uVJ0xrbtOeANu+ao8IWTDF6ypIgPjuZ+UA=", "JuLMnepH3GgH+HzYfFMbF6fy9eqGrAlOXVoi/DQz3Nw=", "HHHjPIZLCo3k0Q3Cb3a+1Vdx0WAaDgTTmcsjlwZMXPg=", "Ki8LVjtAg3Zsi2xghywy7v8rIHoZgcBbHzlhePASB68=", "DBrwvFVGJQp/3fHL0+e8269067l5U14LNDZ23J+UM8o=", "AYvfLnB43ECvHL5IjLVi/TISBJnEyXKm1DuSzhZ93+U=", "IrNoWaFqjNw98QryggcViR93lmCh+aJe9lIBn2QL7wY=", "EOaX27xDx64gMPXUmXT4NE1eSKtm1jW0HnuW+8fGKJ4=", "BX3rT+VjkKu73NiCLKtdoSB6CteUI5IGIrDEoS/vNVI=", "ErJ8FjnxYvhG+zeucUTykTdoLufrFjLnkbRiiv9KrCM=", "Cyx8dtAYQ6LRRlXCPoCRr7bzVZ1mw7vz0RXcnXDbWvI=", "C32WhMDI7KDowxY0yftosug6vnKjZ5s2eKjJsaE6SJU=", "E6sKf+qbLIKHZtL6v1dCSNLX97L45g4mHO8pzZFumis=", "LeNXnXkKw2f2bZBVe1RmgVOlw31TkekqalYVydYL6Xk=", "G6AQttY7lTiygb43ZOjmIxZCxqZzXYnJgI+re62iH24=", "Jv/eqKjZiU674CpwX7dQbhKxp/EAxZAlhOTcvh8hGaw=", "Ef8WGaSdaru1Y5Dj26rwwcsBuVGnNCGLPL2k6AUsy6I=", "Jgw2uAiQvvronLs0eLn3tbP2sR3tR6riwNXgxI2OUXQ=", "BcqIhXyw3V84Dlkqo39vlPfwwyYhMc7ymUihpJ/RhPs=", "GLODKhnrfuGp3PV0MC7gY+wZBGs7nrf7J3pI7oOQ5IU=", "JTUpHwPa0ePFQOfyYgHC4zAYj9pYvngwZ2mKFzn3k2k=", "AU+DKzip9Drybl7C+r9sQlAIPPh/C6hrlQU+kYLRNz4=", "JUjmxHZ8Z2ka9VFi2c4OReieoIpCMvoKIj/ehpv9PqQ=", "Aj7Nqj+UK9RbpG9SjLyBpRzhQlA59EeBp2lvSNKd+9E=", "FhG7WaOyh1a4QNsxiaOl6iLsFoRUcqvWhXCsdxyPFe4=", "C/dhiEUBMzD/Rl8SypUHmrctDKnYp+YzBIwRvyxGx60=", "FciPouuj0If9Kfbeb9hkuHVmL/pDgUQ1LWhHF83NPM0=", "DVjRJ5irVS+W8NlR6Xy+74h9hYZWsfavQBDIAJGwxmI=", "BAbuzXu8IesE+h5WV0XMZUReT4L0okHvuLqwbq+cfLw=", "L6iO2gZXFLmuXhhFYTDjG9b0jQKyQV7GHtIJrY3cMWQ=", "AXSYY66rE8pRImEQPquTtD+sU99rBAIsfLfxdjj1HCk=", "AVUyY6MY7fNEKdkB84eZMrcvXDKtVukAq/R2cvhvmmI=", "Aot6i+R8IjkHmgHdbQ5X3cA/ypxqWNPfbyNN/oL5aso=", "LEib7w+sGbsYfl+KBk5nY280sonC6K3HbsvbtRBfwck=", "H/VIxmkPUifVdmaP72dB+ZnJkUz0hC55P9W1GUvQw90=", "A8G1UchJAwQPrz1tuTToPa/F8O/et6j+snVHckcno0Q=", "HuNiDo8N2oxvFVzoGpN2AJvO8sjY9vJm4Et7gKyM+Gc=", "GORf5+oXH7EdDEr1M4VomQ8iFH4UQh8zb+bgvLuKABQ=", "Jzk0BFIaVeDhpOWMVhGABAwYaCgUiC9Fqt0TG58IdT0=", "B/9oVwEaJLINaYrUOl+Vms7/9ymUDjRqsY+dJgD4PQU=", "KYGzooi0Mng5VCxXls4vCa+dAipgT/rWH+AHfXZ0i/4=", "AN1bC4FY6Kc5le/QudiY1P01hwEfpYbP4CzoAPMGQDM=", "CEwF+uc8vWQy5iLPmIDw0oM3xodLh7iOwLRaVdOTYj0=", "Hi7i/um5v40/NyLnAo/zr45exjGfptiZfcEV5d4uqLE=", "AANBj8WQm2KwKW5utCqgepcQUJOeme43H2QS5E4O9Xc=", "HEmUotQSWAZDdr5c88mYh6q3SAP2fBLGTmWq9/HvVrI=", "BBPCs4czlh/toKaEk9PPRP6813lSuIBv9YPoxAsxAy4=", "AcRq05RVJVUlsme4oFM8XGZQT4GulTS90JHqmJlJl/E=", "Iy+iwJD/Pd6oOtyguc0OCRjJRYt1sLo7fWd63YIL4ok=", "HNVwHIChD0IOs09TRzjA3M/Mtsh8z5rs41q6s3zwX7o=", "A7mB/gxxiCxhlEZVN9XkArgWEYqulL+FGOsHpSnk6lQ=", "FopYiQAQAAZENlimHKnWWfCsRR0eC/1abGo67oVyO+o=", "HlH1WLztJAxlt8683LvbepqwbjWA1G8xjehO3Hleb4g=", "GvpajF/OOW3lbsl9zwMXprfLw+4fjpo7zNbYcAIrdQw=", "ETXv1j6PjMnMBmHdSdNqyOv3kA2Q1m3V+oFgVNQBfco=", "KRTSHC0oRc4rFOlR9CEDWZyHVQFWQdsDxU3zNxA0QK0=", "IMh6LXWXSa6psvD4zAFFJFLnEeOer1qLBxAKGXEn7/Y=", "DbB5IN13nBn8HqjsUyPVrw1RG4adtn3uBAh4XtkikF0=", "DWMfGPrazL/dOzvkZ3KjvO4nY3jNLka6upDVZGjMULY=", "LFAPeQ1GP7E28tjUyt5iKW59fEm84YOVswFMn8ctAFo=", "F2qeupdjXR5ZsZ+qKzMlpbGic3ahbexzF6rkr+4Cv7Q=", "EgL84aUBuItFXKRHiNVSFLrrO1TjfRzIDz1uwOCdR0c=", "IilIN37p0n/GQGAH4XJ7VmuCXey5UJbJrt+o5kU6XLw=", "LsZvwn2CqrLJjrUOZ6CTIhDzxuEkViadV+qQlfQRZus=", "L1wjPb41cYNv2sCRXOZZb8CET+w9C/WpuWjKWMRYRqM=", "E4ibtZucB5U7UvZhI8jBOA5vJyQmEDrc797029KGXaI=", "HPePJfqlLHRzEtCftOmrtPHlWj2jScyNzG3Kgc+ZrDo=", "LA6uKGbWXJcHcEfQ9MQ8KMjX82r2qcb+B+yJIZ8cxzU=", "KLgWzYuMmBYzgAZtClDYsOBv8caQuBuRjH3dCKa3Bmo=", "HUbZFmnOW+ZVT8Ps7oldQf2u7hia3uOBq/t17eFIjPo=", "GEHgO5/FJ0UORHCqjwiI2eyFmdtrD3Ii3KJs1D0iuwU=", "LS6teyB4sJCFgFwnd8kPbFV0S0mnO77wTImTE7r6D1c=", "AYMKjbNCZ2z3SSKBtM/HsTjFXUTarkexT8iI5b90UJU=", "B05M4yvRSwH+n2cp3ioS8hj+RD+3CHOKhg8ZEL36Rng=", "H61MsUD6TVWc+VJfsk5/F0lNI5r2eaAw59G3yc/6lJ0=", "HlDGUmxzJLl7fzOHUr1wDKW9bA78siUmAiRVbXaigzE=", "As8DWbjaGr///XP5B1hkV5P10REv6Jjorwxh555nPls=", "ChSuSXtJeFrndx8N/vS/QYV7sv0fJ9FcPLyM49+Ylc0=", "Fr+gL1dzVmLqwcH1ILSz+cS9Js0nkhd7J2BokWlUzUE=", "D2+pXgEXtzRXn2jcWXNsf5r9nN1KkOE2Ke6r/YRSXps=", "HVnK/ie9/Xj1ZIlDAHY0Ntr5P4Y8MhPBqEnRwxabp3E=", "KJ451qLUvIF6sQREO4m4pgixO7uTs63ncqY77jALvDo=", "DUftr9ao1GUcJ/a+5I6XVvXWUVrxo6NRL1np4+vcwzE=", "GY1qqQcqBt4TEo17FxV/hZlKEMSVcmJ3DMT1nmxtMy8=", "F0uA5CEPnYG+e/cOOrCyHegGX3Ii6Ay708+YXWqrDwU=", "LXgDa6CUh1KueLETi0ucS2fw14qciWXhu7+jVhWFMr8=", "DB/0BFma+COQjzLmB1ZPUht1gSxnBUPjkMsC4wh86SQ=", "ClYbV49L5MUzFR2hpSm8mPSUCqW0j4wBKpwYHYEbjzQ=", "IBKm7SReSM9lAwKJoc0B0m0+suQ5u8TxbyVq3OtAvew=", "CCRCKrtkt1j2AMGOa5mMGdgqn/rLlfnv+eAY1a+zC68=", "JQoJG8kTAbsTk3gqfiHuqBwLyOaBYaOk5eSop+MJZK0=", "GkrbyFMOrOThlpbXegbh7t66PewuRKzNOs/X+ubQdrM=", "JaUR97hZWxInjysFtO1mhO4SsdKY/OJ8zWeHtahuJrs=", "B98l6PdvMtmbmd0E2SfBsvoZA3dmNuOPcYjYwrc8OlQ=", "BZQhztm7kiYvl+fHvrgTVTndZrzW8L1BvRJKkpgj91w=", "JuHNrN6R4RJ5bfcN06R5tZW4z+fEyVtZVu1HegeBOEI=", "KYCD3q6eDMQKm2DklORObv6TqOD+IRgcsTUdl/wNlUs=", "DwH8e/TS8eyMsa+P8XcVMW/EQ4fVFRhfSaJEOtKhTt4=", "GGBJVzsyhrFwA/nlsnuKNqeLjzLvvwUQ2fzI+n5zxfA=", "BzNYKdjjdYy7/EzEm2Vex1gIZna005Eto58szcSijRQ=", "AZ0HLW5mqm4DSEPMPXylHEffUfNdu/SpnTQpP8PVliQ=", "K+o0CiI7ZmX1vm3eLrVbQKBaribTSabErwfjRYq5vl0=", "G5D1wOU0Cfi1cwVkOL2eY5X1JW+rsWAGwAm8reHuzac=", "AZMsPz4cRIFCDGA+I/FgKdi5dgNWX2MUGEd22GW6Ln4=", "EuTp8xvjNnd1J6861EOITjU1Uto2KSEHTgI/FFgLXnM=", "JeegmlVpiwxzI0crJAllTvEvKVmnZWwNzzWtmnkm8/E=", "F4ySOPuR/lEvaIXlEuKlm3aGo0rtD94d3s5rHQjUItQ=", "K1aIMuYmJijDHkBTBfiEApSLUV0ohh8N+u8kkh5+NSw=", "FGyg2/sPu5jBYuuEs3Ioz9cxHg0V0uSN74X50ge9F1s=", "AJU3FnPtPuVYkuNz1a1cdgJoyD339Q1E0p02bh16k3M=", "BRxXzDc0OYl0QnKGnNyUwGYL/PbqHBx65RQn+ymMnbQ=", "HIvZbKOQcUorAHnsOOJa8P56afzhYg83b3cOEyWqZd8=", "FxL2foL5BEZVDVHB0uTrsUddbmBDpcRu2jFwg5eFByo=", "HDNjcV3+qVfelhS2zeoXBmw4Wohk2tW0Ov8JyWNXOSU=", "JnK4re90rbC3HAFm3nZqOeXhyuA3Ga7Q/M+3/0Mv6RY=", "EGNXcaN4UMJBfJa39fpIqYc0/6WQONi3E2y10MZG4ao=", "Cxb9W6l/KPVhn2mJzw1mXpCM/oofwk5TJkYZc9Cb8Oc=", "ACffJ+FhgnjtIkl1kBdWktJi1Kr93+NL+NthnDemYGg=", "A2q43h1993MB0Wy1dqE0b9GW0lU0siZn9QYodprhNuw=", "BJqw837FvMcko+oyGpGVH5DMAK/a1bo9UIFwbfXnXmw=", "ES/j9mSEmvn0lMzzzPDUuPHkpgDCljHQWbxuw0NFDEk=", "Iys+HUcVJy1fGKA2wTfwxvpWh4yaoFTMMwZOKl0w9Wc=", "BWyR3OrOQasTGhxZzkoyCFciSgllftgvcUHnYZpdtUU=", "FEzZg8+iWVFjghSOKQ2rFLqbXY5udrhN2uKrCG56eVI=", "HSGq1ca0B+bu59C1Wqks4KMqOekYuzK8jUXCgJSmNK8=", "F29gvlohuY00aeEzm9XHoKjuhKDTQzm+9nXQZObgpGY=", "AynQSGWNDu/tfzqqm8FDsMJmNvEyYhdtZQoaeiBE00s=", "D+8o8RTWQg0aKI+WD9ndQL1KWgLVgIFiFxHd0oh8dXs=", "CIGIE7o+mpMpJU544AqDs2DJBccgJFnPrQq0dlgnaoE=", "AgoSi3ESmU5SxISbuo0SF/E6lXu00LpqDZfPGRS2Wwc=", "CYDbPH0siGbpygkCw7jgoHhYWVHqSsusJFthz1WnA68=", "FPK9bcMX/hkSa1g9oY4tcXXPpwTFJnuEii/5oSuxiMQ=", "ESJv6dgfqmxqNdOhIjDWMkUGHyBFNh51eqDFunxbMVI=", "H8FEqidcrZUO5OMYK7h3g9xFkGsuhG4nAyKOXVMowfs=", "B4WKPhWt/BQUEJDZcs3aNGGQjb/RyRt+m5kXYMHUd0k=", "GShEide1PtJUnF/GYzHHG5sxRG6zZoxl2FrQlHJ9ReA=", "BYdwLBm5c3hX+Zz9Ah+Pxq9xtCjjrpD59dLsjnFA9dg=", "MGArKWziRQ1ysA7ozs6fiWhC/zRwuY4cuiobOth1Oes=", "J3bb7AeaUDRwDNnG4hQE6r98E/oX0GWi1p0ph6cY544=", "KL3QCVSal/0MKenDD3r5VV2GSu4FrRiG+5GNNxrSnpA=", "KXkaLhfcIEr+ZFMG9YStdn8r6UmqbQYfiG8h0EAarRQ=", "IqZntlkIaZoi7cFpcyS9N/+w8Y8AwLpykuyOBUcPvXY=", "IA1IY7LzWoU7fV3NwivP/Y9FtgvQNsL5SQfYc+XZXKI=", "GL3MrKEcihChK+b3zJbUVX3Zzb7NX4QehzA+OjEuniM=", "Em/1AnFLWMOkD/o9lt8N5Oiv81Q5dSNb81EMerItiXw=", "BXD6TRySzykXA2+y1HdyflW1abSliJGgf5bFAMKLvOI=", "CMhAANuPclZV9HQy2zpN3lFNz0m0D8TTAaF85dcij+s=", "ByEtqK+zU3akufk8IPdBnscEsiyJiyDrvzrJ8b9RMDg=", "KMa9hmen5TNuu35TxySZD8ivagWTkDU77hbYyNupceA=", "AXkOeoxZ673OGOp7m+JhuISKj1xps816e2OhsebUySY=", "Cc4QdRwre5C84NYuj8sp/TyKDShuk0EfxmWIpwoUpP4=", "ID7FeUF+vV8FbhNGqMW+NM2mbJkB+7C8J7jXc95/Zl8=", "IpeYEQC/0L28SVVyquXtVnbs8raT4zkTuPz/5l9X9M8=", "AOP/82u1VKAX+U6IEwlXqXXTQ9FcB3KmfOiLsXNts+U=", "IiFPncMcF2Z4SEYmCXHQUa7ukiJrbxPixGeGie4TBLo=", "HuzKrKI6FEYwnKTD2bfQeWLb+LzYs7NyGPQZkoEmMyc=", "G9Us8Ku9MuiI1AKqwKNYMJvIPrdCVu+hftwautGWv2M=", "Js2M4qznkRTi7pb8HKOAHQEjRcaHUACXRXNe38TinXE=", "HdkhAT5lGeKbmqD1LMjAL/86169qGH7w6QY1AIQG3QI=", "EDWOHLisEuVJiKZL7k8elJIfAwppJqANVyNig+oMCsI=", "HKEWixZ6pSmL/5bYI1a3OH69HXBDHDCxwMDfgfwECMM=", "CNGrJpLSkarvLlCYXIaUhQYVeKLfw3mXIiyB7zAfqUI=", "LVl4DdCgCoaVFsagswDtBvb8OeD56tYFB8skwUREiZw=", "GbMPBjVWkK+neWk/f5nEpHD4q4q9aYmZPUiamxcYDLI=", "G5PJNn1Wsge7Gi8XG1YgjGqhJ5viVywaWeZTRdhzdo0=", "L4tF4eB5RIregYvLeFsMi8ru8ATZVhQjR6CEZ+GWGAk=", "I5r2kbfW7fJ2H4je6uxmUWnemTmc74GdzDe0YJtstOA=", "EmC9KZ2emTIVYQkFWbP5Cv7To282xNOXBy3ik9NM+LM="],
      M: [["GqTUcKvqojVweRKdEUurEXCUT5KfwXghathH1EMPPyc=", "Dh9OTSbp2l+O496vSLSTYQvmHX09sdl1T+yjCHmtxkQ=", "DCmMFDVqWn8ibFpUnlkYSQA4Wq/Y6kHZdGcplk73XzQ=", "GeBwmC0+5nXhYiyiDROyN15Si2dnBoguuPGv4cUEXqE=", "AzPikjmS6J3uVwplASXtp1ogpy5p4QhjoZ0Xt77qkpU=", "GUSqxyv2+83sBDYSOMPE2VENXwdDmhtv9B9lKZC+ATk=", "J9gCrQGaQv0EiSrRZ9noNZanMGBYkEATGWYWdXNjWfM=", "K9BaBAoJh6xrwB9nJC1Ut6LFJ6lwrSgVsnNHHrliPnM="], ["JUuBJvRSQ/FN2CEd9B/lUWs1lS1WxiZ4wUjnPNutNxg=", "IInFl/6qTKmiAu37yCN2MQDilMnjMADlE7KiFkkdR0o=", "Dd6qkGy2Xz6cm+pjRN2o25DCU8D3+Z7O+IeG/v4OXMM=", "ERTJEgRCdQST2ZnU3UXb1PO3WrGDIJI1OWzoPY7pkW8=", "Los1qMKeY53ejf1JtLNH8A7kZ4Y/bvyzVfoVNO9weD8=", "IObMYTrmywpRhCX1PbEpin+IWe4gqtCDINCk+bv+hRI=", "JCDdEoH8DfrBdqdS0VkGtV8Te5zDINXV2qnfPz1D0+Y=", "F71PJyZ0jZmSWvmi8pKeIxwYaUKME7Hjl7sAmRkXI6M="], ["JwcS8YsVGPr+CTZg9JLNvC+3D/qzHYpNihk0vmh5I2k=", "EHz++h6GQEWmaDllJu2fZ1srvycspjXY0+iAEJm7l9A=", "BLlqKWo1rPQVkpuHhLa7pkpjDSnf8otij8mO9wgjC1c=", "HwRlqcEzocaAXXBb5rPqmRKi0GLDTb75LeRpVbg+e9k=", "J6K39VSeXu25AQXA+OIPBXGrevCAHxvdI+qtkfIimhM=", "AxsK+3qy8dJB+IIXj33NrUhZHMZ5BdZR28r86UsU0HM=", "IuAyO7vazl+8dKCz3t6m4eO/EOhN/HH+OVCJrBl690Q=", "Hu821i8/hk6uZ8YzJOR6Y0TjOi1b+4LwW++ZAMVOdFo="], ["K/w5gaJJrqrsSrkAFyfTLU5v51WY7pZPyFzzDVDfWEs=", "AhYw7D8jbtIZ9zzGF7n4smfb7pmmPFKFROoxsnzeSfs=", "KIkKAxmbcn/t5e0AkO1pSUwFPJeTD7tsUjWLDX0QTBY=", "G4Dz9Dk5bC9Ga46bJXZaAUlwRVob6u16b6MI2sdftYI=", "Kku60kWjPl2XAVN/dRQQ5P8pe48dHZCY/pxRjCYaGwo=", "HkMfKxt+2uT4y7XTB79RMcNSwqIVqHDXOWF/SwF8bRY=", "JVY5iJolnr5Z90qP3y785/3h46Zms12ObsYB1NCyJok=", "LQ2KgUz6FsIyPxdL4ty+DClYKfxZvyqJ8TtOrQ6wVqg="], ["FgYKF+GxH4Uc6rIEZFcrPXjVguoFABSEMQFIX2Wrcj0=", "J0EgPWbFI8djnqcTsgNGEZyWHMHpZZpFivdMvuFtcb8=", "IgjFAEgGx6r1gxRZC8vqFhaP5i7ASXr8a90pOMEtmiM=", "HAH220NdxIhe75zf7RkyULnT60zuNmZ0sHvdGU/zSf0=", "Hw42ws+awsQ4jnSWbZ7n0aCzGGkWoIz6MG9rs20h5Ug=", "GZ/CvmDknmeewu3mzzNF3LO5GOWz4Hws2BQTM5NOF48=", "CjjRY7ii+jCSmZwXl7GvkJvZcaJaZWuu+9vfo2KOZ48=", "GYlJ7vKyfCucPWmeP+V9o9W1CcK2cK/OQAq6Gqqe1R8="], ["AOcyF6EGxALkxsFmzZ7x/SoLFqwctDZGvBxyb4MXd3A=", "F7IJKw9jRXa2VMbeIaGo2BK9TAFVn/+DIXEpCC4rKyA=", "LyTWCcsjcg7aVfrinsbxmQLELYv5BPtlYgJzbZey62k=", "LfGD/ivJuLdXc/qWHI1BF+WCqAtlavXFh2PnAk6kGJw=", "Ff6WP1vQ2Sh4wQqJThGAGNuC5jUor6TUcD6Yge2hGNE=", "CvWU3EAw6FCXAfvT2JlfcxJq1yp68P/zRO7oKjHOd/8=", "C46FfZ+x1VTzpOwwetkH3npDZDhgOvGyjU5O43mWDOc=", "B+vNJaEOVmk6KBVfza97NRnZ4OCCQeIXiWlst27gYpc="], ["BLlZygfnGCygjyNRoDVFvXq2dvdAsCMxY36hQ0yFRew=", "Bo6OY0Ed8rOp18Vn9mQZpYDTuhW7/dEibv+j/WvUezw=", "A0TQx3LC8FNmSnuSZrGdSK5dKrPRwaGBUHVKtLg2r9M=", "B+DMoaNe0V+9thm/rsx6mo9MUSk5J1YqzqjquBfGuEs=", "Ii7fPia/dLL1A5gxiSAdTujm1vrTQdf/UHSN1zl0nfY=", "LUMItII7Rl22U9NoGBgSCdI80S+ET3L3VI1J5VBVpgE=", "Lo5n/IX5tNAOnhGXs1vt9Vr9cwCkw3CYfIPBXPc8rjw=", "IvG8TsE4tZYSjOXuW4GElkzCYjGOF60h1FxVJHf1PmE="], ["D8nMlSIvknFc90dgECJeFMw48xQHHlDg87yexnSoqsw=", "L1oqDNDLJIlslIeKgQbVfoLGjc8eIJFnpFrpz4Vw/tI=", "LNGbXFW6sYCeUsyfwaA4wIk12hnPxWPnBI1r0ZcKDI4=", "JP8phngf5ArmHo9coO8XxaXqe928En1DFUfB9qj1zt0=", "Eqh9DFQZ9EhBmEDl5aktJ2rOAJY9mH8qEAiRPZiicRQ=", "CvPO/yyGWpAblAbV2bL8WIM9ZC9Gxkk8oDDvWVBh7Gw=", "J/QthoQvTYqMOv8vR//B4Xnwl6rszlW7oLD9/VsZCqc=", "K2s7w0DUEZ5Xgx5KIYcBPxIWqztjmUXdkqmElDJB8dA="]]
    };
    exports2.default = _default;
  }
});

// node_modules/@selfxyz/common/node_modules/poseidon-lite/poseidon7.js
var require_poseidon7 = __commonJS({
  "node_modules/@selfxyz/common/node_modules/poseidon-lite/poseidon7.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.poseidon7 = poseidon72;
    var _poseidon = _interopRequireDefault(require_poseidon());
    var _unstringify = _interopRequireDefault(require_unstringify());
    var _ = _interopRequireDefault(require__7());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var c = (0, _unstringify.default)(_.default);
    function poseidon72(inputs) {
      return (0, _poseidon.default)(inputs, c);
    }
  }
});

// node_modules/@selfxyz/common/node_modules/poseidon-lite/constants/8.js
var require__8 = __commonJS({
  "node_modules/@selfxyz/common/node_modules/poseidon-lite/constants/8.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _default = {
      C: ["IIjOlTRXe/OL57xFfydW1VjWbgwHucwAGlgL1CzaDnc=", "G4bmOQjEsSr0POxoEDVslNIcnjfXPf/5dCpY4Ow1a+E=", "CcoCK6EULRcPdVIS4u3J0KSs4z4Wgl9UDV1Q1aAhoWk=", "J35p1HoTOAQkH2rr6USb5uIshJxtitjJOOr2E7wa7NQ=", "F7V+oDdU4krg70Jaoq2TGqybpUV6GM7FlFRaI122smk=", "EcdAmDOV4PSgJuLHyTkjY3XJB3dV6xo3p31aH9dKusY=", "HNhVKQEN1+L7fqQDUVurVydVakecWbgi78WoHrN7xb0=", "LLk1QALOxLy/qYXeNPQ9cCztg9GXqjdLWh+W+HsS8pI=", "H3r5jgj2h3kj8no9rUDFJaxS9W+72HhQZUT5rNYaoy0=", "KxUXaSXfM6RcnpmnxPJq2UaxB13ljHBkwP+SxDHTHdU=", "IsiYWbTTmdOmCjItazmbiAYTWEk/PLNlP9qUDpiMHKM=", "Gp8nMMgIVNj23ZgQk2PUBVlwOTc69QVapn/BjlsZOP4=", "BAuuLFf8aOPOXilJmOoGDiVj67rFj/j8ShoKQFdfDtM=", "Fr9PViJylGful0nMOAYF0rxNiFy5lpmqLdhWXE+vi34=", "EEXs6gRLocscO/B/9JaDkKPqB1ABshY37H/O9hsRMpo=", "JqMZ/mt9bgjdbOqVh8/j9SNJLs52n3D2bTthl6Ji/Qk=", "KKVim0wggzh+rLCcFXElbRcu8e2cBzhobahCFrqBvW4=", "GGviK2oGPRjMh2DbpjsRnPxtiJfjLWoLGd4oBTL6lyY=", "LEHq+cASjEhsVZWhztaz3RW9m3MhjGr4gTfLiqXFdOc=", "EYZCZdduiHO00s7M0Y2tpGq3ITMh2+BoNyf6LffjzXo=", "E4PnNx1/Prdfl0Yf95VlU4Fm7eb7asaLAstg2DIkZ+Q=", "GgBTRuntxZVz45ifNMME/xNR3pZC85gWNgLhOMWcdGk=", "K1QTRbxP4VidZJJwzu1LLcYpnGml0ktGDjbztOtIYFI=", "IT5047iGkgaLQg/ax6YvPpD4fovZkzELmCiBtOp+tY0=", "AlQ3D99g4xnfXSe5hOIdiXnIbMbJ23e0fp4DfUGuK4Q=", "CDtzd5h77T+9DF7jJ5zMsxmtqmYLtqec7uYn9aY2nss=", "Cismu/K4SlW8TFsJsgnUp3ut5OywmZ4qcAIczNT7zhw=", "KHCQ1AfExSk81yvdiBrOGkeFxRiJrJygU/rvBoUz6wk=", "AKn8whojS8IqRzwEkx3eZkdgAepuMpMSd8pM2rYqhYc=", "HXn8xQZv8qYtbsDAlvPAYj+XIsXRDWQROGuM8GYG0RY=", "HS2mdggbewp9h6V8am8skQIqgikZNK6NZGgU84t8nMM=", "ASEYnXNi26kvO7ooc36iR+hf9LPOq7Tq2sJvennTca0=", "A7oBvcfzG0s2JoMdXoKFKl2lp/Ry9JdWQ2LuY71tYQI=", "IWSHrE7qgeTYNbIgx/Hnt6MxLfXtC25gahab3siaNcs=", "DrXrQkvHLlsgd51hOKcpbcMztNmOTO3mmMHY8wafyAQ=", "FHYIfuaIY/5p1TjekPkL8nGHX6/sOqxoMfoXgRr8RfY=", "JZlezwefT4GSXOgFDmvdC0QOet+wDafk39ilquwAnzI=", "AbWQ6hRd9hUv8Ojsy5fwV+s3jT3IWFqBlaj8awPd2yE=", "Dr/tEnd62XR3NNgvt6tZ68hfB8PQVeuYfdQkcOAWvVI=", "LgO1Gf8HDjG60c7SXQLeGMXAczVYkPJtZDfJmQo+Iyw=", "Ao7Ui++3BTShV8C8gDc0eDD/b3v/7ak6ImYxF8MDgQk=", "IdVIDvIojPN2Jwg/XG/1gGZF14eDOXkhadEJlFqoecw=", "KgF/TKYnF/6dYW/Dt09CaiJmaiaO7RkMklE2ef9TGGY=", "CFzxIwhNa0sLKzTPBs9viT4KnbZklYVg4TEC3KJYoYI=", "Acqx62GuWpxPGx8PTPcQc9Bjz46m7LOjJrw/LyT8MKs=", "CLZZpzfAp+GYxR3gdDjn+u6UNpcVBCNnSV8DBeibuW8=", "ArOt/vlWAHupSeBEpoEVsKnIlagThudpdE57WywwffY=", "GlAqewiD3q+bJKe0Uc9DnZsExAry/swXKwV7T8AMr6Y=", "MEilNqKnWvQaD6WWdSyD7bGcRsAOQHJRaizOM6Qs6Uk=", "AdAIIWgy93c2ufLI6vGNKuaadZWj0uhyXnWz6cZqsiw=", "BnOJ+mcZu55JNCRXbTDWJU8bfVTmnh0YlsGxXuhcDCA=", "F9oEy1BghhWIpN7mDazsQH4I1rGWUDWUUnBWmbzcq/Q=", "HhELJFJs8ZRIoEtx+R+DTZA6CNOnZY4F/wEEzm3hSvA=", "CwootnJp3PskIjHHOE2blsRAZwjxp77CYWDiNSqCDjQ=", "Aia6Ijv1zIMbymBKL1WzJK0dSym4GuM8vXORrQ3KDGE=", "H6UG+ucfYX22oE26IetiJKzKxffP8UWUcJO/zi8/XPw=", "KXJMwpc7WzTE5T+5gfJzWJ5+BGeltLWhbVlvSIRPA5Q=", "IBhYFebVvUPXabHns6QjadtE+tpEU0qeQaGBp82QysQ=", "LLXsq5Si+viZhrVlVFST1dhknXOp9TEzthSvbYk3ZhI=", "BncnBKamw5by8YYnLbglE1xZhvvbzgo/2Hm8J+4hNL8=", "ARK/9HNmeaR3RA50TX/GGR4Wjv5sN/0L7rbmTTBZGFE=", "L6rMJI0vdCt9xQsBO+nEsuqNAL4XKDKtB6wOJo45Glc=", "EV6gU5FckjHWuacbTzQ3520Ir26P5+QqOAATZJjfQKo=", "A1PiwoRcD9/FP1g5Ti26ygYWTRDbr3VhJ2IbWiIYEjU=", "KbNoWQC7rKkQNjrgzexfYcrixSx+3j7AEOKv6sdIcQ4=", "GnO6mFuCQgnQqfMQkgeR+tkieyG/2OijqfHC+on6waQ=", "J0aC1jodap616iLgVYsUX1ubXoRcjJ3OuDvpQzCaMF8=", "JJ3mY9/fZoLdwSLgKqwNeTmPOOYInZLiyJLM+Un8r80=", "B2NGpJTKSZkYIp0vr4e2ta/UmS8NfUAjy7Z36kN21OI=", "BxIVTrQ7Cj6L3ZTimthZOeIg2vaTG4RGR0HmTpkmtQ4=", "Fbt+EnufyTdkJpKpLYZJYOJJ3fMn/GySr97dib78bDI=", "DUONiFw/zlsGqAWEAV6veorgXGAFLBCrgNgAdoANjhE=", "K/+4c8mwR2Ky42LWGVyAE9z3pf2IGJS33Dg8iqNKngw=", "JOpCx29zUNCOixAWZj/ao/hVK5Vk5botpFt2ZScH1sA=", "KmLqIaCt5HQLgIudg4tO8gWxGTtXns7ODaNFI8SB37w=", "DEl3Smj1J0tGjOoPMiEcyajKhkxtMvLGRLGrie30dek=", "CptNPTJWTYPCTU4FLcMHLP/WHL/67JVxUf6tEyRgc8w=", "IhF52EiuPCm6oN6OGa05nPAA3PzlcqwxD8ZL1NIBw6E=", "FwIpQ1JXmkPRnaFd7h/csqcKRd4lIDQ14jQGkvf14KA=", "BZq3iCc2AGhc9t4E+Hyp27zrGu/jf3eWY6fvUBnU2OA=", "I69ksWIr4Hc1rxmZaROYrWoDQCmhCc5DXxLBshtB9Zk=", "EJ7SHiRWrX+UoMbKbtlC716BMkM+X7pu2PSbIDhZRRY=", "JtnM+lN50/1pJ6WJWDONYDeHInHYkfGfZ/cMOeCJMyY=", "JOqeLbNYwb7Pfc19DkaXmmRyB4Fq5akB+wCmzNmR0P4=", "ABWpuMM/zpOuOXHRk6Qwvpjuyh0nc1l0z1Ar+yDHG7w=", "K7s2b3m8O6oTjXmparXNFIJr06hTR+VZVQvzUfKW3Bw=", "Chx2ZB7e0Vfqob9KrclWeR2eeynrFNB2VK8FJoa3Dik=", "Coqfnujs+K0LXNhCF68m/c4soWwHvHR9EDq8tIqyH8I=", "JtaFK1kX9OIpxGgk0AtERCt32OVm/js5Abpt4gEd6tY=", "GWAXNMMMsqRO5KMjs18sFx7Wfg88H87HCW5fAfuuaIU=", "B4lffwKfhMPxfjWbDukm1AJQVYfzhsu3EHC8F8yH0EQ=", "BYB+Ciskc/O4cTBYbHhoIo602VA78lzCsPNak54O9IM=", "Gsm6jrni/eCnmIaqjH29NiqkkKNV4HmCgovj5QmdL94=", "Ixx1lfdv6lgoZyr8W7tkY80A56BzRuJYivVjjjsyG0A=", "Lj0WdzECF85fzFj0A5Uy/5RuLv8rgNF/WBynjwBoZy0=", "CXQWNEFxKXWjO0CT+SLX3xeyvc57frAseDDFmARkAA4=", "HPXBpCgIIqWd7suCpkuqtO24eXfpjuKRObtRZxuZGbI=", "Ea1G4TeSFQz1eTOqlHbskYS/1fI95G8d947X6UzIEok=", "CCj7/AlRweoMDz1a8v5Xlu15Kpw8xAArQeehu45j2uc=", "AscgqEhucSIwUwTs86APmYVFNcT/QE/oLjDpnoUA/PY=", "Cb38lC+6iCTAo41vUl+RdjYNKIGqQlAo8c06f8PvcsI=", "HZVKD5MlDlWBxriX+9cvTyqUPd5R4mLn3MShssqC4rs=", "K4KTUuKXqyEG50+f5wL2ljXt8356sOGn+S8UyYrtVus=", "EtO5F+WPH0ThurqjQdHaySPfrHVILhCK8cMzaHNKkE4=", "KKnmxl0G7W6kd5W96bF3tVCTBfhTJgYq1QFQd6/ku/s=", "K9PDOuMRwvjUrYJQi3bfiQwxH8jSMvvC3FNfpZMiHKg=", "Jy0A16j7FGO7Yk8d13TtyPOgkjv5BZuuPYTaI3Z9aHM=", "E1WnlqvfqpA7gd+uMhAaEwaPUHBEBVLu4KzypNB9A70=", "BzS8vOQYCuFtSmaJublPKwLMfXTKjvFZLNFq/ioDNyg=", "B3jUphTC924oGZ2YmpBS4mJ0ZLYg2R57bT0V29R5nVQ=", "FrvJgKZ7KmVDTQh8UBhZ0SfbN3rhRP9jTLhXT+i/hpw=", "EqPn4ZewUExolDZiRb7WXjJtt8eq8sHA1Z5LrBDWM88=", "HzX4xEMfsNv0LZ0HM0/Wf5kWD6n34g2BH0uP6n3V0z8=", "JdW/GoY6CmRBz1XnyFuPIy/xVW53+8xtcei980m/37w=", "Fea42at+Bjo2OCFq5HEXbofuTOMMwkytGVh6IzMjIKo=", "AZKe9HxzIrd+vQ0aQPnsTUHrJkG/ujWpy6e3CKU0yco=", "GE9R55Htqi3qeREVEke61LDoZNeo9njHcIrGXFHju3k=", "JgWt9VYtUFX/soTfHsDU43Hu4Flc4UIqxTWkEFl82GY=", "BubUH+uDLC/gB+G8zIFEJYW8nq4WEri8PSpJJcI5rVE=", "E3632gaJVc3ijbauXngLeuHA1jPN0RO/D95DRayclU0=", "LpeTDrQZ9zU7onslh5dT/mTX0YcCPOLeS/nnDrpum7Y=", "E69Ak2IIeGbmLWhg/asVkgdAW/nHWp79kyFzah2BJBM=", "D9L5VASp6S9G1XyAUHN1cklmJkVg66+z/y/RklnUfWI=", "C92TrCGu3zGCb8MBL8j/8UOErdUh2YE13zznDkfTgRY=", "CD6meNWlPoqbYBkGvvvvI4EaYTd4i7hz/v1VIffZnwM=", "CKmQa+bpq5PL8blPCQ3y0C32xsz/Y2TC7WmG1h8Wryk=", "GHscgs+viARJM3z6d/YY4+0ZxgTmX7dosDM9jVNeqkc=", "JFAF+BTjglB1EUMRf14n1cFz8MpOoqgbG48+kNf+xPM=", "JapaU+xecfP0f7HPjqjHV/q2mmEnT7Nuracd6vFhTbI=", "AcJEou0ZInU7Oexrd18HytkbFM2bZXi2RJLCzEsMi7k=", "AWZOXIYSFsTLEM86O9Ua+g8+WeriT81+faqoU9RsOC4=", "KvABopbBEeQeMnrSEu0wI02ivq2gRJ6h0uDwoA5CQHQ=", "FgIr3WfSreFfZhooff4jkVQzsnDyjCTmBm5FA5rtgTs=", "Ey18pfk18+iGQmitcj6HgN82kWOEpUuBLHSnSaJoJvY=", "IL2rmCnkjImpnQ6LDWm3mkonOAiAet5OxduV/RhMTzc=", "KNtJQ1CunIGrUtcZ6gX5jcKv6HvBr+VWFh5hdyJYqVE=", "GfyS8dLB3AQ680J7d+p06Aq59gQeDlHRsk2cufP7PtA=", "Fr6nEmuPByq2yGr8qAtgbLkMfl/QK726Hdczw8uIRwU=", "H8V7FopbrcoVpBfrtL9b6yj9CeDf+IlVChJvWDPx/V0=", "GtINGj7lWbYzS+S6kR3slX1WaZzzfde5fSPcvGW9mv0=", "IXNDCmhCBh8Cc5OkQ7biXlmj5bzSCJWt4PzXvrzYiIU=", "EWcxcwQ+FRNzYdsFoLBnFHoj1/MANoDz4VNLGD/ifNg=", "A3yAr17VHBwiGB8+dziAaYRJPrmYrdBVVu/2USkln/I=", "HXC5YSRtImLKzYwJVAQFSLY/vSXzA4KFw29rROm5/18=", "IYREinu4DRdtvj3nPzg6kJY15GEMJYZLLGMlIYa2xEs=", "A73KayL7gM+eezFxkOu7n2x9PJbBv31QE/NlIaXbp9A=", "K2WHMxPVv/pE1RDcs/VQSENvTuqRoQDsDRr5Uutkskc=", "Kn/QLvENscncA8nL6C6FfPBvN+oQ5+P1ObU3eMonRhY=", "HLiAzqGSFThlcTVl7kJVznLaI7PSFC0mX7whlvuLVp8=", "FmKLb4P8NrvB1gApppyEPSdIT1lKfjuo1HzfpUipGlY=", "JvqbhOhV8QaeduA3EE+Ihrdg1JGb7XmOLkuNvgCA8W4=", "Duhsh73w7NUm42psSsn8m/BbkWGFbWWMG57NgNqeloc=", "CKUXmZOoBWQFUny4K29hmYTGPNEV/+06ZzT/qFJnGR8=", "BHqmHkvwchrE4KLykeYhJLzCrTlJ3Pluh19F337rVDc=", "JjpRHwM+H73G0oK1JxKgm/XR/sIeqLv+LrHvW8TyEUg=", "ImUgv3MEhuLYyFm0SbvadjG4ZDKiwQDdc4bJsfmT804=", "K67ycQelKFR4jwxalA9aTfDRjTi4k8uxFXs4an01Y1c=", "GAIsyhfyaBjVTmDjALXJSdnJISL33lZRpgz3DI2l/FI=", "B7qtMB1YRg0ebtEPUqvxvXhcrvhWV3f+2U3WfeZxfSU=", "HkdhBsS845A6WqxuEQ3yzBp/cbQTW+NmL0sBBH4kimo=", "HgGd6lAo0jst8GPCEEZqiMP8Hr3tzLgEXH6dG7bnepg=", "DdVfAGVZu2dHslTSmnP16nF0xrYGfnMKX5qZCBhjCOI=", "CZMIWoAkpZjgyQWdO5GfsuvIG+QIy5b+OKSKlSwCkYk=", "FD88v5jkCXGyEVST7gbibHiTeHv8+xOznxZYaex/ubc=", "BSX/KPokKRuNAzsCE5V1T6Aw1JcxLMF8qv0AhSTtoH0=", "LZ/cGM0lhrn0SRQgF5CTkgJQlRgtX0DVkR9wjrBc2FI=", "IwmXIC/NbwUeG/Hlmp0BGI42IdYT/g545t+0AO+0P0U=", "BEtWRp/7vJ0MDwdeIPOQ0w0RmBp2flB7gK737WnnFx8=", "FQfYi74QshwjqUVV0eTTeapxZy4AJFA5Pq96I3NhULc=", "EE1nUqdhtQAmN37HmEBPcRUbPPap6hvpPGhAWUgk6bY=", "JSdjBc3q5MFlWN5g2nKUFEap/SImqmBNRLv/ErHg7CM=", "EPPO+wVNYwvX3Ex8q9l5QNymg9rYzDWm0MMMvZgSBRw=", "DkBsv6OExrJO0EP/PLHWiRuv8Fha/E/OzHzM7ICd8D0=", "GPNgM/z2TxvaDBJhawC2EYY+/biWbbftNTTP2kCurw0=", "Fl0CKjTPEK0yVXI2NaUaNboqbbB1ctuhBtxWymyTfFI=", "IjyMmu0wWz0YJltW7Lekz8SxDli6oTZYJ6U5xHgZQk8=", "IQP+6UZ0hAsaoYWh+CIe5FEaK1Jo8ayW17KMiYT95tY=", "HBOWQzu56smgKr8jkJc8FyPsXNVSl6OHqSgG947504Q=", "G+/uJABaiNLJrpImFp6JgQaZb9Mv7LcrDLTezxCfG5I=", "GtxJ8fG0Bd9yemTphnXqCsL8dCyAbw1ZUMisQTUPUYQ=", "EKDgyrdtsLagB5nasfLkp073ORc8+qstA+riQMnIR8s=", "Gpr/YtbGb9/tDrkbbE+XTB4EfAsn70mxDSkzrxrz+Zc=", "Jhln9oQJldr3QRA0Um61rHJfleIfw2yO0ZGHOYX5XLQ=", "EzgDD4X80vrgnrAW9CVAhuGvL4j+fb4p0YPIntUoYJg=", "AsU3RdHw5mSZ/xCed3cn51DBE0kUy7TVK98WSceRGto=", "J0AQA1RAbeTZTrhXocXfHA6I2LC4LRDBJ26n2fYqBdA=", "C4qRU9PWQ/Cp99wI8k1whj5PFQ0cMqyJBaYiaIfJvO8=", "Jd1z2B6okYycH/abC4ag7TgB7RqkBZ2U63LPVIsu6h0=", "JT2BPPBfL/HH1mIr25+q/yd7TQMSpYiKnc0SiRrRUm8=", "JSMyLS0qeMxUyUS1d1K92NLI5i469R4CDrLBXtgw9fY=", "KsnC1g1FaEjo39R0mc29TyN387SsmOEOKuPk+DsAcbQ=", "Kk418d+DNEL5zLjHVSOxrIqXFhdPR/sIMNlPm8Q4a88=", "Jw5/axXywOCSYUfL95pzMLZ20XSstltzBSLcywlvn9s=", "GTPvddS4YvInRjTh9aTlDOiZ8VIU8Lj+rrssou9SztI=", "FlEw3fd6gtuEJ4oxhBEJ2kEI02S73GrLsbD6eqUXXcU=", "L8H+Ax3NRTjV2LE0DQ0331UF6WW359xMGYlbn2/O2mw=", "Dh6tK+b2RVnZA+rrbgKnyF1UZCLncw42Ch5LzA9i8W8=", "CpgzYL8yOS1d8wouSyJTWk8WH9o9BbGlBn0njiHI5Uw=", "LifmGChpNgfBfv+bseXtC67veC6HnFIwuG1qedcp9M4=", "DRzqJqCCB+UirOUF6DfKos57EFy9BOfIOMGs0Ab/pT8=", "C5WNq8moBm3p5M74mryC4zlqA1aDdvtEzN5MOMsqGUQ=", "FvW0LYj41PeH//95a8+BdbHNzjByYd7IbPIDSpuIu+g=", "EraK7C2yYuCmHw/UuXawDdvPdUbvJ/R9dDWiiMK2xjo=", "HSI42Nl2jcY50Gylhw41A/P4HvhjMAlEyHt3Yoq22E0=", "DRZOMvyjw8jaOuMyqDHMmpXnXUgzriMq44K9xreQ2Ro=", "Avzd5tbqvX8voZI0+xV2YbdipcR7V3OaYgANf2yo7zs=", "DxM7ix5U9DSEV0ZHgSyjd8gCoVkN9eW4+cjCGQjvvjc=", "AwV+qJMum/fRpLrYJB4U8eYK/RO6TpCvtHLZ3SnEK94=", "I9vLbstIB3QN69yCX3dkVxvJPzNkWCXQ5FyIsAiKnxg=", "AbkHVKIFghfNtkq0XiTC4pQjvDp2+CiVeZJ+zfY+2sk=", "KNuACuFtcDPI4QfhmK6qu/nQJxx02VfGu5UUoPA4+pE=", "Avl6Nu+Tp5BMvb3Dbl7zdOWOrze1uUOUc8vkd8P6sXg=", "G60dljemrW21y9Gbp7lVpFuegInRaXRFoTB0PgPtPK8=", "K5b1IN2oJRqHiyi/ltKBhVucQyILCjJ5F5dT90DtroA=", "BB+X92xgso4P33l0v5IregmZ4ODkDGVDeK4ShDISkJ0=", "E7XPV0dQV6L1+20ICTEjlzrvlybL2YNblWFsKu1ViOA=", "LKQ67VrqFi6Mm+kqFeetCvhNRPPS45i190kfot8S3u4=", "CJ9rHsi1HNHm6mm5ZJUgpvDy+W6hHfJwqwxdmttcPfA=", "BPUQz8flKDcLq7jtfFDDTGBBdyYneToPNxHRMAtNEnU=", "Jg4SxH0KtSVjr/zdXChi9LrVt69O4DfqX4Fk0PE9EFk=", "GmVkJHYOdUaK7dhRWzER4WzA1g+NzkUfe7NbEt7Hcrc=", "AMyFDpWcVnvtIAWLZ2n8J6bHDPcvIiuAh56b37xnEak=", "CIlHkQ6ztD69hohpXGSsAg4Z0LvodafzoLaZvGDxjKw=", "LCXCNrtIA19F/eWxeBBWVazp8/mvsJBx55DcS6vchr4=", "Et/hvChlT1ybplhldpyeR/K94Ned292iFwSQSykF2mg=", "BWRbaPmaVk/wj3ReFBO9g6tbBELwuO+qKphqbPsv2Ps=", "F88+yYMbTW6tZA2RLkG0xy6cJZEmv2MQ+ksRDkOGTHU=", "ErFfKP7+XW+lGaucxnp4xX3XIatEryhucvu9Vommb2E=", "LaRPchBSB3nL2s+qsuHvAe3aju22/m0Df/r45ZhCoAs=", "E3/3Mj/nV/Mq+hZfEViLQDvTk9XJqWHNL32i5dmolMw=", "ExgQX6n+FUnwTvSGecc9Rrke4L8ntEURld6UXIz3iv8=", "FAikJZ31KkkXdZNrLC1HahIXCMMS5jXvjR+EPDujQ40=", "EM8g3Vc0wYiA3sW+RK4t3MT0R/IMrJjJUZPrdXFYXQc=", "J4f+RiO9MmTgyLWkcZdKwf6x43+8OpyKTqdNYBC30I4=", "G5DiEHSQdUXB3sPFnb8qax9wMli8A3B+M9tYLUWrFy4=", "C46RKl7FoL+3eaCAG5CGPt/ZQpp7NjK7UCL9vEBjbPs=", "DZmCN4zZqDcLt6VVw03zGD7msNir8x8fVHo5kwRBiNs=", "Hkl7z9XJXN/WMLCvv203bymkaNHNPs3lb2lAIh0kivQ=", "LWAkAcq7xp3/PdVS4nHuwppaSsvJNWhsz/mhUHZYW3o=", "FwpfRRj1hUQzBnGtKjYfLIA8DTVfPhCleElR8qvvpwc=", "IbOiPDpVPUAcCFAuykl76Th3avZx7f5Ex4SVas+Yhl4=", "Ik3Ul786Qke5xIyaw87lMHSQ6CShQgTtiMKxFm6OR5o=", "JlSWWjvzySQi+1TmdqyEAbqvD2jUJmTjAGJKN1MC4O8=", "HVJfQQX1G2nABoKGcOd4W3Julb4WDuGj4plneCCDnzI=", "KPiNCJ9CHKK/5pcnD8DzT1DsQaHt5TYSxS23RHm0syM=", "CC5iEVPuNDJOn7f/PRI/yVYO+a8PoPlI2yTRyObwepw=", "B/hXgzdSOGex2UA+nKYa2ZwNfVvN5PGdh1LhKk1YBfc=", "LlLzDdBZMa231+hSVYSbBiuhzy641ZIItb2o411pgZo=", "FMs+VrK4xmBboEJhqLEXeRyvJvfCM7sYP4P3LvTI80U=", "L9a05siSYJ/aIUFN2HEt6EXqswW+Yn3002yNMlyb16w=", "AyWJjIQ098oy69c/U987GtsMmUCmnpGR/ZlqSpYVe/g=", "CPUKe1hNwCK4XWoWoNPf9rin7E3PXsBm+Z/EZE1tXUg=", "KcW7uOshT7KFyjCkPP1xQdnOuKGf88lw8rv0ybrp4R8=", "EmTL2ewAEXUhHihWp4kB5AiPHrfq9ZNJmeGZcwfnQyw=", "KKDngZqgJR6c8r2r9k+tvVHclBZTOuM/fLl/0XdohQQ=", "GpvmUcQS/ubIAISEd8u2fkxS/CPlGt6cSPavMH7GIdY=", "G/cKJP5/yJRv3eb1VrPtSwPDMAXL5/NKwRKW5bDHX20=", "L1bIwDh+XkTPSSGr0zsVkMrQcZ6TKjYZXFE44Masg8I=", "EQnbh7doT0knsq/u/wBgivXyEZIOuNY446fJQ7KT/t4=", "GFHCmAQCW2+cacgIkQNVkKUdEwMs1XbTMsqJIivHV4c=", "CQnkzcC8R/LfSJgQa1xA8lxxN+HVrJqYbJ9m/V3637o=", "KuPpDiZQ4obVkT1N0ecdTyM2WXAbMZqiKOFq+fAQ4H4=", "BqbAFflRc0QfekDU8b3gTrYPvE3HL9q33YHsVXI11TA=", "L2q101zP6eo2baJXyFlvpv8w1sRoFqO9PUhMl/jSRGw=", "AfnGAwgYLrbUqD+ScrwiCodF2ckScFCJm/ZCb3q1fN0=", "L1FMQSv9l1TmeY5MPLE9XkxLKWCdPqVhfe01vAHXmdg=", "FMQWK5ye77l5QbHxM7sYIl0oKU0JLLiRevyz4Iq82cw=", "GZIf1iXGbsZ+zYrz1v8OCjy2UOHnKz/JiISwA1QIWzI=", "HIUq78kpZ1PhJoc5rBXSxtId40NsgW91+TuN6/N+tso=", "BL9KabGqTzBK+qHdG/YN4fVZ6BZ+3drB64itnQJ0X7g=", "JAp5HzuLti1dmq6A80HLVp/j/nLnGD2OWDAWXk0SN1M=", "FRspW0JC4MCf73vF70Dx48hVFlQYbWLMZj7k8o/152Q=", "CG6z0wvE2AZkoHSglzncjEl8k89+ZXlUsMv3Z2Fl8j0=", "F6qJkte5AerefqzZWo6JOCopKnEhqw676+DdYmIsIcQ=", "GlszRaTA2HVmNldge1x/+DL0ibI6PEOWIAhXD5brjeg=", "LwO0bZ7u3Nf49M8s9xDkjOPzHRNk8DNFsqeWSwHmNHw=", "D+9YPn6OEC/rqHn3vWAkGHCgKRcjqjVKNSWeCkAFDUU=", "Lge11wylg89Nm6/6zQLX2A+l5SOrvYlQhqNiiLlp+mo=", "JFmdv6HdH0cU1YUkjPI8oTlLhYr46QTAUXuu2/Lxdt8=", "AKgmr9NwvLZbZhiejZhnd+YTdziNhyfkB7UA+1KR+O4=", "KHRZUIcLwYSK28X0vANBXwor8j6QXn0zytA96QcIHjs=", "IZ5tzaWQ/IjUBWc9LLRxD4tXR7Rt2ZFNG+QIFxTKzlg=", "KWaSB3tC6XI5nxe6cf/t7dlRhf9yU9nR9BdHxvJ9vmo=", "LMxfDiBJ1CaEGGLzL4Bigp+12CampIPdUHjehZ+cvOs=", "BPkVpPq8irIIphXdifogfTZ3ALu5vAYdB/qQpw/v/aI=", "LgS3waqFP57l5Pu1zXtuYMzqTtWSijT05Z6p66h5Rwg=", "CHAN9RE4s2wO8r7RK9eDQOxpsEouG4ZRCANjkbS22zo=", "JQMzY5jxZb3qjUkp2x3Qs3EEFv1j16rc7EG7cGLCR4I=", "BWM3haUKnHdXOrENiTNBoMwt8HLtjquaKZakelJ72u0=", "C6QITkTFDhQSpMmC3A2KDUYiUTt8lun8yyw74tOQHhw=", "LW8yy3YUBt+p4D1/+KQ7rhBtxFGcYcOZbMnMzY8wfIY=", "L5Wcgwc35jE5WEY3Ox99ADyOa6466i7bc0kSRPg3Noc=", "FIY69ZeSrbG7QJAWZDSSF0mNmZJQzAqFjbJ67VT7qjg=", "J2I9EBsfkiiZ+cV4Ph/bsedVKCbk1rWNbfjZhpN83II=", "JHMopNnOgWA+N+pyzF0ciVwh8JMFMBvxQRwHmGAqYmg=", "GSGQmqrQPMeKbPvtbBBW49k6JaVJbK+soSr0zjJMYIE=", "CoXANYzziLR9FNQv6vvdQ5LfFU9km3IT4pzxAa7QDYA=", "AbrARzSlkg1l1nqu4EFl3mIb61b5AspIOGD3B3U3US4=", "HdFyCWazIxuwCwjWuLrGx23uVFT3hBNLk9jHCrPu2Zk=", "Iol968brKn82vuHn9C7UsNN61pZTXYLTnM+76S6GwI4=", "KtAbtCuV0ROzuRrYjGmjPB6U3IVRK8UWjucwZbOH4XU=", "LoK9CgU84Dr5qpR99fExeRUppX+DYKLNaX6qF3xgALA=", "LS2urqqTpfnYtlKfAMTG1pHDvE77/I58LwiuPkTh9Ls=", "CrCJFLLeVzl5g7rOCzJ/mMGpweWMdu8ucWzDBXJ6D3I=", "J1h5bNHBeO0MQzxPG2sZ1C/6G8iEw80czKEHyyvJGZg=", "Bj31sDSQFue9pHQeyJjHTkow/E8bWftxOoJJkjEeMPQ=", "I3EwFlVVRnU9QavWnm+5HkNEt8BYOASO0GQc7cX8Zyg=", "Jr38ColJmOaTt+IFnWpSiqhqtX6wMblrU/6LWtt0wHU=", "CIlxGPdcyOkRXaxYG5VTy0B6HeE1tjJUG7c09TmFKGo=", "Au+Osseyb3pXaR7LHhWkCvqbOlVXq+gRRupvbUlgw0Y=", "JU6OX8EbmSNI/Xosn0paC1hryq8SYDZYslkQ9jzwiwE=", "AvQcIbc91Oe1ENyhbntLQncwHaX7vVnbA9OjK4nFe3w=", "JT8Jzp7P0q7q6YuhspgGvChx5fxnv/E+MD25lhjh0KA=", "BDletlVYLQPyV3XmauZ74Kr3xjzv+76pImsEsOeVv8k=", "E3ESNcPSHddJ4+Qb0EijK/oueW4mty4FyZnm5hJuQCw=", "CDx1EXUQo31DtVE5Y/vQ+fM1kN3MKX483Z6kKt16F1s=", "JsybVxjYTmBlgtNdj9valExlJd3NdIjP8h1NDYI9zqk=", "Dol48EeSmxqUYBSZY0qNoCC5pG0LEYfVRQTtijRNVuQ=", "KxFCOvOaXRW+OXQ5tcpQqpptQSNKyr7SAGJHaI9vqAU=", "IaVjgQQMcC3aWjGlqidc5pJoViXlqne7xDA4JXO0ArY=", "Gahp4Vs/m5ZQFv7KLLgqLxTIAJRbpJ23Sq2Ok0avB/Y=", "KwHForqhb5Vp1GcAmEZvBb864Jeqkwdxt28kr6a+UNU=", "BYYUhXO2tWYX+UYC/WyGrUpxs/xno1RI1k6upTJYISQ=", "BANS4ZgJ3ZO8eixUm8GcsAeHLgWZoxJ6PncEQRiU+Yo=", "LWSGuOe5VJ6obPBE6JUP+jaXToQuH++HZWHhNGxaiTo=", "LqnS4bfQfJo4lVZYQOJYQ8nevliQRPMFwbWHLHTlpJ8=", "EuDcQQWs2GkrfOoL122jSq649tAOz4S08GInBBOoCHo=", "DanBBlbm9Cw858mApwydeT2034MHWZozpJHyS2NoKQ8=", "AvNVHGpkg4faYpyWYz1cyZNg2bia7CPBisdq8hsRqFA=", "IC3jOm/Onf6K7qNK8e1cdAkzhsilU9Oj2kbhNHMd3hQ=", "BzctQQVNvACePpH5AtV6IT8ENXXzQn41dopaUkgrG3w=", "AvfjWku+lpmUmoGSYpQ8l+jpOM2ZnNkRqe28cW4kVPo=", "Kie4SnQi4puMxzv1S/U1sBFgbIGbS6poJLYSMDbXP/E=", "GVJ+kJOzE9XSY4yGNJmDn/XY5fmOdLMS+gxjr/cWGj4=", "CFcaa4tzA2MplmYjHjxJ7SMdHjVdk4lMhWK6AzFH8CU=", "LA8yd47f6TLZEpYcgdiOmNT7ZMrqLMLU4/ITpdKhue0=", "JxCmPoT4vzsV2gnmm8JMVn+EpFd2ELGcxYGRsrFFPqA=", "LUuEQPFodF7YTD45P3W9wLD7PxSOTud7Ul68JYqVPdc=", "I0kB/z7GXgpPYpv26W6vN5rqfICMqe55treWiVkXaE8=", "KKUppifPxom6G7M3IHJRjHcgtFCXUznoeGXDa+Um5eY=", "GhryYEc9g0iaakZt3BhV/cboPXO1xcD+1VSvEcbO9es=", "L9WU3BSZfo4BI/OvFskonQiCZMwWqBGejwKrcnCVKSQ=", "DTVk5EcW3owC2Pgniw0vgZZYI0vE21kUf6Ol3CPuyDM=", "KT6axEi62kI3fdiwLVrlaV6Ibg+OQ/AbOCZqraPPqg0=", "IYbpYd8HKLzXtmfTXpXzVM+x7hKIrvt+CyOBKW2uzbg=", "G0ly7gOyeHonIZzeq3rNtdzkS/g2igxD4eO4yKf0nnQ=", "ARBa0mZR1axS6BfDLYajsQ8Fc4/OmWsvqQXOHDJ5Uio=", "Byt3CnDaskKsMNA/XSR3WVz1Ibp8kUeNcuRTWFae8ww=", "HjmaQhlqgGEHnp1h7Jf/jINxlbuTYgaZf1qTAhtw0nU=", "JPUMzDpoqz4sukU+xAqHlqPFlzXdMwO8+ttiGK77fWo=", "FP6S3JIntC3yP4paCnovULwRnwHf5wi5EY91YWcUvTw=", "JHE9hZUXNsd7ZpQcAH0XAoInGVjJj9QtaxJpanBlkW8=", "Bc8q0Fx13jgjj2MljI384NG2mN7ef+6pqXsmPM6BXOs=", "LWJpXHAIoR0Mh0tAOVppX/+q6m5r/Oha4VgNxIIYqiY=", "GeRyJ+dNVWMSZ3D6W6YUBepvNIVlw6ra0IMLPvXXdaA=", "IOQ/9YA3i6/iB0prL9UMdFlFN/mFZfLWXtjBXlyhCEo=", "Jk5IQTCawarpLd2ctNlz4jdAbVDShJxwkb8cG/XBJz4=", "Eji+rO3U9Ts1tXivHDDAd/QoloBlj7Jq4bTAsvcQ5gQ=", "DZBHTCYqrBkT83RZ1PIFXa3pA96bwC+l/HwTfM4F/jU=", "D1qvSCfV9A4AI169HNG59uvzOIOD5pJXO5XK5PZTrYI=", "LN2kNQ81M0dzzYI983CX7pZ8KNYtDEXDTQzuQAiDSJM=", "HAyMLrtoYOZNxGdVp+ByeVvCx4gyphi7ai1dCRG312g=", "Jp+iYGnbHPDLcFvDWEwBULhWQtTyQ9XmjXJAuOjAMnY=", "CbRDsKdnZXW5ptPwA2Cfp8e2ImNBrIOJJYiB2ZT6kcg=", "GRtGl6jilauA+BsldD/hPz+2mY6RMemahvIr0z573bw=", "C0iLaodfI4vDJPBCiK2GXIV36PkGqXGtS7nZF3VkVzA=", "J1kosl5QPJyVwBsYpdMAgbsM0xw2zRcr3h24Mof19eY=", "H94FPdhykdfhTw8ue3RhtJ9g5K/DnP3N5l1w9lw7Am8=", "KbLDhoFunT92EA6PuVQzKf+IrCkZmhgTWNwjGqHdPgs=", "BJh94+MSGBHsPBBCEAXhM/4c6cKqfXxUom9CXNGXZ8U=", "GaI7qXQmv6gbdX41qjVZBQYoZl60lu2HMtQJlC+24Ws=", "EjM+l9Hw4ygLXi+dllYbLATQAdKzk3kahh/cJsG392c=", "I+SKW2RtNTiV0GkooYHXWtJcladnLzofSRfKA7r/Mic=", "G2v/QjMX0sJyGWWXKCPKLpO48rsKUiRc7c2UWH1ZY4I=", "Fq8POHubqUwLptF23zBwH/N4s1JGgKr9pPfE30sIiwc=", "G/rZwakiNO2XxRrH3C2A8ukIwJiyi75xLLdbknl6IQM=", "KbtQZAc+mmqux7/ZTUj+IgfZDqiWJTDziEQspNleYlY=", "HL5FbsP42ISeEP6jZQmsw2R+3D52X03nSJJk9eNAM+U=", "AIejUGLb1zVjb3bO9vqztBJ0l4HwOzmxgUlaYqrkJCQ=", "HxIZFF/wvxXZZF40eHmnNH+aal896pqb+UlRdNIovMM=", "B/k/tBYF08rhtCuS1SeyznzvFK0rkHcCr6E9ds4C+Iw=", "CuPeim7dWJq2J2fpLzwZ778yEVZ50mKaXr0mwcfTQpk=", "FbZojod3JLQc4I+xdpU0e164hEQjxxqY68wYjCOIjcs=", "ExzcJS8Az+SM1ssbFTRLb+yLF2wcpVhNdtb59q0muxM=", "G9Vwz4eLPcFhbKMr9V4LP9iYRE0OcNZJCex4n/Eeju0=", "HlpU5x73ueq/cXwB3Zm3Jiw7Q9HWlgCUuOUI0eEfA8s=", "IciN42CzaiT7ZBAU/s6s7pSFYjPfvMvdHp8PNcnn/M0=", "LvOH3BASrpSJi4r8mqVKO+H5GCC2GrhvReyzriHiOsM=", "KDkU2pfwNjSZNq8RV8U22cKHP8PBVDr9v8HAxVzG1fQ=", "J2rU97ozlx5Nsiksf/cE0VoUJGpufXbqefEYkGbdQsA=", "JMp/1qIBTZghpiS/B5UOj2T15oktSOSnHNT2Pp4sY9g=", "D+jzcNJJaN5N7A+uWRnY9PZmZz7K54vX4i3CJ2Nkr9U=", "Lwu+x/aiVVEt80gSLfS5F3h3Ws5YnUZX3MEiOq+/JYY=", "GAcy7m064qpIZhWPVPTYuYABPMZx1oxppy1ZVWeHA9E=", "BaCwuha3sGMdviyS+RIShJdKcDOmm+MEB77GsVNZBwM=", "KQiloyBKmhRPZWXlYbv+mktmTtrrpBBuGlesdykBk9s=", "GMhgpdJTeoSUShB16ATDLsZstZeZCKjKjNfy2KcCnA8=", "HvgGF7AlvVTeU2HcL7Fs+5DDZON/eh8H3bmrKSr8DpE=", "KrSVIVzN/aSYUQ9tXb/awUKUZOd4iiKf6uVhvj1iwsU=", "JR3Ac78jAQoGvqJVYOG+PMssOOZ9ZOrGgK6mwZlSp+w=", "AiAcNmKlloWlEeJVVkNWffUHcujBULzsCUOorz8QaEc=", "K7kne4AhxdNUMA2gkQHSTHKoQvl2J6ggZeXmeiL0Zfk=", "FPXuRoeOYFWFs97T+oubf9YqIBe20vMO1hM5zKQ140g=", "EUV4ZotZUi/H15SrzSSXuqvYVfP7pQPV9eBIYEe/P8Q=", "ILwGo1/gfNUH0N0KnaaYfyKAFwVQlu5ozTPqs3c6EUY=", "GEgB9lXoL40yuU+wYSuqTsmD0c2UytpnI3ZwBR1frF8=", "FATV/HouiUB3gVj7LTAzZIkhR6ZL/uVLJdOQarWzSQ8=", "JR30M15RZPy7rnO+uMtXuAnXHLWdbjA9sFYLDB7nng8=", "CaRb5J81xPmHtY10nHjGkIJIbT+Hd+ukED6scZD6rVc=", "Lt4ii5uWsh3V4ebqJgqH+QLABR8fIDx4j7kH3wDlEXc=", "EAoxGOMkisQA5qqw5OaxDwfpbeWCwskjqZzRTkXW8gk=", "FYctuh8QR6wfrqwHa1dROtkv9xtqaisy8nrc4ISJThA=", "H2ijXYHAVzOlcwdszXlGpAOdoi5ClZUgc35KaEMoP6k=", "KhZaGisBirL6TlgdfLVn2bFRXbJ+pxCvNoOokZ6ZooI=", "Bk/5S5igWIqpJOlDymJ/y9LvhUxm+ReuUm9xn7QMZ1k=", "HINJ+JjL8tH+bbk2xTvTVktnO3LWc6qjn5aR4IKD1e8=", "LkYoqGVdL8hKMvEOCpXpLQV2c5wHBQvLAVjxVttufFo=", "AGgxbecf7YAhM4CodXs6nVF+fqHkgAoixRB1WkoewVI=", "Ip4yzflS/UndrIusyp7AqFufXx6LTrvZlexbgomlQok=", "JsmvaatKfggzXN/fM84QKhTPr7Ba0ACvpzg/Abm1uJI=", "FLxRQFZpFVGPINUUmMpg9uXkhnj5fBu1jhevTbjyMtQ=", "Iv4Gu6zMWxi0qL8syMR+NRKRus7lxSJvvQzbMIc0M5w=", "HcoUA3c1gRRLCDqpuXaNtagZAmJt4NgdgPU9ddJHrwQ=", "BBUujKMp6JKkUDYT80cu6Ut+MCWlktRiX0IMRcVqH1I=", "E85+3J8cfS7VMwJhUPK7bSYfN58fu0io1VbMWteRTjY=", "JPT6NqSL4B0LvleFTUg5nYHsA8OU+y7sVEpjH04csd4=", "JuBlmvjIOKrMNScQ8UM9nfnM78R71cSHoLPCmgHlWew=", "Ii+A8zJ/9zDIylhcBntc6UZyRwdgG3pKckdsT3PngY0=", "Gc06ZiFuhZ5DP2Tk+fPirZxY2ZPuFozq5evtMEmrL4c=", "DQGqgj7oRsLLaVVDyEmYAxAfwO8iLjwrRNhoDop2GI4=", "LheQGRjLb0+tmsDTh3V6p3xyB5JOF30IJuvMRcdkiLM=", "LjDMSWOQaeIQHLR5xygehxXOXzTRfAFkMKn6db9IStQ=", "GGlNGP5nWLNsOKxw0TRMbStwJJ25KnThQEaDsvAN7lw=", "JZfvwRMp7j4Mi9QLSnhoFzi0xSr05V+1vlKZlrVr/7w=", "AD6tjLoNJHFa6p/1RD0l7mQIkxhub/bARd/JHtu9HJQ=", "HhfkWD1o8OHnI01BkV8vo8e3wEzCr6q9fzu+Bxzxyiw=", "LQUJjvKCjXHodYg39clz7Je3VHvfoUM6VScWjun51cA=", "CSIMpX4t31obLylxYn0adLfBuDet5ko36OHw1DYFGn4=", "Iu5cbTapgLekKPivyZnrCYaK3FK0/M/baLP1+6UY4D8=", "G3AVS252z5vPRBEgPbHBnHe8DKi++QeuiktKrCcIQsE=", "GirZqDSk1BvA1brDt+lFMQD1jIYF/REu9reiW6p9+4g=", "B1qgb0Oic0M8+O4ZboV35foohEWVsfKzb2Rz/9o4OA0=", "Bw+ITV0Ak/91+wnOk0yHMwCPmU76T1VlIPEe6Lzt+Co=", "B9WpMBIJ3g+lbZ3uRfhICxLTOnO+AvB497nfb5Il3fk=", "AQDdSigzsSf9gA0orwQlSgGIUyGM5WWo9hWZWg8kZuo=", "Fkx54pBiAuc7z7gQXFwQgpOXvLAInOA7r8Xw5ifg2DY=", "Kd7Jv6KhLy+hvJFY3B09HrrR2En61Y00Fj10GSP4/aw=", "J9WQyV093c3UPjxA91ed3mRfM8ewzgPVXgeXgJYlf4g=", "DDLnG+AvqDAtiry4qyxqPcTpYudZVUAcHmpmFX37llw=", "DOzVkepPPP4MfT7fUvT5PWCjEmQzv5ueR3ENKYwx6dM=", "BwYnoEIf3oRCFvXyR4mz9U1E8aBhhKqB91qiJzNfJk4=", "EW9SMqvKusioufGjrIa/qX/ihYEews/XM/Egb0SdHeY=", "Ko7K7PE1WFDQP6Lxp5BM86K6fTuuMKrXo1z7Sm19vsE=", "JS7oot+6qyZcBgYAs/bhnyTkkd3TcZUhH5WRjT05uRE=", "I+1ec6QiPfha/pSP3vK24NPBIKox4vG0yJBU1SGCWOg=", "Dd71ENLHujLkMx3bqTqmiLufuGFzYlA3uGukxioGAP4=", "IznNXLdprPLa+1BzvZiL4Vplv4rQbDioLTjTF/D+vo0=", "JvtKEByXwGrMmZFQSD1EqnYrWFxCK/jcs3r7/fB2q0k=", "B31YdNuiHSYMsC8oDF/fePuO2eCsramYq1y4M7CdGFg=", "It2yvryM0clG+FItcyZwIyhRExO0C0qegStprrYRMiA=", "LnxDxiIuYyP2gsBcVx9qpio9pkviw/OBaY4sDdrck7U=", "Ge4OYPwtp6KVNxxmfOhQdyrNu/oKnqt6fJSlDJxoLeU=", "BNRtMsExynkljvLFJWWbgTjA4ZnOWWjleoLngPH6ebk=", "Ld0lvTfeojOGoDD0vMHUOCY1ptx+o884iaXo+spGvYI=", "C+Pp1HK4EYzj0BqS/BaN54VJNHtEUmiTMS/V7D0nJq0=", "J/qPI122FqWQmi8xiW3I3pWUeYcHtHfzQ7SP9Sjkm44=", "FyJkEqsvq2Ij7toLhIMzgWpN1kleKcpHzouW+Mh66iE=", "AIoqymCeY0QIbu2KcQo1Rpvc5oZGpDWmkYJ3oh0D1Kg=", "J6EGGe7DtSEbfOnDGN9+367Pe8hAmNwcWCMqwlCT41o=", "Bt7y32OOq5iZhlOTVj7IvIGJf+DxrcXASZdV8lSX/EY=", "DIa9WwBGe5hWO3rRs2KgWFOKf6oRCkOLnQ7HvoxQwJg=", "AiN8OHDKUcDJ2vCGUkcHp4vohF30ceTU+z8ufzDZAhQ=", "Ku9MFKUUo2zhr6nyxfHt6NAFMOAeKnBNcElM/Twpgs8=", "D0JfgYYa2oVvAfzw1e8Qis6igXNakT0k7qdbVYM7Mo8=", "HlYvKjqDvhMh7q9WT7GfV67Jxm5syP2hiZnVuqC0Yw8=", "BifY9MGoyPjF4ethdZiVSqgUp1Z4LizYW3no4edIxwU=", "FeWtNvcZzKg6QfZ3gjiMyjgMJZkuXNFMZw/Twxew6ls=", "DMjRONCFT5tiaXt3kdqWC+UA41Kc3v1PCxjRbF51fOI=", "F/9VW1LSi+GzxGyAlG31GeneJH0s+NgXUIb5ddJMHos=", "D9XdV8LO3odmcZeNL9KJqgoCaTJSt09/3ui9QE5seeY=", "IDFEp3xy6on8r/ObFB3vfpOh2h+54it9DGczvXLwb2k=", "GXkyBSTfpFqo7zXuu89vYh4chVtXBNi/dVvtfar3IdQ=", "CJtmg7H4Sdu6sPEJLKBIgPi4lNf4u8uVyt5Oc26iiZg=", "LC3Y5mEKBJV4SqCLuWYfviXJCDlrXD8r1REJUX+igWI=", "K5YntXnsQBkwaIbh/0ADrrOjMkm+XMa1bcNgexfkJHc=", "F49wqZUBpuBb9Mp5stbaRwSfjJiJNmllGTRN3ZMRdPU=", "Ik/6D50NV+sMfXGOmc87a6AbUjVI6gyiOj8VbAQIOr4=", "APLuHivh7OLNiu8dv8gmmX0wTYjN7lVe9np5l1nDntQ=", "JXV3QKsUypN0WnYADiQyjrGj0h08vtGTDdG6LL994jY=", "D6a5Y7xlvZMFELPKbhrmLBtGde33nueafygOrmSW8W8=", "DMt5Td+HC7kqnLpfhZ+zzD9OsfERfRTByu83vs7Q4y0=", "Ej/G0wbxf81aQwnU/m4MwcoA/CPqlEenxraMf2ulAAU=", "IhYhcKH4ResKoe57rqSGISoJgUqVV7y5/HLPkPCimWE=", "E+OFpc0vval43HdA6SfOjUIsnuhhxDA2JXJCSE5Jfjo=", "E769gMICJyQBfY4+uEwmmBDOz0f59X4je7S+aUEKeAM=", "E+0pFQJWanAztMRgckUVahWKb8hPS6bwJGwd4FfY/xw=", "L/oGkoU2r5HHrDt3FPIE4mxUEUJ0IXkhcJWm5U90Mkc=", "Km32VekmxKoCl0mqp8mkChD9VaNoYkwUi15SjUMTGD4=", "J9hTHsYSGj7KdNtSQyP8EA21AqWAuKTPhlHxv2ubAjg=", "HqEEpE2C++G8HM/UYmzqDAZpNCKzhGs6K0qhKjsOdH0=", "HWmjhScgqIdYA02VTepgLlmJEUpGZyUbDaWRVBKsX/Q=", "G44jJxD2wc7v+cEIbUnNjS5kf2km2pE8teEDN9fz1+U=", "LUDT+Ob546pgFMaWMNv98xafiAZ1dP/JIQ99pZnE+z0=", "JOHC9gsc02EBdwzvxDNKjALwDMaW32T3bfVKb7bwUIs=", "JAjy62selYzK2/+ByaRJE6wMnLXLy0tAVAF6uz24wE0=", "DjxuzSgbouFqo32s0qvDjrB8E1Pa2W6H0U5eoz/47N4=", "JIx8+3ui5xgZv8dV656aMGzQ9uMhLiVAkPAAbZ7FQ+g=", "Jn/c3uz2nXmeefaGMiF99RIm2M45V01ytK5POdIXIe0=", "K9kXPvJ2t9SRHr943RU0LrJhYDwsmvz0rYMd6fo0urk=", "HMCvM9B+ULKt2jNGcjAGJQ+rrY+j3bNlwdhYL03GXxQ=", "Ih8rxLfc6RlfnKnOj96u/LBUQMIN2XVLxZwRRHyuzrw=", "GOvVxjsL8g9F0jj9DKtd7I2/GZa80bNInzwkmez5Kwc=", "LzOLxaWG8ndK8765Kqks6OWKXvoZ3ciRvkel536fWks=", "BVa5w3hBRetPL/bgyI9BmJ2lkH+McRiuSSk5v+Tp+x4=", "HsEANn9laEU4vGlWgF7TcFEjijY35HAioylMveOLIoQ=", "FkWindRSerkaS3mMcJboMgc8i6rG5duH4mwhW/RI+E8=", "IqeKv31bNip0PtUu8nN7u93Tdemzv7QkCala0QWsk1A=", "Gpkh3q0mxVqvs6yfPzWsthpJ1fGB6ANlQIMLsYaG6zc=", "DrhkWw0rjww5J9RkNXTAsaWIJyRl0xnhX8xsMmIZGqk=", "DkivDLJ1r1XeuCWjTKSJBKR8MbVZLEr6kHfWDl5+plU=", "F9+6xaJvBv/5Z8/vWXptoRtbyJTua2LmJqYuhaPqS2Y=", "Df+9AW/9K3lSJqg+29s8Wm94kX1/vbvBs2MQJ8hmqqE=", "L5SNX3CFa18jpDONJE9rp+fr/HUOFuvR4sLROCUJQxA=", "GUyfdhXL4+qg+IXFnkILuJ3KYP4XTqMh2AQ1MBURcTw=", "FugaBUAUPLvmYseucmBR7GY9YhVi+zcBJAy/u0sXs88=", "Ee8MLYgTH3FeR+mklT94n+x43s2+7TS8jqpCkn6m7uI=", "CHbkWk+GKQG/xiClWVGAKh0dXD4UFDCNt9VIQA9mhTU=", "LnjTXh3YZ3ak3a7hGSwFWqhnY2O/zzFlMX3MmAF+bHU=", "Gfblibo4TbPDatrkvANPuaRE2kIWS27yiQCaLNfRWm4=", "Cf7ZCx8Q+E9nOb2xtLUIlXrM6trOaHqnNdyfarFEBP4=", "BV41u+985e56NgMiLgkAXdUZKtzXDcM3IXFBNyIfSDE=", "BejcNZ7pjTu2mQ/ZKOzwVvm7c24NR87CKpbnysZamCg=", "DHMil/iwwnL6x2lE7paZMHUqe9OUPHuX4Di80jFdKQ8=", "FnA/uLAslK3jFdW2KqG/eDTeJIMQiH3BPP0T+2wqELo=", "KHFaxSZdeoEq9OOeQ7+ayABZY10B/W/kDz8eBZ1/f04=", "L2g7ACeZTglece7IR1cw/iJ7SApqymerFZPOb4N7yvg=", "CFTZw75yGHovGYWQ3s1DlDxaphQKhY8hWVuaCNqFsyM=", "Hj1ZK3Gkc8hbIQSswdjbjLkQGjzOVcZoAaDTeUl96t0=", "HrJzd8+jijlnpx5pdyXBlbwdfOBH6D0OBp3ui5Wppwo=", "AEW5/R4PEVgBIyx6qvtec7wtZXxHsSL04+owplm92b4=", "Anrv49ETDpOUthqATf4iMdaClZEN05JF8eHeZah9umo=", "LkxfoaQgZOVW/FDdf8p7SGJeTBaUFUh9TfBIKpsd9Os=", "BXZ8so8QGaOWJ6GRlqfkZy6CRBvguQUjx7m5903TMV0=", "F+RD4yqzUtIJ0+A40TZLJOs/lF6ZpoCVAsVDnIB/tN0=", "AXoMDYPOrY/7cJeO3sG/PErO9KLNz9jDNbzkJ5NRPkM=", "KLdJsqm+yzRmXjjzxJt2fyBzikgaenahm/EDAAiiUrM=", "H1JS62KZIscPL8G17F6goOCs7kfaJsQENsPx/8ppA1Y=", "KTJMQO57yF0zoFbD+o9E1qdyTaU8zts+VswmtzNYqg4=", "AFZ+m9iiuUfXWzdqmhrxe/i+xsmr7eWCBU+z7PeGDN4=", "Hpa6tu1vRVUPJiHAra10fC/JmISF9hhDVcMXbVwR6NY=", "CNR9wjsf9SeZLJ7dyRJZp0j2zXwfYYdKCDb1memVo5k=", "InM83TGBUPQNidGsFC8mdQgJoLiIyFdDr2cQUM9nNqI=", "IWgXS7nEW+Luh0QRdKJP1B3mv/Sjd4AwJYZMXKGSc0c=", "C0j9q6iFJO+NBJW6Y+hxO2WvSpJntdYgg+e4cmBDoeA=", "GGWGQ/y2NkRSDA+gLc4jKTWkzo17czqbF6hm5Qs+yKk=", "L8lM2lI4/HhYcbypeWCyme0N8F9sayijg0hl/Ul0vCE=", "GlSpGondfgzodTAwPBLvdiRPz0LDjbNVE9ZcbVmUq28=", "FWENjWS6ApUvQXDq9Conz7LRPwTUZzU3tyUQxcTD2iI=", "E1l7Rwdlf0N+5CCHz4tYkEKyd0Z9igQ2z2bqRKZmEhI=", "LbuV5RFOdAAovF7fWLLp/H44cdPxatDDhF1elhqHg38=", "LLOj584WytlZbquS13L2uK+0PLZJKyw2PsceEfhsUvk=", "KG6LlGi9LTktrV2Q72XSjewn3nFHzlC47f/spdcAIKQ=", "Fm52KnO1GQAddTc319kI7yJiN7B3y3btn2u/zOmYkxc=", "HcW+5kd9fnh5+i8zuprc6Hilf604RefJ6vS+VKuET2E=", "Hxb38c1h2VY+BkyGtQiv7EHWFKvHs0u0UXS0DTh3FVw=", "KN8Ezdf3nLBvvwROYxqxH635aR5OpfYgn4dRr1jI6xU=", "GKpkkAR6tSEF3B5g9Eh2JGG3B104p8CyupVkZSZYj7Y=", "AHargUOikHkhR8amRlyag73fT2U4jK6DV7xr2UAKuZs=", "JhYhepT0BwU87zsjTMEay70uNEtAO72KJvghvLbx+N4=", "IpaGLLmhRCSjTToRCA1u1b/hvE4DAewcvU4mDYFnVoQ=", "CChCgCKimZA0BjFMFZcyvA/aIno+ekCkg05RPz75fFM=", "B3H/nzl0ad2m8gzxhB5wLBeAoHGbP1kBdbOU84J5x3s=", "DcSJ3PYauhEEkl65Q5pPRCKNBt1FZ/zhREllp0lWeXU=", "EERw+Skj07na+jnqvffqojtv8Rsuu2SmO9uRLUOGX6E=", "FKSQzgnJKVBa0iPi85cYYTWqZYayfMnM1PeO++yZOm0=", "IGiTu3R8olBEYfskovcurkzzMINYJfuKyVY/7Zp4U+o=", "A8KnOOdT81sGjGrIFxJEwj+9TzfIC6UIYYyACs9iZUY=", "Ep7begEwKb6A78dAAhLNevEwgQDTSlae82RrUs+wbhY=", "CHSw7f7gXYzdrInntWL5F8fs4ewuJi8ib00VJKHdwVg=", "EKC6snhs2jBTfGlrsf+viYB4hBiW975BzfMK0lF7Kq4=", "C6tmHCoX++AiH0NbqQUgvO2Sg2TKyYThemxypH4T/Cs=", "IEIBbmhsmEBXooqirhPJga2N0CrH1GYwBeE4DFT4Q7I=", "H8KVrHGRGlmoHQh/ln8Wo6iHc5187mY//11uBxDPSkI=", "BZIml7BK5gjMO7DZ00XK3q9PopHeiI6bHdMsGcsah3c=", "JxuH2LiVxuHYZLnNAwcp5SO8kLRpzuN7URRLs7Dkuds=", "JKpAE0PkcF8ikA/uiSzKJp0MD/q49VwhxnTtude7pVI=", "GwcGjK/he1W14A9wN8msN+8CaNXSt21yccYXAE8Fki0=", "HjW60xmgNsxqIJTyob8tGYSit0qvPlsTpu4wyQCXyzM=", "KrkbmoXOaee+po9PtbH6CQOUXgOcTdvgXv8tXnVPwhk=", "Iel5+jollNI2XscLWz4N3F7bjij6fsMHqrFLVHhY9mY=", "GHz/12xfspeVUj6+BlycIRXnN4SsaxXFlv3WhGnRrQ4=", "GNL/iCxSs5aowGj4jD0j+dEdn5HA9/3p72ryGAoAc5I=", "CoeKd95hXoPD1DDxHzJreFwawRTlmcJOWtwdn7kbMfM=", "KGucY4FwAoi8x10CDqCcRZV6YVV212IKC5ryYJ05r8w=", "HE5e19uW21IFmuLacJh51ImhrFAxw17htsQi2QgMPxI=", "JxQWebuSYKaTuIB4T/X7xdWUV7lmMOClwEkSCSpNKr0=", "FeM3xl+ljttqdP2+fN0ZAbXQGc591BRKi0nroCvwhf4=", "CCVnkiGMgifsqJ9RFPHn8JHYilV8abKpVv0tyQyuNjE=", "DAjRmvnDCjGs05KP+1pX3l6DNnIE7mcgnuftG8pRhdo=", "GRmDmtkWBMNw8jfSoKqY76wpJG+Twkob0PnStgcJtvo=", "Fb9lsCuS9AufDqiT3bsFcvSTday1lYv5RMd/9sNWGkE=", "Ei4C8uAWmAmyLe8AGsx5eyAtM1r3vSzwMuOnx17wM7U=", "EgdRAN3bgJhlTnGGBSEff2oh9RdtOAFB+zmXcwUYJGk=", "La27uP7PXM3wH3PQzGCxXxu+8BimP1D2jQC3LYrfCHg=", "FDNOzgWmMas3Xnz+e4n6DYCS7AzuJMn6MAntzWLqi3E=", "CaUYVtSexlT31ErKV7F0NlulR52HFKCfD23gizTjlCw=", "BI6P7qm4KFKNvGPNPYEe0Fzp3gGPSkZHrB9oW7j2cVs=", "IEum8YGT90f/EJgJVwIuyqj6TBPn+k6Jcwp2JTybB/Y=", "AHnhvhYi7cV0Lk+BHqLAN5v/T6gref3l0Mmg0XTfEw4=", "J+SOq7DvOyIwWrcg7kx/QU6NTb9DYMgdH/rk12g/Y3o=", "FVcb7Mf1RU5FrkFqazV2J0dnIV9lnJG6NUNy2ZmIHVo=", "LmpFRev3wuRK+RynGS7sSu3dvSrB309RAff4zdMWZV4=", "LeGfzHiAACexkyzfb56VkghgbL+KB1JEV0koZ/j2vKU=", "Lhyo79GHbiCfwtYssURG6PPEvdU9Y4LKhrET8yCdVfI=", "FUs/herti2VxjnM8osp8ivA8+PI778TXxhd6wA6602g=", "KeWPOVVdnd57rD3xjY6usqWlBQOGDSDFzQuios9jc70=", "Ay0yAy5SEDrXmPs273wGgVBM0thqEsfZN/9Rjle0w/A=", "KB3gGR0wr3MQXjncF0AV1l3H/xLSCIjQLOxlDhokWjo=", "D352r4AOurFCgWRdKQYH6rsGK/Cv4UGRM+H/3PcMgI8=", "J+pAW9/GVXpN0ziivKmBlUdQH293pYinXAFNRig/dbM=", "BXCvVD7+/f3atj+wXTHtytOVrII4FJGoDIJcYhx6wis=", "Anp5fgAUMCR4pBPO3npFzYlLCiKcjon1brrsTEZpK/4=", "HdDig6jvfQ9JZqUXaH/FMkNVSo08fkHZFxmza6zoFRY=", "IAZERpWYdWCGnfbc3iZz5bc+5bzLtDoFwti+bFmXkkI=", "JxkmOS5fHJRDev4sKWm+pP8/bYPucTlACIMdJLsbbLY=", "G2B+0vEwWA2ajCDqJrM7R41uHwDMgvABdpNai1TKv44=", "C3puM4CNIXqeVcI4cc/f5JXBDWK4uYF4SwSH5j3wPgo=", "KKx5DUYrs0WrgM0WcEA5Q1mbee3vF89wI27LHvhyy8k=", "L410WxtHUP0vky95EwlVFcSYvjFCEBgMbDB3IxImu5Q=", "Kj7yDmAULxfS87gu72E1B5UjlW2LxoQJLuy3p9Vtcb4=", "CBGbFLg5IuSyJGl8LGU2z3ctBnSJ1CZyuYjLY4xxoPA=", "GkuubJz3PqInOaJ1vHIsjMg9kefd/VEQYUpS2EznMgU=", "HWWa6+Sze4iL46fX8j42LCUARsCdUyYxLY2UzbOE0b4=", "KOL7kr9tpOa5ZzBHnxcHYFZEWNlfcyquJAavTAOWn48=", "EPTsOtbz7TOHcpmQRWyWhXhu3o5uFLfGYxHUe4d4qmg=", "KtNm2QQZEHhmUE1NNDRuCjxZXebgqlHIBScq4bzdwtg=", "AvHcKaBsZMnkPTN52w8ujwzY+ANRck0xPKAq0kxtrIE=", "IAhqZyw5fmXLN8+2TdqwgHTxc/N9DkoXR7fwIGUtpk4=", "DvKGH07Jul/sdLoiwLevnUWMPNj5DIJcHzYRDKLukHY="],
      M: [["AZD5Itl8in3PChQqO+J3SdHGS8IvHFVqqiSSXRWMrFY=", "H406nS0xqzLZvbY3UXDbuon2+PdNFuT9AvNnXV/iuq0=", "IwxpQTlBb0BCLXE+E8BWxFw8Yxs0aFRSOXDq6lijffQ=", "IGOkYa0GMVrlmSpToUu1mDZ2JK/CgzzLuDr5LKD2ozQ=", "DFdOYo+EtrqdF7nSv9R0fgbdaM2iOD1kzjZZJwmMBG8=", "J2Qo2IBAo+D0QkJNL/y40Zvs8/tsoCwbXGG13cU865A=", "JL32EBsvIjF06GnWrsvo6lsEoUw4/fFJQ5PMb9s+QqU=", "GA/KGEFQwONUtLOkoHWCTUto6CdJQ/Tdiwxk7KJdxo4=", "EHJtz/hymchTIVmXZgdjPxvCrSRFPBurJrcmuC11brs="], ["BgfNj/m4iXc8nraLikNmRp1HDNfGAEEGyq6VwQxCRBk=", "JZFYC3PntdXzTZ/cDPf+Pef2oYolXkN2/ePrMd+lHXk=", "CTz/EhUK7LNGXEyZ8ES+hdzB66IdQpEywiYN09EupEE=", "BZEW2oiggSZ92IggT8b7eQRsMpfMtl+eD+DVC020TsY=", "LJSElzc1FOfZhG3qnd9XVTN922YQQ9bGKM7Lj1UXO9g=", "LCcpgSvp7UMudXCRMxGcsKFOG26jHBJ5t8Pkld6vEI4=", "IoDW1HGPnwa1UamIQI8FFQcORV7WM3fpEL4If7eb0ZE=", "Gxu6ElUFrpZ1vOx8mvV5xcyDUzydVVvjmK+gnL+V1qc=", "FwEyV3FtPLrijhwnLLaqooRBNgSf+8oFyiAVIwMsZNQ="], ["HaUkz/YLZIVtwfXd4P9i2nsYLaJpCPa6blkK3r+RtAw=", "K7RWWJO2/8V5kTnNwVEVh0nCxl20hnKrryTFs4E8Dis=", "JQgaAPwgrjZrH+fqawnmKlH2/Td/YINowSuk47+Jk18=", "G0NxnNELYMVkfAl9H6hLjzwSycR1reE7OIx+xHJAvhE=", "It0gHsurlKLuOTeW/vzKY6pU2aGaucfyCgvtz7nRkfI=", "C455g4zTBweZnGIWIed+acD0M9VDt5xmjPN5tmI7rIQ=", "AggtVkdljq5kiTbO++360s0FOFcqphIspozM7Wj0MvQ=", "J3uuL8WXpTatvpwkvI7oFzHt21dMalFCwcWkjFH4LoE=", "MDVMnynJIMBemdfMdHUQ529/pppxWUopDq5yk8WkhEE="], ["IvM+ruPEgeZYAbdhpygykI8Gb+Idq1+l7B1Mbpndbfw=", "HFznd3aJPUgUdES59tZqTaKclXB96DJ1bHOeq46HZY8=", "Krjt0i++KhzTzppCEtDvsoLMrCivTYdvyUYgMHDJIL0=", "JuSRVKzKJEJNX40p9lD5gk3oLreIcynLyDpWrgHe5KI=", "C63Xf1FtT6Mh0QmbweUZCQAVka2ZGfCM6XGK7rK8pNY=", "I2ccXR+1VgY6ZLX2ZDQJNtxf/t1L26ouliBXBNpYZPU=", "Ag1yAszeJJAdbOLRB+eeH9eNbJOYunpJlvEWre8U3vM=", "HYZJaZXxQmTnoFTMgiSQA2h3XD5axrX1QoX0pzwhca4=", "E2lhdG00/RlgJRc8TXm/iz0dBSkcWEko2XJY/V+0+04="], ["B1+E6ccZu43o5hCDKQ2v8ZqqQzdFTluoBCV3h0cPL1Q=", "F1UFORxhm3VTD6g+UTGEOB5gPYRJ0eBwAX7o7ApNJfk=", "KcXOl3EMFXigmQ2GLPiBut8Q5Pa95ikZnoA80cQmvk4=", "LK+Gz/YFIczF7G4uLIO0cHu5D5SGRL+qj4Cwr81M3hA=", "JPknk9Z2OLSr/fSM47YqtdDhslDcJ010by99BUQYW2I=", "AoCd/iTH/XzUm5eycVD004o0C2Dwcz/UUwzUJptIEeQ=", "JnCWiBUO0DX5WWh+33dH7o7pRrdwFz2+UDkKuMCMX5w=", "HlrkwpWtWhfgD5c/E28SMKb7hWN2MbMG03BfgO/6wko=", "IxDiM35NU8FjXaGKJyIXjVWvWDWRvMMX66hC3yR96qk="], ["IIS+mlfprbgDA6jcr/1Lt3rbaBUWizah02OzhCVDcTU=", "Bu0dFN7fdjowZfJ+ekbX+/INK06GoNuGaSoml2fVd+M=", "EyRUSlQXTPezzY/8S4YyDyMZ2biMF3m4mxkWAY8/ubc=", "LpI+pG1JIkfhLgp9zPZiD17qZim3Uys68kaAk5iFljM=", "AAu7u4fszJHV+we2xVCIylFNaN3ZPPMcjtLSzH8jsis=", "JgEKP1KVu0SBMQy8pThKR68PmQXkx2v1S4cO8P/vocg=", "B1GkpK8kYlXOQSxLtH+jSlG4Yo882QIHd3XI+kiOdRk=", "KNI1FhnMxvsxrUIG4sBkv02bIpKyhGPlPkdx8QZw3b8=", "GBXk97QKcCeHhkCmzcSyhUMAz2/UlTwqwsd2Je9ErgQ="], ["CzA0SfG/S5LSy8Jqs0tCFbbdevAQdHpwWypuM5iIKSI=", "FAzdozu3p5srqoUd9a1Fnn31abnyw9pULTuNW3azVs4=", "HRiyWqyYsoLhC1o6dM5cqhaaXDC65Su6KA7VF/P4L+8=", "HsbDL1E7jzDHqrQufZGuy+VK6xiKhPjKRr1+l0G5o4k=", "CJvushw0bLm8GCqitw+FPxoiWNVok85alI2cZF7Lybs=", "J5BkOmYDjM5KZIiEfY0tou6oSWH4E0sb42lH+ANSfmc=", "FZ4l4AMmp28lwRQ6W+b1P6UczzaNmXTMbZPM6OuB03w=", "JIa4hDcNSaAD/QQegA8KiYq2G16UeZdGHuMoQkHzuqo=", "ER78E2qd/g68/66JQ+Z5zA+/Yv0M4DtAn+zZMqgoGxA="], ["DAmbxoJDU3ID+XJU8I37fvwJ3o+W1y87Pgqt7UXhi0o=", "A16ezEZMtDHMksM1boqYVH6EPtEyTB6XEXn9Gtn9UaA=", "AvNekh2uh/EoTAyK5zfb3Ek2y7sDoDpZGFUv5WUnCo0=", "I6csJ/T15upTJdWzaPmLQGk7LbHoyj0JZzl1PcVngwM=", "Dgex0i7tVP35Zv/fvOu2U7Xaw7KpH1AnKHbvsXFYviw=", "BfpW1DHUvQliWobTYjRk3JC9VB6kF0jyAm9lAl6p0vI=", "LW8+DphBPV1qEQGyRcnnEbsulW4npYcHhP1UA7OYZ8w=", "ITF2vBoEk5/n1rwwaRqr1hUu0k8wm/85OaDZHVTGemY=", "CloRSNrUVi6rGBYrORS2TVdT6WF6UVTpP35D5oYGh+o="], ["HF/ZBg1ODZmSZEKaUATBZVcL0WdbCfl3cIscpI5hY4g=", "Ep8GyTDt02/C+3BEpjMnUaLjvNvnVtiDcWzq1rxwY8s=", "FKXOFgMijW5vreV8HaU2ZZukbRslVm8Swo3ry+3FtPQ=", "FDYX7827wNJ6CR8oA566irs5OS4qRihQsfnNhTL1B18=", "KIXy1Evg7P9X2SpDhO21vr+1hbsj6uKi6lCAa6uLe9c=", "BHFdtthrUT0AJYnx+VIvfeOxqL1wLBZ1We3pfaLAB20=", "CIiHlmwHnS5omo1te9kT6S0yaVm62lm5mmU/6q32xGc=", "Et7UH4BH2j5sIr/tPsW7UtAn5WAEjbTA+Wyp+oXhe8M=", "H0fGekMlZy8XuL0d29gOTp5sYkGanCBMx+iCGJJDGq4="]]
    };
    exports2.default = _default;
  }
});

// node_modules/@selfxyz/common/node_modules/poseidon-lite/poseidon8.js
var require_poseidon8 = __commonJS({
  "node_modules/@selfxyz/common/node_modules/poseidon-lite/poseidon8.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.poseidon8 = poseidon82;
    var _poseidon = _interopRequireDefault(require_poseidon());
    var _unstringify = _interopRequireDefault(require_unstringify());
    var _ = _interopRequireDefault(require__8());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var c = (0, _unstringify.default)(_.default);
    function poseidon82(inputs) {
      return (0, _poseidon.default)(inputs, c);
    }
  }
});

// node_modules/@selfxyz/common/node_modules/poseidon-lite/constants/9.js
var require__9 = __commonJS({
  "node_modules/@selfxyz/common/node_modules/poseidon-lite/constants/9.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _default = {
      C: ["DhliwjL9Cmu1StiWKoK5g4z+8Z0pClX8SdbevQYc0vY=", "AeH0XP8+dBaKzNCpRTb8pjFxKJU+tH2NLXm4R7NVz1E=", "E2fuw7IMt0lTYY/ZJhBHdV73+Krl/+lvyPfZoC43vRo=", "L/atQFM6+irLeMm5FlDXzL0nSwn3jBAEefOk1ylW1wY=", "FSyMPZ5D2QrYCUgxp0r4FR/c2gsY172DdP/aaNGl/HE=", "JBcH2yb5bfUCNk0mcSx/Rl0KxVl6MJVZsHVAY1GiCXc=", "FaTkcooZfa5jA9DN0rbR5BFKn604pTC8pv0Gyh/8H1Y=", "DL/WPzY5eMOH1lbpPxHjNph6aHSMj1TzhYh+ZLEHVZg=", "H7WUR0uDNPmupv5eMj+w4Kwn0olZIaxk6T5STk/9JcQ=", "BaxVNh2pMcG0xWCqjbq8hiS6IlhxvOIkrdta+QFnaus=", "E1+DMUJSWF9+ARaSzZrP8232vphQKfIm3iVoA+pwTXg=", "CmjyYsnhTYqe4Ra/kM19ZePfVhuzkU4xTj9D8Wf1wEo=", "CoNgqDfUyXuUZjPDUymLd9aJG2znjoKjvTn7flEZPRA=", "E2ohvROxGFfg92cOEtIykMIxi9rIMBVMw3MwzK2aP+Y=", "KmCYm4CS+OHBywI47IW71ri2WTJ6A+jhk8FaVNu3PAQ=", "G164HxQ78ybaD065XU9FyBQs6mQNM6yvyN6rFV83NF8=", "CJA89raEgmc3o0isqkUuG6n5NF3pEfI0CrcyTQvLR+A=", "A7i3F7oQA1oSrk3ED0IQsPBSmug3dm4aJpUiEFY12Bg=", "BiPufBnqvRMRU5iJPoJu7iEdrqc/gPpToi+M5VkGAnw=", "C8iyQ2mrdmR/4OonjIZtTUW8P5PosG52kBu+W/INtcY=", "GjJ9X1QBkOHJyx4x2Fe1xRxcrZ8e4SbERnC3gtRsL1A=", "EIfvrIe/pIB6ykEKnCl9IxhMBbtYq/1Do/wt1IM4BZI=", "KZcRcwTfu0ZLXNSkGIqk9szVbenL2BPaJwrX7mmegGU=", "IpZILpGfvUb3pRgVXnKlWWVZaGbzKx+EMzkPPh8OQGM=", "IVLV8WTOCfaSis4lZr68YQmk9iBH5HR6BR4p3Bh1Jdk=", "EFQQmGGzNJ5Bkhbxu+gvSleCOnessd62xI+iZ+5dMC8=", "F3L0ApVAQyq4xpaLNznDokHNo63hPs4uoKCxV9ZcLJM=", "AMKWr9suA315eYeGcceKX2AI2Yy/db5OPsPMHUToRZ4=", "DshbIsYmhuUst5qymgGB3I403fMWfR41NRTsho5yml4=", "FJ4kNcINSKPsVsTkXbvFg7hb1kMRoldv81JmiWLCGGY=", "HUQUDctFl8chSm7YW/8aO1+tM/18UwaZu9YQ479SQN4=", "A8+wVw+CSFb79BUTvgHtMnHhw4oW9hCoCXzSehMl1NM=", "DyI7OWQj7cKdUeWIcrLat+o6rolRe8QZV+rHnOl2E3k=", "H+bcLm6Dq4joQzekUTCWMzd0bM0BwvK+EACAvjKllSA=", "BHMQ67RZ/oYMlUUXJJRA02fG78W5P3DEELx2+AiLSj8=", "IYWM5poBnkzUYJamF5C/fgPhDj7cGimI33aEmK1mfN8=", "DaT4faGW2syWT7aSilHzrO8EIDfbdB8xe02AqBz5io4=", "GY7uqYHrJWtPpD8F+k4a7JCOV2E+79NQJjWAgOMpvBI=", "EZZO/SHqB5NAxmrZL9tiuKGO4IqZkvEzpBfSO3jLGww=", "BLB7GWBRgSL1clzq3AwfBgkovfD17ELhb4wpNId7QUM=", "Akb1+7X3GbCJbge0wj/PHSRIe0x3WYPOpJUA+GN3Cew=", "JNeNrt6TJ/SeumeVOfhdCZ1lgwYJOMsFLc5QElsBzdA=", "I96TJljS8YH1nXI0pn4XR2P/eQ05BM+z3RCvivTYhls=", "DE9UMdqqmU3fXz/msd8MDEIoejjJpcTHWPcmOOO9tAM=", "F1mZWJiVtpR9OG2Dpeb1+vnGWI1SPHhGQzISIz9k0Es=", "AtVM7148rRqARxvG7wxuTnTC5WiGox15JXsnYu56tRc=", "FTnNxp/ZPy6lDdEuuwQ3wj307Nopx2rrCUN//b8Bx3g=", "I1mkVFKCS6l9vAUAhruRDBLO4KkI2xwoCJed7cjymUI=", "CIDl2iElsIQiA7uY5fJK4mIopa9abv1UYfY0pEdqFfI=", "FhEPxsgWeTC94jDV35VPEHz9DaAFruROxf9kKHJ2TBk=", "ExDIRLcNalhW9tGGaeUywta9XQHmox6ATYGi9a3GP98=", "LqhoIXqZpsvnm0QuIVKFPHMw/Y3nV+t1VXZYef5Cziw=", "KcUEJHHZCe5IE80aNujsoI1ODTgwCfF8SjZ6h3o99L0=", "JeNu2g6rV2B16IraORTClEIXKgJ8bRdM4N37sBfVHf8=", "LSEFjsRGdNhJPnAqreW987aR4/qsBCcInoZ/nthWvHM=", "GNF8ODXsq0S9uLZ+/irMcdOenTRD3Q7RHZUEVAmnx4g=", "KKL2Ow6UCv0seNAN4apv1pU+bWzMOqMgOzlhj11pj1o=", "AmNfW9m+uv8M52FOx4Q0GKmqg2N5ECKb7/25HiPrwQ8=", "H7jocmUlJoAYhF+MgmsOTVbE6cWOqSdS1YHRpRcCuII=", "CH4s5NKuXJPqVhHVDDEyAqgMS0NTO0kHf7Vp+DfqH+U=", "B4j6lTLPAPE8gX847hurhfvGh5mM8cFK/1/B6rEVp9o=", "HFyFxXofdYf40vzvwdTpjCdBoBnv+9TFAzSwwVw4Fc4=", "DB+4MrfL4OfhHo7cK6+HSfbqBjeyDpcqYzFdvdW+FHI=", "IpdYoitS7DkH+UoRf2Y5FkUIx3v9vGecGz+Ha0bK+Ak=", "BeBmyhJX2NXtymWikh+1teAeOi8KKjvGYix5FVIZCio=", "KxqTWk/xbCUAvf7iCG2d85J6NY6Oq+dfanDX2yWjGRc=", "GaVZkxCAiOA/5/vCoBRQnOmH9Cd/cpuluSTSWzngZpo=", "G7ZaP5pDda2SbUTBiNz+UbWl3Wp+4VKqbMzkSBPpXbk=", "H3IcTQ23WS+b2gH9H768jldFLiGNii4ZFjBn1K8SjTc=", "K9MqAomUmKlzOCpNQCZtrK6JiphHwrM8KtMLzcQlR3Y=", "KFhbBS0iKDZQqROdY2GwjOlNF9fI9twdVPWFiQZuSjE=", "A+s0NSYQInvrJvjt/kZsv6NH15UL7kMecWVke/HFzN8=", "HBNH70GNZXq75uTAGQEb003bIHq1SpuZ8HxARFieCYY=", "BKiqOxgmPhcTY+k5aEehkz8ET6xfWxH3VOb+r1TsR0c=", "EnRKBjyr6S4uGPAAr+8pyShYWgOvrDsvTBcUEgOUQjk=", "EK9NOactLctl7uq/ykCgimmydBKXBMAhoBOI/4Zi+uc=", "EDjGVrMy5Rn0g9VOUiKzSzWvEpBtE2UtHYxrD1CbJ/w=", "EO4C7RF2gEt9Q2luuHZDtPtF8B3WWInltlEo94HTnZM=", "HQjM1HVBV1xgtWf9m2cF3ogkj5zGCvI0MJjTXZ5PbTU=", "Brv24y0m6SK6rIxivPheyTTL32hw44GM/kndOkxwiX0=", "A65gQD+TqYNwaIEA3Nh61Mce5SnE3MO+Mta8BiHUI1U=", "D9D3dtJn3DwBo3fSF+M6JVw5k3rCgaOw6stYsQEjk8g=", "LUqzuF7m9VvBfQUfzvc5Forii35tWqSsEqLcwHubpvc=", "LsB7P62+KW+b0fzRdY+V5rki23WCBo121VIYQTHggy8=", "CmAT439WD1QNvT6XkGACAHd7hqV3wtLYPsfNE9sxk3Y=", "DcvDy0qv4Ixicx3KRMhDASJllQ4Hlsc9j55Tp2fH6Ig=", "GYw3P7xrpZgCBFb2JN/JBvKMq5FbcOtVaPF1+EI1XCc=", "KpUVdw8wU2OOPAZPWQHaeswlEPsp9fNgf4rRJWraB+4=", "LUFUc57Yps+akuWQgS8V+TATFj9XuAOXc8+GNI1TGMg=", "Arvq5McW7hNsTO7xlOeYXUZBX8EwQwplsk6fR1Mwd9k=", "GStbCDIHZvRb57up6acMDvxpr+wqdeTgcebI9V+571Q=", "K74OC72pNrMFgp46dKgt8DDU/YESqn8WlnCHawKPBwI=", "CWNyLY21MvyVzyJApXDNehNjZt/1RJR4RbbUh9x/pio=", "FgEMDteje8qWgqyFj8jSxK9RPwLQ8X3TBvBc1X3GlM8=", "JEhhIph+Fwd7AmuqgecF5dDLdrTZLdP/VLu4E/PQnqE=", "KNo1qFJiWCsiD3Ji6mjDgVc6kYwQ3Rfo5WTrbaET5cQ=", "HTGWqmIJCFw02y8OKz3Uu2u2cObKJNJ9kNyO+l6BY4o=", "Dlb+S3umLc2g0ve53oa85hZteaCgw8aVNB+9tAe5pQY=", "FF/Udnat5cOAuQvwgCD678jD0nDGvZf5KhirlPlz288=", "C2cESG/dKmM7+eQKXF5AkeLUMMk3MGqzBFs5uLdOMz4=", "J2dHmURzupFSJ10Vvq/kK5JN5pcoEHiYtHAaZjbfPPQ=", "EmZTJMn8jSRsFRjgQKFeOhfA+D8KR5Vx2PYaR/OYLSE=", "AojFiTJ/+Xgk6qPf9Au8ycpz9p5D7r8kspzVP6ERzI0=", "LDs/Jm8h0h2jPkw5ABx6cD5rk+BHNXhAEj8wck/aM2w=", "HQiSYPU9m22RJGDGqdn/nfWmORpJJzFTSCalV16KdyU=", "BSImzU/yyF3D/Lv9yqDsrXEloD1TMiPIZnBA+/z3Bi4=", "JxL5FxgEJzqcGXP36H+uKL7ZqDP9tw7ZPcYnSGWGk1Y=", "J28veB4MnKBCSppRNVk76Vdkp1nCMRmdtdXg53bhWqw=", "KyH/w7oWPqYbfAtxfVGcZKrKuBlX4mjhdfRodumsb2I=", "LzwraHS4FTG4kKYDvn42zqrtbIozYKho8YvyNzYojAk=", "BWchFI2aNwqOgSjuABeGlfZuxQY8ZmD/VUkTOUzV32c=", "DhcS/ReY27Sil236oIW7mCLS0mk5g+mcdqVW515jMT8=", "JsmEbHyguCJ7bqp2NM+qbEoTv6RxDL7+gL7+URnAtgg=", "HruetHmmRNJfU9qz5tyggznw7/3pt6rXo0dIUH1pqK4=", "FhH14q3YzP6dCTvqHVXqxiZhqayXE/pMcIlZl0Qbuog=", "JGLD1VVWEa7qShRrjaUNMMQZlDwapgDlsTvEejgQ9js=", "DzduuefeTEX/UIois05V8P/aAmgmqYsphnLYHIJrYpI=", "Dn/4DD0Zoq2YyMUqXRnRcSUXqmWCYpGubnXgUDyLijw=", "LrE/9mq0mnOqrXYPW/JxMW8/hTjFJqGmT6Zb07P8LU8=", "IqQOUw3n3dwfhCyUIRksY1tDpssfg9id29PFbCpRLts=", "J0C6oxjAL94WLJIKYkWw8iCPfQ7hiYI620e6/91e4h0=", "GWVSLM6L0ps861CM5AQx9A1UtZwEEeXKQn+MHHidKbA=", "EKDbfCsJadwlBkevC9sNmc6kKF/YqQcXwnYCMqkGvn4=", "ApVIYnGto8rkz+NyHm17Cs8hvco8qg4CCm2I6tHyuxE=", "HQAgbWWpJGbd7yLlWDZhxo7jE8xAoBwJDlzLEYoa8T0=", "ESIiYFBSQj/W2iHZVUXW6Wh45ab0P7Jmbi/cWTeXG8U=", "Jc+v233zKoby/0SjKtey/Zpg8xpE5bWtQjrlKw4/8u8=", "GkKsozB9+EqB/1ufvsARrJ/a89nHPN/pUBH3wax3nRU=", "FPtsTg3wBjJ104DmfCUaKa5jgCjY5gcqbk/f9OA5pP8=", "Fof1AajAfJ5D60qyJEkUtlEpOAeii8Q9c6xLVkBEUmQ=", "LWS6QGeriY97Q0QJMZ18rd2xQYL2E+RmQpGbQ8ibgVk=", "Jl4Z4qK8/5SJy3Sdr5t3JW5AjxgM+vBVBuEaAtbUsUI=", "ESDZEWpYTsrTI8uLiCW55DrRbOWcXou18RtKuOXuaAE=", "E1wgD3wUXAQv3JStW9LkZhsNuIndw8JKIH9cfECYA0o=", "L502XZtfn//FSRwMw55rmtFOTYeUv3bma+yil03Gxlo=", "K7J8Gh6EUvMXv4amOElU+GCaKFAEWTxS/c/+fYWBLfQ=", "JF8o2mmGNod2lo1+XaF2PTi04aW1OsO0V7JtNdjMVTs=", "FgR8P0yiPG9drKXQHrxnIaPRVspMNeAISQODa9Eok74=", "Eymd3bnid7EiJA0IZWFk0V+NFcx0g95wh+itlpCcBWU=", "FZDd4p4RQkoOf31LPg/H5BLQkkY8+VRbfGImCrLUNLk=", "Gf1guqJIa/3//8j2cqtky6QLOU8oGDZsdtBbd+keKzY=", "Jlgo7fsDkdhggixBGbOc7uwCGRZT+VxzksAXJURO6Ek=", "Ajvamjwui7GyJ7Em6ldPl+x3k82AxiykTPiy5BUTK7E=", "G3cMgEv7kYsZduM1eriEZosNKqQU4Aft4ABxRxSqCdM=", "HYTqq6ZSHrhmtgB0kGnmZD2qgPfeEOwnNR8TaaNynRM=", "BzoKobpMHh6YLvAFORg+9kj8RBvoirHcUxWgy7QBybM=", "JawJmqhcniruZ4nyWSJYzfXKjHtXOeJn8SA09wV5f4E=", "HB8NwirVTanyYyG3k+AUrBuFMAHRVutZDm7FIuaFDDE=", "EDdJzK6Q5DSh2WExn5bHROBOwPd8jGUFvCGhGU2mwUs=", "CTxHydrV6mHIVmYg5PQ2w2rQDQRrJS0iZNBtmjd+nGg=", "EtSKItRDcRsFu6c/58v14HNN9+00WH+F2FClFYwKJ04=", "DRSH7nv8pG/rztuD6dxzwz08CZvzwad5M0g0+J99ozQ=", "Lrqx5UT2rUUl61WSFS7LRvjg9wzFTnOfWuTEiUXlNKg=", "FyYBELwPothZplpRm2ecqxV6ZIXlBiyvo9noUjVD1GA=", "FLYLsbgTUzZVt00ZSPr9lMc+HgutK/Pny76ZfEDCLLA=", "FEypsYEEtbtanSHXO9lX83MllTmhY8eBlyEM0WyIZkE=", "C2mFQMCrInNLrVjkhRX/hFIAUSFfXOSRXYBEQDKjukk=", "H0WP35KkwDvOK/ad091OJr/BZjwYd5m7NZWNNhPiW9o=", "JsDD+fKr0ZOSMw7pPiVUq7J+03dIHiolUnmNyVKgrNc=", "AP6CW93hq6+0gOmF1vqPTHrpxnNfm+CmkkKT0roRRcA=", "JN7tOYhUauZSCmwgx2WevSpfS4KBgqMPUZVnSZex9zQ=", "C7vNVVwYSq4IkVgsYdZRlRMroUqib65bykz6DvcckLg=", "D5942F3t43hDevvsP2ukDI4/Z0y6pR8vxTVVd5zpqk0=", "JpzS+4wDk2qm4w39CcNP94bIOZbon3BsOc+aZzp5yPA=", "BApe1VwVQa0UMbLgpcI3DMCrjLKrMeYlBfeZsKU1U34=", "CxDbUtaaCDgsmw9g1TxYYzMBiHfsh5BnovlUj6A1thM=", "HmzFxAkNLZH1ZyNwZMV6u4Dx0YhqUJyra8I+gXZ6KqA=", "EE+ZZraokhODGcoDfUKY+uT61dCc0F5uSBS3UuUfVws=", "KdlvUw7VzJLJBNIb9WDIKSO/ZWmsuQq/udaMSVy7mBQ=", "FrkXokHF4qGUHXRWZtit/t77SPnP/HVv72ZnQ56rof0=", "KASdyHA+futK5ct+7J0LlhTzPwO+ylSmfXKc/2WXH6A=", "K8I2cUrv64ZFTPlyZ2xkagcecJWdU4caI6J7zEpRS0Y=", "DoXj8LYt+sBN7+iTJrHxycV/ldwpnvlf3OLdEwsOCfI=", "FXb1VlDg36gZoSc+ag+gTB8a4Y8fhB2vCtWiNXk7hi4=", "Lm0fmE2Q13i8DgmQ2+a+ZiWK0ASHEpqzQ42pDJ7DB/E=", "ClIWwkA3gITXQQzHeIAcWQORxvYAqFUU3h1c/S4p+pU=", "Fq8MbshXcUuennkyrIprGwH7QlMuUelXxzXgJAPs1JI=", "B+84KbIehtzbw6oC/SRrj6jn5MIVeO8FhIdNNt5JGqw=", "Ahzf3Ksf/awrrwFd2tfvb8GWt0QugrNwoRh7SE1dYtU=", "CRGqHOYI9CNP87nzXZvlRvXnuUvwol+LzLNTXr8cWEY=", "HIYesBxLM17P22MgfFFn8vKi271MYE35c5CCxduRcTo=", "Ayq1wAk6/AWdciZRUgJrxnS2mISJ+hki0/ahMObpjAs=", "Hbt8TjCzvbOiSOARjJJZwxt1vrvais3i0RQxHhFmuFA=", "KVchmHsqBy+Wghb2nhSvwQrHzmhwoc72ILnjFnEh5WU=", "DYSLu1PqjHLIygqTNxEGHNEcOL71IE4Zh8bgAWzIdyg=", "ElQ39hBbVzKcBFN2vpgB8VAIg4SRarV+6Q5N8mBTPkA=", "Fqb4XPBwqTQ3ad+96M7DDWJQDVDuKUFnsM/Jr0cHrCQ=", "I+S6Fm4rWhUG353U3HTHow37efSTreOL4hwKYEBz01k=", "DXpXDVwTG/eAMcZsiuX9RUuphV+rkur5yjedCOhWQU8=", "IXk9RqaW7lBA9Zn0gr2YRTVsAuTCsHpkUKEAVUNmWCE=", "BM+fEheLqG+rEcEtaQ5iBgNSX/ffy1YG0PZ/CnJQ0KY=", "HhyHFK66fnVJ4IR3tDZewtvr37tgGJN/aA08+ttbkiQ=", "El+ZyB211+dL4MbmtEdt0OUDwccEs8fT/w7TVvmlv9Q=", "ERvDIVs7sqXRclf6c6d4UdKiTkgErRrG5lLwhYMmzrI=", "Cec3cfrqAGXIBlPfqov/QC7rC+NmiDQ4Jvr2OfaEsxo=", "CWT2IZRoEKEjRp/Oa1RP9hzJtzMDO2MgcNR7yUdPSww=", "CVMr+fEQUfhjpOgGeXgrBzLWY5RzkMErApVJGKGOR60=", "HRSAjFRYOmIOZYfCS5k7GDig6wc5XDCFtEnTE1vjIvU=", "CbiM68y7KgoY4tLnmed8q8tKIxEjwwPpjNiX/61ZjUQ=", "JP9as470V0hEkwVMm9PsiUqFZkkakaUr14g0PEKdCpM=", "E+6uoimMok7npzFi7Doh2Be6hvl3K7aMBGHRFVNdrsM=", "EWAKNstB/eLdJqfNSpjNi+rgoE5G2zme7FwdSQIFEPA=", "LHaC0+5Ow85+H2fM6b3rpKH2afBNn3pL7hOzyX0+qjo=", "LZsdskawBOGFsIyVPcCvT7t8fcZ7I3jv9wdQey2wbLc=", "F/FAfChy04ELdHS+vjcR9yWDzJWDEwG04+BqPKligxg=", "CJ/VgFXSBgK9vCFxrkhf9I8gUwEGWTK8nVJv5U0pfwI=", "J3nq9TcQ86WEio3/vkC19EKooTxRT/l1Af3KCA+zuvw=", "B9bD3bgHuGNMia7zVhXac1lujuGoyrSdAi8LyoeA7BU=", "GykY2gub7qaagLBaFR5oFyLLZvuO8ffdgpOemRzQIeg=", "GiGhQJ3fypnjwJh/l0UIQPlYUkr/6yjBj95znIGJyrs=", "H55n45eRldNoFyJnpro7RIFz4jefJcqhN6tpZHFNH+E=", "B+V5MTmbzEEZ2c17IZF5PeDuaUdHFrCACKn2ikKHh6Y=", "Ce99Surfe/WTxaeSeenmVXjRQxXfne4HQBaT0ZlZlII=", "KF/jsV9LQyadTMAYP591sLT+af8XCsZBsYx/sQXS1xE=", "GadoK/7P4Y+6siMBJziVwcS5qZSHfdd4ZG6d/WTyTbw=", "CreUtEM7XQyp8/kjYVnue58RKr5x06TRk4UgLCCVAdA=", "CP9k9bueP4voFXMRfgEcgD9p3GoJcNwFEYqxBxoomAw=", "Lw1FS0ngNmFx2VFCIwAC1w+QyMNwR8ayWMB8DJ0DiKk=", "F7Rjxo/LpGHhSeVu2p6NsaS8XHuCibDNQobetck1VMg=", "LRqDrIMuSSgN+UseJ7q2X6qeIaYKSO8PRVfAP5t9EfE=", "HhgkEVYMgNfUxIDk/WW5mXEypO0p+ajcPYgiCbY7B8I=", "BLxcGcuzEpQbobcx8JY0mudiTso7g76IZHCA95TX+rM=", "DxChMZUIwJqkQn6nkHHaAtzkoXReE55pSfmSFqzYMFo=", "B1edlrq3k+8fdAcT9w89LPSvHSDqVg9I5vjATfZPIHc=", "H9i1XQooz9AJspizDiJqo9QkM9wUgxjJnE4yrxPFFEo=", "Kv/VDGrrpXaH2CSu/6VcIX9jPUaEDJKMA3PKRkMvpzE=", "L8FjS2ncaXtmj60+iciBhqduQHe/bRFA2OQo6ut6OHI=", "I6U+UUqyYuIuyn7nIkl4GMBk+PdMzTMFA9er+oXwFdM=", "CG6pjopO222FALygPVOgOiL2m28TLJnsr56VD78myHs=", "D0iRWFW00ZG3w32F6KXUkWSM1OU/WAbUmajeh+4Q8uI=", "E+C7ldnTB4wQ7S9zH1f16eQMlWN1dOlakz2fKnqlbFs=", "K8NbDFszXfxvGpNi5bOJ2v62XwzltEVIKA9GwW/1H+s=", "BbLdzIaoUEsAgIrLtKZDsWnbKwf8JcnMMThGfKdQtaw=", "F1DRpH2iEdjoOGwZgJW4P/ZltYmsJ4vKjA+gG/xoPLo=", "G7UyHpXR+6KyLPTXXi6iw2Q7he+78aOyzUvg59EjiA8=", "Kk6K1N+idlKDnOF54JZMxNRzL7VTcJAbMpLWY73kHs0=", "GbmEotWgMjuVb64JtSm9z0VRIsRD7qx/8VhLzdYyeH8=", "ERBfgYzCcjKoRF/4ht7YOP6YADhye54rM0NqVcL5/Ts=", "IiggVzL+a5rygbWytf2i0H9RhMVV+1Kn9RTGwbH6gKA=", "ILTEaLuOKcGG5/Rf7u+EvYV9uFZDqnmLwmRRnapGP90=", "FLzS/Vxzkr+dk+SbWFW181xxfUzlETe4dRuCg4anpfY=", "Fhyybm+kjbsFpcO9q0oaUkRp+YuNEBgfKEgCnHleBXY=", "JtU3zNjU8+Yv0PrEHGokyUEfTW3cAydrrCYXaJU710U=", "HefT35fRGggRBqS9Ibl2A6dq3/FlzUCsdH7UnmHGEfU=", "KYAPsAIK4Y1O/Y+sHe9cdgevNfTiI5BKzGoU2MbRSsA=", "JxJx+FD2kqNQP7chJLWDqB8/DqZ4m+Olb/tJd2V56yU=", "FmlL83/kITQLGGy8gX0LE2+XLJNVefLaMA2PPGY0gfw=", "Gcyvg5vN4/uXZOV7QPi+A2wdCtbdI8r0Dwwt6nZLRTg=", "E0W8Y76OPobT6s3MTPFCVC4KxmD291/jTTx/NFOCPS8=", "B+cz42pjscVORTBQrkMHjIahgDubwZhPg22p5b3ibPQ=", "Bn34X8Rh0eE7CnRMT3iU0xJtQAwPZ0EV12SgegU/ZDE=", "A8ICXqTuLBmy+Ni+CiuQodL0NFNRXsBCV64fxs5TNK8=", "LL8dx69Y+prbi6MbGTCEdiTMT49nzdi8o6knbB8G+7c=", "ASA1pSGbkA3trsMvYsu4WiIoo+cbU6/U0v5rPJZPkfs=", "G4xxPJDWKzZzgsDO6+vimJMVes1W4QdV0QaZko81Ba4=", "FEdfdY1dsBot4q3UbEBdk56xrwqza88m/5PkhgVB3VY=", "ITd28eD6yFX5WMsgqgkNT9R+cP0Ok291EDf8M8+cQSc=", "Ks9CweyhoJPxAZjdWha84Wv4shEHckqUr/LxkJBuaYA=", "GRlLaLiYR2WWqeLUBW4VyVpmSCNKu7+cpZLMLFNwM4A=", "CyCh2aJHABHrL4GAIVQAtYPLux/Qhf1TvdHJIXzFo7g=", "FKfR1wZe1vatcqDvO4SNdgNPepXS2ioGQzxsQWDvnIo=", "GRQkFuOxaKu5m6vBfOaCHZWimjHZK/dKEiqO/nmfm70=", "LNFXHfsyq+bl3+yDcfgTDPd1ZqntoGzItkZv6eGzxSg=", "HLHrxLQgUodugwQL3ns4AjD18UX5QAtdTXE2phxutFg=", "BcSrcs3R3pVBlolmHl5zXhWz/8rsof3IZp5z2KbLyW0=", "JMjaA82PtJfk8EUAabXU3rECtk5o1YiXckg+jQ45dNc=", "DegZWAVwb/dMslHPsLrZueP90FnQGl/HxwXWCXH6SEA=", "MEzoyzzVUZYjUgpIg9NXkiVtygwS3B6FUVelnapFCPQ=", "Dza1hphNGVmnnDig4GRQ7boAPa63ksjU3zB8VcnvqLE=", "GoMl1VSAZGrH+qOt3ssuwO90gvEKCZxbRlZ1LiRVGGk=", "LX9nRNBhlq4IefQGgUqr+IkHNQXe2oRmUfr8jCAYWuw=", "CSBVB9/DdnLdlxHXv0Ln3ikLNmtd8jZ9Q3qC3J4IZoE=", "HCLpvT8j38P3Pcc8kTHhaosHaBj8iCNCXMsbcyv1ST8=", "HFl2IzdQB4QR1sk2gNiHlZbfr1+S1I/U3ZTuXSnFHKE=", "B8uGxpc6u8afidJI10QUfiZpCmG24x0Q6YATeHnkJnM=", "DDyYgKgkhSC2Ee5N9/3MFqZq9F9S6wEEV1eRB9zJnTk=", "A5KObeZtSQy6Oh4+NmUSORmTjv+n/E+MmzG73uHkea0=", "A0D3iFc7U2/h5Cx/1AnTZxJHI92pxLDzuWLgE3Zn6H8=", "AwplvV23nwCcwbP6wc5GTEwNVDOFJS2gF7EWFG/oDYI=", "KkKoAt6QhdksO91AhjcaPxftA8CKK8YbPkPgU5NX3hQ=", "FUmhyyUENWmbOiRn+DkBEoCURGprulJtVHPoJBtQBKo=", "MFAWRdf2fW1OH2S5WjRKhbxqb5f7Nh52ksls/VSh1BQ=", "HD6jad4Y3NwzePYd1WOhqvJWmC+snqCZSj7uJsH10Ao=", "AE8tJDclKg1NnKTBsBtmCDxwEoHCM4B+dEkQs925cfM=", "Ey/lKeSqvQMEEpYkgFYslcj7PEq63pMm4dh77L4TkqA=", "GfoQcVa5YYhvudmewTvNjQxMVE1CQMH39Dx3xj8USFc=", "LV+RzTy1UtrH94Q/YFUr3ob0Xou6rkhMa3nM/zSsXuE=", "La3ZpprRRuZbur+6rDN4r5xVQNF7m6GbspxIyF2/5xo=", "A8kAMHTkUCCSErO9FiLaYccaug6KCUp2YL4fRjjqvIs=", "C6kXKScfa4FDeL8rhHSQ2LBrRsoxzFxPx0wcsEtxzxQ=", "DuWD2BfxcFrHrAua4EIVitDV7zZywdE9x915SqhPMGE=", "EUACalq9icQBLSxDpHi1L7tG7Ahhzls7fBz2n+XED2I=", "F27Av6WLOXYpCsFFlUQYxXftd6uH+5+CKBdamtjm9fo=", "E+WJnEbBT3AE/Q/Tdkds00qn07E0cP3FIy1Wo+WbR+o=", "FnMM52b2XAbLYR+Nf0/D1TxmYuoSykUCu5aIc/PhT4Y=", "Fl2w64hf/tX3elV7PrIe8tSLSnzGIgcJ3gDmHNn49SU=", "DEKCeMIXwefnbjEQ9+GyapCV6MjLwHoXFxTpr+4mcPk=", "LvGDQkxZCgpdO4pjnzfk530Q/p4SMncYuOzCtAoukr4=", "C7vgn7v9p7bgbK2GjLGjifulyime2VRTUcl05hL1/dM=", "L0IAPsyrO/8NzisiqHaaW6GgpvhUxzp4hEO8E+j6XqU=", "BZETqvkorNkVTqkpWlpp+GQUnslvBAlnO+hgzcHt3tE=", "H7+q53vAYPu9A/+uq64s1NMnk2PF5GQ3g9+5pdWUaCU=", "JbPO8dUkxIFW6aJKoNLCDtMvtptN6+HBLeUNskbjyAU=", "FebwMp7U5E0DI/AnRLT20DIeIE/TjJnMtyo1eEuUAm4=", "FuR/ZCvxPOZsLCvKAaJ2PXBLRt4NfJncsrSAcHwaO/c=", "HZ+EjLnf24HK1i3V/UMVblfEuhlOMrQhqgfengqHAOw=", "Bw4gaUb0yywqfFx8DKhP5T/9iEJ5JZ6u7uAGJ92YXP4=", "Cl+RrtEVlQzmNIsPDwAVaSQ8hABBuXTk+96sz3Kxnac=", "J3NnR3ldI1WXBHpXtSTdTB7Q4/QnmCFbqFBWvqdlVA4=", "AWfB12R5EGlTKC+UXI2MtyFg9jEEcKf1Fl8VctbCfqQ=", "G+zUV9IboJSATEfDpohzS9VDsubXy1GuwMqJ1sHjw1U=", "H0M4b+c55/nGP73LuCvM3NQXM4/qwe7ULe9xUNSiE1g=", "LQkcNYF1WDsyy5fFgWjzLYOmjJm9+nwgCNnEVLDq3hY=", "AXJXxbyNrVfvb2bMBBoWBjUJANzhhMMSQmBlNG29sbo=", "C0rcA8e/0xOQLdpnjC+iUVIqkqf8bktH1PH/mOofIcQ=", "GvhFJEQawD+i2LWzkafDcfLZzwagkAX+puO3CMzOLLU=", "I+yvgShjNiUaH8xd1EpKuf05QKBI53HuRmiDB0Slqb0=", "GHvHA8yJPiy6Ivu1mMDneMIEatvliz/yUte2Ne2ZDCA=", "JgsC2xEdY5mLavCagZKPYs/JfE+MuiboKP9cBXoOVfM=", "LwIyqZQMTEzdDkTjxHhc7RT/E7X4cc4vbuNXQq0FCs4=", "BQrcTV1kgH9zDQ9FDaVRdHmjeGo7ssjeJFNqfKXeLY4=", "FquPaCpAg9D5mfWBb0HMftvOgsDVm8yqicJUcpRA+YE=", "ESf7LwypzJU/ux1Hk0dCY6blG3fnLDixFH74ZUFdTaw=", "H20ErZfy9LcQ+R9SJqjFXsvBwlr05MqLdsxPrSTuxnQ=", "FBvlRL5MI7NiXvqIbaZeZ1tnmQKNOnpt3h7RSfqklng=", "G/eF+YZxlLReIdx2sgAyXOS9Zkt842mRdLKMD7MkOQY=", "JNm+fDLH4zv3aBbhmjweSoh8mudNFadxLa6AKGTAhlE=", "KKSB74UVhRMg25z96BaCai6vmUrvilUaPQAi13IFrWw=", "IFc8FYpJxUcx/tt8SU66fMoXl1y0pEjGiLxWSVkHJh8=", "ChWxVlkpcmQe7ylwkE3j4TNDdu5kv3bbS/XnyFQsIcA=", "GyvEo/P0SO+/ohpOQdXW4JtzV0c5tm6sJ+Zaof23jHA=", "Gnml2Doou8TBE2AAOBNehs5hiN9N/5OBVTAVk9TMc6o=", "HhXn8R6jZ1f9z8xVjnxr2MfLhIQ4iiyVJY4hJRZN9BM=", "KYoDvB7dd27DNyyCznPESz4S6VCcEkRZ8V2d94OVOBY=", "CsrtGGvSG2vwGITC6A37hGmeC9g7d3DQO5GNJKASkxY=", "JSnE/7bDnP0apuBIAMtZuuqjHaQ5A9M4WyqyWGSBKWM=", "GcR8Kjcnjxg/O1hCcRQTmz64LAuJDEGZcGrZRDkfpqQ=", "DScBvfpXz5EfHNH7Q1/uBoyu1oXGNjgiSd2az0XUyYk=", "HljjbgrXtLrSesf3bTSrSXSI0WYaRE28B8ucchlAnxI=", "Jpiy9m+xXzsWp+UMvYNaMfu4PgtlmC16esspccxYJbg=", "HDqONzeFZRQHGliRt+sob8yDbxG2KcEsm2Gnam9tvi0=", "KSfOUXMIZHP6RF1TFyoFqmao+dmhafaFxHqpibng9aw=", "JaoX2CRYDW1TMjZBKkiapFqjibPT1Vo0XTVmOhsUO/E=", "D88REtrMMReYGdZldKXLje1FAD92Zn00wdNBU9j8qZQ=", "BgMtblDQWQV9RhR3mZ77Ssq9Gp2lknMaQEiujRmz01E=", "AeQOgZ9Cb649uwCSan1lVvMNhJNMyr+Z6YdjUdFxa14=", "J5CEltCQb1JMJRZTJRCYz73Je510F+Q3cQ4af0uA0Io=", "AtsYFPFDXNB+5U+MMgXH12Jiy1/F2mBYNqCNR/P98TQ=", "GTd6Rdal3gB1HqkBGY4aCsxByoqZ/q5e7Af+UjPSibw=", "LQBPyC49+am4kyGCNFiDJ3DsgPh1iVo//iNwwKqlz7o=", "F7g2JWp95BPNz5OkxPj7a3aXWx7+MK7vCsEqg7NDTA4=", "GyNKKNq5FJ4s05uzT3lKhd0SXzM4O3eEG5ExKMuGo/w=", "FYhh/Xa9iliVDAxV2VeMnGw/8a76iIA/MncK2xpvF6Y=", "Du+AkwLTFBWEKFYYsP8uajc7G+DbBoW+Nxu2AYiKrLQ=", "Gs8+528Z3hV5lnaNr6/mBOGFuyM1a24lkgMutzLbpE4=", "L09V9Xt3HswVgTUm1ztSsvocTwZVF7m7+MNlgEDhILs=", "BiKWTKZaSLMNQKn9To+nV/1zfwIEWedKUzzqVYKQcrw=", "HIyzSbXrpZTj6W7gQe634Jb6zUIfeJvX32rq0DDP0es=", "HvUZ87gvKARpwep7JVHTo40+UK0rDFLtAYV4DoNHBpc=", "Bx+WbFu4cRHh0PA9F+KIXd9Qt7XayZ8s+ch/JaE4M1Q=", "B2j5SozIIi+dLrNquurjs1GtfI/QdZcbyV3mwkIv8qs=", "E2+50IkXD8s0PdHyzyVEaBGMl60slRtrP+STPVpPqnA=", "FCBK1S4X78yNbDspzlIgpeqMaCniqdM/ZG3yQhLCyoE=", "GTSaVvFZGPHpxsWHzSO7P5M69YMyLdXA+mFmzxzVjG8=", "L/0VQA49V68dUDdV65fTMYFKrprdR2S7fpUYFuBrT9g=", "ABiA1AbwQ1K6DnDR6k5VMC8jkyfh37sP6fp02UfAQwQ=", "IZT9BKbT6AoE9TI1pfRujiIl6ZxTAXPMKPsVd6Drqk8=", "E4TM3eV3QigaPRF8DbyCXLfRt+K1fA3uZSHTFdYNihE=", "CrgPZ5rfh4np9oYV+OZcreEsnBnosJb516WKbpFVr8k=", "G+OlVwbUgUSHJovxAZbugACaxp0m6qSua4KZ0/on2ms=", "H4p4iUBEZCd+P6fa0UOOWlXbK1O0bxCAqyWzG1OKzdQ=", "JjyFxYKC9lbqYZP3JkGqLPme5PfkfxvBuyLEbO+tuu4=", "AQGQmSZ/8e1yTkY1c3AfTC0HQzeyf0dAYNw15yzNGKE=", "BCm+vEMNQGLjhzNhm40/3dXCbQWyA7qbzV+5BYx1Rfk=", "CgPhE/dPwK7j5Ublk3v4xWHBInT8UAjMYxgKJgBBR98=", "BoiIczT0g0IvR6k5fkVmbJ/cFeUI+9T6g6XnIr6SYSo=", "HKtzF3/uyoyGNgF0W0ATjYGwwgkzSqxYlRcJJ4zPfD8=", "BYnhEvQ8l5qzuPExp5CaKE83hng6kgUnH3mBNQCCbzo=", "CBodebIm0C8+3HnWdWsreNBrdnf757/S4cc8WwVc9vg=", "HRJrI9omvSYqC6RcuDt4rhfvzxqluXR42QhD8KYY6SM=", "GdAsyvH3KMNbiFkuMA2vjGy6bqpzNDUusEeIXbIvl90=", "Hn4h2/ZtpHt2tOAlu9Q4plTWZe7M/5KOKd3QWHvavew=", "Fpygn2HRAQRls9agTqbzI/8hJrLFE/Rz4linOMNOhKM=", "GvwdDbj01D0yGTNEY0BDvTzVnsPJ6Gflj3yDSJz44bs=", "IZ+GBL+i9a69GW7OIfuqK16dWmKFW+2oeBr81mg1fu8=", "Dbcdm+hUgTOiYF1xO59QzHaMGrKCQwOxQfSy8nTG8Jg=", "E2A+XNIMEszxLaT30E6VVc2mROXZq9D1QX97uMbCRUQ=", "ADXENWBEOJ6NjT2EYZJDtX7DDOzDuox+5m2O2Yd8QNM=", "C6aMVq8PBF/uGyJm9TmAwxzuVRh/r5e2EtzZMM3bRSo=", "I/R1noz4KvTlGxoxIz3FJ39TqiQiQ12iaY8bZalRV4c=", "EgEoebn1nezh7Q4DsX7JSmrG8pGRV6uX3B1f7G+k8Bc=", "GRV5elS3A4M2MQ5G4vqgtIuj4aLUK4tYe6uG+AuVlOo=", "GQ7Rh3fOiKqK2F6OwjnYJZvw9R7YmWM5dZ0EU0KbRCU=", "JOBAgcFRnqw5kEOdX4bylnaF/oa43DekRE1fvyq3AbA=", "E0XNq0dRD9vn/Dib4EJWM144fT8k0qpzJvWTmaEMhf0=", "EZo6x4A9+9pVZNyBeKecwe/3hZespv2Vs9u/SVJRHnw=", "GXs1ltO2bK2sbMTYjC2h3jNllO5IpPLoLO79nIEme0k=", "AVdAy/W4DAWPZxq3sUsuC/OxWkTcpNZA2kBFPQ68yxM=", "I9pkSUPW+JCjRCSfDUmXAoOAEdxuRTXEeO/IoOfqGvw=", "I0T3ahvo9LukjZ3sAvqItu7gHRxI1+N9chC1qORxKB4=", "Ltb3x7QYis1WIwIrRhwmcgVO+PaaBexY/I7H8Kj8YIU=", "D1qRnoOhA8xipzUCgZ+hY0lNkC186t9hPX4Pe1auli0=", "FoUG+1riFwMx7kY3CK0BJMUN2obBq0ZPE3Edt6L2xOg=", "BlBkriwoRrHoxzlCvbHitALrl6OT4YpgC7jtvI0CmvA=", "FxD/lMB5rsVYnXoEh+4HT/pJ+ICrsU2d3dJznuat3is=", "KvNVTJu+WVs5YWZpyhmEwsFD0W+e6e0xYim09aCgEDo=", "IpZPw0ebIOcLPpgwbsML89USgFa2+1JeEA9oQ2bDiRo=", "Jd4LTNYcgZQND+qH2TietHPUafBBXu/YG1bSBI66y2I=", "H9V12hxTUtquI3sOj3ZyPUSjQTtJ4BbqEmNIdjEO2zg=", "BTO1avMpl2NQZFx8t/opweDDtdiA4l9aUndNBW6WWKw=", "Fn2IXGRb2c+0otY9VyaAALc9iDmGFvvb5W8jG4sryCU=", "DMLyQ91gzUHgSyQwyWq+QPIeP9EJ56GUYTGIBRa/hvg=", "A0FxW81St16Exg7dRykmEcRwP4+Bq7RfWPhv94l+7hI=", "HMxtgwGsFLy32Muf7sIo+cLuve9XePuI5pVxN08sJIE=", "JtVM/NUfHXbIpvZ/N9/ky1Nl4zAX+0zU1arf6mcrO4g=", "JEUxNECiCyllCgDi76dDLszNIYqLERpn4OwoxVm+csM=", "CCh81wmbcYpHPjotv/c1Tm9WpU+GDRUzsooMA0B1WLc=", "JsJGKDVqZ8CkUM9T9gRT3vpYD/vsUpXaxvJth8pnpx0=", "HRzz7qnW8jwXIgcSQTZ+6LBVYKevGoJf54hYdpIJGqQ=", "KabMNA3FCTIajbmaHkpvku0iUYcY4FCUaiEbmwsDUJE=", "IrBHLY0Y4iB8f6qBnmRqr/7AKDwGzMsEVUiZwo3ds4U=", "CspjfT9xOT9ctdAeCDd49Rm4Ie834TNdZdFLL61VVWg=", "DMBs3am7rFih4WLvXJEO2fqYYRY7W/9id2W23o4elxk=", "IcVHco/JZMF7ZaYBdtoqGoKS0NUD3BalxgUTv4iGPEQ=", "CFEt9S2KlDGbzG2qn4FIU+S/WPV9FvV5l+th1qGb/78=", "JcDZ/rDAKmS3U7ylfMaCSKXexBSb4rdZvdtTtvdZPDk=", "I1LTlE+mGixO1chOwxj7uuBesQIHVhLCaw84Zw5pmV4=", "JLs5Pe2z+BFKzcd82i50qX/4z4nXUfv82fUqQodEF2M=", "AzugkbxmXiaLZajyJ4qzET+MSum2oLrMtLhAlpo7Tzs=", "IctLRF6KV5xzQ29uCLaySHrQ9cRwbw3clUX6YuoCJLM=", "BKklrjQmDf3rF/XHk+S2crj1wNpp8Wv7KUA5JujX1Q0=", "LfQmZ2EKa8ZgKromdGJmh3B53DRaefbWc9ZPsn1/9Jk=", "F5k0OGpkI82zoQlQ+2XRx3doEu4ZyBP1pnICvfNsmAc=", "DA88wGQ8kFPn6Hoe1ZDeqKcObV69kHVDyVYdpO6fz2M=", "BRqFje/AQOrwhHvFcU/KPWN3VwnVSGqZXpMzYYT+Cqg=", "EKDak/XiTgLh2jtwPuzpf9Ogj0OgR2z+/XA3LWJ0+kc=", "LXvrQGeEC2VFaTX+gI9XzJcbb++34J7JEzYQPi+wcrM=", "E/G7tqhQy7U2oBl8AWpGcj1zh+mRtn1YqAZcPk3BjFU=", "BB/ZgJcdSJfl4/QvQ0LbEOUX9jmFX7ryHAuVkLI72Ng=", "CWNpJ/WzSdKQBnAp90BQyXUO9XJpFCSooKAWY6RcUDE=", "KvNucEAB9gI6y+B1djf2yw+suo4FFbDfXrMXod0OZb8=", "L5dVj+b2AEEJrEZYYJptLNGyLl3AmaLqEy6ICH5yzKA=", "I8xMD5brkVJEdEClXjo9C+GryDg02f4Ic/ydcUsOJtA=", "Kltr2Iioo2V42GJfW3flJ+oG243BtUeW2A+xx9spO5A=", "JyIL438iPILvMVffWWt8PyG8wD3oxKuNfx1bqq9jjww=", "CbktBcBZCMXZqvTo0jRIH5aEBmvsD0eKb39B5HOPlMI=", "EDaG2E9iCVcs24KbeqZ5Yr4BdSiZ3bcXgx32WcLi9gs=", "I7YnI9WO1cLGuoGDg6zTlkzzkkMojVkaS6CAOxW0hzU=", "GIcPQ2zLZaDh3F5oNySEdK5S/SJrF5Ihu/5z90fq4Tk=", "AoaR0vDDNhSLW18cXcBrQi00BxcF+aM/ryYTyQfzMl0=", "EZH8Y7edhe2spqJ9iOktQNiXzArQUhNuYLW9Co5WAoI=", "FmgLgvbnVdi0GdHjAyA0V7VHDY36IU0CNXnLbB0Jo7Y=", "GA/WX4xzfn4H+9DnZGwVQcjDTwvYoeFiOjoOODykIjc=", "BsesVN1A04kaFLSOdCoG5YfL37Zd/0qVXanHHRUiQbI=", "LGXJWnJXE3Omq3oYt/Q5LBrvKW61gVQdh2urbDv+ba8=", "DZwACKTwchTCT9DnM4ZNfFf04TwEDDGSO94+kohVK8c=", "EtOgTzQ5v4W2UlIho/MUomY7m4TuKQ5IEWnasrCkjQ4=", "LHXvX87iktBd7np+on7r6Hvt/mWCZE26D7URjP3yVes=", "F8ATMLtXCxyplw1YcsGqq4zaJLMw6UosldElSRaCg+M=", "A1+iZbp47+wbOJ1Q8YgBkcNb1AKXfFDSUokscP86Zvk=", "FGpkjkcViALh/XtuIRVh3jzhDfY0c8JU7S45lHlvOyg=", "BcLy1zGPkfA5irVBxyuavkzUgQWYvQr7Iw/Nyijw3Jw=", "GhS6ySa8gE+qsK1i+iE1g4cilP8x2nMG6KCS6wcKzUc=", "CIPNbn2+O7KTINsdoRdhj/n3YXE7eweBT0u61xYQ2J0=", "BvmNK760WtgudiS8Pjh6Gw2Bj8yUzp2W9Oc+gMqiPlU=", "DC7JjcDuZ22GLMBbCefXQ4n2hE70Yt4zb2qLaT5WjZY=", "JVGRz6gzzWqGKshp5SBXXo2nDaMOyXBlfDh4GnsAJkE=", "JjbD3h3XeeVXfeIUs+bGNRcR6cwTSNvFU74cjWi4sGc=", "BkNwN5NyGPz05zzpszi6ygw/6UjDmM+fy6JawC5lKVY=", "EAhVAoQ0AXTR5HrFoCd5MxHEKGfjtxiySkeJrPt9bck=", "FSuZFZ6H3W5oGq7zi/cpVBm7h9tfn7DL83Mg7HJtRI4=", "DTgq3psoGi5ybLlttU0m9DMliBh1O4jiZigPdNjcqAY=", "D1ROJFnmpjbY2iODTjF+qa3nsqB8SrlMNo2jVs2ITm0=", "KmEir3wc8pRrM3NdKp9QIMxd2GaVKed9AGnbNkzLCMo=", "K9cQY4+gn6cMsKq2vN5WysrrEaqb7GiMAz73gw3QzQc=", "F+FysD8lyY6WgM0Lus8ZM6lC2DTZRfuYgPrpXSWUk54=", "B1msycuXWu+xioM/9MhN+DRu9jxOtn4iCxGw9TUMYzE=", "Ip9B4VOkQJ+iwMfHWBGBPYpxkw2myLG4gnqmSL3Opjw=", "DTFT1tFECqjo3AvxBYZnoY5ZMa/iT6kKwZEf4yLT2fc=", "GYpvF5+SukJ0kPuQuM80VfafArdW6Y6wfUYBpSx3ozw=", "KcK+B+MNk92SfoCqScRN8Nu18FBulmdtLUsakVcLx+Q=", "E+dbCVrSGsnRB7Kn8eYgiJdCQFScC7Tn2DzkYwzavc0=", "GG0eJsTkFciqswXxYvANindUzBp6Sl8vMYt0N0ZcqGk=", "JEYuF7Kz/zkS0OQfF1DP8WmAa8FYZI2oIuG8n2ISiGw=", "BMj/O5oXT8BtOzMC/1fFEK04WAw19OO1r3niQFVmK8I=", "F0om958m+nxMJoLOwU2nCu1J/nx1dw+HpStaZyQTKJ8=", "F5TID6IG6Zhi1+GnU9d1T28XeVgahSAf1Gpb+3uqlS8=", "AltGMtKXcGZ9CfecM7sqilr2akSdbTn2/b5jyXbhyhE=", "Ea333vlsU9vf/QaoXWMUXw3SOVBj6NMyvkLqmco2hUc=", "Abkot/KTvqsDI1DdPqTEtIxKBP3/CCtPVC4JTZc6OZs=", "KBGHv5ikxaa/kCAwksauy5/C5WGXT3n3SBqm0pkYMro=", "JHFozY/A7izJ/qVhvE4BrT6leHR1b52dc0p/vEXAALk=", "Iwl9dBJeBCeOX9DhT1LuGTa5AcLeZKBbK4CZGh8/Geg=", "LK/f/2QiI5OZdTqWEQ/qqKFWJku/WQE/HYGVowg45kk=", "GlggKA0cxm4su5kyCinYDnhEV2N3Y22MwipbiYOLXoE=", "BDmvGRyCR3W4a2rpzd7WngrFJNLXlTvOZdxU4RZUakc=", "BZIW3OBr15ephwmtK5DBXR+feBd/CtZtUACXJe1oZLM=", "F0U/2M6XxgB589AKopvoubkMvMmiFht871LFmcYobNI=", "AjoayPOgfIbpMYTF8IK+UamPcGttFGfc40S/4mY5fsc=", "E7e/061RkZDUm+snsA3zCZH61AppTvDfEuidYXJj65g=", "A9N1RhRyKLX6+VuggLK0AialiBBGMgi5s5Vm8HMWPf0=", "BfO8+43ckXg1Qwoi5Qz7UTlvFSQqX9DH46wVOABNGe4=", "C3VVj5JWf8HsVOmVSjPvr79RhmpYlKdlUtE0lSPPZf8=", "CUFRg98QMdrSMpfDNO96JVgZt9dDZb5PNTqItCfZBpc=", "LcLH8ZtQJDFc9bDHZUb5Qy4GjvtQ3TfDlfuHRHccDjQ=", "EVpawUj/DCmQEiC/W5y9PV3pqQLIxu/QL3qSyx1O2l0=", "HseJQusP7RaPvlW3MGdfPd/KtpwSLZ9soi98+nIoC6I=", "JLxGDGlyV7swVStFrTcxOYdzniUHnChC3N8vl0+btoY=", "J4orKb3lS14dD4chbeSPUdTfooRVXr1/5/Pd3CNNGls=", "EPXEsCr1CHd8TNPNDGwR9NZ5+zsNelJphZO/UM8gPLQ=", "LWlTJPiFRFhA9Sa3HlGfKVz7Cm5PJBRflS2Lr4Vy9XM=", "GBE1J1NkNLYx+zd3rHM6slDdvpcdpQ8T+mzybJ4FvR4=", "BAcw42hOOR1aFmtUh+8vpCqe/BVGKc5BPJie/iyHhZI=", "Hrsh2uavTcfYC9K7k4mCwhXKEksV4Hl4g68qgK3sShI=", "DGgCLrY8s6c4WbV3tZsX5vg2F2xZXGof2hJKBezvwQ4=", "CI9KmvXWaEdbuqNWEL+sV5DhA+9TuaGzq9u+KT5W9a4=", "EyXi6E4oHKrof5Bd9xnrZlFz/ILPzkN0PrPw0fzMmLQ=", "Lz6joipW25cMu+2q/p2F8U8CRWiJtkq3EkskeZeO0+4=", "BVVkt4Maz9j0bflu+BliKkRiv+goGwXpVVdZgWfunzA=", "CMKemiLsfwJEknOjUTaUm3PeZoNOPwFfRokEOqs0EBU=", "ISplSSxuKZJIQWDl4vb+j+x1gSVmE7BbjNQjfqWW3aM=", "IOYpu1tsHvB++i/B+PY7EqqSv7QuOOSDNds63yZ0Fvw=", "BAhv1sISixGlqlj6Kosl7V5Xxbaj32U0g5qBcpnOdxM=", "BlJFz1kUjvPPkj0oZubx9h6lTmoOZQtquMm/lNzx6aM=", "C2wbG63ADmDcfihr8bdhmOYaBjz9wmMPdWUGSvF5+lQ=", "Ajo4Kd785E3igZ2+3c2b0XzBzCTV79lDRTUtFTyJgJc=", "G1HVC58qHOA54b8zpDlfaT4Sy6mqXOr1/AxiZepEa98=", "Ctori/BpsKhiK+hb7FzBUCR1vMmVpWhwI+oz06lJOC0=", "CDJiCjVeExpHnRY71wLi6WqrNoj4GLVK03h2SuGi08w=", "Ad189REC6osQSNPfymSTCNWfZfTzcL4Acmz1yOOnL8U=", "Is+erdlYCTXwLNiniJeMU7tM14CyYseqC+tn3vXRl14=", "F+O1YFUW2xG2JRI0j45/IGwucf1Xp72f6Wgyr2v3IVs=", "Gq0cvdGFvForvc7vVw7bmGUg65K84rJlq4hkxRrEidM=", "KNXs7Z2eVRXQwpuADjM79mZiqLW5g5hW5AlCIt+049M=", "FWYNjJNuHu7tsQQ3xMrlRNvBub4P3WOf7/0CRqMT6IY=", "H16PP3Fcug26bxJx4cyJQLNzBSRv6mKqfhbDAcif4+Y=", "A7w6ExvOpbL03bXNWPcaksVJc9pn87au65wrKx7TJig=", "EJicIYFegV42lbHobqwK1eaEaPNwZhQtBC2VGvoBNgk=", "E6FHlr4sYr/O84msy1CVKkbHVp4AkgGWXxMiOnf+/4g=", "DzBxSLdp1aOqDXC1RRTR3lCY4HDauYbALNkQBcN6k4U=", "HnIMVCuDGpeIYOyogK1SIhBWWgZYhLgv3Zq67T0iS5k=", "E2mB/E83pd29V6KEOOsAPKf/AQmzScKzEURHv+ZCDV8=", "I8D03KeXp//u1hhbYnAEWulg+A4f+97SNJ94V978xeY=", "DK3sNTLu9uQ1ZWQ2vffsVoU+3y7MHcqzPlhdf58z8hU=", "HT/QzdypZ0nA52sQlHR/ZugiuwehoBFQbRmOuAuDFCE=", "D6S/V1HgXLGHmn6dG+GMDPsHCuLlQ2UDe/FStFrAhe8=", "CAHEUApRG1+bbwvLbestCJij7p2XJ88Ce7F7zteZImM=", "E7JXyLcZTwzPzYWbA/dFHN6DFHmBFawd5Zgcy+6ljlY=", "DI6MsTXdOBEgCHN2oDw4bmeHEADaKxvAK+lRMw96VnA=", "FldirIuuZvPzgH3ZJaQzTocKm4hWKMt7wLi3y5QcBw8=", "BCVDVWwyWljjrHU/SlrsQNPHOSbp47CmK5KluSDEfMA=", "EIhBN+hmAL3wb4HXkEXqxsNPWK1oe3mchJ0tEq+ysAU=", "JDqpp9NHjrc/xcEQezm+zZgIxuXkVTOjsmfOphKjvBA=", "DVbNT1grVxmjMBvnhzFCzb26w5AcM8cfSQop8ZjPg38=", "Ab+3nrNyZNZ8ErxLIU/XKNat+E0CoIFl7MmChoYS5QQ=", "CCs4A3uWpH9U/qVPT4UUMPfHFnZstYwU89uO4dqnB7M=", "HZLvC2fUapkd5gPIKRejK3sJEUCPjIqyg702/Bxiung=", "HoW8yRky+coHs1mEpBxL/cokOhUUQeG3WMWkwK5roYE=", "JeMPbYTamJ4NTQ24TPV3Oe2dHzVMjjqvzAG0eALFejQ=", "Ee4N0wjGXtyIzirS7eyim2YA/68wn8bF46PWMYypjIM=", "GPPKdRiP/1J0IkzeNsLYUhGwlMIPU9njpDUYluPRocA=", "BbayHB9wgDKRG24NxOV9Ho7cvdFEECsoyGF+U7EeTns=", "AOt5sHvL3y0iWBd7/RW6Q7xW2TYuSfE9ACOU9sY18g8=", "HZY1cc5zE6FxELF9ZNRQAbNtILSGn/zuRO5XjSPWSI0=", "KMRRROrc40X4c3i0MrzzDp/bQOL/z2H1uRjjrULM8VM=", "J3ZTCZOhH7flIi7g31Bb5eV827Y1L/eFPmaAB3FL1xg=", "IQpwBEVqTH5WZC55QCMIQv1Ut/vbjDN8sUk1Yed4/o8=", "DMHLUZhqsaD2KMEtfGZWqdhJXbkdkOXa6PDdJk2fGbo=", "E9Hgy9ng9CFibI2wndJN+SwnBojnAklSMdBXx2dvsd0=", "HCta1Fz0GBYR7aZwYKBJDY1q480bEKFXCwC/C9Oibgk=", "Je3BHTtebpaMqaJ8NAz5NQdE0okg9XYmh9LTHfrhQjU=", "IwyOesP/Kzna66J4gRnNWKOpCpwkw+2CHq/Qg4PziaA=", "KTfLM8kwrEvnh7bokOZ/igjMksFR9+Zz/7zCeyXNCx8=", "KKOsZ3tvGazmnj0GBJVX/eKpJHbBmeHIGckHzkVoEuU=", "Lew0Hu11JKJre5G6swAyM0cDjAEgbg94A0nlwsokcHY=", "DoPJ9oxf60IQ1jOCHMhAvR+8vth+/96fI9RAPZuLA+U=", "ES+yEYVZjnhb/w8PfkghKJIyQD+ysxtI5+yQIt8reXE=", "H6piHwwDn9yAJMvd9MqBdYHG4/Jr3ieLE8NM1lG9h4I=", "BOPSat/LTvfMMi7lV4eGBupbU3+h+IBEXGR+jRLJjJE=", "GnDCAVvxxd+mN+jev491njCfRsN+U18MZEhplepbkGE=", "Io9g3ltfOuilK87ez3s4MNW2h5/tfu2VIxxnTAFsf+o=", "Dk3cUS/fg5rEi33bA+dl6c9eMgdFVypdT3AJfBB0QGo=", "H45XLi4LSPm2vcR0IQocjfZVyl4Z99E7WomhhfOjzqE=", "A6GDITFRwz1sWLZjHK+gwFMA913rn/lx+v01RB9crHg=", "G32pgIKASKdJjN0rSewIvjutfUMnyXVLXj/WdOAsgoY=", "KF3Zw73nw2GhbL8Uv7C1p42PTORDPUHxOjcuksNeIbU=", "BvlS1m1gzRiUnsCKXCA3B/9FLj3zLVCk4iHnKnk8ugY=", "L2hD2giPZ16nc6A3fs/O4zyWAa2luCVrSfLCJZq4q98=", "G+5NnhaKxganPXmpkMWQkAASqv8DKRdHVTeBOEwo2AA=", "DIyFwDINaRGrZaUN6ysoJdPjOSGkZSLlTMtrgG5V8ZI=", "EZ/8buSgAOyLa9F1vJlxjatlCOmZV42F9X/iKUYSDVU=", "MA0OhoHxF/tJGCf6EhASBiVOz+WnCwhxbRlQtmNc/wY=", "BPQkwmRxkGCG2tLeVFKzFIqUgKZE5psNLGqONXIHAYE=", "Ku6ghDvm0mNwBnLEJumCDBbwlv3q3ve+scQjwE7d3lU=", "JwqgrlxaXd9oW8QytHyZburZ6x7YmiW+0rs1jLTttvQ=", "C6T0L6Q7AF4x/i+/J64d8Bf/bRHyfPlSQ2ODrJAb0X8=", "GJrJ9Y0lmR0QymIzsa2MxYPMHCR5lnkEqAH5LE2wiBg=", "CsfCA7WwbktvVt5F+9nlAteWYrPvTBIvc/ejOD+1KvU=", "LtSCvMtKfIp139MaRDt00eTvUiolBmA0TCGoMgpHjP4=", "D06trpLM8HHc231nJB24IoagtTQ2Il2NbQbDCU0DK+g=", "Lz7kp2cVs7w/63TlKJSP8VLQtpyueqow7T0lS6iTGnM=", "CmZsy/pu0JxX9Y7iljQHI2uOvhk1cp6BFomzmKnde0A=", "Kr+LnlUzeci/aPvGemfe5aIt+XOTZzFFIR0P6fXvyiQ=", "Hg5KUqL+AR6vqs6D1UuS5thXY0tFEBAZWOfYBobuknQ=", "E+5z9lJazFIKCYfBYeUZVyO0eF17pqAxyDV/1V6nVA8=", "CU/ywkz9KFnvZsT2Jpb83H7bk6uSEnymInpsAp3hnhE=", "Am/dQJK+NwkvoT4C0Ds8k9q7f7e7rPMSk0QGGQlVbMc=", "Bgyw6/IJBnkAmNJg7QCnVwTojjM4b0PichVIiNVv7+Y=", "CrD6jM0oCATFN9LgmuxMEwaxp7R5xmI+kSg2TZKX990=", "E90i5h/16eM4f5BIgDfgbEjPnse4/ECy946DHpd/PRM=", "JMYq8h1hzCd+0+7La1PaQPgkpryGGfgwpaW/hoRsHUE=", "KgJceIjLDsaiM4pL5XGnxnvff33PXAd1t4Wixeo6DGA=", "A1wf8HewFrgGnARKK/XMCYA+lO4BEMF6W75ZTLsnDhQ=", "LyllBb8TU7I6ZyeRpO4yWiip4bId2wInjki3yP01TRg=", "E7FsPMDKRwx1vCrXv9bL8LZpx2K/BBEBAJnBFi4mqac=", "LTyQC6mp1UlPztXXDopArLaPR6C9JSHzgT74MfaQ9a8=", "DOnl8x/rCo0g6xq6iQCDzDCSc4v8GW4Q24zDSzHxry0=", "DaQTvGxkpS0Gi7xmqiUXwyPOLgDsNlI1yrsiNcMsk9E=", "GJeuGiPfD5n4wc1NSAlYuVnTJ4FuannYP2TxHyn5om4=", "DRFt/lNiEjaEU51oQYJadkwFPe5ttrK7XTWWZ2CiMtA=", "IeJZUumPlhW2lrTNxUA818xDKDWo54rHJ6ZGdLNOQxQ=", "Gj2tV+euIFpI86AkmExNoFAbVEr8Y66igwImQtO3RSg=", "Gb0++gpgkpUe5xsxPBts0rAW8d7LW1HY3BSSfsdw8YY=", "Jm78QqMM0E1nePUKP71cUdvPzvtutAD4WnoniuGE44E=", "HI2Q2F72S/S+3eYJlX/03QB6oF6yotBOB7AwE9fJC2o=", "AqwG1M29MIR6n84URyrjIOHzYlJocifggvITshnnJwM=", "BSLyybCHbSc4i4tSpRAC5f4GafM9oHAU27jAqOKehc8=", "Jr90RiTOV1RhxGYnDDx8sJ71wLg0LYZZhf8i0XtHI5s=", "I3UQD4aPBuxhTg3tbZn3FKGzFZ+BBJPIRu7CXMLfKFQ=", "C/RhFGtGs+c+Dt1JNpifQEzqH52aBYKXuUzerHdYMlw=", "Dpg3btZBQl4nFvrv2O11RLFzxaOmaTYgnkr2Ka5nccQ=", "L5xNlgVqE5HYnyhyCiDQoefLWaXJOoff5gabX07KJxA=", "GS8gC/O1VbuseXgZuyG5kLcp1lpNKKJ9bT8A8aAqojo=", "K/iYS1YmrM8Qt2Z/T9zNt8tgWgrjTW0gSsHLyAy0kSY=", "C8ohwSRkJHJEsqGf0w/tZfjjq7+DNbSSBcH8wfaqwao=", "FAeNTuEfRjRxpJUWw8hfmiZvjED217H4ax0ZNbCfFfg=", "C7igTs+fmOFpfTMOki0Mir3gAAtQtapXxYANUt9N4BE=", "IVJhIcBeCaCr0spu/ltC6/fpEVOCIhyqrmKKM0kXsDU=", "APakQ7Dn67C/d3URUS9mxeW74ETJZl2WEJAY2XKchPQ=", "EAknUelPtrXkm+oVigFL2ZB4VCRYrxS6TL2SWLis0jY=", "ApOJkD0NPCmhc930UqZrSr0278ZCywtX2PEIGdXA9fQ=", "K20g5sx8qRb1QmaHJBedjQ/wdBw9UfdFReITkRIXc3Y=", "KQC0J3+zoP+DtMWPrHmohh4wXV6zE/LPV9uwWTkDZVg=", "EK/cAGbdqbZL3UO4bQ7WK5s5OAB8xQ9WmSUCQM0u4ak=", "MB7RVm9SIOF/vUCDpXv0LBLBWmZHroED7conL71fjxE=", "J/GDMinDpZmGhpA+gkuz4+ELyWnxNCqw0C3mNf3a/xE=", "DE7zX/n5BtC+pInSAcIQxTq71HoVGp5O+9uSICn7ZK8=", "C6Wrkkavcjv/RXq4IovgZISvPjVF27TJMspJEV+VfSc=", "IcVyvUJk2CHF4q75kwBkmciLMkXO6Vk/AsJQFJroesA=", "BNHMR5UAhxkyb4EGyc6aSw3eT03gHSQpojURsf0P0XE=", "CjeffW7tynxPB7td8tjqDdh/Hu/irCJxNwp/O+JwZc8=", "KNrvfTekPyukQGXyITkS6rbIxg4/dWD8qZC+D/RjlyA=", "KQbomWRYUE8sBE8FPErSTTWw4O03OyfgLlI1o9NPZcM=", "Jgc4s9CnRvsGEtym21O7loxVIhOy+aE03zQbrz4TecM=", "BfF3roxu7IuXEs+gQndmkOkkv0IkMAEe8nr4LfCrsjc=", "JoEQJ/RF6GwZLorjcdLoP7c1YcjP0Qu/Wymnf1ax2V8=", "Et717lnBtKlrUKs942F1ZAy3A2P++JmV80km7oS+UU8=", "BptYpqpBmUoRzH3TpCj2xM5iG1sGeT9elbQDTi736bs=", "DbsWL84YEr8qFq62qsfxc38tJ2YMpM3255Eh+/u2xeY=", "KHuoSqUIfYzJ+JRQ8f45HMOoTyiiSyYc0dzasDmjCfg=", "HoeKHy/HfL4jKup2g9RtiZbeu5ywavADhJ/QmenFBOk=", "HI0e8kbddfQt4Txb/gacCNavmUPNfyM28xyJZFbLovE=", "B08aZ4ywKUiDVty0d6iDA9De1fLV7OVHafFavBmUU4w=", "J2blWBcqxwsfPdhfTIBRe6bhhVa/UdIPaHtmnngV1H0=", "IGNjU+KfrOuu5fBO3kL8Pq0NB3J+3nqArxxQXG/11TQ=", "Ee2XWqPT+brB4LqxIwQWcfjbaV/gdgH+WnHg/MqRa0Y=", "GBABYEGP2Fjz5P6NXWuA4u83Zhi/5aVW8kvDJHCZxEE=", "KryhjZs/JSLiHuV6HGY07BJ3TQQeZe+EMCJM8x+WDxQ=", "FmJSQVM8WCubV/bglj37uppwJhOdqrMXT75xsNlSLI0=", "G9PPG9MSSrqmJ4UP93pneOjYLQfKJGVdlMWie1fHgLc=", "CE566KUVu+b9g3DnwT59CYNcN0ntIcKELnxGtL+tTjg=", "AQW2T9sPApiHMrWOBtuACy3wmnGltaFlrSAR6/SKZEc=", "BD7UNta5r1Z6rH4kIGE3+qCG0YjoREyr1SNJg5BLzvE=", "JFHLel3sH5P9Kz+Ll8Sx3S/OfIfQqSyfaZvFUAMqCns=", "GPN8Yk6W75xJTS8Ba7HtlW75UfO1dCCkbHFgvfqldsE=", "G/hNbXDHSMzZgcIbGdVVznw4QfNCIMEHl6929i4liYA=", "C/mwUfICHziilOrf0IEfBcCIUnIL3HSeH5picg9icZo=", "GfH9IZnjqsiMfM192FjRWMLvEOgjbSzWanCj8NGHmIo=", "GvnWOs5tt6iuIKBLd2+jneNLeVOUIxIUMX8DbllU7qQ=", "GzotCNHDdjt2eLnZ3h/uEM2oCTf9fXTyfW5VA4b1RD4="],
      M: [["Cx55fu4/FbiM46H6/siNodYymsPDRxLbVw3ohs9WkJg=", "L+Qp24Bo5huCYk8ldmJzzZ/mNo/wl+q5eqoJvkxjDic=", "LnUIZ5QkOQgzZdIf52DH3+yeNZPGfeEqQlXGsBZItpA=", "IyN5halrF3/3wBSGqw1gPSmZG4Mkq9awfbuW9cIboX8=", "FczshXslk0/9Qpr5LJENsx0A3Bw/uDdFox2BMepbqoU=", "FxAq0tmAQ+VQnnbDMeayLV+2LQdHYIBqpnV2RmDrVtI=", "Ck7Kq96dHqEcgdr6jV1Iab7nrQv063g5e3G4+YnPmBI=", "DsGCFkj93ESKFRKuzIrDdxSSOYGUD1VCc3pGjU2IfI8=", "JVpJOqS+zZ0TfrdpQcQSB4TBIz9sX99dZcCDKvVD5BU=", "Eg9EZwMBsUNSSSlNmDPVngFoKvTIZYcZcnZ4/Zq37y4="], ["GruVtuMyQ6BQ5WO1xP0FneVRPsKJlKb2DlfJjTvI9YY=", "CltgTJWLyQBxrRBhixdyWZ4Mjd37ZBEx/vOdqlijmSM=", "JOgt9Yc5U3krrKNFt8GfYQOa3rEZBZK8oYz0+QfBpv4=", "EOM0nu/ToRJBfhEP2egyB45UtfRTfNAYruPfu5BUFYE=", "FlrevgDHugGUmQGMlvXFhw7KVnnJDIQ9lScYSlJfzKA=", "AfuBIY/u7fTn4OM92Oy+YtZca31CM/MuBzVx/4YticM=", "G+KAL76lEAOq+ugv9EmdEVg3exCPiwIMgrhGCo1gOvo=", "BBgIHejClYNVoeReKO5RuixmytBINfT72B5pbeY5h2k=", "Hz6TerKfOojG/kOGmKcZilIJqmrJ8UExnzuyAef9ZxY=", "ARPpaHabDqMst7X/cEhKrMlvE9woJ6jl5hFpXgeX/Dw="], ["EQ0hOoNkeKowG8H9Tt04hQfYd0Wzq/ulvygq/SH3JCo=", "LN7gxjWk/NlUnw+RtPSptiiqcxni6qCUppOzi1z5okI=", "ANYPBYV1XUhXe0ZXRt6OKG5JklFQ8XhPKftrltvY8Ow=", "IWjc8hbYNppibMxhRTI2o4nQJRnzBS6H7/nMuKopnEY=", "A1MN2WLvI9wW95sowfwd2v6UWL4VF0y7vzqAbeX2PO8=", "HO3G1OFHZ0HBCZVX5Y5kLEKJKqNuLQp5P2cHgaIbDb0=", "JpyME5pPYeFr+q6ei7scaYCMkHEIOwoznf+eSQS0Q9Y=", "Dqe8UlA+IDnSd5EuAi/W0N7VvGh8b/lxlJdvOii9MMY=", "IYC56xVuszytGqdQ6g+j3b+kEnKW5Jf4bmRB4FKiO0U=", "GM0UcUMK2tMeRbUpSU/Ip+MZvS/AYZyZIH36zbZXu/c="], ["GO2y0QW7U7dorgE3hQ3C0r9tEwOh+O5Krfdtj4GZBYg=", "LJYtfVSpjDqCpjjYyCRQgT9CBxoXxsBfRwtElY9X7xU=", "H0lekwFDFJiNrOXk6Gf1EJ4J+gD86Hkp0eDs6VpEk0U=", "JikD82rPDcBV9hA5ffB5T7wwkn7xhcY1a8M+XDH6758=", "G36SKz3VA+ZEGtqWbIs7p7kIyyuYtfvh5ML7mCRVuqI=", "GoiuL94SujLl9OzKzxHCW8Fjve2qqIJEdMrlhp5ewg8=", "I0B3KCaccP5xKwIZFQWdyNwhJK5kjiy1Sfx2NivCuX0=", "EqsxhibVEcI9KLqp+1tYAuCrlePLF67bqiX00ITP2lc=", "HMadjzTuh3g4lQ4gqdTEvT6ayvPWk6pkyuBPqiJaLh4=", "I9D6ll6SDfxTC1JnCx4y4tX8KCH8kYwIRKADtxQYJa0="], ["HlPpLfbFPs7EwN5bB9xMmgxVRfKrzB+r9My4SgpuLCc=", "K8dhGF9Z77e2e88dPlTaANrqBn/knj8dkzTlRwQ4tFQ=", "EkMx4Oyx2YCKHZHvqpiVCr6TDEb+5aMNWtB5dqW8AmM=", "AEaIdyTykyGJXC74vAz1Rd93PAS6oJfDUqQWU5XMp4Y=", "JHRgrUWAoYY56tppuQTJGxn31Dh0NXB2lsQLrDv73TM=", "JlQSpOO1Vgq6UC0g7YM97/cHt9QlujwJ87Y5K28fQzk=", "Aq0G/J+BaEVC4EWKrhnAp8GL6U8d4/zmo+XSM1oB6Q4=", "DR40GSND1m/BtlkctqOwYCsINaQDxyJ9vL1y/YAAxvI=", "C1ZReYh+4w44FjHY5d01fHDuLrtBBhfSMh9thTf5iXA=", "LqazKvN812XXKN3vowkYkCoh4ZspFACFT1Y5PFbWlGA="], ["EPy4F+EPafcHTmTDk7gHzd3zPISotc/jP0S3P+GMDjY=", "LkUNH+d3PJiJoL5V5ERTvMhEyUtW/Au4BuuZgqxVNCg=", "L0Ifz1TXfdOJMM1pB2+bqt09PxlHNxIVpmyJTWN+ibk=", "EydggdsBLR1PS33S2KL4pRgNLswzhUzdNfnOsHv0DVM=", "FE1b441Exb+PPFc1M0+xoHwTcC2Grzm6C0Ig7Jp1aKI=", "EmkbWZ0y7cSK6Zx6c6vVnlsY9L93P6EFHKvSxJqqv2s=", "BXilXw/aKZCbn4UMPXS+ZmjkRErGkXZPFkSmJkmCGOQ=", "EuOwSSSyz25Ae9JrPNR7ymHW/89++hrqHC4NikneZL4=", "EWKlbtO7u0tnYKFqMAunICEwCG2k1ViKcJJkI/+MJC8=", "AzQMrLBNWoVhTqzEvjNSk4uqP8cUwldaqdhfc5ETxQs="], ["Kx2MEfxlLFk1Q7b5gAu30Mk3He25bwi7vM/9xsxE25g=", "JcD4fJRvN140H3L2qN1jqU6G9K0YJxW8/L8rKN9rSg0=", "BUOyvGbzstk9TBiCA53bN8cMC0N6wjrFu5ho5t8kSF4=", "LdEXIYU46KywMB60Ct+iQ19b/6gCj/Uvlqmdd/6ScGY=", "JpsGsx6J/xMtrrwgDv3IqwaBNvzmXy/FWh3Lk5t/xvU=", "INRAHLv5KHfs9hbX0oVRywrsVS+ulRjc+SGMOMGgvJA=", "LuLaJLf45wNftzsIw0FIM/+jjhSx+qwZioYKV2fS/u0=", "Bt2J+r+SVGhHucE7Oja7x+Z5xbsN14VAPz/0m75hyOc=", "E2D3GQNFcrWUEMUptipiqpRWVlRZfkJ3nzNADx0X1lI=", "Ff+CfgNMAqkHZ/AVKEDn/G25g+SW6gUZwP9B3qgYBig="], ["GfRz5AwFZ21fjVHhEzbpxlyzKCjDl8yBJfHcZntsrfc=", "C/5vwI4qLhuJEa4GW5hTiPzRBaSQpKuUOyVVjPPQVLY=", "ID2e5kYqWGkU/n2/wb+il3O3+bPWOupBIMYBEpwWZg8=", "G5Eqvy4WSa1INMpbKjgxzJwgfU0I5L8nSnncqA5S/iQ=", "BiyqPJ/Tm2mGT69wHcikWIVxyzG/1cnDxZ39l+mfcBo=", "E4wDouzqGDy48mXuzX6TJ1sLuYKXwVRachl9xt3ZM18=", "EViZWfwkkykvtsUHMOdJlK181tNTPDsApX2ugzzHAeU=", "F7n6zb50fXxRY8oA47C4JdAS7UNXYE5xhXUNZ3xrNX8=", "DGA9A/koYNqKaMbcsZJNGkUJmupQ8aNi7bLyp93+kP8=", "BdVvDIRNFpJIUDE15N65/9YynVTPzu1LlH14pWhoEUc="], ["D886TZxsM5LeG9/iXPuGgX7LgMUb4X1H95dQIB8fzQE=", "DBguQ4JXxK1+e3nDto1gmE5QesWXy0fcMdkTp6VA/Zo=", "Aloey9fniT9kbzXT4H7pl8lDVHN4hP5sJq6BVXYNuKo=", "IBNf8mOGf3CO4CdRcMyXiGicCIspM6Nhx3XPQwdI7x8=", "IOFg93KZii99AGTH76FYhOvG2LcYIc1TNuLfFDQcle4=", "FQ3xEpG2gOO6kloEccf7sw5wSrS1VOpdjAe3CyuWICo=", "F1cgKejolyAtDmXCFyxXHUuRyoVuetPxGK2SISe4cFQ=", "Cv8VZQuAW/9vizUV1eKc+RS3NJr4kk55YAn4pPG3Jkw=", "GpGPwRfZpkReNj7lgz3AFBEDS5U4TZju5HrolvkqfWc=", "LlYYQR7+owzH3jENSHJZfQh8HhIuAuuxF9sMLf8E/Aw="], ["I7AtAP4mNIiWc6fQRzb+Fbn2JlKxwGJqGa+NYIXXCCI=", "L/TQuHmKgmZ3k1M3MAg8JSI9WJzdB5Ni8ejC4B1UR2o=", "HYl/YOh/zlzu2Np/L0pj/e5/+dzxecCOBenlzdgjisc=", "C6bUzu4hgtPyqy5KOtCPwx9/TMD+yRrVPpK/ito+J48=", "Bc6UuOmmCyiUdxBGHYfHdXJGJmro+l068+qBd2tbjAc=", "DDRrBGrwPLkEjCk1PhEH1rdeWQuy1CLqg8CaXaG6DGU=", "L7+Mxux++zAQZCPy5nsKqUAzYOVuiLbFy67DSoC9x/Q=", "DQZOckSe/BHR6QuXdJ3jkJSQuRK7H3L1QvQdYqsthHo=", "AqiODDVhdmXzzC/HfZCvx6jRABxx3rzyczygxxoZ4eo=", "Fe6z4FQbzwENoMR62xL231QLl01DnJPhnqTQL5l11EY="]]
    };
    exports2.default = _default;
  }
});

// node_modules/@selfxyz/common/node_modules/poseidon-lite/poseidon9.js
var require_poseidon9 = __commonJS({
  "node_modules/@selfxyz/common/node_modules/poseidon-lite/poseidon9.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.poseidon9 = poseidon92;
    var _poseidon = _interopRequireDefault(require_poseidon());
    var _unstringify = _interopRequireDefault(require_unstringify());
    var _ = _interopRequireDefault(require__9());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var c = (0, _unstringify.default)(_.default);
    function poseidon92(inputs) {
      return (0, _poseidon.default)(inputs, c);
    }
  }
});

// node_modules/@selfxyz/common/node_modules/poseidon-lite/constants/10.js
var require__10 = __commonJS({
  "node_modules/@selfxyz/common/node_modules/poseidon-lite/constants/10.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _default = {
      C: ["B1KvPG/cyvOGgnZoXwppuXSeFwaoKRe2TsLvhH+ARVk=", "BpUD1BfiX0Vox4WLqDNDAcD6GcGzSLx+GKTBrOHRVBg=", "JcGxIfM/TPezCOxGMPJ7YD0iqoHKNZXoAcX6fZdwoJY=", "I9a1UUW9sygnwUVq9Ne+TC0hPoJcHS8Mn/mbInN1H24=", "GzV7zj7z8rdq/CtYBIBa2xTPa/N/4jV8eap9azKsrso=", "KOxawIgcHmQmukmUCYlKbzwnb+Vonyw1yQJ+gJRId9k=", "LJhiUkrIoHtH0hHJxQTIsL05jQKKz2kOS47UAF3Qbu0=", "H25vCsSut6UjQ/MEGAeLQGRM1D4pDaC67pKJHEwGWsg=", "A9s1F+Iz+KdtIbL7I8hfp8rMV3dp7eoJquOUB7mvL90=", "D8Mz3KQYPatHnFli6wXuS3morG4Mzp6bCiFCJHv9CHc=", "Hu0oGXioOVwEKJuGGXZzsPK2XhoTUmRSfiUKXN+ZrKQ=", "JWi99lEQNDQ/tdXQIeBS0wgJVP7jV9yjb6XXjzO1vj8=", "Ha+t43TmMlHeypcFkdpKKFpj0Rz+ZGYfrdmgAd/4IzA=", "CvJceBq/VvpM1oM1gOl8emDqqX8dwytiLold86aRWzk=", "E1AUUct9Pgzzy1d0H76N1ZdXyTZ/zEj6Ed6xNUJ8XBw=", "GXBF/NzxW82yR9j79shcgPLQZfkjEIVZoXMNccc+Vs4=", "GjkNcoE3X6wkm5hV+MZ6J16P+KCoIdGzBcTNsTE8hmE=", "F/Bwb34S+wItFflCl8e0WUd1Xl6Ex7mVdlm+HeZLc3w=", "Co9fA/GdSXmbb7plDAbkrvJR/8dSQ6jXruiSTVY/fkk=", "JMnmw19PgZ9bwe8mV24W0sfHIGoFmARKzwwY/FBC8OI=", "ACQFynDVFVDcFKv+4Y44I7npeQcjMNVHEzoUsl5GH9U=", "HqtM1W8UdLJw1QKUViHZPkRmPK+PHTHYaxVuEH/vOMs=", "BmuXUPc/RWHt5Vk5QH50tJfU3u9Zi4c8S0ofMq5CXQA=", "HuPfpZb12HAwpsnSfWHdF1snEXlAgjXxO7P4TqKOekI=", "HqlLmsb8G94p1Yk/3LZg7WH/eyxltjikBG6rIXwCquM=", "ExOINR8HltR1POVk51RZHLG64Cot1Uh4KBrG56PAac0=", "GkWgF/2+U2GaKdjTHyfkCPZL4QvwXOFskK89HxOIai0=", "G0oNaOVDErn6Z1UMXA/w2I/leCLd351Y2dIhUFeqlK8=", "HUXTaewDmZBbsCndn+C5elztHSnHtaOdo1itImaR27A=", "JhVMnFHfgFl0W7LZfZqbjMjz09gT3Er0FK3OHWmSDo8=", "K3SK09pDxcuUEsxkMTyNRxElGnCA7FtZIG56yMcBcw4=", "F6VGj9seX9rNnJ/Qp/X7dW4F8vL7QQSyy0jYMP7RN1g=", "Jpel4iVCEj8JI7hrFSmlQF74Cd4D7kEpsrruXLO9lOY=", "CbB61DNw/Ev5reYQ4a3dONnZYuhNjdsQnv26aZFt1Ik=", "BpwZS1ufIwG8SNY2PI5a+kp1yi+KAJ4VrUyhGhfIGh4=", "Ghl0rUGMs3LVVeya8PNIuXKc3uaB6w5EebkLtyD1Qsk=", "GKnY00zyxjMTip656ymCDIW3CYiVgm7N8uG/BA3PAoc=", "LgVUg53XCkuZmP2RUyf64UaF7KYj1mJYUYbS8SS6i7A=", "Hm0CFsi2eL2eiQzNctI7wmeUith/qyWupiV/jLcBKAM=", "CSCTKmxAWx7oca4XOUlzHmFpokRC2PjJ7XnMx6JKSV0=", "FCxC3mq//1gFT2pL2o66X38Qzzn76vuNOa7zDohPo7g=", "FBjt2I5k092tA/M8oJNhckRLsHEtZGqLzmey5FHuDYE=", "BcXc8r1eBOplZU+0c8TUaS6ZWKWZmr1+XN1wbLfggrE=", "EURkMR/foR7sFm0gKu78YB5NFpWeyTap6PGy+X/TXd8=", "IbcTsP2yOPOwU/bVlsrwciOyqdH8ynWDIaHZF1wyfvU=", "Fe9nyuWDilC8Zxpep46HtIvJjjzXv3bV+gMwk93JdYE=", "C/iJF8t8Vw9os5Qp2P7g/P5YMwamymkzjDSQJv5mv+k=", "GIHwEppkt/hhCF9rNmnc71flaNY0l5gngHcLS8O0N/k=", "IFXrcypy03ytqD8E73QXhTaNZI0Jy1AUJXVDChEOic4=", "GbhIwzs4drsWiEbROJfN5rC54rKZVDlbOZRqT18m0AM=", "AeGXlyMpZM1fJq6KLgS9ez3BvaJbVB89SgWbSPyVLaY=", "AouN146HEuFySGpLJ4rI4WaxmWVSx0vS+kv7y6ORNFc=", "H7HP9zGW0TTDA1naFaUwsaV0GqDgV4ip1PsgMq/w1YY=", "I70zAfWb1lUiX4XEKpRmvNfGSqk2N+4nrv7N8ogyYDk=", "Dira6yrH1pROKH3HyDMBUxPT8r6rol6kwdxvDj+8jjQ=", "L10IVI73PWXChTF4y8vIpwxIADwNE4bbcogmDSmlLQo=", "L1XA6W3nSmH8l03w2oWxGsVEtchUSuWa12y8A4ieebQ=", "GIhfc5qcPf7tOc63yO73f9Y1rVLjKU0+EmqSpkxaRUM=", "EmfKzpzsPBqW+9pfIN8wnfiPnt9WhKBb/KyxEWeYMII=", "KkXASERI2jGyU7Yy85w9T2xq+OPjmd3Tk7ggzexm+QI=", "ImAnnDMlg6NgEZc6p2JtToHWOClnhoqWQ6duU6KyUxY=", "KOyCRGrouyF4P1TNTa8H4nm8Dq0E16MTdp9mLI50oOs=", "FuE1cN7/s76+EYlYsthkcFeMsRKWm8bu86EyG+/aybA=", "IojoO+t5RZgHy3dAjJu9vdB35iAnmYb04vCz5frKq9U=", "LbWwbxECtyzkmUYITXXyEJrZcHhagynejiJaQQ4kM4k=", "L845oZ6hFfOpFwQf2yZ8G1EDtYh+XWPEju39xTNpl1g=", "LGXvBVso+0FwfDJKNqiUxq2fhi/R+X2lRFnF2wvaVa8=", "KeY6JMkSNdwApncLnlcjWMGKkGOjQGb4tvVmg8/0j/4=", "BUIRxWz5ze5kt9qnZ3/p8jXitcmcXYtV3iDZqmEscsM=", "EI6Og0M/fLFyhyODft6U0HMDKrZuLg+225eHs5VZ1zs=", "D/m/tBkU4ZmlU+Bw7tlDj/8DPNMUdliRSanmDVBYEU4=", "BpE7wuNyMNS29WtEaX1vgEGNfBGh0g2EhOlbBn+TW/A=", "MA07dzuaQe+Bj90SIC9JnV2945U4ioHFzjvDzItIgJk=", "KfmyiXIf4wAZN/bEh7sw40KzRMcd3Q+VfQLZKV+r5ZQ=", "FN4Nu1Cgqv/7OZR2LRSWz1FEk1C1386wZQZn99t/M/w=", "BFzx03Yp3ukon8vkgjUZ3rhX72bLOcxmMKOsYVfp4O0=", "Hn3kb90jxq65St32y5mYVjItOtbVgDzviLZpPtE1kKA=", "LAM/3FcjLmhavprrGKWVDln2ZlmKCpAyr89Yrqdyk5s=", "EX6uZf/mY0JBJlNI2YRyB06Jyr49j59Vy8dN29mEPks=", "KYjoGptdwiyLPHqdATREIvJIM2TBiZlryrB5kS0lmT0=", "Db6lkbZqJEj7+4htELiZ1lb92+pOZmwPFEZeCcyt3/U=", "Ht9CS7bKCKyMTN/JjW0/0EAA7ExqhijV4rOxJjI0dV0=", "IUMGwBBfNj1SWeIUHpe32kG51RFQSNGshIP8aIpwNLE=", "JC4AtpML5YNapQJ0k9OxHjEYdyZacCEOASFjKEUv3Jg=", "KRVNASjMZQmJ2ruMoLGN1b6x66wPY/pHvpbjgyASGXo=", "JdItVNnILXz7icYapiyhUFBqK/q10wDbeE0l0mCCfQs=", "LyPwuimfXAl2wW6zuIMGiSYShzkj7ojqotuMwQEI9cY=", "C3Q6iRO9jn5wnmgxGjWF77CWcIMVqYEgOfIViZ9ClMA=", "Jk76AJKVRstOwwpiHDxvZhMlhyhk/9+E1a22Gvjbs9A=", "HEnXZmOjWDh3YtII3IVADnrPG2X7sT7bNG3x8qEKzjc=", "L0ByXR61GK5FYu4lygiz5W2sqlEb34LQmfvu5RELaC0=", "JlG785IV1tZjKmUqzm/1EYVVrP99TIvn7j4gb0TufAA=", "IZjzsKP70L+rB1eNQNf6A+UHYbqPHysBhhPWWwkfPq8=", "GNTEaZ99AfoA7a3EPI4fENkqT325bC2ROb3W+xH+pAg=", "BZ7bxVNJHsa5QjPVO1MopdJLbkn0VxkLz9BipYIpV8w=", "EpphYUtOnkIeZmfaqbhf4UvqqCKzlU5VEohWS9KxRVI=", "Liv+TXsyNN9rYmiL3LLIdnWX6j97d5L7RDd+ceHsnxY=", "Afg5fP2OruukeY6YY3N+xUVy9qNV7kfNuCen8g3Dick=", "EX25zJFA5GcLx05/06b+mbh+F4HSrhkdARxtZOAtz4s=", "EeDM41to3vfe1VIvQ0xIbyh9sLa648r7Ix3PlRWY+J8=", "Jb9K4wxE3fyHAOI2mu1/VomAxtSOM7bGNzfIL5QrkjA=", "EVP1wW1WCKF9z6L8xf+S0KQdD9E4C1jS93wFgzmIb28=", "BBvtOcKa+3AEzumT/CImBc3f5kH6OglsgBPzi1zYW38=", "BHzVxbDCpgSumchCVA+jfUTmq+w2V2maEWuE/EKtXT0=", "FU7yXmcUhtuOiCGBozGCba57lzny62yPdIowZJqkGA4=", "G0g+dPQcJlj6/QgbnLdwnfKImZRUSWoppJLu5577liI=", "EtuINC0BS1b9v5Pb+dnAghlss04M7d/soKQJBOK4yy0=", "CUQmP8rXY1p+jt529P46+yBc+DX0KpXAM23mxC6lqZA=", "LnrG+p3/r4Op67aWbvVGTkQpuYt4uPFBZcUBVGlwtzQ=", "BLygehW1hc0neQdoyqOC6Z0Uz/j6V+L9qhFaRy3U7BI=", "CiMKtIXngUaP2/7fMkE6pADIOeqFWlDxkWsDxnYcA0s=", "FiHcPIw9uG+oMFn0o8QSmK7I7ZPEnFO90lhzObIW7HQ=", "G05LxPAo/e0NqlwaCU/soNBQlPr+vWYZNI4d2fzhaMo=", "GnOeVcpkTpyg/ygGIyCXfZc4s1cof+bYcn4Q/0RSx5k=", "KSgA6EUqVmbNArF1aVD4BIw2eiQ5reo9lC7jwxhc/ZI=", "H6Nx2RBrgapmTBH1DNQdJIGpFDmjnA+hMR/8KMRITdg=", "KnhpQbirYxpFXx8L270+uaGc2l12xGO/9O8SIAvWzfE=", "FSHzA/1BUJ4SLWt2YdYskR+67u6CH6LhHinnDIQ/yFk=", "JCr3oQfMe9nBxbJTfl7reUxneCfFZjQYu5osnc7ykVc=", "HMMNSBO7/0uRdAzIuiC9Bq+p0hfqASzhLRTgJxMB530=", "I70pIrQlr02L21h7HMCMzf8BCrAwQxZkiZpKMjspc18=", "FQ+rWYbu9b0f76kqq1ACUw2fVMt+ZWM81cMQVV4LOQw=", "GLQ8sGS788g/wvFYrnhaq8cw335cauO7yu9hO8CucHo=", "E7tC605zeHBgiJvhdQGLjy5aKKEYHXd+KqwcmTrNZpg=", "GribVm3/NqlfgFDoQ0lHQLo0zTs10LfJe9LXBe+EKrs=", "LV/ZDnF9ivjVsQ9zhExspQ0AWUCvCVRt6ONP+ZFDX7Y=", "C4NtDVgZFCGNsOk8hZiziJcqR5s1yTPMrZhKC2zpS8k=", "AuzfsVD6Luz0w0x21W6ymkSpQAOZb+PH+51k1y01Ljo=", "I1eNfV7I7TGy1+t5RWTTiQJf79AGUhldrRIrQApRlrU=", "HM+4tNk+XgjHxMTzBjVwb8nfdZN1//poNaTBwn8iJ5Y=", "HAy3NTRhZLqTMIiB1Tb1iIhz1EQeMIN16Oa3OKHAz9M=", "C3Plt44NI/d7D9/QAXOBkcMwKcBtu/b0EHdPJC0AI+M=", "BEcVwA5fy5nENRicHsJLPOm4MRQh9bHzhISrdpLGxjI=", "HTs2R7jqNF6SzChvG8GLbqOzqFUdC/GluVIUzyMQ9wA=", "EES5FaM5olgqbn+2pm8rl71hgvmUatoeXT92TOGrDOA=", "GBPbIlHj2QTQ0wu4a+LXxYA6krhzdd/Wj5dvRiKlFTQ=", "KAgVL1aFv+V3yU/KnXCWLloI4Pb82Nkhgt9/s7Kzkk4=", "LalAoejImm+YPj+Yik55dZtcaYe6EfP1HZpT0/0dQBE=", "IPsdhpzRksh+NCVOS0jyIvmXtFJqPT+cn+31HNFnAmk=", "G9Se7qrDkn0ZgoKQZaTbQmmMD11f68/UjsO8EFmVnxo=", "E1ESs3RIBkIxG2sUJwTyFoTdAk4K1VrgJyisMiaJ5m0=", "LJ4kXHGDLGkKfKPbHNqtzdfN05VwvtwUqHrOX3Jv/qw=", "GjGaWrOyqelesMEaWhK3noVpKRhqHuPrKHKthr5z9WQ=", "GhI8MfmdXqVbxC7jIrfAcPTMwfwmvs6fTz60S5BROAg=", "CyP/3qBlyOdeoNO/2Wbf8TbWYCr6lDKEOVkP8+IA73Y=", "HIH44BSrJbjtecXhvb+Gn7G+Hq7dh1p1OWeARr0aMxQ=", "Ab/AkvRwHUyu/27TJgXMDzVD71I4WL996SI2M1SsM3A=", "FgaPyJsziP5b1UGnLuvyl2idHm+XiSXe7VbyrabQH+w=", "A72dwSHn6YtUlEG88HO1ZNWp1A4wIN5NGnEDnvJjAzY=", "HQu7k9nJJ6YJ7/dsPKlaxulOGJPIjvKlRPtfYpXacsI=", "IOni3IiupFiD4T2yBiIuTCHU6OuVQgLyuQwhHKyWycg=", "CmnewM2KOZ//EZAqNK/poTMfUa0Tp+5ace/X64WU2uU=", "CGfJEIUNLyMPfloDs88NwDJk1bbyZhEFtnXF/0FXXIk=", "FFYD+PtaDPVr9xueb//4MSfC0Ls2jeI8afx6lMhExAQ=", "K4u3bc6v3UoSvh/JQ3udQG/+IUS3vkbZpWpBDRfadcQ=", "CJvFzg/UHZCxqmWd54NG4F6sfQVPH6X6fbkcB/s/p9Y=", "J7rXi4z95HomTLY0gbWgOI8TOcsh8swykF2C/rTpP5M=", "BwQ+5wPSsbarhkH8/67NEHvLzANKvP1G/pZ9hBf9NyA=", "BPXM30A2u3iIkzX2hjP+CR4No3DS8H5vhU9nBJ5UwMw=", "FbH/4SFH7nHjQBszNeeGgcU0vMWPqfgKgTBQncCCAlY=", "EJsFSO7wf7uSMOkrTPt0QYc6RO29Jl/BUtZQGHg81XM=", "DwfFiqclrrcxtq8IfnxczsWjeWrXTIcqdCb763/s6H0=", "HRNC3c5uRGn3CpSM4QkQjTsedbNzPOfJojekxeUnRRQ=", "BjW+nn6EQ9OyiG0VQ0TSQ9qpV4yCo44lKIXE87sTixA=", "G9SSKsdYwPTFC7MDW37UtWGK0LcUq0aLXquYjP2MKVk=", "LhoOb4TJM0K01Sn4gYRVSXbiHsYYDFgOSlhjSnt0dZ0=", "LxWJvloSdpikeDukhyLkyakIjHye3Zqt+RUrndg58rU=", "Jz269kXxGFRmv8mbZ2xhh/hBW5+i4d1vxkNfCj7zVSY=", "HBG3bfBCOFzrbQ/iac+hUGlZGeBHtIB71umjzUtOCiI=", "FqCYjUI07LCQ8J22veea81OUybPM/GoLtETfxseGc1k=", "IV0CVzCtoXiOICTM4n8qU86ASpOi/GBFKgz5SPsDqLM=", "LN/bCEfegJntipQYIrFe+ekfz2QyWvIgLeQurJK73yE=", "CUbb6ZmN7FQdo5qdjqVEp+RJ4mpPmqh8KMfi8RiWE0I=", "D5WJgrQ/j9wsN4XErD5jHVyJ+5TgxySnplwcMhi2fkA=", "GFAhsZInSxthlSrSGcq2Gsw7Nv02GIobjBLlbZmMXoQ=", "JNVrTVK0f5vG3LetNT7sknwOfUISoubeDqxEohAmCzU=", "EJjVj+e1NSPu6BUQsIP9rcoAS1SUaMvSAbCjHIt+HRc=", "JKmbxISBBoOQvEgzDBE7eSHM/wKK1QRYOXbn4w78PIg=", "Eqf9Cnpu2cDqyjRlrlV88xhwUUb3L3tOSrJJNNu0xnM=", "DUKt7kR9aupmNlvwHltgfFKEgImoRdH8/66fR+BxaxY=", "ANXRCd4lefTlyidjo30TEJMN3e9pwgI7Fn/+pUsMSqo=", "Lv5+dEovDkUGk1B3MdnASSoHfRlKAiEAIqzFnn6kadQ=", "HcN2RLvs3CT4W3E/0Zr1W2/K0xG3e1/jAwqW1TNLuDM=", "JDEVVo2jZILQBACBdqdUJ/2jZsnQe89Wx7D0ghwmN2Q=", "KskQbl2C1OIAslewsiLLMJVzJ76umDT8QoBGoPWSbnE=", "FrhSlEVwKH1uAsNaYwA5JjWCDOSIP9CTgmD4VVXGwLU=", "Kd+kABYbZh9SZLQVhGDUd28+hit7gjURlDD3Z4oqKnQ=", "JZCKXPscIQ86/Nbo1jFzptedznU1rtxXqu6ZQybDhrM=", "FID1azpo70Hl6kTf8lSq3dvxnVDw6ZCWX8yJvcO/NUY=", "LBSQ+TNeFNv66sZnVZX2sQgHvPo+Sadu/JAy9fU69bg=", "GDPwzl3FKdNXan+0gdj3D6biFw0xwQMaJVzYAPyyYrE=", "JtNkYaHJ86NlNZDoJzVU+B/VHMQw8lvuLMz1Xi52JzM=", "KQJ/D7OBMY+OrBSvJPduFwfca+0nEDYiVvFtvaaakK4=", "Ckzejz1C7Uj7Pap1iQNvSZQXbN8HouzD2vtU+dRdmwM=", "H77BL+/+CInMSjH8rn2BnOxIJ4XhkN2iU24sQBHahwQ=", "GybyOMe7hjZ4K8DuSKkxowknRoQBTOcnFABdmLjYxmY=", "CP9N8MAn6IgHuLblXmv35kP6YMZtdKM9yETsHDRZjuk=", "IgfBMY6VnkoAKtUBXTgbKZFd4iYpphKhtto4mrhvvCQ=", "CfywfoIZNTm3HQoFLTl3mWoJ+EIWvMHkbxGshNXXXvU=", "GWn1wg6A8Q5x/0L+Wve+xH7nUzFTZ43S7zPx6R+/mM8=", "B7ZdaodPVwYoJHnOMj82vyO9+8NHaeEaw07ySU8r/4U=", "CemsTFG2HOraLIYeJ2ocBmXxsGkULxRPgMRmSaZbxCU=", "CLdOuQsOWzATNHUV+8/pTY/qz9Wu+5VG4eWt9Zq0rPc=", "GTUXFM49Lj6T7JAVwC4PoFb2js+NHH+rpRneoRbgIXo=", "A8ShW8l0iBOc4cuSj0dFBa1bx4k6U7PPHJuiHVGwBBA=", "DYt3c98zW2qc8piwhyHWQCkKCxfVBg8CIvJjx0F9Jcw=", "HhTCEvt2eWdq9Qw3EbGRfWWZ9iBlK4vf0kQlFmeu2c4=", "IYbMbNxScSkamxEbmL3lDGKigEPZCu9lQXG7cOQp+t4=", "B2jb1LkHS0NUZ5J9EYc3jEsXRoWu7KNXiN5mXygSoZU=", "Bj9aiIt7zT+K5Aa6QOESB74BNhitX4Ecwxf8HlWMedo=", "F4B83C5y8Fszcfzpj97l81U+tM6S6TmNcC+TjPnudB8=", "JfPdC+O9+OYyr9y9QxvnrmYBVJMER1ylgNE3QeKn/ZI=", "InSkXi1pBkvOZ+LrZk20Wu9PHZ3MzRV73O73quFF9tU=", "CH7nk23rd6l7jXRz9TQ2zz+xzoXfB6tooCi0beqEFwE=", "Cq7A915TCH25N6l07esy6r62M+zhGA8fhDeryQmd8b4=", "EM3wHoxhJjtEbD96EMwp/QHtkfrZiR+cb8t7XOQ4upU=", "F2YnqSBy+iu2TdXf+cxKDVvtzz8iyR/pkcxlaKT7VM4=", "DqsOFY4vZyxop6CkgyjiEXmkF+sMZbG2F2ROHFLEtCU=", "Lt8eoc2X0akf55AeZMDy0S95ZXQdpafH+r7iXqw7R+4=", "H8BxN4Y7HTN7tdrBitkSN3OWgKae7V2gvzUGL01MrME=", "A3vf9oAlvdy+1VTOrD32ap6ymJZteTCK5BTTQieq+GI=", "F39olXugfaZxud2RnyQz3+XzY7dKPBYWlIHFfFtcB6M=", "BtR7mSHiUCwquwE407ECiwK4X49CNiz0NnG2Cmnp5go=", "Ex1Yy4pBp1PnZ+HpfO9g0AA+ScjNHw9RAchhsXdxXaU=", "I2ynYjXZ5pRyyZhfhC5ibzOz/U/V9UOBCgxdIUPtTJw=", "L+f4WleZFlRZB/KgIgK4Npa2TR9h6BNzDOvAbQaFN/I=", "BJUjJr0m7+1kY31PwPeku1KOOjQSYBJViOdaqoj2LXE=", "AMLftXe3ja0Yg3u3DI4pkPMjJbtBj09mJjorY/P5g4Q=", "EixoIpO0iS1RJVmR+c+vluJRQL1rNzN+p9+tXhJCMoo=", "Ed3FQNShEOSCokVRErpn/7PKPuVHEUmNsaNyucwj0UU=", "L2vXH2svOvPUaIIMgKqtcu5Iozfx/j184Bu4kkIQahs=", "DWoW0Tbud8NfIW8aoMqeCb3CWecVhIzgR74FakoJ94c=", "LnxgE9G+YqeLTAAVRl+wspOgfUYF3KZCIQkJYWSyKyw=", "DWu/GLfraErexBJxNXDTv7Nv0PVp+zZHT2lLEbKUi6U=", "EkA8+Id65RC3MUt8datbD7f83i5qtIEhKI3ATVtR5ZQ=", "FRs6z0zjKX2G6COnIGfHFxc4IVDAgMo/gBK7C6L+1Hs=", "KhOWcCBjxi4HxRK51NGB1x2ItWgafkf9EUz7aC+vT5g=", "JcxJ81CPyhhzpvhbZVC24QQdkM5TXGONK1I6Yd14acY=", "H9GDJ6BILDlHI7FSyQVEcpz0BAvM7ZToo34cnjB2g+E=", "CydWbOAr1M0ic/1TEzbA6/5lpbDaEjyzG7yJUz5Rizs=", "Gp4VPOgr8qb6DXHRiJwktfER0mLILPNFD5yoBgjsFf8=", "B8p5TVrE9A8P7E1p46PNH0csdEbk4n/B+kzc3IYFrMc=", "L9r0THB9gonak3NTam9htmSU+p6eeC4OQQQF77r1BK0=", "FU18fpTuBqQ2/fWbUBt2O+jcfxKu7AdSt5F5Jn1kOnQ=", "LHU7d3mjkJ+gywaVqfM6ZzUyv1zzlPQLuNtexft6ZO4=", "FE70DfeiYv9BeV0JWQES1j/q51w1M8CrS7muQ9YSAag=", "IsaNbNS7GBY3kSdKKLozsNE44UjW2AtGnW6VGX0WSIM=", "J8o4y+iy7IqSe2+gEemCMj5W2pMsJNcwlRd/5/iql5s=", "A2mUwWlz6gEkQduueS+z0GsTmt3XzMDA81O+M9iHPqA=", "JC19G7jtNlgDUDS1Xii0MTjFbH+pwFhpeAVqp33s/To=", "GUV2VHAnxCJOnPbedipRacpcGKxduQEIvXYCG7mwzvI=", "DoI6oRYk7lcfI9oCHU15kFY/yYmKfQzmhOU1/sefzdg=", "CChYpNsoORm1bAvAi4k4ZyS5CGikuhcLscz14RIgXEw=", "AheCJnWvrD2kqRN+CxclMohKpnDxQtpolWnbJPWw1lA=", "J0xhTC45LO6Ja3hQqntv6VK3aBlZ+/15E7Q68PWFi7Y=", "J9NVcoldYe93mUWS/HUlH0QOXRIBMyUgSThe4b4lquM=", "KzkazJyORSs18xyRvH3ifgDT5iVBPSf21gw50Ax0v3o=", "G2MgzIrNmMksqEmls65S8t42hHTc5yegBp6XzApUa1w=", "IoYHXmqW8aVfum+Es8pJdOhwFoZK7WJzX/DUKMCskfQ=", "GKraFxgi6OHcPadpF/7RY6Uju/ghI9yY9MCX4X4R3qo=", "D8P6tF1AX6cV7jrEonnHADiF5SAj5uNuXXHwXPXzA1o=", "HOmVCa8k4EiSXqrSbSlM1VXNEuHWWIF3fs2mlKXlKjI=", "LibBfJIRY7W7Oq0j/63UfdDcREm5TJDqPrTk/vE49yc=", "FRFqfJLm2dRvt/tRre5ahiqi+nYsaQmRgErqffXP0/U=", "GKJqCAD88oiqfpjwRzFyEOZlbIe+kDvxmpLnwqSZw5Y=", "ItekDn5MHnbb+8zhYBwiRpt/v90FWj+VPPz+60eoXHs=", "CudxSI60vxB82jBC3aNJWJnsX8Q3khUI/SnVvyGAev4=", "FxBOBECoEqM/gl/lfamd3hPBvT4Q3o7JZ6Xe7iNM1wE=", "JoDkr8k/u+uXLYQvGPo6NeHOgizgKmKcNpbizbKJSl4=", "DWT9qTq6XDhOs5v8FEvqV7E9EbJ9iTI9KuJ0j9VPFtk=", "CurMY1E5AJZG24lBQQyBngh6vGAXCbH5I/BOpntfWPM=", "Coou0rIVj+ZEO8OxF1TBRSHbGTM1YWx4Wgc/ac8Vvzg=", "B7EzogFznuIEyB33iyChPgD9jAo4aUJ5TCkYeqtic7w=", "EY+8drf4YeAumuW6UWlgyRFCrXxK8RVj4a3/l/hjzrU=", "J1S0/0c2gfMGnt+r4h3HX0EjoMytVZfUJ3moEg9U8CI=", "GQNgoDZmhxSDdnX35Z/fFfpXY09NsMLCSoDSaVHB3cI=", "Iiki82cLX2XPNLKyZltAoYfzwwPHa+1SAXBzoKGNv1M=", "EJ6fwgrPzs89R8BK/fupJvMOEXKl1QbRJBgYrunMfFU=", "FiE7Qtyd1MnvkVAK3y74cIhReHN03O7k1FpmRaOmmzA=", "JAI+pooqKwCKy8XUoV/NCUK2fOlSsOGgOtF1Bm91WSA=", "JHQExI+qBubHKx0FC5Bfo+vXdFlrTP5rtNV6w4BwhZ4=", "HYaCMeLfEz3AISxiSBec6hfLD3HEzYJ/U1OAYjDYkWs=", "DDFHSVWcE0iG/BK6Eybk/9wzAo2OrNNB9RDx3qK+N64=", "DMHDO1MgyRG0fu4DxNluorJbzSbjcR0oyxUsvFuH0s4=", "BfTDYF6gnUtzeyn+6H4cK6dNMyvBnm0+i6lH8Os5maw=", "Bb185EGjpyeGMS5jhmu5hq28uEewZHb5jGt/i48EJFc=", "E/xMDpUCge9OluymA1UVL3wLM14PNrwc3eXzlS3twTI=", "FTwvidZoHn+U31Ebnxk+KHaIT67hvTrsJruTSToGTwM=", "Fvz9bd0kK+jNSYJnjLq69AEL5Hl4dk7k0U6VLcSjoRg=", "FVQ10CszzkW5w7bz8QkJMPwKn6mXiJJ+UEch6gZoz3w=", "Bmn6fUQOOgbbb7gMh2o2JFu2k7t5YGRkIWIfwsORxcE=", "K1ffk6CW541/FOsReppcXvadls9FvIB+Vdib+YDorHY=", "Hop9GaZ2syY/hahILZXQ8+dr4LblyawQehL7nmVchxM=", "Km3gve0rvitYZoAfiA5H5r+mkAWgwYWJfHLvtWvZioc=", "CZ7Toq4/D20KZ6H3m1WhNb0GbMMuWUKj+iVy3hNI+EA=", "Hn184IRlQhNWXW7iG/Hyez2AJ6L6qBBRfvvf3KmX+/c=", "LnA9+9yG9Vhu36AiHIG7aJkUMhC72MZoR3ZKpPY8Zbk=", "BQWww9+fkpWaQfs2xy2Fu4JtVnJ5j+dIJXK19B83GU0=", "JtH8kgq2DX/E6CYFb30Zx4J1CH/5EW41b94wKED/06w=", "KzQ5wWsa8nvXpMjZ3caTTnufXhCq58zkDOapN1BtUQo=", "HkXYa8GE8OCGAg3q405Tqw7nEjs6EZBHXG4l4G+DIVQ=", "I/Pi9JyhyVQ0sDQhVhcuZdvGyfgyHMdenxWmbDvLCcA=", "HYwuUdtZ1ulu5p9oSA0fjkjAO8h2zXkV2Ii1sKEaIaM=", "Hh3DVGqGAyzfi4v3+UpEcwtmL4pWrYYuoSR7oqsPPSs=", "EUfoLADfReGC1Ba4M4/64pkXjaX5LY+fkVPGleeFlEc=", "C+lEVrmgPGy/q52KNLQR6R0gyxH1Yk+us/ePOCR+kLk=", "DEvZo6qpI/ZJuc0cvXh5V0smb/L3wMBjtcRNa0jMo/c=", "BhmMH+QS4liHEVtU/4frTx4ocdTPN3lpyhUf7V17Te4=", "HukKrmimvaQsNKeX1NMfeWec60G1h/YZ1iDh9RCLg50=", "EapTYLWGwhRHcRtJch6fT93GtsmLV7hHctb8a4vgF8o=", "GkGmc5D5IvEM26qgzl6u9h1mtnMIJeuYok0lmH6Hvlg=", "JKKZfIMvulSWGJJq+8rQDOkgeIOT3xKPilQW0mIxYVw=", "BnA2yvi1fapZrUUUdziY4bIvjojUVLwfjvDILMk6J3I=", "LxjoU/m3t8SxtMPw0aJXCwNf0rQjGlhBOa23oRIhvDM=", "Gzh0FEkjlDvrZsqLeY0LuPK+f43Z3trG2R/FueUxhqE=", "DvWEn/RYoR3EE6LYq+qYiMYiQcPCha/jobFM9xV0w/4=", "GWo2ojF1P/0MCUZC4n2AuiAaVJr1hP+ppwqAJoF8pmg=", "LgL8Ii3Vb+ZWijRa3TwdV3iYo2GEfli2dXbxLjA0qMY=", "I4O76v05HZaq8Lp0gUZ4Z8Z605Nm7YxDtCUgxikkUsE=", "IN4s1c5zPqAKfxZ/aGrmcZJjcyHMnw9KpyFHkGdqP3U=", "HxvOM0Oa+426sTVLRqW5zrGYC4NRQJXWXlE7eTUamQc=", "BXuN6djtWTtdIUMCzojuCPGBLvU87G4FuuwWDAVNZ0c=", "Jnd6y9iOkyslUveBPmLzaKuLHWJraFUCJToQyAUKSlU=", "AVick54uPv64y2wQNHaHkQH+x6Uwyhj+S9Lwlv9Er0A=", "Kja3nYfJY7H0dZDsxM1pFCNGpUrki8P1c633GbTglxk=", "Du2HcItbAKQq8+beWNTN2vIieL4O5jRPKndRMv4Qeg0=", "K/hP7WOhFpW2OXJ+GBEawgg9k2zmS9UaMt+p8bDnEyU=", "FkpgmAdZQcZGcxnCNyRjw+x626b225pYrVmmePjxijk=", "IFB16jVYoXsMUa46EH2JhgnjzV2C+N+MP3SxtzsIlz4=", "Hx48dvxp/YrPo6m/0K9pXBDCvNzm2PTR97dtUEGbQ3Y=", "AGmYKpslvXWBQ5e208ipB4Hhczvlf3Vz8v5E3TVhjFQ=", "LxdYKUFIG1SJIRvv1LwNykPUQyzhEVOg/nNeVUdKI5M=", "FkUx6rOAv4H2MT8y9cJVqbrb1O23dn+ZDEaw/b6fspc=", "Ax9GqLRFX/EhvBhKHDVR1FB6F8iIkx8+mdNWqaBu+Kw=", "ETNNuqb39BQNFJO9GIx3Yo3MeCxf+C8ev0HKCUgVdBo=", "Ahix04pv0R1lZqUv4TbiyC3iKWmOVBSza+iZfwYOiRM=", "Lv/KNpzzT3QkjjeuO8dCmRh+FqdfLr5ARnBgUA65PDE=", "B+VBOPgowkuYs1ETkoYa6cWHZVD/Dud2Zjw5l6jxoRY=", "KX4ft9pUl9Pb0HmKFG0vq5rFsOeQbYWII4GHt5UAH7E=", "FJAWpxf9hcx99/A5ymsbiwalvb2jZaM7sK4iiQDlOzE=", "D556IhJL9Q2U25Ix1jaFEi+S21JorSFIulNNyFO/xU8=", "GjUZpi+mkrNxbRG4jp1iqqDkO88Dx+qBlwsdgCqGe4g=", "K7Z8XWxIz0WKKT1pstHUT6fCxgiOe3+a3s4/hz3t+5U=", "H6cT3eOQPkHmjwmsLzTJsSN6RF1RlcXjYcW8ox7fqXI=", "IBmqkq33teeV8OU5aC5LObTjK7ZSDHERAq690MFRaEM=", "IlO5Iz0EevoBjEDEn+n/H5mUMqnH3wZiGyUEpG8SDNo=", "HOoIxJMo9fBTxrR8u8lVkiS+HYE1SRGhiSapjgR72uE=", "EjrSOWakLHKXEwlPw1LkZuJkavmtqsIP2OWPMI0nNuE=", "HvWafiZkd6ZEUn6+zwu7z5LOX4DSKA2vgmYZt+vfeaU=", "GewddNfzZy+bxmvprED1vnAre6yAtOM+zrWS+G1d46E=", "JCZGxD1/KM84yayvjGOxsz/wfHeMKuaMVdSJOpJ6OkU=", "DiyKYEVT2zuBmA/kDYAcrMz7y9eZkkMPy1CwSkLL6bM=", "LnfaMnyGm2P63zgk1xiYPyzR9/iuZMiPXopQCjQFau4=", "GRyjvp6sxr5ICLwWaNgUSZdCoRZ3kuM9cNNbX9CsJzY=", "KibhC3FMjJLEIzE2hzYBiFC0ig5d55NrLPJe7kZjGWQ=", "BaprLiW3zkwXBCcIGgEZDyNkhy0B5R6WmxTZhJMMEPA=", "B6yzkE4szYesXZ17a3t7vN44UEkzceGxC870zzL/IIU=", "BaqcpfIN/BBMhesrzYDf57/mnULRukQAvPDYrVOhjAk=", "BBGgtusJ//vpZodmg+hquWUoAYaYX3L6xtoxDoAXXdk=", "HhZWgqVitt0pzvhQsnWev4Ysr3HjSLQgJ1U6sefwzR4=", "K2XpKh+R44sufxkuvwvGDNIk7HwcZ7ENHl9jT99Sa3Q=", "IgjqfR/GN2ex090ef8/UsTy/qssPn1MbNrC8dNNkgR8=", "GscYoocQX91ty91uOp+DN5Hnw0WJG2q0dg5uK7YgWbQ=", "CYCQ9yPep7kn7cNqjuz4RjDJLQE4+Q3FVfakiXH1Dms=", "Hb4A+qM0Ov9y03swImAUO/tdTlv6Sgs9CmIiPtZrTW4=", "BkLDZRgcouw+Qj1s504UUGikP4jOBTV1ouvK9xiGCZg=", "JFYR0NgEeiTbPXgTG97cZ+NF774+p/bHpPy9PGQiRus=", "CR/+PVGVJboIDh+rVGcJstxioXk+OBHsUWHIALSH9U4=", "KmF+1YhyLTrPSQCz3FAVckt8jO9FjPnbSU14aia2nk4=", "EwKGipqztqNsztD4D1PxoTykNuLXwPmtqQBAr/ugqMw=", "HZA9r0MAdVvgrKr567RBR5W8P7N35ZA/ie6bPvrAUqs=", "D2cXkuxri70JNqu8A50qho9SOgBQ3AEi9dlmmyY0d3A=", "EEWkJBZnqM04B4BnlwsC3OnDUFSjb6Uc2JLV0hM88nE=", "KNc495wHs10t93LVYtVDRt16Qb0HCWw2wiBDIKZ2Cys=", "LSRbXBwacy+Cg0Ru3n6EbzW+nUnLTz87tOXh/NF4nVE=", "JaSZyhkHY4NR7byDbBSYunyPLhS/mfC8K4uGu4m07qE=", "G+P012Y7lJQCMHuCuCihX5Qj+b4RXKmsRYTUrHUpa90=", "G2frUfrO9YFKMM9XlKldStEVFGmtTYUdDDNm7WuZMgo=", "Bq1pIB+UjkdJ75CVcH/cZZECLHjLb6BH+CWkHdPklcI=", "CkuCiFSNX7Pd589LvRoIgeXmHZmx1S0Pgug3FQllQRk=", "DrSpNC6J2c8PSCxBzmbkD/fH2PmtHejR2NSKmLAFTJM=", "GmRaIjRx4s93a+G/23BgGF5aWKa2UaEqiWmtWg362X4=", "AwLESZ1B4ln/dh3bMFo2bz58KwHEZXd7zq4aZ+a0EsE=", "LBfgt/kBuTYwydqZuu88XC9aZE3OpkRDV6EhvCqkJ0w=", "Cw422oM14kPcf9WcwjZZdNDg/6JHxU75YXqA921Blcw=", "Ep5zPB3aLt6NOW2F/Wu4tuYTmfIxHAkzHH7y+b6rIrs=", "LN6n6xj2FGtnxDfzfBP4Vu7QHV5GTohwRHxci0vvxP8=", "KtTwIWAzAY59KlUMLggkMmFPQH+2AJfUUFzPyzHWd0U=", "KqxPVCVoNbrZbuwlZkGhD8RNDWP9WGD9R1zoGCdmkfY=", "F+JRMsCerY397WkbkIG1gfH3bEqG8v2cnCnSQz9NIos=", "LtleSTrJeaCRu20o6BZy7F4fHjnxY+X0uZSN5bS+MpY=", "FhzmPVlt5pRD1/VC//Ns08EQwzz7tEXJzztw2QgeTwo=", "GT78d+p2AQVHxbzGAKEfHVqAvdd5ams9mg2vZqC4pLs=", "FEmjipOM7jtW9QXxuiMlsYbiyiKoQ18kHPpEPGAA9+E=", "IGDs+aox2zEgIBgn/N9rXufxu5PVUBh8otu9SkIFp9I=", "BI283+L7bFCWjoJalYNXZGd5VGyTNAdI7y4FeUtIqx4=", "AwL76bE6Pu2RqCOwtNPjYhQTQISX5sPC+knZyKo29Ag=", "A+gZJaP9XyUIFTLymGUH4O2RJ2y69M4IYIF6x7uDjps=", "HFSYeRONQ0zzFDUX3ZvyoyIiTXa6Wz5N40t+xJBAdEA=", "CBIMfsNW4WlF2U5V6DXufi6R5BAxXc80dfgtJw0W0O8=", "EwZGQAYzAFFoweFO4nq40jjYunUUyQOqpZHc3nv8GGM=", "I+m03T0fMMN8/fs6g9ReUk9Uq6HAZ6we8azggqtDR5w=", "KFs4qrogw4sEWfSkiEMSK2RzFilWJHiUcR7HZ5lPw74=", "JVn99Y08IgDIPtH7Tx7tVowiSMoI5XlIBtGEHzoIGEw=", "DjPHNiarHtdB5HrFK+Tp9/eRO12B19oar+IDpJ7LmDs=", "BR1BI2Mkl6oyQleuUqUeL8H5uokBqSXcRMDcZ3n/VJY=", "H7q+0oIIF4d4JBBSsjbwvHrpiT0kfKnNBWcumv9hMUg=", "HC90E5U4vSU8PdRaL/uWFzVQpRzb/ip2gnI3+4W+7H0=", "FXdn4qf98lwYR1Wy9HNp8s6STlra7lo3ONT5QrsL+VY=", "D98efIaJgETds5f+tI5e3p49JPulQg26jR6m0Q2/R/c=", "B2noTtF+bB6sQLXgDM0tggQoEBsshLWI7kCkQ6yeCLA=", "LyoPUN7R5qs09g+MVpBKUW2vyBU3IbRPGzVhiQwC6Fw=", "Cx3AT+ddyzbeC/4Vyi1a1b8lOK7RMz31bhsthhko4sQ=", "F67Y0RfCd+0NHYiLNexL09wLgjsq8DfTYj6hA6IHiyQ=", "FTFAqmZYbO4jGo8/2GBZdubTLd9DH/M+4FufQpwMlIE=", "Kuki4R701Bt7hNUquDX1vIAnvOneJcHOWwu4i2oX0ao=", "D4GCQ8w/rst8c9/CHClovmO36TkLrAd3R7u+FnoFW1U=", "H2KDijC61u7U7eKrUoZttRVRN8zjJ6J/S2biIEB1AA4=", "L9l5V7lGDTQUAIyuglu2EPAYxbUzCf/Sbzns8ef3lbU=", "JpLRHmRpXg0hA3S0gqRyZ8wA3y0bkFVyJ81J/DfsK1E=", "D8qniYijUgJof/DdppGwNbTpVApTCMluJYI9h4eloEA=", "GnQrLM4hyD15Q/5rSSqbiPr/OZDkiGZnD1Kh2zPWkcw=", "BzpZ4snBrrKiu4mx+5tk/EKhv+/x2FtuehY7jDv6ggM=", "BMYE13s1a0hdIVqf335ew/KWSPyQoYbJflEhQM/F2WY=", "HTgKrWODvZ9cS5+0sSfgdV0RmOo6lp7+XjvPEtFniCo=", "DLB8vyAZSTCI4X0Wzp0U/EIE9nDWuOKxtQHR8bP9eVE=", "Fm62rVhV39PEXiffkVSFPUsIdBEsRIn/eqAFDkH7uhs=", "A3KjvrnbNgMbfwxyuvHlPpxyIHgLJHrtgu4gee+t7tw=", "Bb1lUgTVXMa2OQvBZQMBlXpnb309YBfGSWrQMf1fezQ=", "FEF5GZ26E1zF+ekbdogPNCpOdLjuZhwn1bZR9FZWAhs=", "Dm/oyWzpjzzJfBGZO1CHtV895wvtYycw+SKZs8Mroco=", "B6LrWIY3VRfTmb+r5MfOXAPt6DbESsK1G7PjWqlXbU4=", "B2TsiWuno3T1/VocvtiivmK64NVyY54Xv/rSRZDDuJ8=", "B7qexngctHT6TWIpCPCaAXZ6B4XDoUrFuikyjE2l9PI=", "DDJbSYll43cCQwEtr6DdT7A2pAE/L2fzUPP8nnQEkWA=", "IZ3TyjyY0WEzk4OMc8iKbGUCyiOzyFtbiVmilpHjQnE=", "DrK0X9UY9U4bDUglAm//3XZIn2JgOAr0Ddq1/8HFsz4=", "IwW4tav/3FUs2WlW6/pFajazXSAL0+Q84WXrOHEaZ+o=", "GnyxHqlGP2OQq7cHmHYVzr5ZTPIy+16JFEB6Q65XuYI=", "HmfOBSTRB5IIqU3CVIPZ5rdCjUDDYwW74Ik+GUolsyU=", "AP/FOahTd4lwQy2GMbwP2wz2AgtHJLSe8DEZDcS7ESA=", "KZRcnKTDnUVUDANcEGeKPy9Ryty/GbMy91zh9GtZeK0=", "GctAEyPb0/2L4dqVTAKR1nEkh8aH3ZZkpLFn3AGARFI=", "KF/YatshkIzERBJJ/QBcsa3Qsqv3Bsr/QhknUGYZ3Eg=", "L6q/0JtjqBwc9Nv8ZDI9jBJ65VLQAzmx3ExZscx6tO4=", "L8dTnEBrzib75hUXubjv02FxEMjNSyuztKKzOemFfUw=", "EpbNCJ1HUOVcHAHXaLXo8h0rwfrXa4QpQPKT7AvCrJU=", "IaDD2q9X/c8uiOvU0dGkTqpGWkDPYLB8wmVJtXeh8ig=", "Gs+X9MrMl9iI5OO1rQLdmo7lEUdeIemC+hzlBGdRGrc=", "CzVWue72noRH0YadEobg0VSCES0j0OvX+LvWHENd9hI=", "C4LPXi24uIsys3l4sRdvKmTaK+pxiUAF9KyxzmpoS3A=", "LIrRrMdjb2WhK/g85orJKr3p9FHsoVBRQT82u1Za4+c=", "L9zEZJnPsRAvVUCAeTZYIoySrkntfYFHAK0eE+tb74k=", "LI17kyP+MOwh63uOC4gkj73HDwR7W5Fm492KYL0qjQw=", "DR6/lzydJqZDYmIOZbDKn1nJ6XH8l1Bjca+Uid6T6Rg=", "G92SkhahBbE1HGBHtDxT15hmoLZT0PRnAjPp9ZzWMNs=", "Fiq6JGdQ3NhWyXWppHOnySG2JWmSApNLCh0p/9A4/pc=", "LmgdsOdMO2zEmamvviIpyK/eKTLksVIoZ5tUD/ReLqo=", "L8wjUTR5L7SoHaDB/9gITLjNgJkpPDoSlQSAjT7jm9E=", "HrZmGtu7Chd0xs8WN/oeXiQ5n2aQpVQW3vMkHO7OdKA=", "F0BFxy9oSIOLKginoBF1YJew8+0lTP+rKSbOFZ6fVic=", "AqBXXwnzKC+gfptc9VOJk/x0xO6GIclfuyyi5fLcOhE=", "KC9irrFn71lj2mxvqoZxEjIlrZGyJ7iGtrmBrv2soMY=", "G5q7uBvP9fFwRjLe9tmJ5Qz9vuHSSYAyOOrCRDUdfrk=", "GPikZp+vnP8R3Rnz1zw3dI+0Ym0YM5wHegblxcgQutw=", "Ia8N5N38RJNo21m+npJBGFxJyElu6G0Rdb23pDEIaoQ=", "C5oeyf0hy5Xck8CsGRETWzpo03LObanUVdgKeAsV+Lc=", "G0E/cJNYAI9Ew+YId9gQoIHZCETzZ+PdCnu5zBGNxQI=", "JLTvtQKFdYiP61uLWdQONJj//OofNQgmNZv/t/1PMdI=", "KxHt7zUFqdrWAAYH/8vdAniMe1gCM5vpzXTSuldiARc=", "ICJ5cGCWzUL5BiOcQMZxPovYnv2fY3QSmd/1N0Xe6N4=", "IH7Z9/9XuxfSePgzthz2ePUsjjIcxrzjrwgEp8FZIF4=", "BQQcCI1OY3QxsqSbqjdyqbBEPzFh/kZRWujTrAsOVR0=", "ABt8e8FWgiWa0IgdzLzgpkoCWcWeo8XgEvmVNPwCN0o=", "HsGXEWI+vEnvTYVzJaqd1++1+jzXrVDz9EzMqZEoyE4=", "Bssb51F5wZ+ImSDqkxht/5I+LCFMUKFFUYg3orAcqQA=", "JxKoIDl2kxfCGyJaTgukXfY8r7SCEwNmTVszHSIhjYM=", "HX0JaHOHNNBxCuhRN340DbsQFCjXIAtzGt87HCIPOwI=", "GAUCuuLaA52F9TchK63j7bVvs7alVn+rHkBhuG+j5m0=", "HD8aMp8A9vcRWl+ru3Ome910ys6sDlpMzyWuA3PpITo=", "C4iAOL8eivouREufR86/KPQoVNGpFgjjnbzahyvelgw=", "KgNucOKYfYVFPtej2aaNV0rfVurhIU3HdLqhBliWLBI=", "A/EavVUeRNm2oPRED0cAbpjNkAFFnJZy5vlqkuUCPTw=", "Hw+gS81jt6K/3IcO+7NpZvVD4jXJ3Vs3HF6lwmqnuc4=", "AVTiu9eWaSuJQtw3q9lTTEhrpwvHe+IedMThU4Hhy0w=", "CgUls/lqdQeJDn9l57WTiG0YyxR09duGUBpNsfugSwo=", "BKRzky5ST8DmBNXunPO6nvjVtGOhN5/NfWrxTb3rVNw=", "IRUNEccjL2FWKOc5L2oMk0jHARWhoHuIc20ErrheD40=", "DHGxKo6KfY/StOqbWH8ccie+HE6XQNs2z3x8Xo8xMIc=", "LZTNvgT393xa8tNsN7u4FynZUav715H+4Ko6MjIaxmE=", "FORcXisJ1tYxzGDFn7XCSwpXBBqsZLSoLbC2NgD1WBo=", "CrxcXISJeAKDwTnDbd36OfiO4GAWNu09bkzBS7Ox3/U=", "C5N7oVE12+9zZEb7SSMgbIQDpCqADCbmKEqTuyM9XDk=", "E4aa/O+DCb/UN1JhADG9DRVfD40Rv+mnFURS4r8IQFc=", "BtQs71ri7DTkl8WWE57x1QSgzaJA8XYjNfAtzVjDg5U=", "FVQwjMcSTMvcBP+xu5f+HoJ3s4b2XM8si1YU40MDGjE=", "Hk+8TD5PV+kK1QvG56ELRo/PmgqHopDEhziX5JeRORw=", "CNLKW88A6Xad/IaNHIbyiOQKMcqDloUvOXc2mvJNcLc=", "H1u+vkoYhDSsaZM/uN9QULqJBwh5l4+kt3h7+uf4O1Y=", "EaLc9F10BEXdHoLviIKYE1Vaz3aiGQJMpwAlASQKDkM=", "KooS5osfy6EOCm0ahsFKENJuPHQW821izmIXz5Z+HGc=", "BFKEjTwMAP5g1yE4BlDISc7Sz3nTBEgggSIj4UZkfzU=", "KkelT1n/InRVl6z2AHVHWRE8p9uvEdnAj1B8Rqmqyb4=", "GFv1dHJWLMpF+HrBsa6BIq7FjO24MSgcUfN5nwfnK40=", "Ds72SJ5wmtXFh2NrO92ce26FdCF1/4br38U6tYjW2NY=", "Fgiz4mJP/CwAkeR+kOWsPJlicTxqE2g/1VMXI8uziJo=", "DT9gdGvKV+XJaDcuwOmHUQpkfy59NEFbo3mJ2vqUxgo=", "CY7PBIThJ6pnlSPK0UjqInI3qNn/ndjY85+1gWLDvWE=", "MC8Q4RwT83ZyI7xQGl+d0TD+UXtifwJI94n7ezCsEF0=", "CSRxf+e6v+lUGzOG+kBFWgF3xpcxuvIsCYLPdieImeI=", "FzgpZbp75wnVTXDKPhP+yiOyK55uWpGKnwCPR82/qIU=", "INMAENl3+dkSvnlzd3UXiqhB2XISiqqV63sn4WDC0rE=", "BZS9t4s7aZk0SWCThqJR+hSsU2w37QFghImsHHIcBwY=", "LO7GwTwRu9R2ZIRDIMz97uQC4K8uyAaHlsfDdTMwr/Y=", "J5+tqD+DDf2XtyiOZwRZ3AeMds8GN6iYPAYX8ntLNHI=", "Ap1ZOjESw79X7Iq2h9g5j8J2/PHUYqaCKJJzhTP7RQ4=", "BxdRgfBVTab/6kqGDAMSS41Qw65bWaFn5YR7oz0ZwFA=", "EoDLe96brBw9f1V/J6Ws6tbkp3vl3D6CIQh+SmziPq0=", "GplJWNRMND9ZSJBWuM1yVJH/VRwPRJaXtUbI3Py5C/w=", "HwBANOiBDB8d5Qe37thCmDQSq4Rz4rAPx1WT604/VQk=", "BAX8x7dZuMow6Sc4FO+zUMHlJULTOPJMR/2ZqUIHgAo=", "C4clRctczHPSILu+Af45lA56iSmwhGAlQSMIB9r7PIs=", "KBn6zKLNbMFqauoxkfgzwtNynUd8c4NepVO+WHPOJzA=", "Iucl9s7PFldUzhpS/7rqd02OSF1my6eZcjJTsmtoxT8=", "AdEi5GVIYcSz92w7xJUpqMVzx7DU0+ecSOOkv71izRw=", "HtT1ZNFH8/qjgzagmFAi1TfTRSG1Eck2C9zRsp+JovI=", "L62ZEsTK6l1EBRfw5WiGlaTRaw53s9w/2H+GnIPludw=", "K1qFYfDcWG1uO7g+1ewySO0MCfmzA1JHHysLgDId6uE=", "GG9NY7AU3oyep6sBp5q+W5vjgI5sqDRBMvYPVZWjPVc=", "GuXpQPxdEpXTJFeoQFgcO4u9oBFbZvf3ykKYJPruTRY=", "FK/giArZL4FikqRSzQEThGMtZOoYOZedPWfUBa8yd4w=", "Gshp51S+iwcaPunGSvSQlkObmPRLFajG9PWui3WjhJ0=", "LcKaGjF0mbQ6Wkuhs2ysFQj3lbzEQxv7DqcCjvL9Mqk=", "LujQOv5DwriFmfCjW5CSauZRBjficzrA9pRtkI3lExI=", "Jm2A+1wQsmVeFBd3CXBARzzVpN7akiW4UlyUg23VHrk=", "Lk1m9lWUg/dvH1VoLR7bVsjD4U2vtr6zoCOQVE5Swi0=", "EBI67VFCWA3GdAjjN9THc3idk+R55PtEvXMhjPPbdQA=", "GVJvJbfr4sRhOV5m+Gb/uAspktU4gxAPDb/GfxMqWpE=", "LnfZaoc25sOPtnuTWlWDK1EaStjYZiH5uzEyIt031lY=", "CfLGyWnUjsKRV2u82Rf9YiwrmOwhu/ot9dVzJP+7Sxg=", "DdNgBYFxsCMmyeTEYYyOGUmZ1sRIAIH6c4h4w+GxHlc=", "GYpSuCgsrX66OjgAtZp5SixwlJ7ZZshrop2bzDfyk2U=", "F+uMjoAD1rk3g+Z70U0SqUVWhM3qTsWNdqg6B7Qo3Ec=", "H7nBYLCXl+nU7sx5xQ4mWOwQ0POOzvwePoeGuV/fliY=", "AgLDtklaivid3G4/v01m1z5t0T+Kq4kxdMDK/XjIpRA=", "EUun8SwOGjsSwrUpG9gUG9UN/HAARlCEpwH0exV2MIM=", "AZrT6GrYKjdlqmTqAi0RF+HCMMAqaskAN4lXKPgrM0c=", "JU/47J7KTT+ybHLNY6fU6Ym7G566DYv893E9q/f2TgE=", "C+jJta7jfvqT7nm1/8AOi3cnQsYBv48jAlKSWtLJpwI=", "DHF3U0GpiskJuh8mrOQN6KVjMJMTNqvnFdLB632TG6I=", "C4M+yDBcLLUAK1m+ueWCFqJ6tpu8cYjkMCEx4g/une4=", "F0ruMcNrgaYhK51EYGWviACmDMpeqhsW/shcLi/5dOE=", "F4Md1AbHeFpTZNOTknfanrW23/Hlb6Nf8YUGxksqi5U=", "Eh4cG9t+SjV0v9HDpMs5lKxJNv9UsHyqCnylPMCdxEU=", "D7LKXTcGb9cpJHiRdJj4eIvuM9PtSQRSWkFFvONf/xs=", "HBMc+KHVRAM3+hPllc9tQsMBYEn/rAmVfmnQtFAef/Q=", "Bw7ksvepCt0TVfnNvDpVf4SqzGSGNLD/SPg95PdqWFY=", "CsBcmxPR8oKBBTsSrxmHdvPJE11I+V1nyTFLLEjuDdo=", "DJWhdr+bN+Du+SQmzPrdKWlUwLynlJKSJc/cQniWFXQ=", "FmNaE1EocLcvqB5GSEIaIhDAspv6GjzJ9BRwqRiERF8=", "DNwz6xnyEBe+ikzws3trEvgB6lxM23ejTPF2rYW/pu0=", "DodkWXcBCb0xX9ky6nxpyWzzFONAPQ+T/bOv1koVBHI=", "HyagC/1ne/5XuHnHHLxUypE6R5HUsE4wQ3Zwlm2EADc=", "IpoXaSyM8zdyJUJs4Mul1h7V99u1ox3WA+rfoWW8z40=", "Ia5xQJQ5XfZSZ6y2VJ1YAhnESb+Gwz6095PgdHpkRfo=", "KvvdI1x5Vlvi9uLNsdUnvVaa3/7ODLOf4IvJ0OwuotY=", "CpXBGvPvegxYXr0gaL36sqEymCGhe69lpqB0azikrFY=", "LtgiQBpIWmIe4LBPb3tQrfeW0iXj6qWHvL+HxOwKGak=", "EPUiacDEfj2KTIeLp3sJjRp+kT/NWPihvNSvtSCuAbU=", "C6tJANwhnRpzexHGG95dpq83XTZAHBIej/6FNdq2dII=", "Dw+FMPAxDLL2yZnuLcaUMpqVeUayx2HIUF7OzLL/Ijc=", "IBXLjzKszqsUTZaBNuh9Z8wlF1KpNkt3WYiOsYAKJUo=", "BmAZTYguN4oWe4cM5wleWtEZ9m/5dGXcySnLAq62AtY=", "AxK62Sdaxn8rs0YQv988aYnonvGL/rOlr1o96tq94Og=", "BcvGjlsFofw+eEVp7zJQEfg52tOA6OB3QtwK9RSASTg=", "I+ZoithGkLL8wdFm+mchEF02lmzpo4Sg9lmrAqe74B0=", "JiAXEweNNn1oozzm67gqtVtsEW5TTIUEP+RYz00fkSA=", "KtF3ROB5tw4xde8MyG69cjjMzSgRSAOEmMR8czuu8/A=", "ACJ7JFay3zgB7WQEdGQlDoGzvB0g8/t5/vNNOPqjl3M=", "GTbCWreOVKlHp0Ut1lwEc59S3zJMtIHrmhMGc2Sg/dA=", "KqnTU7ivrr/6u6jtCSIKgSHvjNYa0sIMyk/o1dZXcto=", "LDfehEXOsObhZVGgglH9R3pXw21JNwj48VAzRuIk7HM=", "C2AWtBMGj9gRlgOsCuCv35QoSRarlYJzJYSFcxL8Yig=", "HC2kw/ywIVrvgudfZ7YttX9+JheS+2kZU4K4q1ZbKBQ=", "DZAZ4Ge4ot1IEpmskEoUy1FqwN2qF3g5WBdwonYWBB4=", "Ct2PLhKZliXWZefsgEwlmGK5l2aZeidUSY8cEMcI9RY=", "GwTJT7oBYPrxppriiQH25Y8mUTfE5ur/AD3DTMBq6aI=", "GbWMOKNo0b+0neiqsUU2gSOBfhXQa/HYh8oh/u5IG4I=", "JoUSphkVeb5MUcyLuLncrNRmP2nmDyle11BDD29/19E=", "E9JotCwzhbaMVPK8ufckV9ftkTj+38hRgaBIly004bQ=", "LLCplEjjiOBPXeTJy6Uvl7nEt8dIbfMjbI+S4WIAlB8=", "HwEBMo2J2Mk01yyjbIPeDwye7gbKNsVR2PvuolXNGM4=", "FCYvobM/euPXZmcZkA9koThxA+1LPh2ZX9ztZnYHILw=", "ATZBIbPW1kxMzbEFhLS8aw90e7tm8w12TQ5gp5bTCl4=", "L/2l7T6hiEfs2Pu7lR6DYoRi4VwkY3pqX8RDzGRFAys=", "G2qfnHwJNUu48gb5/kqcqOlcbkGy3ylF0u/t7TGZ78M=", "KVQYJ4K4qcKqrmdeXYyBo43J0upkYvXobQgXcL6/0qo=", "DK1X7BuIBZvabUHZV/FxeL64qTKim2FiZ1pv7n2uFXQ=", "Kdb2Bsr1qteF6Wd/uqH4cVsTDpCKp6XW2I4Is7hxZJI=", "MDpof1We1udwyahBFa5yZkP6FvSp7FwkD4mBaZ8vjHs=", "IxilqADeRnrHQGhI0iun4vKt4f5n3yVc1ionza0YgIY=", "Io6p7687GHAdOuvwDHQy0TpnYOc3Z8umfb/qxGHQqKg=", "LtTEK/BK63hzwvoU1WRlhTNVPQzINXz9LE3PVDsim+Q=", "Ha/FOh3uh9wGHhJDXJMq4fTU9szlfY5PAw63wO00e4Y=", "GB+ICSFxH2Eo4t+rVEQMIIetfQI1vspJbcYa6uI12zo=", "FD+6zIuUj/Vh1hz/IQ6K+CoKUAhS2ErinYQQ5NLcfhw=", "BsTgZ56LTRuCSeCbriI4uRYWpCCUxpvoOTlXCkdR4JM=", "FPfNqJu7zXzdd4/4eMjfZuKZfO0/7TCR+gslnHQzR80=", "IbQL2z2xeK+5fmyPUJo6VOSXDHAqPJbipoCjvZzRFZ4=", "AiM6+jRW9HLN/j9hDQYS8NdK2YQtCtCLgmkW06O0O6w=", "GVg4zXYsKgrCN8a7ER0nS/gJAP9rSVZoC95BrfyQEQ0=", "CYK4gCIWQi9G8pwJhZZxAgSLQ7U+PI0eVYss6BYn8NI=", "ARy8dBwb9I9wgPSRwm0RZ2aovFHZz7bNCBY+Vp5fVG0=", "BMJncL/TC+fwhsnHB/KeOKIqtlQf3V2UkdYT0/w21ko=", "Idor2D7oAXDUyxI+Mi+GxKovLr+Fy5e7GejXNAzPpVY=", "E4CqWbA7WMaNN39i7gs73AbBst8MaNUD+LCpXBcjm6M=", "ITCc7GEgsyBBR1upust6pQdXj8fUKLsBD8BvDqNtB2I=", "CHksz4jPbkUNE37XtUlilfP5zWN2RUNG+uRxf3mA5VQ=", "Cu8PkIbJ6UJDIgDotZVVaVpPUx4xn9DVfxiBpV46A34=", "Dgt0jVhWk2s/2PLrHrTCzSuLi+TWMYqCytPgusUFdm8=", "Fy+tMlk8N0zu8aQqu9cIVl01kegDLFF+RZXzBkFVro4=", "JvX5zk1yFF0+csQsl0/9/ImkjFEb12Cz2dsDubEFxLg=", "EOBTM2k0kE/217Zyo70spYco5RSalYKnLBwwnvz3pAc=", "HwGpiTTd3lHzANVC0frY//QRdHHKsBXUFGsF8d6wQRY=", "CHzXqV/fX7nX8EMaBGZiXNtC3GI3//539boUxt+hs5M=", "H5ro73HbzQ1IoSS9Jl03zAwQGMoLRee0N5awRfZaelU=", "FXGisKJRWMDF0pejl3FbAL0cVDXSaGwxYY1BKMU48Mg=", "IyL98nYeRffPJl5NYnJRlibeCLv15xrxcGnfKUl6WDg=", "LKiYD5/c2xs1Ai4C9r5i8ZNVykuerJsv3MN98u0CZPk=", "GoiBwzTzlCDUZyxQUPRdkoFCTrYVRXgqbBcEDcfTgEg=", "HzGaDcD5t0KePum+1XqWoPL2fLX82SscnNyXoV93Yb8=", "JBkzbybcXUmPJ5r5W019EhETfGCO7Sm1yVEGleGkZ8Y=", "H1FNIvZyy7FjY776VmeHeCCb0lfKEXtRQbKeBuS9V5g=", "KANKbJAc7ExWZ1MR3vEPvNgIjy9o95XTs1UZux+/Gh0=", "JsK5IRjNJwQGMkH7kZgGoP75gUyHsHHVoR78LLEQPPI=", "A9U56i3cs1h2OGF5HMQ00e7+cxrTJi7ahXxWoG2c+N8=", "Igb0lDZAnovo9UKSbZ4pkSG0MhDnHdeXD7QoMzfSQcc=", "DfJVmGB3cQOf71d6b227YQzuryBOqsegm5atIt5oNGc=", "KDqJjeWiFGXMoyE69YS39WQTqehLUkQxQ20LE2aVZk4=", "JqsmTolhEDncnP1LIW30Rwm1TyQY32ZUXDDLk4FORGo=", "IhDX8u9D4inFYx1OcB74n/3xrKZDUXkeD+fu1ChJPI4=", "B9oK/7R9ZLftxoLavlxtsiR0O1o4XQSiR01S/+ir/Qk=", "Aq2CgK5c+Ck2Bp9y5JAQ+NFkPNwpnxKsCW/UTFAf+a8=", "JnuJ+E9IReOSRWX88aVOijJX/oru9RX4bMHABW9G9qo=", "LUb1w15agc2QL0GLS5PyWr+ALTLVLaBUpe3u4nYUjKo=", "IK6OcVcPiuXmVetCpPJ0ZQImrx/hYKlrF3hU1zbyvSo=", "AgubKaVkR5CloxqgpyT7V482UFkN3RZM5a9ZP0PHmPQ=", "E5DB2VmRlys7jvoaNnODq5f0cUOWY16HkTlZNwEO8KI=", "BJc7Q2Px9V2hLU6rmFAS0yvYC8CtuQIWrtlXTanpfFg=", "JfemU/xarcSvD+U0lTvIgweiDpQdfGhrxTu+Mk0YTNM=", "Ek14EIIfR3gv5r9kp8XqzwPVWXdqJeL2neKDYr4YC8k=", "L28EkJ3DYNGt1QOVPBFkj3JusPYS9wOsHjeGA9MzCag=", "E8LPGyG3hiOPqpO/v/XAkhiZ7xqylUiCijdeS8AKG1I=", "CEwgDxDv9Zv0PPPMOlBt5QDtaOWbzlzd8RN+x9YaTqQ=", "BTta1ZAt+1yjbXay+YCQaxTr3EchVGofXx6XQWRPKRM=", "I71EmLTAyfJIgi8VtciLx6eNUo070+PTsnr2Azr+EmI=", "K1/2Gw4f4YzYTjUsQXq1uDZoPyjfHBbijAi8T9JpqZ4=", "KPd0t5NrxQled+tlUAWrh2eq0HbAmLj7uoUh8YokhbQ=", "DH9tLq1oN3JWWYSsgZ3CyDJsxNOxj2M5ElYhJiEoyEU=", "HgNTLjURFWUXP3a2funHE5U3VwN7Jys2mxS7XSKrZDM=", "HNrhaC8sEORA3jLrUXJtnbdtB7ZClnW/rX53jMC+4HY=", "JN5AZm9Z3pfe7/bTTIc7fCSY8CK4VsVR+0um/gM+Tho=", "D90BZtFcD0Jm7XKW26S2OQQM6qaRBoPuRNN7CGefSCU=", "AxjuIlTDiIzkU02QkESLeoYq+9/71EcNq1XJ+iT1CoU=", "B6jRmhl5yPo0Ab/pZO1dPz7vGdfk0LoAfzhUtJBMXzc=", "KEbxWhIUVvD3S1ByESqQ7MVqSNmKegfzDrVTQkoAsno=", "EpWtLeaOBbETAx3oVJWdmFj6z0SMoQFAVAeq/B/lBJY=", "J0UhDswlMwF6QzBfzRMHjWlEPQ3aNb4upQ/Ehf+PHIg=", "DcJ/CzX+wOD/jL4THH7kKiKNiJy4JUxJAMtW6nhJGbI=", "CXgJJc2xQpzBfB5wsLQ3VeLnBgKZTpddNMP8McrBmDk=", "LvieyuEAaiD3OapNpph7uGbWmT+onkovvMu5zijtWK0=", "D2/qsyFRVqw/h4zmfFlT28Tlqz0THulYJ1Mm/5TSmlQ=", "IEnBvLA1y1miNQvOzCpi9P22WBCPBZvDjBQJhXGofSI=", "CcUpj2aWg2sqZUTJyhwPZEjg5uTg1KjDqn5jWu0g2kU=", "HUjsjXhr4o9xvXGZTaBPeH3Et3kv4lglWvdCs0jk6mQ=", "B2a6PzYPnLjSdZPO4diQ9XNQwjUJbZ0FYzmS1HfvJWc=", "GIk5Vs5gBzRxTM/rxE9nA29RxlKCK8DCN5fXOpPUdJM=", "ADrF5qPANzxYN5vzjIcWXXFqygXhTORynskUltx0od4=", "Fx9LPQSm6vfbC4bbC6W+fURRtOoKEzO/qjG+j1DaEqo=", "GBlVo/7U/xnZDZR8LxV/BQ2zTIR/WfX2OsbAO1U4OqA=", "FeUDrmbNN7OlisZVSaod5ZIo9eWq3qcDUWm5gB5YqAA=", "D+64rsbJY3dLJ/hqVbRZTVS0swlV41hJDqFpc4+eYWk=", "DdlTH3o08aAB1OvHTLTqR3K5VRkyXSmJ/JMwNcaK030=", "IZ+1msIhdHlyvOZveMozybrjgwXhGrNIGuvbndtLLLg=", "H9YNwMR23vO2JMIZswVTc9cyE92SXpQL9VztiCMc4J8=", "H40H7z4Wy+uniSQZViEc+llUUoAfCMh2wlJdxQTFILk=", "BRV0FUjro5fRTmJpsyVmYV0JRHFVurABrG7iBWmPFuw=", "JTCzfS3RthZgOfKfsdeOkOkDTLbptlP+dCjXaPjpstU=", "FgLoadULKAlR7Ms85xcVYomA1kg5Domv9Q5VobvK1LU=", "IziHIXr2crus2HPxKFo2EnlrDL94kEY+3lSIL8d0zH4=", "GEmzqp5wU8jpUlKFiYCr6PFkLsZoBHU/Av9j8P8h1kg=", "GgBJeAiF4IJ0R6+bqeueZY/9Yqy6yZj2wagN3lrtwaM=", "HKnL+oCMqchVWUJa8xwK7D5ZNLarUaLqJUn7wudWKRM=", "KKKg8GIsKo5PFvLgNltytIExLY1Qh+LliuibNLjMk6E=", "IdG+7RC/+Wyp9hW97ZlnSnMxpS+zVmlT5t357KKAFT4=", "GHEU8ru6mpkyl710DCc17wG4WrvbW0fEHObs8vx+2+M=", "EdCjhndcbmcKNgpv2VfEA7Q0uhP3LO3DnRQIv6c/wGw=", "D/TvL0ar7yTKFdizieAs05RNEpYTG20tzpVN0R1yT2U=", "IDOOR7Ug0oFEjz+L8AiqdD90xbY/mKYwoAEIRkuyiSU=", "JW+g/vWFPcEK76hlxWUxaTl9VF8HWE6uZeGz5Q+2phY=", "FEujYZ1fydhPBjLfKW6N6lAXMpVzZhtpiAw4ykWuMYk=", "KYSYyN8x3TFTgLNlH+nH7VqvSklQpmE0vItgKUcqNWQ=", "GMr54mSjLbyiPaUaNRT7qS+2L3jswthEVXNV7IpDsME=", "GUyBKCjxzb8MTwsEhq+0xdlszCGLO5DQS8XxyGZf9kE=", "I/k+HEQRm6hWoQOAwjMxkbMQX1AqYeq92LGryAPASuI=", "JdLMmI5HznD6mc8YEFAA0wRnF9g5r1R+3D3pMZaawAY=", "HRCDYAAjzM3H2u6+sZeDqsxulCJtAMfKRNr9dVYUqA4=", "GUOp74Eav+ZX//klBPKokU8J391bl5kRBHvuS2mABM8=", "AfltsTkqOuXL/uTBhj8L3f2VplKZPI8XzhiGnCYbxsc=", "EtSBTrsxUzHU+6nfwu+QnNd7HnEmyeYlijyYIdZj13g=", "J6KtabnrVpe4W0MeuoXbsZhD88dRgSGqSVFaZe5VLjA=", "Bm9/KYHsxMRBXaYuq9MjBCSr/tNWcSH2VugZGnjF3fA=", "FuKY9gsmXwb47JIn5U6LvPK0gjkh3rRPBjySQw/EChI=", "HBCrOcsEzgK6ctmWBJrWiJYfYPjZgh0XFsWmov4KlzQ=", "LNfIp43Zmu3BjI1HRStNWy6cWyEo6zc7ggyovuyXCnM=", "IzkayfKcGpntb72bv75ytIhWm/miB63b1OMKOouXMR8=", "MEHFWZpR7aM6Y5jrMSMlGXl7AHJnAqmKMZx8y6n+0vI=", "BOZJCNefNe13+oGW8HqUjISFErU02b9PMO8JPHl0A64=", "GSUekH16kDv6e+2H6wS9kh3BkGLk7Dq8noK3+k4lvm8=", "GzloHCwSXK6NOMxe9vrCUvT4I3T9W5BZYU7ME08rKdU=", "IXpU3Wjc1T4zbOpJ2Jkl/RKP7mW9yhMWWdMkrmNmlrA=", "LAVL9vkXdgIN4/uXBbop4N8X1+Gv5h4R7ajK94dirzw=", "H4hhHWwCh85TVD2H7YGCukdfbiI5ie2jXRq3RidfpOk=", "IE1amCnVcOIDveSRuGKpaXnXHkgOv/uxPEyzr1Zjcc8=", "DqyVxoivqnc6zkhWJSeIFwurppphgQcdHRpODdMgtLU=", "IkWgln13esUWAIJWPVgVtE7Q/55DBcZcUD4P/rrl3S8=", "G3MpBUZq2SGrJDDL33cqgW0c7U3qaBjcPO38Z//l/74=", "CMrxpM2CbRnhwn+XDK0FstSZMbrjabgsMAEQQYefKJQ=", "J9gTRCPNmHskn0vtx3c/t7cxToyD2XJ/OiHQ8WLFYc0=", "CaLqN7PXOdzXCGLOYqiDfdJnwiop6wUO8kbt2E9I+fo=", "Gtz7Q2sjj3RhdXqWZdLcz+occ1LFnlrqqO0kuFML37Y=", "KiNU21Nf66CACtZll2HymqsxwUJxbhZ3lYPBfTy81wA=", "AQMbh2/HBMMpa7OBELh0dviPVyGhEyunG6DcQWhxmm0=", "C4Xp+2ZMw7TuU5k2+IWIWuVDxgb9oAeu0gJXyOTuNZc=", "GAZ70IXGDaYwqyTN9Bmv2gl3iRLVx26/2d9+z/YgcYY=", "A3cdvlwzQP0omRfW+smhVLbVXWNVevE9m+pxGq/F4ds=", "A6EgOBsVlnzeGjOTn8p4MMqhrx+61tbL1GI1khAfH3c=", "BAMk+61zkL2Yw1UyMs6mgdSxi+hXkxIY+70dOU1n94E=", "KUqTeKzPcjwmJm34m/8aK9txDxmN4WiJDf1zrPeGzZg=", "ID2GQEZjMs4MSTOWcxojuF93zdlYgMRX3ZzUbpm/DyU=", "DTOUgc9Sqx9lLsiWeol3bpK2qhIFZ5TJ3IVvwn7JHvg=", "FYvkIXdHB2ooqm9hfH7MYEXIzlxISq2hl5lLYYs3y6A=", "LaoXs1rC6iHto2uwbbQKf6gf5gzaVW1zEh2/F8igXr0=", "Gi95A71kPGHMXraEVSAvZhPJwDvDxZqM1/jRCwx3khA=", "HKeDX08cXzWqHgBUr7EUdpqCR0svn3cSJ/Ai+nYrpWo=", "BDqzyVtkzvp/l+Hoq/nbJdZMIhO/RLAbAAX+4GeAS+s=", "Du0WlAhs3W3YQALGk2USDMIxgoMibrfb2cEVTlvndKI=", "AxtyaqXdpFb/rCnNOLZJJr5XobbB/Fk6UOfpzThPfvM=", "JlLPv5ARD3cndQ1o7qt6SThYhpU/dYMr43XDfqmtZ1A=", "JKWNCHrzgabyewZV3nlbanvnNPBaT07e8FcieaKKO9g=", "GwTT6Sozj2vuuAkTgtkxQbO7PQMylEE6OY2iRGQnKkI=", "KQue4Co6Ke2pTOCKZ1IZHDwpbMLARO274JEXI2CyTB8=", "KgEtL0QVRckU0l0M0o+oEEzaKggIRcecx9DzkUaws1g=", "AdTlvBgM7cuO8KWdJUmKVC4yTPD3Eo9wfEM+rB7e1H8=", "BUZZ8BLsi3V7HSoXWp+mQ+ljI4w0ImSun8OaaddUYqg=", "GfwDBeHlsq/LhqdCFSuolasCSsWce1flNSJP+4B9xyA=", "IdH9DCr/zmdKsBZmGiFvBhW1ux8/w5henXTdceqGrWY=", "JpVtk/AXdtI7x/HjRkmSWBrd20gXa8uwPvqFOrCcOxc=", "JAMSDlpoeJW8vle1sR+6DZY+sMhj2Kq3QRL1Eu2K2eI=", "JmhPqblUiwiseeehS8KPjUdlAxLwYppAu8zbWQopjPM=", "IWlpwiG9w9qhwq25vkVsoZ/LlI3pcl/Fl6xiaWhxXBg=", "BtTlQ2LV3HzUie9GZxPBuKcDh2Bi7QNmpHWumsB3bA0=", "EMIev2QtOKrz3hWsSg3jtxq5eItZBKeDJu8Jmh65U/o=", "CkuOkbAtqUqmIaz/FrvdRPB50psgNKnh3YvicOfjqAM=", "KxpbUrXxxzn44WeoVht8WlZ/1Em2HkqqKWXzF3ut978=", "HoWKHtsJfxaPELkTDlHVpPO1Xaf61olimPFLt69OY1Y=", "KDYsP/ar5PsBdFDH3TRL1OCBAK/loJywGHcmWWeq/NM=", "IE4BfULmsyz/IJE2jjRCAUQIVHYaDNRjdmBB1+ONzUQ=", "GCMHqm4Gvxsgy+U0kToLVh4xAxbiNUDzXxvJ7kN+kqo=", "HuQArtK58e1nqBFkOMy3vbjReYaMH9am3ZSXdE75up0=", "KIWQrNMx9Eme/C5+iqJlbmTL8KaMfZKMIiDbZD251BA=", "AIY09kmz0lAiohJfXzANLM4svhIt9PHFEpbmtl//F5U=", "A8Riz8tFFp2c6tHQcVyM7P/sd+pEmiCIKur6Su4nTmo=", "GP1U1JhqLngEy8t35oEsBue44oylGuMj5W2QlHgqMM0=", "Abnv4EqAmkPGJMcm6SlL3NO9HpfL3tdC4hc9P+nkKf4=", "EJylkbk1DHGn8ohsblViizggYiOlfAeypEkHcckh4uo=", "D5gTTpB3Updo5Ow9zktiymuvgZnXjH419FGRKoD7G/o=", "IgWDSrHIpm3hvHZq3uGOr2iaUr6uhlmtTQtDe+wilSY=", "KSpsq6Bxuf2PtfDkbd5NcRu0oRitDGfnenY3VEvGwh0=", "DyGKxjqJ2W6jfWLqA4fBRd8vFJV7z1x7Wyy5MXqHF0A=", "ITk+Xy4RIRNqJfBxRly4WwKy/hJKjk6oMYGJGnELClA=", "BuItaUZITa0/StDaQb4R2iqlRR/H9M9sxYmCeKZ0e7k=", "HsgRfFWQB0opoBkUDv0cYntxX8Rk8desnUfwl5pMWcc=", "Dm9dLvgpRd+zkuRHE4vJTDK923JIMFWgVjREoOT23XA=", "Fpq/yz7pbX4C+XEercCp4kpHovn7ESHPjG2s2RpbMso=", "LR3NgljSxVlTXsYoYXiN6mDdQtf+4MzNIKauQhTSGZA=", "H4pGzsRlu6lkSW0lyvmjUb59CaYo/5fqxPzu17/tXEU=", "DdrldTAV58HzsH2uS+d0c5jJuYZnqhP4D3aKIgRiCyg=", "HZYSBGlyeSA/RyHdCFgkTyzGTFy/GkvxB3oELr8Rr4E=", "JhG78ZrduX9Ldhq8pDmZpLmNdYvHTtNxm/ZbFyY1q70=", "LJPFxbBX9SwLPVQzhlnwXRVm0CjBgWv7/PkANZO5gZA=", "KpJv0+Bmqft192/QKqmZaZmgkEUNEe4ah6Hg5lzSh/g=", "IR3O4P7j+Fcf2W8rXFXeETmAf6afvnkhZWP2xXCfcuQ=", "K33cKLK8LScY6da0x5DVWDS3eQbeLUzoswGsNdM712E=", "F7pRWTIaGA3e/pa8nQ+at/RL8uVRdLagkCm54/2D4Nw=", "JeErYyYhOWleUKHpa2SANTpt1qG7mAwg+R/VnlGKAw4=", "CV7KNILigFe1QRjabEWj8PWuU9Z77MT7DKLpbiQQFrA=", "ERKuuWIr0uADBt+nYIi6h+jZz+uD11a0CstEVOd+OrQ=", "G2lQfeg0Us45d6g+AWSBFK/A9Bl0prqWL3fafuA7I1M=", "GMNqIn8wuovoNQIs2giR1RsgSdzstSYcAkQzY0JoEoM=", "Ay3/ZQKtvz6uHtsKoqFCwjhyFt1QGsqhijVlESw87zA=", "Bn6bLfEORj/05l+iHRi457XFXSF5QSB4UNmEwmTqZLk=", "GGqMHd/Z+2cxJDpsGQ10wlgHYlT8TYUbtnwVyFXaaMk=", "JfEuCQSvcw7GiSASLo1+g+bbfg04GNgqs/UXllKs8aQ=", "KSoFO+kBPzdBVkVHJzKcowxQeBt/aDcesIKXSRTML4o=", "EoZ7tUHqF8UyzeFX6+L/bwo9PoO5VuYZlRzJmvIuPXs=", "Cd0qdXJqJl6Yq0LKDQE+e6LhWyYQBRbg6rc3+3AEm1Y=", "E3z9AFTbrmtjW05PnmF1Im5clcReWyVBM0+U39k7Ig8=", "DRRjbXt6/RGG8LnVyPjvVRvqx7stNrJUNvBL99y2Dec=", "HbyBAC2KXK4f2RBTLwikMjw1eBwrkBvXIrq+Cl9txhM=", "JBBXsNmXfqpQ4Euok3AroYLNsziMxjKQf0wggYNNjaU=", "B8p1ydUcZb/CypnJx3O8orrXtJg3C11Q4nWojLawYzk=", "Ffq280ro0ive3XYGEN1GPYgc74zoL+SgwPhgUC9tPMU=", "DPhG5nq4Fbe/slUAhzP4tF2Dk45usNvRnm1TfqpYHgA="],
      M: [["Am26WK3ozaGI9J5S/OcWe48hnb2STXeGsPmPt5n++i4=", "ARoTGjd4w3dCM7xUCWQZ1GPTq7rhgyKn53pRGIFmX5M=", "KhirTcR3fhPLg1jBxCMVNXDRy5CVRCQ6vazUVHyOw6o=", "FuvXgsvPbWPDi4eyfbKkpa9YR6mmCInEz2qjGNaGax4=", "ArftR/rCddNPhC8JsB75QhAU3gQMJqWRWVsie6e8b7I=", "DF5J4xn7lTUHPwf54FWsyvPj8ko13LRsq2ffxkjvrzA=", "AWHkrlstJM1ji6XDK8Ixe/kNQE434APxBV2aluQG0w0=", "Ijx/xtJPxT0bQo7bjxxS0gzuxZIYfSx6awsUe2KSuB4=", "GuBg45szjQmEXi6evrcL+3TNSvkmIX9XMr4rbLf+cqY=", "BGGRq0HpOSnqUfGQ/U53OsjVCDMo1LLwSCjco+aQmMM=", "FLobU4Pjczxj0Awywrv/2OVFB+0zv3VEyGOIGR7KPkA="], ["AJgTyAP/hKNpTu2vSxwhcmFSddwYymVMeZpwRAlGzPA=", "FJWvA9yRgMiG8OG9r50Y4y5rDRuANw58vldF2vxDNSM=", "DZXoz4pmtWwy59EeAQfkHhKXEi0azEEzLxtJiVo8l/w=", "CwXxYQjEYWqXOwHYLlDU/J3NzOZ9LSH4UoFr0jTphys=", "IwtiMVswvEnXPf+KneecYg4Dx0exTEMvFwcV5YjWBao=", "FdIXoxeEdBBI8ybhVa+W6QtarnNPBneeaYhkA5yS4SM=", "CvmvvsrhdhzBfUS1HKZtHb3q80HoXxCClY+cty97VdQ=", "HaT048Z5CuG4nEEYhh2MoqUMyCpOfx7TxbqMuUS6Rok=", "KGCqUtwvlnwMGguUKsgeAhidAxQwwRqRmlqolbz7YVE=", "Fv8z1nyFEhvO59gc/xYYkn8ckrTR0hwqB7auGLK3ubc=", "G6DoNfR2JrDYJCaQDEkXCovinDnZAzeqX8EHZOIyGhs="], ["ACApc/f7pb0h7Vi/5xVteykBDUEJD2PxuykMHV2hrWA=", "EZNExTcH8AJDmDxtAk/Umg+K+A5YcZM+WP+Hw6H0i5M=", "B8IvlvL1VlPQTtxjFQVnp6BGCbC3nuz6yxSF3Ot7yHM=", "LzlM/T5EJQPDoiUSqkt2uVt0PHB2ykEVqfu7fGsH7l0=", "IGNRdQA3vckNTz55GGGfxpDCtYV/i/vYbXwAHkzyyhg=", "GszqCcK/0X9AYXJccS/Rl2oH53PlTZBtoWYhUgGlgTY=", "BeUsD/jASo5ePH6vodCQL+Y+NYmJNLAPQzOzj+YU+RM=", "LnCLqviUvFg15f6oEif6jPrvmQhtErCjp/P4W7ymHSg=", "CsI/AP8BW6qxyL6akJQ8PHLReBi+etQnxF6z/xgocn0=", "AhNHmPTKf7mSgBLJN/N96HQyuGZa7t83Pn/6b+DBPQA=", "Ahn14opfpSaJ0re+QyYkKAyUDJv5iDwfsP6Sn3iHPBs="], ["EjBerfZNrCSnkTpi2Vrv1F9INVV2xnHlb96cx8g0T/0=", "AKkr1qkZ0WBWFXhvLv6AdDylfBDsgM+5JnIrW+1Ai3k=", "D3FsVN5BkgxAGmLfj5GG4ZuVI+mGN6WxE9YczDC6AhM=", "ChV+JE+TkSXVf5yOZvfYjsD7PAW5D1JrrAhxvKhGd/U=", "Ihi+hh1STq8DuUILE2jpxap87+5y0ObvgHMu6dfm4sA=", "L5vRnQyMOIen/AFz+GPwdeZrGDrYnxNwSTBBbh1ct+w=", "FOtAHBCEqd3NXQCS5dGimaoPVcNRVFx4FwPAHOh9ayk=", "E/4jviQmG6W5LTY5ifWOF/zu1KhY0cYfws8rcdvbaTY=", "Ay+i8WZiLwV/YalAXJJWIjyrK6gslJVgeSF1WrAY9pA=", "Ku3b+iRXVq0eFlhin3R7jadZOxlcyVAyT5Xtye2kKq8=", "EjpgVWgQI7FlcMcPzfOujjh6lzaQueZ2G+IvmUHX73Y="], ["JceDrWbWofxshHcL1jf2IHCX3/sDeNfgOV+MC4a1Bfk=", "HH06ksqkNc3ZdFILtvtsrIFjTMm/TlNN93c24G12jDw=", "LNaPwxtn3EX7axb0K164nboq5+mqUMXxkVJ1qBiHGQo=", "HUVnwS22SNSpxBMkwDKTJbdqB3MPrXLvnkkKdIZ0mFw=", "Bp7k6yC0hg1K+Rr+F4Ezj1OqNUVi7Nhz4OYlr3B0byY=", "BsrQwr1DjE26LtZLv3UGbnMUhMNtH2c4tumGAen7SY0=", "Hg4WbXNKphTGtT209pEXmEGjP4EFQwo+5wq8qDum7G4=", "HIeclCjhlgfWR/XvFBXnb3xZ/QHlKvuASGCBhR+aUoQ=", "IVwM1OPxvbSCuT5XGHnXkxvpACPXoiDo+TshyK3UH/o=", "H0H8Z8oTIrN7eqAbYx/RkQUoH2xqTTf79o/BtfYoAsY=", "Hc42Bir35LAJj1WQYiztevnyjojUds3hOR6zBAjV0mY="], ["Ii3rYG8TzyjHOmchbYixb1lY1dKSuhDvO8LBD1oLYT8=", "EvuIoPb3SdaNqSUNWt7PCIRCgnJI1n+Yn9FLXJzU1Mc=", "AGYpLmTmosZGc67TZctQ971OHTtScPay6ZglkMP4QA4=", "CpSi18QJPGOII7CVcz83F21+dHuiRkW1FawqJB/92oE=", "CiJhKNodm9WzKfVfUsdWgt7zNpqxM1nct9IS7vyoYik=", "G12oOWY2FYbogQ/tAyQ1yqgKm0dtshKQR07Rl3/O8i8=", "L6dd7tKB23NPq6W3Dq9Xli+T4u6h09zuNMgasen8wO4=", "EoyzFQsVy8T6qxS/fWdu82grUsq/yNNBnf2YEJ0Z7MA=", "BScAsZ721C6jkuBEoJTL/DCO6h9y8qNCix5yG/wyxq0=", "ItHmTU7hXmDEWdhR7580lek39akJkDgsl4Z8RbeUAHE=", "JS50dGZ3/XWEzrD4qmk2vQT5Uo72AHN+mRP+S1aY6yg="], ["FhTQJUcncf2HCp6dQis1ccVJTn1nmCTY/hISF31fouw=", "L2xOCXu1hRvhK74scSwvqQbzELeASNaVtKrTAf/A0mg=", "CKHvZfUhKOs7It8rasowUJsK+K8veIju52bAwkhxGIs=", "L28UUC8g2Vip/yO2lsrDriSWdReuiy6Vktr0UYQLuY4=", "F860KhnebdMuOzjMKZDmQnO1KlYYJj7r+knYRRjqO+8=", "KtveXHtz6afiK5E/meQNleaJxlxCjCOXzSc5I89o3b0=", "FL/jMRXfKTZwOT4dyNpNaUesxLYCSeWxyMrjdmZc1YA=", "K/UjzYqjviDOfYkfhyensktypNSDhITehCrMeC/YvTI=", "AzuTpc8V/7r6JybyUngkoRr45C4B06fuFZsnPKCmUgw=", "JJ9Bb65atSpDXWUgEAbdiujVQmbk1WQzB1UZAkI/fMY=", "GakHmpiXojcHQlJ2eRK+17djWujKDt4t06QqdcHGuBo="], ["ATWL3Wt6UbH1tdCU29juCGzNz7nCf6rQgG6O9xjQ4rE=", "HAbHgvvAmAueSTsppeSgSu/GaM1CVdbP4gjp58i5ocQ=", "JFKWOOvN8m3ogWKH/sY3BhThEuEMA5GQwQOnXO0RtCY=", "EmQcw89Qyme8k7yMGe2J1GE+nigaUc3zE8vIERkiJCw=", "KQEt7/sRLrFANBWcWRYvhm1KGAO00ZKkMpNZ8PkDJm8=", "GouK0ey2y4iCc6kL74saLPwD3UTgsosY4QdOQEqeD0w=", "F+oZjzqyYdoAAVLyaw6w6+CIpwnosGoYo9whCMIJaGQ=", "BFqqmc4eBqPAIVCASpEIf1ekO3l5d3PoMhbKlp6HM4A=", "JU46zbx1rFkmebAytlqckdLgkqteVxlVG12mNbE+lHE=", "EqmWq8hXcCGseIDBbwWNngbpURGH8Krf9rtkDkMW0mw=", "B3ft702RUg/NSQoi3Faal+VAoP21J7Sxo6hU/jRrjn8="], ["HCAH66TRYphGu2lASsyEVl3l0kYg91z82fEf7us/N0g=", "IRhlt/nBx5GjPXA60ygPaXVjJDSa/IkSoZuD3izQagw=", "EuS1QI9IZBlRc56iflIQZyQLgqpRpC3i1NwegiWQgYc=", "AhhcekrYyyHxkAk5bxNKLD/WFNMF5HXd0Z8m9tSz+c4=", "CcSy9hrfJFJmFozJGOlvf438Nb0997I/xkHvAbzHHM4=", "KB7KFLvDkgkZ4AEVBFHD5E/xjh3RFxQS/15mPXSgc8E=", "BTPopFS4zW341I+psKnLKVKTPhprHUI8vFTQUzpyWZs=", "KEzPcIWVR/y5w8e2TPCtYuUXJuyBtY6wHBofjsep63A=", "BPpWIKLAV9xVKln97+UKkBBoGQ/cPfh2GZHKtQoBpEk=", "LSZAp07emvbJiI5faKhPrJKxMzfa2PxhUvqzS1VBmQg=", "Eho3ZCaf01zfHmIcPcYxj0e4YjgLoANXhJ2IQAWUY+4="], ["IvSdckQHfkH0CcCzU6/RaW46oV/9tKC9uIP/56Gochc=", "JVQuB8HBOXm7FPjU7pPat6PcdQgGzzfywC/1O0u55m0=", "AIS4ixzkWYtwHPlqM3mgKjFX1Bk8io8RV0WfajTsMvs=", "L22jhUUJEc0nLhNgHnzmbCuR2AkwdJL37leK401vX7Q=", "GAK5flS/Ool4Yyy+EOQpcFsDaAMl0m6hkMDx68c2LqM=", "AFTMgcfR1ZWB680msWzL3L8ZaNd/h6IIHRMFT1ERj3w=", "GWgbQkLRHiiqclMM8zp9FXGfGoiP/2JeBGUsd+4rLeM=", "Gr/ksc9dsp1AeOUom7FDSYq7vcmvVnIEcKJqPforqFU=", "HSJ5Zz9sq/ChxLjuv46ceDYWgLLlnX7Bk0iBn1s9WhQ=", "DyRtL7tOEhfwljH7yHcIJ8NnUeatjW+xaBDjOVFDrYA=", "L4DKFRsHe1B2coHqXUwfdFf42kRN2hbYFJu2wQYe0Ko="], ["GVFSOkJwxUQD3+Mhj9PUzO+kMRTxsZ+ywoIaQ3Rxi50=", "ErWgnh6V4NAfvNI0+tRz2O4rqXb6IoJ/+m3QPIslpk8=", "LBhOkE17/TaNRJW54wJ/mva5MTyPGT+SmsniTRDXo28=", "FvxI5V1k2DAQrVczd+okIjl/w6fmyIr4CKVm3gIj8MA=", "LbGsTCscI6AAJ/3PD2Y6+JbYdBW7A1sUnSitPamMb8w=", "FwwFpfilXVyf3F6COLNnvjWJF6GaKLTEfkbz5z1CoIU=", "Hrf25VICFcFeJ0NVsZu/cau/BKpCbNB9pTbLP5Cfblc=", "FBEadL0kcwyDNpnrQbOPHU7Rb88P7MFlW3byQ31KDJo=", "LUa0jlCQwMVqOQ3jc/TJogCNsxH+MQY89P7VRikRNYU=", "FfMOvfuLjuZEJBA5omtAjceo3nfyzG/tdUtwPqkt3lM=", "HulQxFoML0pLZGiKeTXtK2PU/ltBSvoFwaKEZ0QJ8WU="]]
    };
    exports2.default = _default;
  }
});

// node_modules/@selfxyz/common/node_modules/poseidon-lite/poseidon10.js
var require_poseidon10 = __commonJS({
  "node_modules/@selfxyz/common/node_modules/poseidon-lite/poseidon10.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.poseidon10 = poseidon102;
    var _poseidon = _interopRequireDefault(require_poseidon());
    var _unstringify = _interopRequireDefault(require_unstringify());
    var _ = _interopRequireDefault(require__10());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var c = (0, _unstringify.default)(_.default);
    function poseidon102(inputs) {
      return (0, _poseidon.default)(inputs, c);
    }
  }
});

// node_modules/@selfxyz/common/node_modules/poseidon-lite/constants/11.js
var require__11 = __commonJS({
  "node_modules/@selfxyz/common/node_modules/poseidon-lite/constants/11.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _default = {
      C: ["FRLfATW2aSWJ8HEUCmB0nPd1xkKzANovtK1cbiOtTl8=", "KxCa4DftMDYc9lRLL0zljzVliYltaohJSC7T+bZuEZg=", "Alhb7OBu/1U9SFR4oZ6xSeIRGuTh7LHWH8EM/hwHfzQ=", "Af+Jb0wGYvSyrZJnQbSB0DuBOozDQ7nC0rxIGccLLzw=", "GwyvAvQ0+j1M1PuxPTEWrItzhqWv1sZwduy8NwSqRdw=", "D8t8nxPIVRengFiUrIK1fAby8VOm9R9g+OUIaE3+W80=", "LcK99/Q4EuOc7yEOQukrSWiti/VUVBGCNUUE0yy/mVQ=", "Ba3Z3yDBiY2ka790WUQ4vrB8mmVjXJD0XAoI/rrRNmQ=", "IcraZkFmTaqZf9VazouIGRzcQZT727bKWJVEfIpYhZ8=", "GWI1BFiaYPBYsESJsVMyTRbtZmZ6BN9XKxA1kLhIvwQ=", "F3ZELYUKQ2oAXgLGR1ty/S1fhEUokMREFihI7h1X3sI=", "BsFpH9bS7pg5ZhDzyGjXCHTyTv+FOTjYf6zokjSgmpg=", "IsOroV86Fwob0RdhzCF5Snr7NIpF2F4wvFIniBST9Fs=", "H3exjwbhRYh3wrGMrk6SwZbAvg93m55jsGxI6QsCdPo=", "Imw9/npqZzGcHa3aG07wTkX2uAp43bC9Z+Nj5juFxUY=", "BW7746reaOaIarkumKPSimjKidL7dXBvaUagCB8B9iE=", "KWQGRR8gHA0JWHt/TgCn0OGUAmDUgxPegH/C3w91XX8=", "IADgtgErIPCd+O7SWwlb8i514qnIfkeCh3ALWTNW+Es=", "In83ZrZkLUTG2DahfDDOz/ZUtUSuhjaBjbjifbEkrTE=", "JARkGy9drZciVCvxUdSX6RmYBySbiGyXXyY4XfslSnQ=", "A3STrGTR3rNLm4NJDzUXDEIS0sMJJtTk7+5XuqZSun8=", "GOoHSI8CxpJfSwHQG4CcmmMl7MfZx5CSK2jOXnlBWV0=", "EZUr/LoGRCs8Hr2Vnx1MUfmC8h+ZThBcJXj8Sv/5HJE=", "Er4qMvJ6TiA1F6sgKOZblJ+JbFvs/lfiTArwT6xyBUQ=", "I+gJf2m75F8C+uxeJtxSOgIVO5756LucXxed/jA2w1g=", "B2P8S32pS629l7qTNhPDU07yFTaucIXhI8jT4jI1E24=", "J6T70cQ+CsFerJdODOLiU0TEbDIy7nExQZOMsBmz+Qc=", "Le5K2lk9dWZU3sErhr+wQa14WlZwdhH8SEX02Enn+G0=", "C1FR0N32GyKRdy65Ok4+IR9SEkM4zHDz0e2VsOnaM1U=", "IRbibHCG5wyAZgWhZxOX18BzvQFtNwqzzOfGlafu+Ws=", "CUGEkUerLNjRicT4sXtalzHlXy0UPwp20AAjo45O/l4=", "K6B6b4TS0twvGxfiNS3qvbXR47kuQkzWWXx32f5nLpE=", "Gq/vei0vBRa074zuM7To+joXdv0pVah4710ifSFagHE=", "GUNMyG4vU+XbPOv9LbUrQC+ibinBO8E/MVeG0Q6gHa0=", "B1UZwL16bm/kv732Gt3elNuEJ1gBk+KshRc0mAW2Yjs=", "EhZdR1zxxLr2Yrxs2HRPmqSRSh2eU0d7IR6FPu+94C8=", "C69DT1bLa70IoKWHE7lJtUxEHt5T7rDE+aakBHva58I=", "LilbBrvvdabXbdEO26Hrk7KHJhvIRW7ZHCu9CZhETq0=", "FGVnknGAysCncdWDDxQx0UzSRF9doWz5NEQuc2WEfk8=", "Ix0m59PtlFeRpSAT9G0C9fTkbBfDBHrK/qvkrQLLxEw=", "AaL1zkQGJG+9QqV+bVrjsiGSYeNkz8Hyo5KUj6+uHnY=", "AGYcyKOdYL6bPIvNgdkfqOv5rr+YKcJTOFz58OPnazk=", "H1Zdpw8E+W8ms7NiZfl33aCbQ7zImIkw27IHn7KR/LM=", "Ev1G2TXUWlyEia4MsCwvwCFLQNLQ885EKijXZKn7CCE=", "KSQVPc9HoVvh+mf43fAOxcgWhoyOkbAp9K+9RfxS7Q8=", "HU5h+MZFWAnhm1Y9FotLu4epJnQ0b5/WKOpdIOug/0w=", "LE56zsrKji6p/YSb5WLU1dlVhk0VL/M58rLHzMtOw+s=", "CAMAhJ8CK1ctYvp4dYO2ybHqdSDzzEJQq/qLS2AKyYY=", "GTo3+/02cdv+dZOZ0BjfZM3kX3WxdzMpTodZajBIeM4=", "JeJWNoiVfPYReKXwBzq33SjGvNEuu7mj8GVuoOu4fJg=", "Hg2RmAxZplJGXOcC5Ojec/nrQhfq4lFFZqOdtEoJ1RY=", "E5GyWNr+xZR5nfqBdUToqQf6eUr0pBH4m/V1LzZWH7k=", "EsMNX1k9SwuA/IyWfCpQxEgopBdRleR6l8vq1g0CaSU=", "IJrIoqu3DrM/INXuK0TvcfL7MXpMvwBMieVanjeqmt4=", "C8etCamLWd0Wd6swMC/fDJDlRQa1CExciWkaNk0mjqk=", "GnRizSNTo1cBWSocVP02N0fTAizYVIq4yDjIwWNAGmQ=", "DiUdxv3Xa9vr6/cICNBSUEIE+rVMTvYxWdBk1o7F820=", "KqqFdx6DVZmxPmxDwCKBZ/zMs4Cq98jom0YQ5Yb4+fw=", "LEKcNSGawDPKn/VDb//EnDugGk6ycCWfbpo/HD+2FBQ=", "ARpanjiTSlkSu+5J1QlWTJlL6dLj62FUaLIqcvwyTao=", "IqckAp8AnHW4pDWKp2NtE+rr03zHlYdJe+j/1YtLbA4=", "IpI2wVuxkyfSREV6MR1p8HAnzZX8FSqEtuADuEHDN78=", "ME5LiglQo5qylDw7aOtvFoUKjO5Fgv5KiCgpY1aBFpY=", "CDQXinXQg6Ex6tCUJLPj6WneU7stIPlAEIg/g3yZ+eQ=", "EFzEBey0CuP3nPW5vXan+XoD+aB2+KGiLBD0SSBjBJ8=", "Kje0tl8IyK3bU+jwJMB+R7KIWgZaNSpGo2FUnh+Poog=", "EHjA7ghd0b0k/nH65CbX1rlpfZThenJYdXknqGTPybo=", "G+SburcO9npdThcGYkoihgzaKG3sfDosmcC18jXtfi0=", "BoyoLRiz59u8dpopVZsdh+3QgiOE0tTOmw7+LGMxbz8=", "LYmJNzpVZjnjPymPsEmCSWmhooS2AFPtuXKgWRNq1x0=", "DT5BbArhKv9Z2N1c1dxQmt3T9jkNshZ0LFF/LfcVgd8=", "FLKmcYH72cgTx7q8nR96fx/r+fUSwSq9DfNGaim0m70=", "Is/pMEiUz3moTLsbbgtXfWg7Ak8NWoVdDIahvLQyvY0=", "Gt/ppk6AKTMevS+j3vKWH1yVX1lW1hs0wC0LBivdKo8=", "J1Gy2n24cbpf20DgvNp8q1sVe1VVFoIgzzt5adYTz3Y=", "BX+QpMCBMEGCULeQI28j8yCeiP/ivcaiQKgS87Vxq6E=", "CtdO8JdxCZwEDCxUZxl4PDnrr9XsKlX8g5mwSrkig54=", "CwDC+nYTtS4l5KbPYzozNVut6kNcu/72dSPjs7G3PvM=", "J5U4G+aU4JkaNp6ObOdeffGNOMQ68bxYjNxl7Y6He4Q=", "CRd9GMv/Wc5n7nbT0Q198S+gux3qZgw86wBqajAh3is=", "G8d+VxiCbvzlKoa4YQ2UgAdGR79LO5+jcHtoHBqFWkM=", "Ly0Si0LTIQLQV2EkCBfsu8qgPS+kXFyy+CwaDASM67E=", "IVv9JY68eTUqek+qusswhA9+s1ft0haZ1bMmG1diiAs=", "DmszK0rluV1Rjmrrt6B/tPwJI103pBM6Ub4X++n4J0s=", "Jyk2dz/Bo4qoL30xcqJHe2AeEBWsAZjcKICiG7rGVCA=", "JrxNQqF6D/yTeYv78uK1YcFadGDhr9nCOvesKm3gNCc=", "LQk2If1Aq3bvFv30mnkj0tEsAij47bm4aVloRhE2f/0=", "AnW6DioqTDsfXXGLW4y43MS7+6G3BktrODMNlQy6DoQ=", "HtY4TKneeIwjXH+/DDGlm4YaUr/yhHryqyJZJIeHnao=", "LDN8gIv+DSyrVEvZrwHwj5FtlLfOBymgjMTvue7vmOw=", "LT4JNKQ3FITJWN8el+fw85hLVmdTn9EMPo5xJGra0Jo=", "BU5CWqAq2s/rcpyunfGQfkFhMCKJRnyTJ+0I41dVzBM=", "AklX+p1I+UIHPvkKVMsGMsiaQz7LI20Y9X2sWv+F75Y=", "GUtWGpEzS9DdTq7PuU8D66uSf+V4fxcjwlNZRLL+aXE=", "H187t3pIeQXj05smVrkeCoIjImo8wMekc8/EpSx0rAM=", "Gzo6/tegghpoT8DQ+a2d+jtVfGVCv3u8XPAb0zacugY=", "K5Zhndw7KikvzrB+KqgMhq1jbqfW1Lq+jSlH4Gk5BzY=", "C6MeLR6Ac3SnEM2/gfBa9Pqtzojq0KFliwtIFAZhMXc=", "JdfVvct0uSt0pgTW+rOy86IorSM2Dk3vORkUboxE+lI=", "HKn5EfCwjRpiBZJc3nql/TiwYQlWIRUuir0BZUOA+ts=", "GpDU4JCqq/ZSBTQ1483qXepkUn5chB6pNYgl4hkbSLc=", "DKrzt2kJsLHhx/TsST8nUB9ebwg2noo26sQG8px4VOQ=", "HI+UKG4ykGnR6AtFeHyzCM4hSwSZmzuZUx0QP9JXfNk=", "Gs1DJx1LBJdttexCcA6D+xUTWfnyYKW5dwhz48uYqQA=", "BGy91N/ojGd5G7DFrHSbXN9Eo6h+hfx7vBm3g5ZHpwQ=", "K0sDz7RIfBoZ18BcoVEzvinJ0/MFHksB+k3Fc+7rwq8=", "GpoB8AQKO+phJJRqd+Z/06pPxv8h/1+0nIUqxZtl5cc=", "CeteB3p9ARBnOmF+WTaYMKzf7lDeWCOuBojmBxQpK28=", "DQBs58GH7GRyVi0hLfwp9hXF0RkFfODHIWIK9uRmb6Q=", "BUvI1lmzEAGipSn0VkCpmNyq8uzx/4/T8gb+NPqEci4=", "HKH/JExRBuqIBFEWCBwgHGMjaYxraHOBZq+Ofz+N2bs=", "BPJU3oCT8/szMN10I9nZ4XNXzLNKPBjpQBlidhDKsds=", "GPpq+TQQDNoBI/7gtWNraTaS2RzIMvh8dsBLsglQFT0=", "C8F1zWoK1UbTMpjSfSzhj/xplfFT9r8FxZwJpO7qsUI=", "Lit5KrtrYxDizVsYj9zPUwKNbKcGBONlaLFfNAjuphg=", "Ehb8D256yPDqWb94QPxyCzeEjm3LDHfyU+LNaDOqOvY=", "FTgSdQdBc1Qs0lC6fNptG+bBLESvKgChH88Hh0IdigI=", "JapWLE37CjjdkuAgtNb5snaTQfOB3pwnrw7aFFMYO88=", "GayeNUn/IJCUiKtyim6I0QoPY093F0KlF+ALwsx8vjw=", "E8AjOUYtCC8T7Mje1rK8smqABamrVe9pqR+EfnYL8wI=", "H+8NzY9YWPJAyJhgA+V3onajUmxrRfdUA+gUoLxiCh0=", "Ax2b4hJCSmQ8bJvxRNgaBub8nWhjegk4ic88f+5ePqY=", "GmzKB+8w00MUBHIU8ahylyi43+jA5VvqNWSSiwfeQvE=", "LTue2pbPGG+OC14URlQygZMbJgo/8EPGbPIy9JCcEqY=", "B9pYMlllvsJLTRLWBvtFY6I6Ew6Y7uf3dmpKNVi11q8=", "JlVXHCP38c0b5nuyTUxOfMZ0uIS5xY6oFl0pNJMNb/w=", "LlupXkos5cQz8VqwoCaxq8Kyy6JWxhcGtpl/61d6QtI=", "MADHlZ3zHuS/0RGMeuIpBtqNgC2cR4VQUBF5JjQryoc=", "EOE9CIHSewjPW2TO73LEKO8QhGebU5sFjIGhcAar4FM=", "K+KpOzcr5mTuv4Cd2HPHQSKss89auqbCFYcWAbiI9Ik=", "ITECGCF6cmzIUMCn3JGdKf+oth/2BjkLLrDsqV1EZaw=", "FNkH9HBwdUIgW/143ydL3yTYl4lZtE2+nfen5SEUp+U=", "Baz6HoV9gAHOMR/TtdnrOhyS/G5drCRmwK8LJ3gWo94=", "Ej/+YdF8vWYj7Uhq8OuOdtBN46d6SDxmKwtcuYzUSdo=", "JjaKopR0ZF7doeFVpc8N8e7JX06JVlCBCqd/S6cCevc=", "IQUOIGDc7rVjZ1Eq8/oR89LmvptycxJVsFvl/ueT+IA=", "Iu4NkMfXFTJqA4PHq/aCS52TavKWdWEpV0vHmvL+8KQ=", "DkV0Z7rowTL2h/wGI1+pKguyw/3h67vubvg3KfJfPCw=", "HfucsAAqVuOLc5E2NvpW4mo7TedRk51esJo0MqPiljg=", "BsX2BIDADKYMAW80qK4Wa2k0MZuBq0snvrRKEzg53BY=", "AShJBBV8BxSOYeVil/8E/a05SmmQ1OR6YUoAmZ5Ljng=", "E9EDAKw5HHj5whXbxdLUYbYs+lo6xwppvUcL5dgs8y0=", "Bj1lhEuIBdqo/XcbB8J4QExyi2ZesXICKXJmxCKpYYg=", "FeO/F8UoMO0yVc1cEUnzYYZB1uf+30aMMF0IIg28ijg=", "Er9d1cPKrRLgh15X4ZsQdS2WUeOl3aBcD2blv4+qPfA=", "JDw7eX6DGlUEauiRYVj+U2SOIek5QA+fXrZ9bAzAlMc=", "AB4o+ps0wsYVW4Qh7dTeWMmdHl6B6SNF9iMZq5bfA+U=", "KtHbpVBu4GQGSWNSe97NgjzOBJSobqRS2bQDNiPzhrw=", "IxN4eaAky8G0gQ7lTH+bhQRnNBRfM0p8weSlfHQMjYI=", "B09vpilylo4iGJOEVj1nUuMCNdoidUgbxsOwVpN8dzw=", "IrEKUlNxbRZaZwc27iQ94GJ2GTeO2/dRtGvaCxLczPU=", "DBkAQPHk6qEbT8cEaZWYloCEkXfs57/ve0RlE/nr4RI=", "MBh1hSya0lYhG3+fMc7Y4iVhiNMsMHLFGdcGmw0Q23Y=", "HA9n0F6/1lDSLerXoREwMivBJy766YuFyBXbazGN2kI=", "KG6aFzZPNpRqPSx7oGEv7z+sYLDa626XOqvrzlh6ePk=", "K3KUaBJuqhAfQjO6qgmdAtsU/jXEhYDrMWXGHdvOtS8=", "HzD3FAal2pjpKQYstI4KNORz6DL8DOgRwo8Jox1UFvo=", "JZVG+EGfoVl4qzYAhP4KEyKfwR3GmNuLuByCLiyDIXM=", "BuNhJBIa+soZiHp8pCjhLA7I+qr11zPsxpYL16pdfes=", "EPHOC/V8B3i/TeYKHiusiJLea3tu8vjekR9zFJQmC+I=", "F3/JUfY5/MJ0tO4o8/f/Vg1soNn5MPU9OrtV5tda0QM=", "HzQDKqRswI1oVVu8JGmmai77ojxW7D3dxYNuLpGc1hA=", "JpzQt3T4Yl9d51Gb5hhXzJ6+BtEGENyR2fTMVxEeq0E=", "B09DeCgUD8+xrgCzjCmlCA8ND+65nUaI/4hx9jSfPGY=", "A5by/OjNWrPSYB03+A/Zd1ql6fVrQG8BXZsJX+GQWUU=", "LgOvv/c/sF8y9QI5kH9IquGrqBCmMSSAzOND7GY/IQ8=", "KuiZRVpqfEmZfIK742Bm7x1sIthCavVNLHSXCzOtKpA=", "K/7e4+r3NAoQ/Alx7wAD3IfLmXzWh++ff4izDD3vJpA=", "K1CzmkPPnx2f6vBKHxADEeeJMqaAUeeSwjqZ/5UTmgA=", "JNFusfye45Ni3GYzjqDSdRR/inq0tizrJtw+KxbDu74=", "FTnU9heNoQIARjWQxu+xynMFu7qTXlp97JQOI226L3E=", "Cehd3LAr/gcJAh3JufTvuiynoEB1p4wb/Snd28e+dSg=", "Af5/d7osAYKCBzq00iKVk1H3zBbKx+HGeUYR7tBqOBM=", "HTIgz3zroZeJnnkv0rUWWAeoN4LfVUOMyPzuaudWWfk=", "E2S7Rv58ebyRVqE6jIa3fTQlOR9+0SSgNblBM0BFF9g=", "C3DuoPqVlxxStMkf2c9v+13pfmPjZAKPDAsZBLB1sG4=", "Kpq5a03jP4zP3M2OhlEOjMcx/mc+sonRWjdOsNBV0hc=", "LserTUOeItHZfv8lAelFd2kdKGmEQOe0EZCouODJhSU=", "HBtZ/5ISIkQilo52Fs6ucVc7BcmeS8smITEm/k27XeQ=", "H9+qTaVA5Q0rzRoqCXU1D5aeNJJYQIX33T//nYgUzUk=", "DMjvaj3CUNekyUu4kL55e5HwiGmpk5HK9w4u/99/CGY=", "CeWV+uyFBnAKQqWkEZDLa595+um2AcxlZ1aejuniSBM=", "BgR83A/4vZTGq2Dj/+ohkS8BAaYL9sLpY3G+VOY9c0Y=", "LkAoikpoHh/1MY+/t5bot/Cy+s+lyeaRocSST/+6SVA=", "EmFpkr9vr1FEyM5YNV7CtuIKfSXH37E0YLByJoFZaAc=", "CnhCXVY3KvmV2JMNSM1kWm5rRUhbTAb8OOBSgYtbPK8=", "D+nGCmTc6LRbU0YspuaL4yXYF00GdHEpWpg867HJoPo=", "LnqpzudiT3H6SQKXHQfNMDMZv0EAe9xOoP6kDvl8uh0=", "EEaQzwSgZm9JIaTvn4CPuaO+5hkt8ObNsVtvMC9HbI0=", "LmPEISpAIoTe3fnvJgvP56OVAC4iyaYVWTBTOymVlHE=", "I94MlSfU7eUWuVbJIAMVhmN4UQYVgVNRvFjTtdateCY=", "JUOe0XN0QNeeS+AJQDlJ7J0yoLpszX/FFY7JfJ0yxEc=", "FONQgOjakLF+crb7//4Sawnd8MDL0LIm31SVjmgK/pA=", "Lg6HygogkNmuGCTOyKOJ4AGzwK/3PoG9JYR/8KRdH6Y=", "Exng9gihL6Abd0Co4UBmuIDwtlCDHY9CS2rz+zYcbes=", "JiuC8dHQe7GLmSBZfDklpBwKYUNrcdJO53I8f7iHWvk=", "J3c9euftAIKWpXKttk9PtcIpc1slnAPUxDnsKuRot38=", "BaZRiKxtZGfgKNvkuUG6xagSQOgIN6UZFS1lQqX0B0w=", "AKKosHcZ7PsslOkPjgRbGOxFX2cyUyTEURnAMpGV784=", "Eswxamac7QKQvslnV26OKp6bYIG7Cb/aZFbc0/2AJaI=", "JaBbqaP33MKaQ99F78QEvtQIdJt9IWUDjXArMD6/EDc=", "Br1F2bE68o4wk0jRwGzxU7Bh4NsSbsWaivCVoxDChNg=", "L1X92i3I+vLPgwhnWMe8d6GjgpNOcWjDCh6dqtK5b7s=", "GkaKGLGF3DQqxrjr5T7yZcaRkXWeVT7rvmdO6XY7GQA=", "AxsPm2/8tFHyYX7pFc1tr+F6yZaJQXsdkmmGB+4AUUI=", "KPldbrdUfnq+JdJIQZO7+qNsZXaxnDb74GtEVezSDzc=", "BPcMNAsWboNAgK/ESuRE6h71aqjQhLIwHmLwjgd3Qgs=", "D9ch0UMFsv2bIJdXdfVObE6AaeLHH9ZjqcnNDRMIYWU=", "DnnrUT6r2Mo/xhCWUFBRCHnA0sdVt+Wdp3JtDVSUN4M=", "LjY2oPjDAU/ZY/8c/vzIRKF2O/st4jNS6lWqXde7j10=", "Dt6vNfRPM52vtX4wgMmcdMEH9h4+Dem4tMI0oyGnVYk=", "IOQ5E1BlTQRjtuoWzGjSxBG/jJfa8dr8SuYQbrs0dkM=", "GqC5q6tcdyWbJLpt8DW/hkx+bVc0gKtLLYWSbpWwudY=", "K1gq5+APPG3VFj8+RPiuH46qkyTmNHrp/KfCo68rla8=", "EQfpEtJtDEJTSWNS8UsmOjCgmyCtsx29T8v6wOTKk7U=", "Ex3sKKuw66Dpgh/855gLzKBgRsEvAUE60AoZuEV/gEw=", "MA7YD0kV/LXcjUIK2s3GtUF8jONdkH2VN2dW0jI2u2Y=", "GI4hHiFd7ZyGHToh9D8VeJd5OKUzW+dDJeBmnn7bVR0=", "F9MhhV0coDA9x7CygHxD3hiAu2b9azq/5cwsOo5qInw=", "FSjglvvSfg4JAEYL4ippt/gsoaoIpt7z81JWkUsFAhA=", "JxZy+7Upp98n3SDoiL8zH13e9cB/9OcgYEdUc5/VY4E=", "LX1QjfEo+pbaeRFsFJHW1NTYeort+Xsk3i8y6GhV9dE=", "AsEq4GSQNE1lhFUzigulV+Kh2tvYyZFaxALyN4mUs+4=", "Hvf1cdfarFraL1uU3hN0Ar6KgfnJ/e+UKP8/Rr7YG3A=", "GGIT5tml7MhRkteQOI6v7VU13DY02DWecwaFodfrhmY=", "A3DrbS6YKCzn6r2N+tvEa3S+6g8Fq6r2evFpirPQJeU=", "EE//+/8iWLHUosZh0tDL94luBTmO83MIi8hjJ7N7wQM=", "IG051a9eHlC0d+RsYlNCALwEPKmFzuF/C/0+aLyJeuQ=", "AaqiCTHV3lkxc06AVGyWa4uvitbCeVWN4WlrLospB98=", "H0qheEokA/PAsxLiD//Cn3fk0B5xLUOjW59ULWSUiPk=", "JwGgsJ54Ws2XEeXm/2IyvGSX6pemzrgtOUdQi7tSAuY=", "B+ma1fMxfBrOGbSny5S1CQAxn2RbK5VqNAVjVdOzAEc=", "IlBFVnDerlCHX3Wul3mmAIyfz+UwtBfeTUI6oCypj1k=", "Jg1iiT4lSr0Q8OT4vje1Ih0VKS/wCoaE9eKLXySVl54=", "Fau80uDEQkSSdeyl5JEdFXy23ARaWVQXg0vznFWPnyY=", "CXUfeTIYI/S/uTgEkZxk5crBkH0DEIX/jaqe/aleQZo=", "CLPYLPvsjME/dfd8OmGEiqDLwNzkzvjXLOOllAey4lo=", "GXa8DbvYOhom+eFKpDHiSnKK9Oj1zf19KZQ9/CmnssU=", "BPWdIB27Jj3QTSwvo5axK6CKSJidwkZLO9WXZTTrOOk=", "K7IyQ+hBxWTnrdLXtSjZrwP+dYgOmrdutNRqAgym4w0=", "L2a5YUTvbFyuW/0lEd0kVqHW41SFaavsfXpJ4eBHSYM=", "KbVp8vZ/HANj9gSTbNWcMplFPYIz55aiUHXEH6fhnUM=", "GqthAxBL1Q86ZetCu/kBeS556znUR1bK7yWSaKBtJ04=", "EAlV8+Vr0XpOr/b3m2l3QtBlU3GFm8cE3Opez8iF6iM=", "Jxs2PE9E9PqvoC2ydS3MGS9O31w5wXrVp7j0eQUnEeo=", "ECHqqPogC7DT1+9QLF1+7fKmyjbmOje1zt2Yoxin+3Y=", "E8aiAzIRcMBG19ROJfIcRwj1hATfbCtXhGL0rBgcXho=", "BmaRoCdU29Aq2igdpBiT/uvmhwg/TsKZYAyEZX7yvJ8=", "Fjea83wnTmY7fjwErQZe4wmZwwoF+93xpDA3qNvU8Zk=", "LgHPmBMlKlFxYkpJY9Vy4bbmWiuTqcmQ9qU7p9V3VpY=", "BaTsd6IcoV+ASu2HuY3D1fySrtecNySz6c/PXI01v3c=", "ADLzurBpq9SmaqmEXoSj6h05CjwrCUGXpVkcawwptLI=", "BWQWMoz21H09KRzXJZSBRDIVt9KQTHxWMbtLcug959k=", "FsBonUgoyTXq/ar6wI5NkJ2nvId2x2xdzGtL1JxyF/0=", "HY0j7R3WpT0sGPkVN1ZOtwbsETm6IkC3M606y4R/eZI=", "GqGiHjeEuXhD7GIMqJYejGLV4SuOPv+6sqTu2biljeQ=", "C7VEOdTG+BKnBYGrfB2lbZigiRYEjWtI+VQLRRt+Ztw=", "JEIbc+6vYxNLRsKWRsKyTdesuGChiLCKbtHQDLkLPD4=", "MEXCAS90RYkPefFWcGDDyTWWWs0OpVGmcfG2JeaE19Q=", "COyGOZGgU/7tqlKBCYr8Axt1VRBl1tAfbesExjECyb0=", "JQyyq51VeaJKV/qqh/fIKMlJUs+ySMxG2S7mC4xMla8=", "DyW2O17rwxmBIsYGsKWy3hXm9f0s0PST+WJlNpZC+T0=", "LvarxasCyEMd6PemS6NpnHnh3wyPLZ1ejWW3ktvDbQ0=", "HoSJd2aqneBWu12Xxnl73pPDsFklEjQCBmNTMrXCKxE=", "CJI/BbBQ5uD+wO/vTepQD/OuwwVNSysKH7rrNWOE1w4=", "EWh6wF4k9Q2wYzXhh123PY83nbOlwcO59XtyWx/YQ3o=", "J1WDe4BUmtq6R+CYCQdZEin1ppce4PM6yTD1vhOxVKY=", "CfgMgjC8WngTj5lSumtkzmI+EtoBlGA2Okn15e/AdsU=", "EEAJdG1hwLtmQ+ZN3+qi1PMIcqkkFlUqHftLddQJLUs=", "GW6CH2U4Y7FLcrGaBoqsQ0pgE1mL9zso7rNsQedvxUo=", "LIqKheJhhFKo0KnqWSvElaUGclIlNux2Y4afdYrHIMc=", "B71N4q7Fp6z6ZmeHVO+V7qhA3Jf9FnnmU9X6MritYZU=", "JGShf0NTp22RHMg0n13QLL8rLFiht96iXwAOua3KOW8=", "JoMSlOM49ERArc9d0cpNFBKlzEHJOiA3mF7s9ML75KU=", "Ftae465rIN3WLdGhPSedTX2nSyB7xXoVrJrJLK4uz6s=", "FrVaeS8bGdzOa59Mm2G+DgRXqZgOYFDaJQCkCUFfIHs=", "DUnjHifhxxwW1SSyqK2wpkhDrqXaL6TmhvGDvpXUFwo=", "Gv+4/YskPWLV1Kewe2JPmgRSeT0dGhHq07uChOtl+Xo=", "J9p7oQy4bAZ1jFXn6Kx23Jq6LoY8LeuPrnUl5CyWzrs=", "J+G+DbH91zbSGEQ/VtBph0Q3BNGMQqlvP9y3xFNvugk=", "L7HdH3Rh11+jweJd9nDBRCsAG5J15nDXPIHrYf4CgyI=", "D18MyaPU0wZsmRlP6yKfDjGDHc8IC/9C/x0Ul0+C/+Y=", "K80jWFQBsPf+M/42bOkuOs2IGKI1UPN1Peyx7CRAX/4=", "AFxVKgLio5rw4hyJRLnE9W4VtDjPNGUWuiFHNWkE8B0=", "A2KoooZaKy/pAoMcgETFSwypS5X8t5tl8UdTxYIitKw=", "Apuxg6aikbk/CYl0YQXjPMZpkHJQ/XBkho/TE4EPqik=", "Bgj2IhSHFXjtWKEtzE0cFSr5cOblBF95E89MQMpt8Yw=", "H4pM9TL16DVwTtfKg+/7UXV5AGyiLs10IlEcA5G1xO4=", "ITiCuzEpHbw0bK5Y+/3PA5eBUuFbNEiSqUxE4vCxszg=", "KXEl9nKLZfGJ+rYcOJYBa+sKly3TR2SRDwWVCNfoYiw=", "D3YCnMP/CGHgSKYB61KhHPG/xp8t1u4VFqRuSGW3x64=", "BaUG7XOC21GFHCJNUhPHzmoisZx/96f8zGI3rxFCuxc=", "FX3bb7bUJ7l7pp6HmPOVDWiI5Exg3+wKmLcmKpd3RKE=", "J3qjmeVcPly0nEvYeJ9lUTUdpUDK4Dfro3VDsEXpHq8=", "FJkJGujcVn+NBQoINers9LmVtTQdKcVI2gg5Hm8UU6U=", "IAva4+9wp1oSl5BBzeM6F47AKxEKvTecLSbL6pFntvg=", "Lmg13kSVcTDdckoKxjNbfDXor61qy7pqqxb0VZOdx3o=", "CeMCIiwBzbLEXlw6kg7dgto8uoVeFf9jSJMgm7/lXTo=", "CltBLMzOCjcWF9raJnvHg8oZzsBo8VXWlU0nnzlZzZk=", "L/sDS/K6Yp6tb4pgIuIzl3nmjvLIvznv2hoDMuY968Q=", "Hzqz+/X9JIWTgKtZqPcsxS3BqyR5oQ8z18W3EhxYF2s=", "CDA9jqbErwUKkGrrrkkuMgEOzmCbWyxusTfvXcJ2myg=", "GfCUXZ9xlQ9sKymK08ZG5PuemZOdwXDHNfQHFIx5JTI=", "GmIaWyR1i7A2NEY55CfAPzPSWvf3cRw+2ZmV2YPEw6Q=", "IYp7dF819Je0Qo5hw7eVY3UupvjIdjYdMnMpV5M5kos=", "Fuzr6+WN/1mnsLpAaTqkMbiZyndptEWnOH2xGAiJY/s=", "Ha7kbPy71jQ1+m+HkbNqT8ZZ9SNuiWpNRHqz2mgoD6w=", "Jgh1yh6Y6JXGNds77VANOTlAtWVNNpxhFW2ykn3l7Rg=", "HL9x4OvrwtFRlmrMK+ERFniIFWFL7Gb2hzWRTDuK3jU=", "A7KjIOrd9I6lcOZD+J7yJyu+vbHK7zKq2tsiqRioqZ8=", "By9TS/B7pVVCYVLDfiEMwdNti3zELh3WSoMIE1cYn28=", "F/5iqTqe+xI2AS4soQZLG5PYZ7Daow3TNO5coI0wSwc=", "LtO123rS/Ag3NPthRxYpRj1Glt3YyNzbHS/dRgq0zR0=", "Jug7mop8e9aSnyICH+p4CIA3wlxyCUJbqD6ZgRUzXBk=", "F1j95eLYuIhq4hNJQ0B9i+zrpL5RegHlGlGpwRwVEKs=", "Iz4i/4W//LV881B3/GyBljWQ9n40hKZ9hGvBz/LL4dU=", "K91zSi2KdfXhzacRSoxBi/UGQ5gEXcepqPMWaSgs6S4=", "IcLijVRzOQa9E4OG1/BbHMQvZgTfiTUJpinDUfV7ldk=", "A+w9tBm3ibmhOBHfosUYQNOgGWHl+IQUirP2r77Mo/k=", "BEUs67DNlPcWMmaqs2WzZm0qMp1jTsU9sAnfvjMQYvo=", "I3TnzTSS3eQKIaQRGzIxPfWk0dSD/zjEsM1JIUsS7io=", "GKrOFjmcf9bp0hl8XXh5WY0rcr1QjgXW+Lzrfz/GaKM=", "BB1Gn4W/reyWwH93VqZzX0F716iC5Guga6B1cx9WtWM=", "ELPBzqMC+2sa7v56cBiQzuA1i7Rd/NbbZPkN+WTLkuU=", "CG3/A50icYldCozflE11ulQoSJfRSy6qAJQAqNd6S+s=", "By5y2Gd/alH0wjhuLoMNZkjEUzpyhR/bo0pQg/AIAu8=", "E97dV0WQ82K4NcBRUdbXwachBixQ8URT+/zhKBLexHc=", "D3tzC59avDW4dLIk6/Eg1Gm8uIPUtOdX6OtSvCaVgIQ=", "I/Lf0CQuDdnd92tXVWPmmGjhPCzzmCxSd35sUzlHIIM=", "JkAyyETavLAlVFMVWItFCeJ3F7jpZPYEBNKpjoxECO0=", "KlBcaD7QCbhOoJ5wWxySVhh6SO6WBk0/CU0VqTHAnWU=", "EhlftTFOXcptu1MBoLqzdBUiqs2SYsVQPeygntO1v6U=", "K5Z0jLthR+9IYPDX2Twh5CqE2ipdJMB/LmmQF142ITg=", "Fo3E369v7NSISIH9Xw/rJ5mtsEHG4WcH+fhwHKNTW94=", "KT/fXpdBhRtu/dIWQYlOq6rk571LS5HXJ6gM6FBYVDk=", "EI1BIv+kqb7Uhtib+c5xiOU+AWGyM3vFv72BxmgUTmA=", "HTTvkPH165vppxjC9Yk/5N1CIgOjBvlhcHtKF56KgJY=", "LW22L5GUnxLdffCEbH1z3p0T9XHt0yoaOx5X78eWcEk=", "GLpzeD9m6PlmFiIfSVmlpt8GzrW9PTYvrEsQYRHuLVI=", "ChdgPSKZu/mQ7hqVtazAia7RFkb/5pbuBlvC6mUM9uk=", "D8nua1EMAL8s+qXmEituaMqGb84R3630J/t3DYwl0vw=", "KCIuCJlck+OMg4m9MvOdvMID0O/EARRHxUPQUWVhIsw=", "B9J6i7pzSd1xbRzyqVlXQN1BMTuTmJ3n5en6q5fOm0Y=", "FEmLR8S48mY+Qi9xcbSjwHPTqheJWzMbzNCfGJJ4iow=", "C9jndvO6dVOTNhn2BxEYToXBxrWWtyq7y9DR7w8Gf80=", "IPrfOFQOHkbaIq5Wt1MktJgwMbnI9RmNMsUNXyWwOgE=", "JpmX7q675Ytuqfnn/XnRhbrHFYUHOSinTqb1lN0uoFw=", "KH2RyOsNLQiC/Fdk2rVATIqP/xaF5932Vt68ezthkNU=", "CHjTNEp9FH/7TAR7fW36hahk3qpMFqZ1PB5yRUwsYwo=", "LjxKzKBhERLCmxjg+bWTV/fF3Kt6jV+avpLXsrKqZ+o=", "HiiNN8yj0LpVit5JzFIg72Ke9UNnmVlO3K1gVcW8aUM=", "Gh1/ZVmEYMB591unJDidURjRQg+Vi+A0j+127E9wV4Y=", "DxpsWH8VTLngkixcTY0nfmZnmsN+q1sn3f9mhhXMrYg=", "LXgnkuPPqEEc9iM+W+MN7A3yLTbJ0gfahd28pex0cZc=", "G/TcWbMcAcqd0tmnBSCsCdG4Y7TnZHHaAVRPBteKm+A=", "KavhTUSnch/+tSg2BmKEIWKxcIGBBuVE7xRykQR8P8U=", "AvSwIO32AgTI3HWrz7B2BRc8vGjE2TXQ9+ZU8QRpb6g=", "HGkqEhS7auLFs0grluxGeML3lWqCgZ46nIU99GBrmp4=", "JcuQNDRf00XHmCQGmluaBbd7lPvcJOtXgtVWItta/SA=", "FbplsyNlvvovfLDFIQ65AapAlonJx0v90lONeAJaYyw=", "MBoC1F+ro8Fh+CUKLn4oDVYJD0zsAjRIrhGZ/LxYqog=", "LpXG8qZ6E29RJDReOkPvIu3PqAar1zHJGkwwA/og81U=", "Ch3B2pDxd606vMs1E+G7dEDY5pXyzwgPu4PmHtKF6HE=", "Jv6xBTOouZDczp7ALoe3zTB1N1DRFWpSIHuCzmOpLFE=", "GQ6vkUIy+WzdHeS73hN6K4qnuoF9bUsdzl3T8DqEHUs=", "HUQcP8R/53oYg+BpZsiYDlhGh46XBx7g6Z5WDv/1iyM=", "JwKKgZaVUI5wiC3VagIukS44bbRtvg2AZOEciudKISI=", "Cia7/VCmj/nxYi40TiC/iQwqGYtqWL2CLHIvfkLuLFM=", "JVHjURwRQDXfSY4H2DVMBC3zGwvT7lAsjCCri8qCb9c=", "F8YgPesKgDJyBD1bqSe1mEwHjACikALmVTpiXvzwsKw=", "DepNTFK97CFO5OC4i87wPgYu4t3attBQsUUMC5WlHH4=", "BeZgsVUtNP8/YtvFsatn6OEVbfUGw5wKsdbasfb5piw=", "C5hwwtF7yyu4siWeyy5U7hYjYs+bGCQ8iGQhqQpkbDA=", "DYPvk79VFVBDTcB2PP61wKthTUfLDLPHkYDOVRhJmTo=", "K9RIRYmNiaAF9cG7v19bjphdSOkWKFpk5naoEdVzO6A=", "JVch4S+8giNeZKEGcxwSkQkgxxv+s5vmvIIpHTIufzQ=", "EbQZEO0zrgFsfQWaNzZX9Wqx7Tr6iE9q6qw+hle1LW8=", "FjSv4buuF2a3/3sRsBHvn4j/Df2INPywhZaKNYcMls0=", "F+mSKENZ6SNTbu1BvWHjCChTmaErbB3yL2VwvQDlojc=", "GYCMflQ2iMokNxnfwtoTAUcSew1EHYjf9TRD09fbnZA=", "KqGcFFSKT87hcMAZbTY+iGUGS/yYIiXVlGx+v/eUWXk=", "LmorAjrHZudIW9g8uroBahMMAKcxE0v2ZpLNXXRgYW0=", "BOEyEwl8skoqizgZAZoLZ2vLyB0v9Jr02ox8sM6NUSU=", "BDbbiLT2beOEuupzxQW4ccecI1JgD1hZsw4hjwcyatg=", "AMl+lWiO4H/6eQVngW4x1qt7sObo+dPpzQmpsbFqkJQ=", "LwTIxyyKABgK5tDCny36vYPQ1mDr615688YCTT5Xd0c=", "FQcM3Zm5tc3AaUaFvbBkicVvLJmWHhrplmCFFs/Qh5E=", "E0444YwfQrhXuiFL51zktdMxVboQ+YNOlfOpbiXi9w4=", "FxFikFPVAhuvoRGsIKyFFhzeyFT8FwoGS+dFRxq13u4=", "DQcuHI/xchOyeEhVekJnAarYvzUBxqVe8B3UshrPAX4=", "DWy6gYzJsPTiMjoHOGnE1LTl3ZX9BGEP/ieplof6mKA=", "G7fscgEHBltddfxFObO5GvDZXuwLUc4G9q47QPEKVN4=", "D0sZivKq5MHxUDWv+90wZHrQSGHePmU6dn76UDa8WaU=", "Jr1dTmoV7W4q1Mr4d2Ko4lMxWMaJ7S5rFPU39/ivSJE=", "Hbdiw+GLxsANroEk6xOSE1epzbKn2NWviZzlyKME70s=", "JCHy54gpR+BotZBJPfRT3SKjrEH5qB4Ej9XIARn/Ytg=", "C9nXFpfWyS43aFBJO6aHKD6Eg7UppXvWuPMkCUcxDNw=", "Jk5RDlp+tY/jfIkRlOcihzfiwKwv2efsQW6Eu0SDUCU=", "Gijv4V5bprwu5gLqhYgp1UsatxVM+Uu5SBcf8JLwhKU=", "FKIGZC+ppsvnjWmU1Ecq7C1m6b3P7KTPwTOFVmKgrhU=", "KRlfb16ylgXrtRNIrbcrhuGE1a8qVZeehdjDfV+jd8M=", "K+y9GqL8HWoMuHp0MroYBw1NjYfHxQhcxXo2hyzc9JY=", "LrMRx9lq8bu+7cgR3NDPOw86C5MtqrgFgO8Z8uyk3H4=", "BrE7Dsae/sDdqA3eBaIpguRQ2ktxnq3ALo5vCuipyL4=", "KVFWlYbEUuV6Ft7/7WZDuQcyergw+kPHYWxrvXszf6U=", "D4CRPWqY1o59IDFJCDQhWYeQvRf7caujvmgjXaMfrpo=", "D2xuvBUscUI1XzZQVhCMonUqk5ND9S1M+qGtD56oBic=", "JlGjVF1VoXm5XB1eyfR5AJTM7+mRtDSC06zMGl5rxBs=", "Gf/taXvpkL0iwzoxUvG2HZJKiPJaaCpgSBSrD4P92mQ=", "BRT1ERKyEx/3RGvcjmA1+KFWMwQeMcrM2uV6LPLm4w8=", "J7JQ7t6hJ4ew50xn/SnuPW8xAyBLDsFTveGzEK2KuWA=", "A047CSru7Pn8vgEiUAcbfYb1Dd/Gi1v1nlfF+Txx4ck=", "FFOqvUqzCc4R3wYLNpBvIh407EV/PhGG4eozab5Lkjo=", "EWgLGcD2IsOuzjcBPZ2cawlNy150wI4i8XD9p0TuF8Y=", "JRIbpKCt6ai03avcM3sJZF7mxCw/u2wwug+0V7yjPZk=", "MBDB0lzOZPbdNjVYkc+mgdxuLu1trrNo9meMy0Gwg1A=", "HVDJfi/IUBcEDMGS0ZnOlsrPpUGJttZq9ddZ/La9p54=", "Fc3LscUxcZIoHfYCZwCKnOjbhm/vPs3MzDz60p56sqo=", "C66GKS0AS2HeqR2rWt3s2EUuTcD2ZMxgDSy2ljt9+Hw=", "CWbgrntuUv0YGFJmxEmsoTnXYEg2FZLThjKiDI0CRvc=", "HK6S/ob5p++DugQZomHcg6oSoSZWJQv2zbkpCahRCGc=", "AKLLg6BUmIzuGnqEfCKMgAZobqYqbxPdlTXbokj8vUc=", "FBfQt0n9oFvIo29B8/cUAl8uSs8C9vYWBxS7TYbYp8Q=", "BSxacHI0QhNONTKAblfSg6FCBG0qgykdp5LPpUsjR4I=", "IqjJ098lkFx7+ZwGl+E5iCYJwIJ2oXHIjcAuhdtJrs0=", "HDiCYeB2oGQ9VHkYfLbtJDG14fUx+RzbUSe6+JyDxzw=", "CrJiwyFdkCY/AtnPGiNQ2dWrARShrHgmRg80Y1pVx7E=", "IaqGXNAkzQIQTaF2IVREGI+ZKuybU7ZbnP9jkLKKwsw=", "CwSOBa76D7LBkuxVaQ0W6mqWnSR1diudIf3/itpKC84=", "HPtmT6xIsBNy+G8QeGA5jAE8I2HcVnG5jxOFXBVzKuY=", "HGOXjYKYSo9bEF1ZfWWkN8gpj7QHTuFAYi6cvfOctHk=", "Bocn3ex4Ki0MAgKPyjdX+oXmHzOvz1zTWYZzIhZQnHc=", "DYkFgswhU0DTR2tQvY0iJh28tj7nxs4ZpBHoCbcxpWM=", "GEzY5n0zRrCx7VEyJd9PiBHyKyUhmsbK3Ai9J0RMWfU=", "Ea7c1JD8dwr0UbtUppjdvUo84mZxXqhbmQ8BAnkQAA8=", "KW2m5eMsIK7caadD9qReS7jV9mBIl7HMdRvEJqzg3oM=", "C6V2lw2jksVEdxWKvSWWi2A4cVjKz18IKIlU4REz+Ls=", "GX6dUSnXE+OCrlzmZs0SdviN2q591Q2/qwcBm8Ql9t8=", "KYUpIwyO/KEm8uXxJ+tXfB+N/eT2Ey5hsmkzcmzXFi4=", "CX7DLh4QywGfpbqHp44xtPVjh98tzyEGOcnZYj77UEE=", "Cmlq0ZmmHf+lIQ9aZ+95eVGyWWDv3ROuR3hSmT2XQ/s=", "IOaRECRoYVZSA/Kz/v/+aGZ4k82IG70K27BzBr3fTtY=", "J4kPMiv9D6vJaCv2BiDR/AQ0R1OU7BINdwiAQ1E6ELA=", "Gd9ht7jb6BUsV6jZUkYJrV/Fi5XZ3Lxqrg/lDlo/BnE=", "HxWaAJLo4TdT2aRwgsz9TpziM4j6f0jQNB4YS+7U32k=", "A++K+zbdur3O+ptD0eVVfokVlXblTHsaF3/qWgk7v8s=", "HM3/o6j5GM0zi4UUawV/h/hhajIVmEL1V0TM7Y+0Y7A=", "EMbOWAdwtJHgTPIiIc7OXscQ+dxwSKmAY/vKmw6e46E=", "FVFUNExEu65IiCq2geHkAvcmWFimpJmST5YeQkHX6hw=", "Fo8o0oonl5Ree057WF3KsZKx/Ac/aw5ir6jMkWF0jAo=", "JdmcCAqDbs8Kp+EpmnV898XQqWtYElR5abPwkHPTOm0=", "CVWtGrEHTbEoDHh1PqQ0OtBe7kLQuvvzISxlbDBexV8=", "CNRm1kuJSeS9F1OS5CGZIpc+r8v72WXLJFXtPyGG8zw=", "E0mSNCZ0lDO34AFOgns1QMA8OnMj56JaT4q/wU1JK2g=", "FXkrvipvhBR/AI+EtZG1g+ZGXLYjjvVAGJ9eaUEt2ck=", "BhpoW07QW2WEOkHCSyNqKnty/9BgIDC2O3g8HiOSMJY=", "Jdfw3D4KnnEJDHK0iwUbjY++2jk9lb2OnPvqoZ7+tkI=", "IwHAwxnP1VILx/lytmRmYRNbKsbNgrDo+/fIFKnzivg=", "LWmS8t97VryfoU5l0AcHY9+lxtcL8v2I5CitHfc/tSM=", "AeZiGpjGXvfr6ydfaW0REQ2DyoAxAUV2uqEOz9hBECQ=", "BpDljtokZleZoqFWaYbwWzw0I0CihVrnRqmqbX0L4ug=", "KCkkrSq0MdUNR5wtQ5QLRxNShQ8y/Ht1ZHpTcYnpgec=", "A5g6/t5I+BB9PEPY7yAFAHHmk+FPdYNefOOq/PIJnXI=", "LT4s890XQF+qnKvaxVnKtcS4jAU8z4iBYacC2dCDFNc=", "CkEYyxHjWvCcgKditmXP2RX7nMEFpkOYWejQnGquOzI=", "H08qy/eGigmcDPMOz88lQhDAqbbdlSCQAn9lrth8JwE=", "EnRWyc9LBMZOoygPGLSrnhuWQHYnBMk0PFyTyibb/i8=", "IvYGGHrekdzTj5zH/7zVF1NxPUMcMvJrtQ8aBo2Stw4=", "IxzGLyX2Fp1XCXY4UTJyTNWq/aNPlV8vtVeMjrb60uk=", "D8l9DmX3rqs5fK/DaWar3qkiFX1n3M3q0bIxXR8AjLI=", "KgfMQ0PqGziYKCC8nz2N8BS9K+WLn51VaqG3VRHMi3o=", "IFYSy8El0AtKJtWix0jLe2f3905cGjr5nStTsh+QRSc=", "ETuU+guzenziDnR2lOGcThl68/6wPiflXOG22ox/gVE=", "E19XyIiQsQkWSx8Zk0sOMHcAGqPDmbRsvks9RVhK7LY=", "Ev7FI6d74HWsDEeGLysYzF5fXKodvvPZB8kmJSUuJwI=", "JPhkvjXvYFfeB4qF0elqa21l9fdgQv5GyKAoAWyZFj4=", "ADKiiNJwGFvBZ7vCG/Q71pVXjPxNrE9ZrSat/wO0HfM=", "ASp6Iptt4ynPQNYd4VEY1gULmyNdYHRWXJOTjPm15WQ=", "BYtjZF45Y769tutjkQbE4WwP3vK+gmPiO4YD/iAEJBo=", "GaWvDCsAsdoHudS1Nbu73fBS/dCQM1QWg/xU+nzs380=", "CiUS//lOvQBXHQVnBNXNSj2LAkw26y8poD0KamnUcvo=", "F3df5y0XhavhG3Y3m9s1QciN/Wu+yjfSweas8ooA5aU=", "FEd3NRMgsTaXkX27ocJSMV/4X8ueXBD2QsQfkGyMLLQ=", "DM6HCI02nqJc8gMV23MjmzHfiXkVtws4AJ0IMRHt77Y=", "HINgQxj3jBh6gMeLji72a0iIKgkTgFg/PBSleXw+v70=", "GVsQURAu1pPiYob670B0afDCM+po+3S+W4uAHfT+OXI=", "JFT1O6T/HAmyplDN/MMnNRBcAxFrJUwgvYoZYoXPbuM=", "AtD+FUqFW9aD1GdsNgd3TFBa4zsGVkJeLdIaYQRcSqk=", "Gpwapl0F6QdjI3toalny1zisHuv0M5k+JzdrzcbaOY8=", "A4DG/+w12RsmgFLoV1By2lELX6l2QAIhET3wrcIoPgo=", "L0g1t8iTjm49Wo2FPNpeJMh5peDnp5tjqK+OPAI1l2k=", "EngRHbuqRquUR5SFaD5HPv30W+JJCDw/ZXYtre212rc=", "L20OIFkWkZzXxTgauSY+m/2XWqfPpFzp60tnmf+QNTg=", "CYe3lWHQ0kxfzWxr8RibE/E6oKr++5imwRMF5waPmhU=", "IKH5TqOdlnS+sOI3t02ScGuPG+/1j0IP6xoGKZOOpEo=", "BGYklE9nKBpggtMOMaLXgiXeoAv6Vf8uvWtLaku8+g0=", "Dsht9OJAS01MXBx/K3z0/8riuq7JbxyTtXGMRuMvS14=", "F6mIti80MxvCPFxm/lVV3Cr2gPkXXE6VJp/yZWQafCg=", "L5M6QAnDhAbBA4dM3pHsAtYiBnx8rFaJBAPHRAih78M=", "KcYKbufiLAuNilHPhyFdTj3VLCPIxROoyFwhIFra9OI=", "Hi483XEsasA5rrPU3KTpLeUSShqSiTqPG4tt0X3QINU=", "HMDPG1pne7Vq+pKNcITJ4x1PVGkam5Ci9IIg+yb7U04=", "A/X1PLNMpbZHb2HUtMwB4dEjuQ3/mOBEfIAQB+ZASGU=", "Jk9SNAegdrBPcuJoNM6L1FuMkNxKkV+lUfOuVtUNtQM=", "F5Axl0X3kyr8gm+MKW+SssD39rPP20v9x2PQofKPNws=", "AwmacqnDU7MpobxLqrt4RQHJA3unNsSYBvHaSCkQQbU=", "FgSqpBvOBy9Etq28wHV1QuTKq8rxCer3r3GOussJD+U=", "EO61mhb6E5Jn48Rc7wG1POfcqPiAjMwkj9tXKKeZ22c=", "Euq4z/zAbO+NESu+Xfun51U09kxEYdFi/LO6BnFZR+U=", "DFjgRlPYi7px6fU5tQMLk32tJAXSJaMLWnXaiuGcI7A=", "GxV/LtdAzb95ivCSquWDO/UuORsROYXKajDu1YjLpPk=", "DQg30JfO4AIDRdA402Vt4U7kwoM7uc0Noa/yOZ2kNuY=", "CkIlpdNn4M54oSVcmmmqYm7SIkh2PRkO2d0PPTWTQVQ=", "H2ooGaZ+IBoldvCv/LCUlu1/7KC4UFhBHQmm51b/6OQ=", "HGdKm5/bSfyWbgZLo9oywawtS2obTQa5b3XjFgXDjLM=", "IIRM1Heikh6OyybuwjHYxtm4RtupPbXv8iAKzOPcUxI=", "Co+mtlaseXvnl/QuKUs6xNnqfT1SEluf13+NRMtymGQ=", "JllH/gh3xz4MZa9U9kOw84RKS3TecJ/fdxVvTDOMgAc=", "HwTkZj8vmTfPB9PC/l8G6FQUuWDcd6GejW44xbztfUg=", "BtAg8D2d2RjJhfHn1c05+tY/ZFkFX4XhuNZcJXrWQEY=", "D0+4JjvIExkMRMOD1Uh0GyRNIT30NEw9y855eWmHOVE=", "Djseat+gVFCvunz76Oigi7/2u+wJnGjVdV8JYHXCECU=", "Ivt8AAQuXkuktRLvuQAiS8a81TyxIk88zNQlMx/W+DE=", "GTdd2Qnl7CbnJ0v7i0AsXVjKGTF1Bb1EaugN2lU6xx0=", "EdCVJGHtudJMa7CK/TaWkhc6ct7Ch/axk1PDu1QN004=", "HaCHKs87Ne2gmczJ6aX/JHeIm/oSK1vFS0vgXomHAqg=", "GnSjst6aFsFMAmucURFSzBF0C5udmba++fRMv3V7c3Y=", "Ihs0W6S0ncuq1J/lGRfZKMUzzeu0SwlQgAZKk+bO7MM=", "DeUp7zJAQRb8DdYEHIqdP3mAljFDw+J18p7GOGycK9s=", "HfA0F+cLyKWBKac/K/7UdfWc9pQLpIdXyGDk1a/pErw=", "AaamxeQd18oWIxKTX/pMqm4WgXabECkfpl+8NixX98Q=", "Jr5KuFXvosOVoLrVEzjiQoOIOXPQ3+sthYS7OUH3uS0=", "AfHH0ieYblqaMpusGaI/x99SYJNg02bgr85ZE6gJ+TI=", "B1hSrghQEaNCDu9vxNUciBDUD1fOTFRWngNJvd5k8l8=", "LmnKFVHkipMAkxmu9A/M14uKsOs+anWqOnzcLqlRDhg=", "IdHYGD5UMK6xvnc2IFBLqZTB307VUKh1Bf1oibvHCUA=", "EYZti7uM+P5YXeGdgW9EQJew1euIBxwnhaw6dX6lqXM=", "GOs/0PZ5OgG05KNQUFVaef1Dx9mzBfQum2du14VQhv4=", "KHThYpNYUOsrHnqZhH2+SLOXJr91oYqZiSsrttuxQa4=", "BDFk5cDWGK91H5RYrWEHzCwYtOJJaGFNqpCfOmZPyJg=", "HH+tdUdteWYxTaqSbhiKwDO8PA6ddU23R2WdmEUoXxU=", "AByvpgmGZFlpBzrYwOKdjUbEkRszNr0Vo4leENCjk3g=", "BZs5qEvqqzvRbmSRFNUHrKi0l0DdvEx+cJryUfflwAI=", "LvftFHVdQ+cepuum1HjkGXxTaMydf/fEJ+PJetzq+qU=", "B+Ji9DlHw+Q4C+1ZibNTaPbuEBhekR4pkYRXMN8qzXg=", "D1TvgNlmSHbnuenPjOMAuf2CkpJ0+O9LpQMJZ1IINRc=", "F7GaDNdZfAuVqdGx86o4/t4FZeNOuu58mVdpb5Kj+uM=", "I3JNsHj9QQ9JTlOBiGooSGGP/UqMCI/VETOwvnhEF9s=", "CH9gKRWc93zyKMnPE30l+k2EKghP6kL82y0KFtxMs6k=", "LJG0NuIiA/XN87HCGIYmAHMSt+gP/CxwJk/wZWDz9S0=", "CLl5PPI/tbDuvSZH0rx9TMkB1wdHFbRFsU+2SlXkO84=", "IUFD+EIRdK1w00Me/p1AvtNhggYz4nuRzwUFqJULO+0=", "HVuIVgUXF2ckqFMl9ieevZEwov+ijNALByhv46mCIU0=", "FMlXfAY9TfqryO7XwyuZoYcCjYZuK5kZdObmOw+Dj6Q=", "BGJzN1v0Nb7d5ZDLK6yI7+6Jra6MbiewH3eSSTB0uzQ=", "H9ifBjImmQOHsBfr6YX1XU9rHlulor/W8ic9LWu2qBs=", "BQIIHzsSUFVa71h8tbSzB9cwwbzRUa3sqlMwL8Lue/0=", "ELqmwxjH5qOjYodWrULspmqSvlH0des4b5bAJncuHLU=", "Ad/kUB6LLvQYThpNDwycx2qJSXZmNjCLAsZqyYI+3GU=", "GnLTIPrq8F4M9E25ML29ju0loJvBR1RmXn+18o6j/L0=", "JmszNAqL9mE255mbpHNFW9kPiqU/RVNDM57VtTILBpE=", "AkSOUuBpxrREAtWVc4IsO1cDCQIW1gfeS/tnjhNXuVg=", "KqJeRZBlUytlqyeAtjz28D2HLqdZZke/lResYot5oiY=", "ALHVTniYtjo62v7m46NrKquB45vzoVqbH0ebdJmy79c=", "JG9/fY5e6AAi1FNIpa7bqGEsPPRiOmJg3ckxlSUSxM8=", "AnkHrTafxLg3LHjmqznUo/qkRVHwC4PSSp4z4B3we6A=", "K2e9J3vcTAjHkIuxWtOXJW78YuAyUyf4GQx62bCepeg=", "CKXpSNHbFF4gvwq/1BnnBwiyAX6PixFwRZwsdnp+41Q=", "BJHJOBE4G78IDN3aIDV7vQF1XVDrhprFDr+3dbSVmf0=", "C75YEMM5UF8ZFlnFH+6sTW3YvIOW8wweSz2JiEA1lGw=", "A7BlvSkeKIoXfxYeNcNlLFfvcORuF0LvdQzmPSKySBA=", "EfJbhduEH/dkj/DjWsC2xGPHFPsrxfKIlwYIqzU6au0=", "LxT3USMhDPadOPLzK4M8rgqjEOdjSGEm0NNsKeaAFK4=", "JnF58fBQqiTRd340ipnazkWq2/FkINgo6R99i6XWtqs=", "AtdgqczZWPcj4ILIBN/CkGhgdnzDq6iLNdR9lVUaEoM=", "BCVAEz/CVIdpZ9JznxAUk0aVdh2kZH0zCxgHKNnbl8E=", "ANT81YYTUyaXXhIFfN4ZMkTK0VBMThRxFWEMOv+wZVc=", "J6I1L4xfiPZD1t6nJRsCfNOqBDZPrmDj5xT2hNBaiWY=", "HH6VXH3qPeFEmeGwDGRRKx0N9gPFSS8ddXRxYcIRLs8=", "BQ57y/2fqcHE0pQVsDwNAKUcK8zvWxxEHYMB/cczWVY=", "Grtqjq3vCUBwTWEVA8nylXFcPE6+Ajq8YIqP83BEE8s=", "BlYgORSZX3j0odXyVGOH736LUUl/V5ZSGZm/Dg0egKQ=", "Gippx2c/ByrrLsxedQyBvQr1ZcccvQ0zZ++nd56t7LU=", "FZliK1sLdfxmzNnvIOxVm78/UaSkrOhW2PaH9oRciSY=", "DrVN/CNxB0avEC3EF6NkX1sbh9iIv421yM+0tF6wOiI=", "GeGm+R6X3rGt8NJcuqsJofcgBu6So261nzLPME2ImGQ=", "IBCBUpQTpvH0nz1S3N38dKzxRsazL4W+s1FJR5yJHUo=", "IMOTWE4oV/V8I+/reCAYalBEDJNb00pKF/Klu/8ofxs=", "F5zwRhyYqZ9wxDP3T2D7pQ58L8m/2+UAoKUS9r6TaTQ=", "E4y3bTeA1ClCv+AEPWJb3U1ukcg75M7D2ghb8lDBjYE=", "DnBESvAZOcYqjKX/Pdzkbimx5FrGqrfTcpfezyBj/c4=", "FCsQ9YIEvvTLFRExNv7leVE8EmoWhIjDdsIa22KCeWE=", "EkyMYHYStfvSr4SsN77hA+7hGk63EeEfrncA68Y4f7A=", "FD/ecN1r3osmoIWc2lEtr1V8RS+l92tUJCa5+8lPdEY=", "JGlN5ToTmmQ17PcWtBOevQHLQDotOG1Y7HM3NswhaSw=", "FoYYRmIR8F6IobdxrIlZ/OOmNSy2R9RzRgFLxIb5wPI=", "G5vnEFJmJF5wekbiuj3oMi1KjnvcpDRIqwWnJ1505D4=", "D8LI4fVOFmBJ1f839rX615rnbX8Gn5j4/PjzZ8D7O4g=", "DG9YMyMGQM6OcK9NymdIIc7nIGkL00nmRfDY9ZaErEg=", "JFYOSvSf8IoiJqfwleRIkFGcm5l2rvo1FMCwZaBS40A=", "DWHwYXYmhCMcX0ae4Kwz9B0xSt1qedVTxkLc7jY+oEc=", "Gt+lf07EQ+SX3jBG9k0Ymnzb4IbZjJTLHQA6WSZdQN4=", "CfwiiFqwGXW6mqTIaSoE115Qlx99y3c4YpUFUyJyZRo=", "HAG/j4XIvMA1zOkprq4g5byV4dNhYOKG9aNzAyy7Sfg=", "LfvMSNckGmZ0gDqmQlO8syENs3ry6cA2xHl4yYQq56k=", "J7lF1DmNt8aNE1dqiSiqyZrKiKGAsxvphbhfqJ0KvUk=", "J3VyvwspAQY4DEv1iVnaIX+eaJlA2dsP2+ecGhVKf4k=", "CDHRuIr4VhwO7mlkvXIMN30ENh+a9lztfwMp5963FaE=", "EZRZyjOeXIobNlk6igkbvp3nyGGf+DqNMqVmwrFTNqQ=", "J+hIm8jO1qnyCb/oP25mT9JVOuhGMqjd6Fd0+GpxT5Q=", "EPtsj6trE116UMVPix+1dOsFQsBbm9hKr0rokyjW9T0=", "Ha04ZIFmZso6XR/LDf8HvxLTUvCKrdHUoUufqbKsBXo=", "JDmv0lQqnFZLhfpo/sb5/UjVTDmM3+FO7LftfZ4JZC8=", "K+pAWHlNi9clcF5lCHXaIVO4KdwkWXAIJ3CgNUZjak0=", "KScS7NCNNJvAP+YQ7CoOfZuDg+PfPBOvflc2W0jZhdw=", "JBwfdyGdF41NYfUIOKabbXApyhs20+s0igsaC2TENTA=", "IZGReNDKmHTJD4dUB+bedC/WR6dnlomXLPAsKGPbbgA=", "MD15bVKGfplCIa9RshIP84Is2KBjfJCW7+Lpqj0se1M=", "Hw8wJDIS60vsa/not5SYmrrdrxNX99gbefInMU6aqEM=", "DBJYGu2WOhaf8cM3Fsi6/GvpqLbbE6JYiSGCI/hQ3no=", "EUWd38D1krJkJpcGUBwEznvZmFR5eSU+zcvMqj9UAHw=", "Dys3FGoKBKxT57Ywhx2yUqHdhDMajTnqApYfk4te+ho=", "Ie/K5ll5Bna12RFLgdYEkOtVHWsh9l82Lwggjq++TT0=", "HhtWxvduPMJihLBKQrWgLFudubhCJyEAJF2758h2GE0=", "EIe+TQxHvPIKgV9gzoA9X7khbx0LR0p4HIXo7RR47KY=", "IMeiwQHjQnD8GLTwXSsvWloSmKJZLb8/m2mOSnkdkxE=", "LUiG8gC5nFf08JwMNi/TU1rpBqEc8BHiYfr0hzSjsH4=", "LebaFVG18dF43k3YidA67uRkAk/Ck2CXIVwF7hSST1w=", "ANkDSL10XlzXeaamtcS2JeG4ZVnXHFWhO0qSq6IYeqQ=", "FBwwhARNK8/pWU2mv4F1uVCrNrRDOn5huBW2EBpbtwM=", "BnwyQXmePIlALRBIujADAoO1B1U6BsprN6OHIABBLig=", "FI85/TWla8fSC6HIki5K1cIVZg2tjURrD1l+3EKh/gc=", "HdH9YIvkdk7h3OBQZ4md5T//xrAPvkdaLgIipjxoxU8=", "FbsPht0KN4ArEVqB1OP2j5odP+WJ5YSLu8X1pdd77vQ=", "JkL99d8fr3qmovN7M6Zl8WOn33DIatqth9+rBkk+xys=", "JccmuyChugjHOAjgD4Kb0/2VOB54yIux0/NH3H3FQ6o=", "HKWAjD1otRr8WG7UT0QYmk9NDlbLSWzRD13jaJZrhns=", "HNquoXoteDhaVumYSWN+3X512FVr/Y8kGhH9kDr0+oc=", "JVsG1IUj+X0tML3K6TzpgDJWoHI+wWG5h87wYod5SK8=", "HLP/IPdDqEXENf0+LRDpMS9h2kE3Q8SnnmerbDLbr8Y=", "BHoyI4Uyp6c03auxUCS4oVRFX8JIHTHDVI0eclSIZR4=", "CZWyEBMZEPAd+Jdq50LpXgpatJCkq+sw/ONI5U3MTng=", "G/Fu5TDJyUpAjy/9Sazn3eY1CZvP3cHuQd7x2Gra3Jg=", "ExB6XqKjQGrNtlY6Xj8ICaHGt+qaBJKFMyZidfpvUh8=", "LVYswGUAKN9uMMB72+wH9z7r52ahktEwpsc3/Jzj2zk=", "Lv0SteT6EC+9YL7cEgsdwCL4xDovzoZCiTaY31PCNSk=", "EQCYyRa1IyEeGLmF+PzH6KgEvLx2K/62wlyBDO1VIWI=", "IKnVIWyqwX21q0X8trRd/s1gpwgpH1yGq4TaIspZatM=", "BIyCVAkJTQViWd08p+FaCFlL6C9IjWb5G0OvZg3POLY=", "GYRHn/ymtko7lQNydHwbkmrDan3U9w5H4Yi/e0EN7SA=", "IJzsfuN9R6ilb4SEuU9dsgU1tVLBHV/azIAwX9glyPg=", "LammkrCJFbe2GTDwEfdrCb637c/WoZxIzedC6ZzUkwg=", "MC9Q7OSvoX1VI3Ck4Swlo7AVGkPjmC715xo4x0w271k=", "G0bggedWxCx4MVP3OmQFT/SYUHO5pzIVOrackpRwKD4=", "FRA+OYjQuvYmv53lTXWwMBotOSfGXXC3I5GwYt98tPQ=", "FWTnAGLtbDs/8nLeqA/z3FfKHeaIsd5IHnwHJjdq7tI=", "HlRfOIueBaRt7lFgyHBtqAz4B8bBAmDIXOBKw9Qe/F4=", "CIzUB/Blf8i26Kzz7isEc+UOcr9Y9U6pHspA34AXPcY=", "CLjkL6HEEERn1nx6PjhKPABD4cHVN9Br7tmX4LUqvMU=", "FPGz+ecgMbp04uAygE2nho03vexlx7TDMTPc4rGZCEY=", "FhnA7MoULtFC+Iov4LA4EiCxDT/1wg+2ema62r7vAYo=", "EPYgqGLH7JhsPufpLuQxyqTo0xgr7yIXXSlUJ5bJmSU=", "Ly9z85U69uzqhvXvKQdfxOAb3Ag8A/5u+JhCy4H1eTY=", "EkrpP9sbMnVANhlkKFGcg1DmmcEK54O47+wE9tDk1A8=", "I7uo/ZwdiIzJ8yaPxU7v314Y1gtB9XlBF8gA6pVk9Xk=", "HaJI9NkOAFa2g+Kokodv3Y7+R0+1EfRpVa0xRTQeDTM=", "L9gjRRHlSWbQDz6kpl388KaqB9CTI/mUM5tDvNmO5nA=", "HPg0UNI8X9ZOpe1gA+1lA3N9/iSe+/8tBfbMKFtK278=", "BzAChwO2OID6R6oLlIoqlWWQ+dLeAiKYwDUGNlht17A=", "Ku45pRZpwUdjCU+4xC1kkGSYX/HhddiCj04CUukIEQ0=", "I2pI/sf0hx4qD8YwW07TUWm5QvnoApc03JpfRQsKQLw=", "JpF9dNtxZYAOuwuwWv2M3Hm0cMHVSl6x3trYdKSness=", "IXJ5ydmtVov94ZlSJ26KdXAhmFssbBln3NjDpBmKOKo=", "H4SiZgL4OXCjiv36M150DiS4+5dN2diwMZx89tNJHhI=", "FCn8mlOmk38VFWIoMybZ+ZVKKtgkKF5WO2fSg45dwmU=", "JTJk5bRyWZOAf3mdawZtOFAjLs0Q27wB6aDVL4G7t6M=", "Hxk94FDh5vxVk544yGkD6gMlK0iRINCnTuKqIDtYfyM=", "Cxeen881mEAM6YgnhCH3pettWtw2kX+lFklTc5a9+Zo=", "DdPP0udKxkQ/EInEwIhKiQgBxgjBpTtQPrphU4GfkBY=", "EeT0PnPBjfUGaD2JpRG0k/r7xP7hTDSoND6wPRwZeM4=", "B+lhP1z2VRqX7NzCTYgQ43jJtUK7WdeUYaTCVJNXHuw=", "CPJQqrryt7tYoJxs2VjhPAuGyAbDPmD0zfBnic0CQcM=", "EHanhV87fR7NW9x8CGA5HFeuHq01COqZTDFTDinFokI=", "G1dga/1xq447LqnNMqeFadAOioNrii+U4WUUkAWiIEs=", "FqD+yOK9dVWWOW8dHPt5IQeWuFvTve2CvMK45tSmHF8=", "L6k5t4/TWJFguwmzWu3d60PBDdQMKsZHFZjErRNoiaw=", "L+xKp1Vj97jONprC0jlIan4uWTxMv3R0/CDlFUIn2R4=", "DhFY5jybffMtfD8yqX6OQVND9Uxil34o9r4wFBjYw94=", "DhGJPDLmO0KnS+2B3XHmNIqby1W/WDUzVYC+Hqqy/uQ=", "D8BwG5Q1swW2EMf+DGZ7M957vTMMqUDXHVzNtzMkUtA=", "D+5KpwqXWApzldZ6N/VTMLkIRw+4A/0ATUNK5mR2X8Q=", "FGdC9FMfpJxISAQGSYxlQWANKjA92NrJcbe5IHFO4TE=", "JvFF3FKDQMuTNcu2+x5w0MhxhJ50def5wIkLkH+fa9c=", "DjB6PSC9FjgeLLnQuAIEbz0zAmU18bK3wDqwdbaBz7k=", "A3UY46D9R8mh4zqRjDD+n9zk3QTcDpOBYtLDpUE5Tlw=", "BSDE9r3DdbqO9eT01V7nOUk4aoE8YHGNsIyj6KrmgLc=", "Gl7gkbdNzHw5YlkNMEJIa7Q5kQdgDF9mZLFFt+uMmi8=", "GYYlZCQIT7eXUpz6tAOyy/C2Ym1JMKvOF7GmTa4DYxQ=", "A4Z8cdPPqAOatkB6tGBTq0t0BSdvSD3JgxkEe5UaFW4=", "BtVjBQ9Ql3dORWQFuMQNH2W4oKneFOKwUgOXAL26I/s=", "EHZ+Vogr5ICTKKWNdHxtP/hd5lE9UNCcLjN9IusRwgs=", "EBcXZnT5PUggfiOWdNme45ts2JPr+5A6KkHyj/C1YzI=", "DufmzjWSVCR5MvTgPTETwuom5RqDMT5MFknM4iNms88=", "Jv+CxlvkN0/M11syOFNN+lRMsEIouLF/3mi/VKeR1j0=", "B+iKb85gHEjVzS7FlF4kCA+4QMWsdQhBRtS6Gmpv1hc=", "EpuMaehRi9FmNqsPGj1+Oa2iil3nnqX7oban0TVQuF0=", "DXlPCGvE5F7qYzfNHmU5EEnVw9P+6JRwMsQAaa7v9oo=", "JiK0+o+wciZTK3eekE7qRPb5CUiM9RYFa9gdr8/WCgc=", "JWMMjRBGk+el/kGuZds1/T9MY/j1HvnQlI6iWV8ViiY=", "KQI/xPM8kCjN+jAFADN/Zo3ipUOEemGbam3PfGRxG1o=", "LAVnLpp2PqIJuqD3wx7Fbrq7NMRbJLcJfIQbs8vatG0=", "H1AcAMG6iq7Rc1JL4vKyF9a2ugCsJi7lj/YiAWe6IB8=", "GboIWzZ5WlXb8EDlTDVucDIbgfrim+DXHXd9ScT0u40=", "GbUdL+eIMUJw4U0bwkjAkNqGBaQPdVkhb7hkgv5pAi0=", "E1Vl/dbT5lEZHX7RqwEEM3gvmwekHb4UYpurcTwiljU=", "IkYe17pEWWvzp0Atyu1cJHsJg1xTSoGrNlFI4Uj9Eyc=", "DgnDmTVlB3OXWkEbwJNxjax36NeHdmaoWsPaFYBc34o=", "CEq4UxRAKgtozTAh4a5nkLJ2hsaw/y5JSKrk7my1B34=", "FDtd6DgUgUvBVTvH7JvEdWu9250xhDqdr7wpNvyMv2k=", "Kpuc4m8LhyG+BtqF7hR0cnWAsCN82wgTW67uYQpGBSI=", "Cqs+py9D0AZLd2pHRupuKxibfgb+jUnr9FLKRiejh9c=", "Flb/owwDesRXO4oHJoiNmSKK2DJFSr78pZjCMYo+xlM=", "AUoqoqWYsuI3DRQhDatcXrdYsMkXjOt/8/poHaXJvN0=", "FTyT3iTgHAfM11I25OySm276DalsaHtdwSX2gYUFZ+s=", "FBcHvcdpg5jln0rQTsRPq4t/T3sgCW94Ag6Uh3ipD1U=", "AhOBJZ2c0YqDfcNPuVAXo/Mnhb2RzJGFidrkISr3uXk=", "HV0QwTIisXFteh3vazhNcnlIsP3rGecjsr+hKS2XVH8=", "E2/57bnAVozVhbJZqqVizj4kswpsRmCswLUpDTCg2oA=", "Lzq0QYuwy3uFlnW5/86MSI8WzdjOpEwU3gQy5uKIFGQ=", "LwNyfQiUp03JfmDL/nTHxzEbBdAgyoeHGNv1YduL6jk=", "BN34i+uRamYo5gp9qYF4HfsKXhB2KFskNX8ikSj+Ja0=", "CBhRnqK3H77Gxr//h8l4r0Qn57zFdt+lwVvE/J/tJjs=", "EVTRqjRFhcTs+e6TkMhGaNzpkjHA9CfoYprJBSNOnrU=", "AwQpjGteIUSumlCM1Mn0yBYMN6+kd7OCmv1J1qSfywA=", "E2UKWNyp/a6AbnZFTJSiGYvtJN821pSnpTMUdUitAjQ=", "B8zxnIuHFLGNKApMDKDozGjiF1FtHFTbb/c1gr9NMmM=", "GyhHbjTfFGtPnVMLb1nNA6vigb4psyRqUP7e1kcIPTI=", "HFg0emT9W+YtR4yp2P44Or6z+jDYdr1QJezwcBJXtz8=", "HMkALUEZWWr/l0MQ2lvGJyGRUJJQQSam/ztoQ4P56q4=", "E9md50i0/tRHa7LW6aTscriwSISH1lgiiVpSZ7NaV3I=", "IaeAq7Lvr85h9NZ9p7i9+sSUg56MOE8JBgWpTns5bag=", "DZ3Ii/OGH3Bbmq8fgt+dU4cKDT+N5P2LjJZc2vZXGIY=", "B4868tE+v4VehAqMhYo/LxQxauUgqxL+YTgcDS1KBGk=", "Bi9bV3gEpCP/Okc5Usr38FLyLItDjwDDKsiI0AyZcTs=", "JajDPXrbfd1qGd2DB6k12RSPLpYkdfJB7WcFG+w4vHs=", "BDFlKwPJQzOg7XbDbxlo1Qmsc7iRDfQHsDQ7ndA/tWw=", "IhI605kQhio6JTlzKePcFJtQKJ+QleciSoHV8tOZh8A=", "K0MzR0P8OMG9zHzH02zkQas74BZ03kSbFTSadcuTez8=", "LQoLyS4QnF/XCvvbhxvOwXimn9HiRBleLdrq71yhDdA=", "KZ21+eSfSs63YKSqw2q8N69y5QmtbSH2rxomfS/vxrM=", "DIE/beCBvyWAhlbViBGoi469X9pbE2WlT3k6wr1NwPg=", "DjJnOmi6lqqVmyXmVblCLZhxxtW2FdFNqXjRBBMvqTg=", "Gp6dw97C5xLalS+0zn9k6ZHMWQoKP88kY9zvkrXtw4k=", "FZrnLoCxtl9DtQdN3GZCN54JxGdp1wKLnWjpeav1lEI=", "JHmyEa2egfgYD6LUTQZ1+N42BG3yFuJU3anAQ7NNB2s=", "Bi+LMS85uy5fEaeG6muwUeU3N2MyndkExRmeoZ41R90=", "IpY8A2Vh3OyOHc/tbOUKcnCssuQV+zQ83c/Mt3kG2lU=", "BEQPsyNUf0bGc9DeWk+xmM/IuUtk4Md2RC+x8YmtI7Q=", "K9bgj5bHgB0+xzwE7HBuOlbhDpCQTCmloJZU1WzDn4g=", "BTHQ1tymLtLLR5zCSQIIRzznji1josHW3rahX37vSTs=", "FhHDjQfLzitRV3tkBzM49Qr2r4p9TpmSiUK2poc0Dtw=", "FIYE/SNNL1Qkd8egxzpZ/ZoZxVJ+n+tBZeT3EdBNhK8=", "D/sB60dSdBsFtRtjMcKxoDvK+tStv1f7Yh+P/j7sjgI=", "FK9kftNr5OFlk/ioEzUwBFlyHX3J666xyd4kULx9IZk=", "AR4qK/FrS3DZFUb+PpdBUY8U4rbuddWWQP1i8GBtbJg=", "H8L93mxawlf0BS8BIDNUB+Uzcw2SeAmHneDQI3Jv5PQ=", "BJ6JIEW42STXV+7O9mYCmHwxe6VbeQm1+6pK31apoHU=", "AYuExZ6LW9yeTFWukUV75KZjMrWGmpv0koEk4XDqpsE=", "Jjx75WREY+Eu/nFxV5k/1YdRzXVa0xo6dbf1JCAgix0=", "DLJ80jnqXW+Yis+0t96albDqqwrQzslsm7oOai5Fmvc=", "A2NIMeiw5zu0V4dJp4dfV2Q5FN9HiuwMRX9i6NFVACc=", "Ihypox6KEXiAF1kesGex+HvDWzYuEEc4Y3jYXCTSaks=", "CNXcz9LSFkwAhvvauRanVScVa4KrRTYSCrZUjcma3vo=", "HqIvgmRp8ENPnf5nSUJ/0VeBVkNhre6iVIUEWK1IJWA=", "FiWZed6eE7eaqsarigLsDvJrCxaQ5oLsqlSIZ/0WGic=", "JWFhM+6R53KwINTExZU8BajOogiwFiyCtX+dB6W2vN0=", "EJRR/37o+/2VY7jC59+DT3JCLN1o+TcnWcOjG1FNhwQ=", "KenrYdDOM8iZVLBTC6VXcfO2UKnKANC1K2Eg2kvZeIU=", "F2sja3eaqWPebig7wG9NQLIRn98ia7zE1W+TN+6UDfg=", "FqAz1sJmCbBi+cNpsG6+HtrDZuhTSjO2LQ7JGYVVIMM=", "J81moy3Zabqf2wOCAXQsgGJQfsrWLolHZY9GbyrLu8I=", "D5ADh3nnLpiAM//LH+yrCH8wLvYXUaaoSUbJl+Y0N10=", "IF9wuW1uf+10Sf8PcL5pjLW4BcdXPXcI4saOS93oUfw=", "G6icJ8CRz4X5l7oOPfu4S6ldRj0aWJgm+ZO/YNhnAGE=", "GC6i2QVjBWcTb4OuZxrGMVjbnvqucbW9PuCj3pqfnuw=", "BlCaiF/hFrlnrSzJmZ1EIQay8JZ7v/8CyEnFJyoQBIE=", "Aig/fTG8dejsPI8dtM04PATALa/kKmzIMgXAwWU6qFU=", "F/ryTSOyQLw6QwZtIY24odiShxRkHnK0G3T+v/A31Ow=", "CgOp/HqlCNoyYULmLH1IGPWT38UOFLi4NKuJNDGipiA=", "Bxza0JDdBs6kUETyWmrbUpcVlPPhYfYvQSngtyp6lAc=", "EfF2WJuCRPVVYAlqGEI+xDRR1umd4WWil3Xx4Fa647Q=", "JZ9QwToXb4UT2ndE/DGv7K4OmkECprv4kxeL7ialPQg=", "JoBwwX9m6CoSGfFE6XrBqfb5JtjWBrvmbCvHwFHqU4o=", "L+sepkgNbKqtCiWjtmDQFjtwGTG39zdR1ehqSPCu9Ww=", "JnqABMCkpltKwzuGWLG2g1ee14RkezeHcrS2bMTBifk=", "JdZ6dg8qF6lDXluk10hrznoAEPdx6QncOMtAEX5AEwg=", "HhTC0yCdQ+c/clJO/aOWDhbI0W2sbfuuc8fnUYnyDRE=", "HBJBDQmzNkNArFcbQLwddKm0KrEAH564nNyDoyZWtEg=", "J5e3nGekjE5SEOk0Avf3OdHk9ENmTmmB3xtCMqmRb1U=", "L2/ueArFpYza+2U/8lCsluAsZxP9xT7lMBERMa/S3KM=", "AJbYddd2QlecqRcIxbzO9hrNafyUHOLhJsOsOUylsaM=", "CckYsfEoThI69KQnlZja5cROXCAUdasIPaqicOQ1maA=", "FMCwYZaVvwdaI3lHvEJa3xfDW+ddRE5UKIo83IW47Rk=", "JtjynMQarD4OOeNUVHxTswYn7Cbk+6M72NYJeb4ny3Q=", "CdnwQ5S0svW6XC5Pg+Tw9j5MF5HvARFIyyGWkB3scM8=", "FwTECFg+kt62NlXDa5DLpqmixAMmH6IgG0/muhDc3LA=", "AwcCtk0KdssMnmUetXkmNxizXP5i4TZHLghhaTj/Dsc=", "Gd7Pg97ONQBTCYl6PrgdXiXLzk614v7+xc9o2QODKX8=", "A4xiX1Tk0uxJw4EcNwY6HRCMDVN2z5eUTKEHSWT36pU=", "DNcm0IWaVcgGMFbYNWrSm0ELHh3R7Q4oKuSE1rlMM+o=", "DpoNsUoYKC1DmUfvdBL+Hmru/MlrSsUOf0MNmAtH+9I=", "HTsA5nASWR8/5b3cHrNldN56A1ehvig1nBUY0H1c+YU=", "CXRexdJM8YN2lvWoZ8PGEpoNRMA32WYS6ZuC7vPb2Hw=", "LdXi6kFYjbewHMYRUohQEUrfyFE7N7F/sqRvKwm/axs=", "Cz2tcxuR7Uwq7rEEEMUabpJTYMvKsgw93s+D26p+TJc=", "BJmYspT4rru/L7vsaV5NLVapkE7gUchLDuH+yXmM+0I="],
      M: [["LLExedbopK0bn+w3N2JTz2Q4atkF4kBXX8qGU5snLcY=", "D9VHhA86MKUzqZTR/bP2CuUHP0SE80vpUe4Wonb965o=", "BQGWcb2gJmcMf/qQgXlRBZY/Vs4yf894RR+6K9s6wcY=", "KVLBjBVVjymyrnf8OeUaOV8XOpCX20BNt2WrApBrJ9w=", "I1OmCva9YeXqwsmkJj1FH60HOAZU1HkjeNr3UuXMM/o=", "DtajvUgXTjcLTyZLN0iLA6Xj9MD2HPMtMVetPjuG9r0=", "IRA6eqIMjRVQG+jCNQTGqRLGEAxdiAhcwuQqUjAvRIM=", "L7IyVz6F1oxTbRAMOm6pFyiERR5new0c0PtNxMJ1Nrc=", "MCoIW+BA/5pwmtDHMjiw0eEeHRdAmrqjT8Rd4ptUFTU=", "BoPmQOYVTvc8PNax0PD9huv34pLmP6hM8KiDwvH6qLo=", "Hwnz+wf39kdvrJiUa3N1CV4BSyjyOgesn8cHcUSsOXk=", "BZjDjS4seN/kkHx06CMlyxkdUmCJVbWD5YJuvr0YV7U="], ["H5MFV6KEmYIl9fTk37z1rCEfGxLZGwVi7T1jKF16cUo=", "BMQGGCDNqb9HLfP2TWr6AE8ehiPQpPYULMofGaTCdfs=", "Dbwiw+VMkkqILCIACVEjnMJjdV38s4sn70+IDiAstfo=", "L7scWenomZ2RxA9NRCMxIqs1/8l17ftDxT7Qfb8NnHY=", "C49A0sTSjEcghSA6DkYK9zu+zsOys6Y/JwKPLKinElE=", "AowBqfAWAbtGQX7UZr5gCFlQUveC5GhX2BIp5k5r2gI=", "I86OQCk5zM82F2pb2DGDoNVKJO5sq+T8f4FN+/Jvheo=", "Dbgqu806G1b3/I0RbLVMVP4mJDcCvT1X5x984NRwpA8=", "LnA+qa+ZFhrPmUnaevsY1GLYW2cWVtYcLN7jpyOQIT8=", "FlEsFQwdL7cjXv0tTw+tX914+NDN5TpmvJAgbILEtZc=", "ApiqXVpEVlt172jfkC15HQHZinXoIu9VOxdhxY1v3zI=", "ID/SB4qyqPiLdgZUMUXuNNrqsq78oxvASkdgZWl8q/g="], ["AY6CIvaQfaV0Xuuc1KnmLyi4txCqhf5yn56nOj7wCZ0=", "EHdX6wwHmfeBMI2D0uBX74EG9rZWtF52NhgeETos3zI=", "CWaiG5YVryt1Y9/kG4ufwGA5US3JyOEZaJHrd/hWtgg=", "CCBGCBSY7uY8KHxvo+/N7+uhtScqd7upz921avpTyC0=", "LH7L8UstYEmmQ50PKfEOJuyXWsw+Pt23fIMaUJr1kZY=", "FEAi5+B3/yKizj3+mSMQfVrvBG0KHyy182GRqwTq5O0=", "FwQD1BQUj0aBuCE1UJUeI47cAJ9GsAaTzj2cWAD63Qo=", "KZfZKl6bxmyE9jXoy/CA63IOzUyj5Cw6uNCIYRiAhho=", "IUJ7Opos3x4ubGKJBrIeJCcdcsGLAmG+aMykSGXezhE=", "JLulgIanhUGo6/1TXBB8NpRteLpssm0ifmFRMfcdM30=", "Af1abrpS6eods4mh/I3T0Cg9c3wY6wbgkLb9LciOChQ=", "EnZELZODxS1Q/Jtaw0RCpOyOnNeu5tbOrMGm9SGq5KQ="], ["GA6STXV9C+QGb+sUbtViEuOKz530lXQyZT83D5Bbiwc=", "Ks0544kqxCntgShj76Be2nRrVbuXRpSk53uaGau1UAE=", "F7GGIdvWHfCF2kz4oDOV43ACacffTZjOSFH5Cry7NjE=", "AqQpwtBtzzTTRzDDr4vBmwSr1lJGjeWoW11cv9nCPm4=", "GX37ZBicCarvlKH1QtjDSuon//unBCAtUobWK9Du03I=", "D9O9t5ytkTQyt9OCjgctrcJs9JA9VriXYgByOEbGV34=", "Kbn/4F2yxS3dG/DlxTLu/nBJfH30uX2y8GJINldqayk=", "CioAbjsIa/UCxbFUDqrsFLnBW/iEccttR5+0Vj8BZJc=", "I3qeAgkIzQ7b2erodyNQ4Ocx4yKLiS/F9k/fqbnapnA=", "AG00nWGC7DDWjJvgEFh8cH9+HhdcDTJOat3tYzenLCs=", "Cqu6OdIg8wYE0MRN1Hw8cN47efW6pwo6egygKuGwgMU=", "Fu6YCixn3iT6GjQILxHHG3xFlmpui8aqGh28fvapurI="], ["L30HFdE5EZDnsUoSQrZ5nqwxQuIfCMoCwhdV6ud6Vbw=", "KXiLts2Ufqnvru/Q7rf9Vj/MLkC9Yj6iskQrVdmNxaY=", "EswnRkf8Vyu3kDW/wzMqTlZqKAEfad0IdPAcVrxEw+I=", "LvWEw6ru274rSxA6YelO1AqXKUFWrX3fDeQ7hFJJ9TQ=", "BfmmqNZMyhJyXdFREPdK7Pmd0w5Xp9mYKc2HV7dbdy8=", "KXnRrq/fl5iFYNTrus+m4rfz0CaUaru51Tl2ReboGCU=", "FTiRBS/KEpD7+DJA0zT9TOBd54rfqiyWhkiODEfOH8A=", "G4x+sE01Gv9Odq9/n6ERT+Rartr960LBwjUDsSJjnHs=", "LYEl2+9gK9lw0R+tfP4Gw8ZPVoewm5YKuSsU9p776lc=", "EJJIB/b9xOnlhnkuOs4wAfFrwC6EraXfUde9NyQ+4e4=", "IwkYkZtoJvqnEkxb0V0QwDbVZeEAtpajvnr67bKrums=", "HbkiuMJJ/3v5YSHq6dlVXvd3Dz3XsFYZGumrOKXM9u0="], ["Aig+2NXm+UcLP09Jp3EGHkpPx9rGg978wDSKiGLGznE=", "BquGcsk2BwoQdXrbRQMaXiki8PuLX6s6T144cvtYLtM=", "LH1Ti55tKy4G5y+KqrJtvd6tH+9qdAoR6ZU/jo6e4Fc=", "KORiDSEFNryqQu5Gsc3LIb8hWTO65O7GOe+9UfS7ZVc=", "AP4N73C/ukBnmu+NWiObOhtaUv6P1+23VK7isYLWS2Y=", "Iq4CNSCXl0HlxY+wT9JdEtyPX8tq0VIjpdp+D5HHtPU=", "EFwLJGZgxL2Kbxs2/Dz/hqLEMsDckyHLUKu5ihDNG64=", "Klq6O0XnnrJgaypbR+uQdYSuz7/AtM1QzaHOSFQzhZc=", "I6OyPV7fXLZhYP0lI7OjgxQikcDg7mZmgulGsdV5N9Y=", "JmNfTfcXIQfa1rfDBo0tQ4v79IZHEDn55lqchGKiycI=", "K7KO9C9fratqb/1WVbNlgN6wY64wgdWHuxWYh4WQ8cw=", "CW3UOoMqto415XyY17AfKi5ZNoB3BFk6xyx0ABOD9+I="], ["IfYO+xMrYpCZkLn5lPOBqcAqvDzLVMXI6MnFZkxpE9Y=", "HbmKVi/NGl5EluYSZKrV6jtFX0bqvYlXumcenDHlCSs=", "LzCADA7kYQEFadNrYGhaOLApEqAgvEcIWYhU9lgi8Vw=", "HjKx4ua1knOhE9YJZjr2swyVs2iE/l+vNx3j1WQhPDs=", "GxUjRjpFopgoiQSGgaQiwC6jc/i4wb8Wx0o3XVBgxmI=", "BSRu54VLLiDoYS2gIbMHmOXw0Cpb/V550/msbHn6YJs=", "Bs34BVQ5rIQkxDXn6b6j8K6T6rFxrDg+0s7bRg/LBMQ=", "L5pc23lkXjRUxhfXendP6vJO9gNFTAIHb8TJ11SMxFU=", "AbFiXXV3hqGak7N6338iyopQKqRGLKePfaLXwis31/k=", "KL9UiKUl9VFEANznIkMCh/6OTIEBVAVusPTW/mEJHPU=", "IYkb7jH7e9ifDkQis8j1s5MpmvDZgl25vnPnsgCXkjw=", "IoLoat6FhV1OoGV8St0gYlxtqpC8k5Q7Waktu3e2NoE="], ["HN6CrO5guEQk6bzuSaVGTuBdHPC3BGkgimdWNaxxVJU=", "HE3eB9D5TRqqgyrC9XEtQ4tOGAS1IJzlWULXr7JMZAE=", "EWxF5NiM6uRWXA6U2oROryd11fW0NdlNLT04tYP6eEE=", "GIIDZIBNIhGTR7coE1tAmVb3kz3voQWdY0uXfZ06vN4=", "DISdB7HZ5uy6xRf8GSN/9zQkoGePlGmbI/dpUq+kUUw=", "K2Ck1D0SzzEHbgaQ6TFxbEeobncow0stPLDLz5W7t08=", "AxYde5ThsEEfwB3PvXSKbfMVb/BFNrPdMQH3suvDgRs=", "BkOOiwIgRkA5p7gCLwa+ruUCxd4mnbgvkdiP4bcoNPo=", "FImLq8iBDLxiZohTFRGoRz7YmiJWnUe6WGwoTkW9CuA=", "AJDfzAMnpUFnLPwmx+E3BYPF+SFBdwkwEP0/vyear9Q=", "A44MLinHnM9GteobxYknauyVt06LuC5DhcBYVjfIhfg=", "KDMdDTHKhnWtR2fEkCYbv+W4SttMosVZmofzMZCBMPQ="], ["EYokUQohU/gY8KmWyH3pE1h4BfFs2xk52UBpQflY6OE=", "LPyCcS7Z1x/0/fY+5K0Rb6wZV5T42RAobBUu/Z+Vm+4=", "L/zLxAAx66/s/DqXKEvQ9txNRezri4mY8aZnvuNp7WI=", "CbbACjffJ3DOwPG/Yqaqw704DGzp9PluDwh5I3/6UQs=", "LEA2YWwVYAYzd3HB41X8Dy8jjmTL1p0Giqu0tYEWiG8=", "BBuQmmWNE2mTs/UJqenVATi6ykj2tmOZrFxknmjdOqQ=", "JcB1tB6i2CeklVtkadudQXYPr4hfLG6cCUB+uxxNwnQ=", "EVqRhnIzzHXRyQakKTDpPLnBavztOQzBRDXlz++06W4=", "L4+zcXi1JXWL9qpSfyV3Ph68+OFCU3lQDIJFx0G6P8Q=", "KaFNxLrApMUr8wqva5uOBUU9DXlyRrZHMtUPF2p8olc=", "LIncdWK5HY8vfaogm3VgUgtrxi7GMdtBzF7awfsUK+Q=", "FJcr/IXeA3sH5VMy5rxbTwjzntTripch3/xKWG3Zod8="], ["FkVnsN4Wt6VVD8oim6x8sHeVJDJeTKXnioYHiIFmAmQ=", "GLSbdz9XmYiOmr4/aIPXBjMzg1ts3TM1gLK0v0jzsn4=", "IAdCSxKa3iGUxz5uLJ15Ng0TYMT7uMXzEzD5OFWLOs4=", "BEXibib5FwfaLfXBiLr4DqL0jHA2FJgPp5iXHNjsYPU=", "F2gE7Bz4XTUpg1EkXTIjZUaDjZuYz0JC1gHH6OUBtJs=", "JbbmXpD/v5ENGf464j0Df49k2p/j30g/xPSXfKNqexw=", "L6KveXDhMffv46fHiIkKuGD3Z1HlW0/2NN1GzE3mYNg=", "DI/U7OXCBRkM9shC0Wg0RAeb9Jg11ci437sRr5VsyvM=", "DpkvREY+Lf0mfmpKHDMD6noRhiUu/Wyfrp5fDB9tgmY=", "AmCf+X71dP1o0Wo94IcsO1mluSgljdFGmCahkdy/W9A=", "FdxXh5y0HWAV2piB+Ui0DSDw4D+th3RthXWvAJyWAz0=", "BtA5tk6C15dd0ho3te55MI8g6C4jSJOC7C0XYZBYeJY="], ["GI/zAxlBEqcDRSfMndC03rCWDJwQbOEVF43XCH5OjAI=", "CzAN5bmcJ9MyCR+PsNl88EqGpR1NIDd4jg1POOj06rI=", "LFPWZ21NTIfZ6vXU2gjR6Y0QOjOI1Zp8DD3lHiYjqjo=", "GfUQFxUWKXZ2bitXpYZ0vFjhuivhilmwegfkqT4DgHU=", "L1hVqHajf3u71hBKzPyuUH6d3NKnIZtIenaxfFJbUMo=", "LA3kSKiN/qrMm88oULb/T3AeGlONaQmLyUCHzDWTCWY=", "DOWHBm6uDDRcM2jFPf8hcM2wgb7lKyQ6Hm3m1PgkUdc=", "LOqYzGSr2Sbflj2lfy70xDQUHLU6xjEbJWbtuVeYJxM=", "LHrkddkMR19zwNKb6IidDEuFNv7mwDiZhL+eTbsarm0=", "IyOP2hQXMC3QPOVGB3SWECkpRb3b1YckFxT9OWSvXxA=", "HGdP8urSfOAC9L78etXw9RI+WXk8D+IQdegZzlbOHoM=", "Jie+aNnNDM2jgo1RYhukCfms8J8anMUDop7DBvhgauc="], ["CD2DKt+btKJfaGq+2p8W6/UyY9z570MReB0Jkg0JTq0=", "BUGva5ZSRmIITRII1xtrKo1m2RF5dFshNnnCorvJSWg=", "LPLJksAqNjNP9dyFFkbufaBLROtUTuPA+tuNxe7ypYU=", "BsXfj9Yeyi+0kj8KRt1OQWo6O0jBDe0TEz/+q2/RU+M=", "GiM8fOv7DG63Lf0HqitTfM8pHoQJOq42zGgAL/uDY5s=", "BfbWL1RRjwOeeapya/FaWYNYPspAYkBUAKzKWMqdIjU=", "Kwnek8bjFIz3/1cxyOFE3rtmyoluy+QInS0iy9sJd34=", "Ajns2SUXglF095Y0XbKWViIjdg+xuBwJG3SmpKgpaKQ=", "KUXLheNFMuOiL8V2cDeXiTzikNAVZDCo3OYcnfiai9U=", "ANO+alsSvPG8cFwgww8yC4iBxsLsAOhXaFwFmSYqPPA=", "Eee8SjnScwGWtsM0+ZdQ3lu15PvKXWoZ63/hSr6EXb0=", "DHyduVKGX7lHD4qhQCU2yzuCJ22eKICCrH+DsQvLbRc="]]
    };
    exports2.default = _default;
  }
});

// node_modules/@selfxyz/common/node_modules/poseidon-lite/poseidon11.js
var require_poseidon11 = __commonJS({
  "node_modules/@selfxyz/common/node_modules/poseidon-lite/poseidon11.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.poseidon11 = poseidon112;
    var _poseidon = _interopRequireDefault(require_poseidon());
    var _unstringify = _interopRequireDefault(require_unstringify());
    var _ = _interopRequireDefault(require__11());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var c = (0, _unstringify.default)(_.default);
    function poseidon112(inputs) {
      return (0, _poseidon.default)(inputs, c);
    }
  }
});

// node_modules/@selfxyz/common/node_modules/poseidon-lite/constants/12.js
var require__12 = __commonJS({
  "node_modules/@selfxyz/common/node_modules/poseidon-lite/constants/12.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _default = {
      C: ["E3PHcc3xUSGiJPMw2EtmiO+f4AOKO8JqKOMZZXigAA0=", "Kfn72jyZmDYBf3bhIa86ylzni7SPqGemqV5bnbOHUzo=", "HH61EWogB1wWm3htnchqJO56JSW1ZbvCYiCajNpJBSg=", "IaVJ61VPD4WfYdaPG2u+mqNEmmI4VGu98qHDCMnMUuY=", "C1P/9wE0fRud+YtGF1gA4NMlCsbUoa+nGjSe0ZWHNQg=", "AhKaxHQkFcAg2yRzmZs039urujytRxNxj5XmNG4Vg7c=", "AdKPMF6LDsiNo3yCUbDI0jC2i+qUAaFfUSTWTFRUvCk=", "HtMB4C4/yTCZn85tN0TCNZZwDANyBwWTnWHO5FH6/5M=", "LtsYMpZuNOru4JA4WK/tsT27qffIAsg+5ihTDQ4mrhs=", "Ej2q3ckwxl/Ge8d8qL9BI/6B+9BQHo+JrDGmmHVth9k=", "K8w2NiyQIQrPZ9X+IdUxBOnVR40FcUHTsXJZ/tjkqPw=", "H6koyrWTggfomOYdmcfWFiaRRPeQCBWxcJX3/3bjydU=", "KcLxz6cqD7j1OmMehM/fXMGPtCbCVPWpBf0+gx/HyDc=", "F6cyrRPxtqGv9CZkw5C5AXxBghAnPH0Ei/MAqnvpxl4=", "DBjG53PqfrQ7mMrGZyLenRNUhMbPoITCpRLqGXemAmg=", "GVTFwjjYowyfG6T7lj4JGsrLw+17SY3PZgD1MLZUXkk=", "JZGrd4E/NNig4LewyqzW7xed0xRZfP3ni3SGnXTa1gA=", "F525+4qrRhnmemqGZ8e0sy9A7YSNjjO3VsmnlLWTL+w=", "MF0BQhS0EHwR/YOHBFhzjgT7jcTnRwd8DkYvUdHFlXU=", "KYcj1waUV4/ikWNYmHYrzryprEVjsSuQ4f7092+be78=", "ArM26bOLUExBKmgzCa6AJNCAKkXQbmSaXlNxmqspqRM=", "CGh+aZtSexNB+at/FxE9ng7KBEMlHvNfCpBXBPFV0zk=", "Cl/599RbPKm3mxjXnbQwfufErE3eqajaGjarO+BXyb0=", "IORHR2ATGSI1NfRWbNyGylQyTFZXJlNTrdfb9PJQRlY=", "AlTcMeOv0wToXJ74+rwaHNGkx7m8hgzpzkNsM6ICqW0=", "Ec1kktxSDFfcPlXjP4o4fLwe2joUkLakvOvZTgdCy/A=", "L5ixAmWjBHW7A0jUp4fPtmAxGaGk/hXDbcmGy0+MfPE=", "FT2BTk5VrXgrzO+ZjJdCUMBzRl73B3VQJG9pxYupifo=", "BNsRqeoBSu0u0I5GwGMG6HExdE1l0onlmWT5MNE7ntY=", "Dpqabe6TOfXecTXKMiL9IjDD8/PgHu3TYz5gaqCxod0=", "Dm2ORkv824+e5g+x8vMweZEeegc4VvrueDmIEcuXZ1c=", "Ajf+IVEYZDehzxkBEGriWqwW6YRvnUH9aHlteijtcoo=", "Hj09HuqLdhWpiX74Yil3bL2h2EiqWmgJNYJec/H1qoQ=", "CXJBRMekrsDdy7qfmp6eybzfaIyj9YcPHubhdBeftEA=", "EROZh+EUdGfZJ9sl7siPDB4CMuNIbNmgFL4/yM8GYSk=", "FSTlvs73LCaX40yAVeyBl0rwSRLXyh34PmWggOqWJp0=", "Bk0SmbEbGmu1Cz5ax1kqBU/XI4CvpMCSzijsjDHoDJk=", "Etn70nviTrYgt3Q8/FKWVny0gECRoYA92Xd4ip9Yjkw=", "CI0ibmnhsnProx1NqFdghcwP0NquFUa+8wB5+EtlG8M=", "FRJt4YchPrtA3OXaGrOtxYoxOZIMGUl8P0cRm6pQZw8=", "EWnB/nObxSjqwWpSY9It7kpmqZYfAe71FoTveSEmhZ0=", "KnAGxoMJT2+E0SKtV3StLwyfqAtslj4vo6Hq09dPOqo=", "JgfCLKmu/ozeow//BbBcT+x+2OkwLQ+VDNlAWulLslg=", "JFMLCG9EHjg082wrEevAqAnb392DF6OERlkxwcWMJjg=", "BjVOAtjE3peoEUgeOQwm5ck/wpoqGoSCSs5QRnyaplI=", "H2+6s+LqJ5HJT1/0PKEolDZAaSFRspXc9CysDYqwdXs=", "F0fKRbcoLvCZKPdkn1zIM3U34oNObIkFwa5pAI33C/0=", "A+/UubTUGXTjaITjsQVacFq07D+xyOdvguA1mRIApjM=", "LZzRidR7CxsyyaJBLbalmxtHXckevS1oXJazScIgtLY=", "AcmYJlCqzRpEntBGBb1l/XXOOT1CTJdRgU/QNUG0dWs=", "JD/+qoLzwDhIHoS3KLRZ6yITWYUa4ibBxtanuhsf/bQ=", "BlDar9ADvtC+0iutoxvqcJSRqDtVyv8wAzmIVIHcZeg=", "FtIMYZZ0Iot2f8YlqsZQuq4tDNFcH50BZFRwgrMJnfk=", "Be6NXWYdOfFb6SP6KUTvKynaP0gx6x5PLxwSMM9dFJs=", "I+vI/ED+7FJALhj4gerOv+RB3iVic//lUe7g7X5NrXM=", "KSu1nnpscBFq17fhGVHDuLaxsTDzW8bEKKlTPAA6cOg=", "Ez1C2fg9BU20PkNU0b1+w6ibjPlHA/3BKVDZ88IaY+o=", "H9a+0NNHqI5G/LQvM5eusM8HqOcUZ+YRC5TJD5MjdF4=", "AjsJGgwfCCLIFWdHqQfIp5uMH8q0o0IGIlEchn9513Y=", "B1/HO8tuosFY5yGpqmw/HE0Tm1zxt1LIfZb0RCBRLu8=", "AX47y6Cy0i0nzau8s2DIAg5WwBwHnLVQ4/Fp+yqaRRs=", "GUKZ8Pt5UagKzplKPqMSPm4Mty1cRv7ilupvjnOtGII=", "BvDlIpJKTPJdkBHUd6J0bHfozHcVC4e0LIwRjxRztRQ=", "DMkcGMX+4bV52gkA8E5abDbWXw/Jd5kyA9SzEcv10O8=", "Gr2UwqWyjmYTEOMxW2etv1Y/2waSa23E5Nk9BBZe0wk=", "JBQskAGnv/82Pz9n9KK9Eo77cuhG47oQNE/65lXlby4=", "GTG51FI8s/eL+89rHd5oxGASqnR9zXo684LteBJS5Hg=", "LOO9EWGgEqVyg26X6o8GlPk8lS0R/RGo6Pmknf+d+F4=", "FaCfo3MEHCOegUllfJi086ow0ZLIfAPM5HorJFPVpIw=", "Cx3Dj3SnG32Qnlzn/lYBdoc4QXpXhomNoxb1KJmK9mU=", "E+oi+TFrtWlNaQJP7iy5XuZDxUVJbfC9HCVJDjTQ8fY=", "H/5YvRSxK5+v3DZecIGjlalhTgIvf017x9/JdLCq1x0=", "Ebqx8YbNoDwB6F3+3UC8XUBuJMpYswWmJXt8dyvOJEc=", "FAB+stFEC3uOCTbHlnIFGub1yp/UBVtBfwDJYyq+MOw=", "EDfwGT1A9oLtliOnct5nnwQxhz6OC1AEofJCrJY/7nI=", "ILGL52DofXxhSbgQ/klqv3eg+EDuV+vP4c93I2M4+r0=", "Heg15mI/QmcRJ23eeiocIKYbkQv2/c0zs0Noz5bpWi0=", "IRw4BQsHxKdHxdxEk5zh92sIIMS18HpH6LELBeepnU8=", "A3L8LNgyAV4RnCoS02Iv1yEqSIfkvRJ1wgX64uF/RS4=", "AUON7newgly+9rD0EumnJ31OXcFhzpgW8CCuTRQQ0L4=", "B/Ls4WwSyXV6qmCVPe3XCcUT9vgzfiKWimXNULDZkhE=", "DFemnQlXXY4fUl4BLXNym8iWSbW8QmDXPkMkhIRSUQ8=", "HI0Knbd/FPg1MJ8tPGghuZIaNmRooNFe+zCPV85lhRM=", "Fp2gk+els5vwiCdwctT9WNgCFbacomLMLRKl6zDAC44=", "LzA0qyCvD9g6xgsCNmloZvglC/LXZbENbaLj7x4teHs=", "DjG0+mJ90OXy2srxBYZad3gVQ2IPPrKP99wQJlZYMHM=", "KpAHEm9n4WMdKVEvQzpqC8uMlaNr4WS+X6hr6f64pZQ=", "CAr0AhW2B4voT7R6zXm1nszv6KkramAz53LCIYO9wNc=", "DeiiNNIIhh67Bas4EuXE/dOeetqQR8km77iOHL8uu1I=", "IqryTA8eP5QWBqUnN23f+RzGsK3AYu/mQfluMAWvNlk=", "H09bdwnPWEvwcEhh6UI0zYkJhR47ISxkoLMFH/qi62Y=", "EpbUZCfrLjiBal6BcTNWXU9t7U63K10KtVm9V2Z6ovE=", "A/qGdnwfote060W0olWxKYxV0EXGlif12K3rloOhKb4=", "CAIoBavgK611MG0iZHjknSX6z7yv9kk2Q1LUqI2Sjzg=", "HVizOiqWOLoYDNNgKTCKLovn7Sc0QdXSgEVrLTuNigo=", "H4yuc1nIAPMHpiW2b/IVTGxDZOhcqOAZEaY0qkrWV6c=", "A5ymby/X+AwXFxpO2Mgq48O/BGLRRRqfWlh0iVhxe/I=", "B09+E+dPK3sxajg5lW9L8lQerySXZTttsakzXabIgtw=", "H2PPEUjA76ZW1a+FDNAqDYea14hs/K/h7FX+a/StXLA=", "HZv268BGS5y0dYNJSie0V2PXpiKW7MoX776pc1anPiM=", "B2SSh0YDsCGJLlwqA8cGl5vlV/1O4uBAeS2hbii8isY=", "BwEjOMXGJuJn921Cg4iUC5AOAIXHhRZtJ7fsiWCCUjg=", "CcKQWeIBPQzizOCyTjlGdlqV8EBSbDySJNKAGhvU/4E=", "Hy3gNQmBqzdMm6fqGmnYGyh8LJ+tkJUgWrIVgroOpkE=", "DFK6uG4lmjvYwGEZcCiHO4AbTFbqgDb/laZ/Q087dCU=", "LyYuBheGcMT/hh9nDHtR755ikhOmQiAy38smdgQmo+U=", "KvaqIzVAARRFNDXpcBDb5weGppGl2XLqIRrxLUzjhMI=", "GMrWVWfwMi/W8GJstcr1Z6RvqhItMMNzgLVLa10Bqz4=", "FFZn4ZBn3dvUJp22ynbQwNflfxlF7qJR+KythuhJhY4=", "Lrqn4QGUzSlXoT0aNY/JPOVNi9Pb7QbiFbK/JiOyGEc=", "KLhblZguvHbEdiZU+TLbAx/9U3ahKZtFuoBcS04HVNA=", "F8sMRzhB7S6x8aHd8CG3T3PzQXLgZbJMloTdPP/DQKU=", "JPRuy4WDypfFsBhzbSJ/3nw50ZeMpjyX456gZYjbB7A=", "J0tcQJ6pgJv38Ep8te5NMi0alahsHQlhsV1KJKcYXew=", "LLqJYNVD/ZhGN3NI6lW30EKzNIUk12EBg2ZGYn3tRHc=", "J/AuQW3XC0SQf5fX7LlFzrurHU3HPIoYwAz7H7JGmYg=", "KrIYZWkSKfpEC2UorXw5xBaTsbk57Anb7t8m83ckoVE=", "KRDakW5DjASDfOeZuBsOl5LB6tAI2S/PnKhnsWX14nU=", "DwPOmDZhEd4SzL5aESHJ+DCVGaflIwDjl9nZA2ggevo=", "I2sDcefOlyE9iutmg/AvRARKH+2so9FR7dMSGkT6GeE=", "LFDKtqhnsegBo2/7zuUhuDr7xYC+GJfcTFts1d87NQ8=", "DL+MjczYN9HbrAkVHk7jePk+hUjZI9iknm34G5w/J3w=", "HRip+wASRcGmoX980k7YILDb7envR5gw0K5IM0blS+Q=", "FHa7HDBgP3+UST0uAWvuYyg7Kn79mZ1ZCQxDTIiDftM=", "JNVl+1eN0lL1anoNXY1NHF1yfVI0rEvZqWAEVcy1rVg=", "DGjn6VZ96rjouVBRp3iEQ0OOD1++DX3kNvo8+tWWNp4=", "HOWyWlOdPhwMXc0evQ9O5xaEDUTDrhCaZp6s3cSjVhE=", "LTIQ5mQH9sND7vKPu3uuWfYm23O+xdn/BrqdQ7qE4gg=", "EYqzQndH7xpFpgnN9+cQKvrm1BE5LeJU07cvHUUK0vk=", "C0XHDShWx+Wz/W+PD94af8sUoqzOT93f5Qs5+5dCO10=", "LOfCutVggVPF0eQO4XzDPvF4PZsc8BU+SikYiU+qRrM=", "CFS9Rv72wuZICzsJmCFfVfTgkKPpngOlpkdC+Y3OWvg=", "Fcd+dgDfcR9Y8vD6iLfUNXcBBKGWB2t05vXXqWyOaT0=", "Kgo+447f2gdhu5swF5JNCTCUeLFnpgmeVNL1oiFyTtg=", "DowU/UO5rOK36Y4axlZZzTf43pQZiu5C9b5mWXZaStk=", "FjJ26DbE7mq5RmYTxh/Gkk+u2c/cCkWLyVtZ/zgeIeQ=", "I9FYSlywt0wABxxofN2stKYysQTeQVnA4AxTUtB4zP0=", "FWhbyQOhxMAxzgFsCThgoq4q76v6R9HykOtaYoUi9aA=", "GzP1DpDpC13KyxoVhkHWMxGXJFfv2UhYNLg/D6BCYKU=", "KDgMVc1meJTGOGR+aqFLhX0/McAxWrMV1qlFcwTyHcE=", "KdEIVB87RRlD6s9yOsxohqqxjI5EhYCPSx5VpzzaYkY=", "HUwsulnVVRvD/pdq5awJ5bco0wW72hk6/CWcmZMvlfA=", "FqjWmXBWEANlAzeqvl5OXd+ktxwbnbjMe4J4A1nHDTM=", "KJ5QwfCwvd7cmLfoo1vmLxT1bdXXNFv6atDS5Dv5LkM=", "CkF2WlNS7L4LMnyngnqfxklee2wULf/KAD9YODxt/2U=", "JMDUI3igyKYTwEAu3m3pvTUn7yuCzupgBuf3G/d2ZtQ=", "J3yuUFfVtaznLEfmDMS44RPtcGtdkepPubE/0Z+k1Hs=", "CjA1Z8v5SWgJBDiiPi/SzLin9xYiv/3BwWhOiVjDdl0=", "H37YwmeimmnZRQ3HSvr3aKiE5Cw34Ob7TUOFywJ6uUk=", "CGxLgwFla2rLinNQGVVqJ4pgMTBA8jboFf0i6Ec7vGU=", "J7Y/vClZR2Db/++NMP70mv793xUEvUh/1igtnj1uMzc=", "ALnApFYhcW+YSa+KPJB1t6uDnCgoge3osOWp5yN2bXA=", "G1ui+87ZIsN5bVe0li/SU/WrbiuRNV0sCo0iYEBlI5U=", "LhrVfr35MmA/Ubsd2rIE3AJuE9xJhnkfVMQDDKxvGTg=", "L4ZeHfEWmjV3H2FwRkhfj7F6/eOyuX0er6+9GGKsbhY=", "AGKs5b44DF5DYbIJuAvv3K0FIUa4adUN1YCF6mXZ0UE=", "Lby7G06gjjdphEvtUiuS7gH+zVs/I3nCS0XVmEJTYzc=", "HOPZADTf2hHpv32Stl+BBIPEiybMoJJ0e0zq8Hx7qEc=", "CGWDpZSXR0sNHrDDzsTx31lq7z22OP7hiV0/WlhFJSw=", "K5hNXJG3syD38pe93Wh4nvbKiM/tOVfSxeim/A5412w=", "CO3q+d3NJacwdRsyzUPGMNqDEQHrMQOZNW5LUt8R/Cg=", "KN85zH+WZyVpz4buNzYj2p8cWP8f1m2TDMI0p+lZxB8=", "Fa9qhMaxQurMWBN/s3F5m/Ov8XgEVcMtjTWYz7kbJN8=", "Gc8NyiJ4GpvVYXNJHr69GOyERtZxdWO9OoDMUqG+aWE=", "BODgtSkjv/i2exIQ8joRJ3M3mWzlAYDrqXd1YYsANVg=", "FasKX9orUZHMK9BIWjDC51tUC8OXw0NtLmS2otqaxJ4=", "AY6D96a79Ff957i6T8U61IEO4HGUGWn4e2K2xuqPVe8=", "FxsFOc8dboUZeJ++sxKStr5gw/k+K0UwmrVZqFTmM1U=", "LqdqFODRd/NV9oHIIt4rNxQq5uk3EkkiZdKZJHPaECE=", "FEKSYntkO1GAxxDrptdKB2zaXT/4NldumD2pt9k1ZLM=", "B60r83zh70qPrFtEMF8aXSEn2Mb/Fz7ELw5CHqU/fBw=", "BVUU3JsBSArle6JP1d0S8im7VZftz/yhRRVq8zJLDYQ=", "CwWkW7k3fhWXUH/eDbv6LWQvbDWOIz7LjtfldexqNKU=", "GYs2nwJKBWGvmtegz3rBBwQrQvkwG6/i4bTCrZ5G+oY=", "JT+CshrdqoZyRne61KTEZKxex1x4dV++xvRtnvc8LwQ=", "DvJW6dXp49ofVtfSEV/fEO12dOPOy8yc28tGx8+8dCk=", "LYkmVwsIAmAWTmtmr6+609klpGTpldeh0C+QxyZPezg=", "Gc5MNsUSEHh/ccuwgMw0Dy+3MswZFhjVJUALL9xRaJY=", "BZ35B8n+UknUhBg/LonxAuH5l4WFyItXuah+jYzfxss=", "KvwnpBgy4L072OlHKE2azRrHBQKVs4i2tcwxeahC+AM=", "BulgpbI4VBdCnfqJzRTXeHwHeOTFQh26LrppSwhUohs=", "Hot5DKLQgWJEhqz9YTJF79cQ56epCKIz7Fr+EUhHYJg=", "L2jXjfTgiyPJb6lZere6WheFMpo3AFMwDXkqBCHPOuk=", "Ci6C8ML540Vomy8tohCNAYzOMITuhdyD1Xk3+s8+VsM=", "EIsq9l2KK474FDTXNkbP9sJf6Ou4i7do3ENcqhkUMRE=", "DC+Q63f7KFXTm3RahdPJYMPQwe50DYd3lxyTbdziZgE=", "A9rdxZA949UwLHoH1MVGA5+oTD2mz06snCucvJTbAFw=", "AQ9NSBiIBdMSZzjSSXbvTIBZazxjgO/7I8s7PqyVQTQ=", "BnATF3CGWc50UV9i+RKOqaHP8nluGOuer+nC7E+eQoA=", "LdA0nw8O9S13YCA3ohHlxWXgCR4BBy7whjAFbZB/xtk=", "GxWVfYyHdAdt8W1J14ixGlrUaQy9gCJDf0AqayXrVDY=", "AqkqH1DEZYtofytsivtTI8m4490X/c1cQOF9tziidZI=", "DUyzFvBy/I4kY6SkLRaNbcBOCxN/pLVyFtHyul5krVY=", "HPD5v5DiB/Ogql/BCFOMZBxA4JUsb2bmAk+tvSJI4Ww=", "C4HAPmgGpJqKXt/D20v3j9S+uAZ00MiN3e71Q9NgCug=", "Hb0y0El2TWq29ne4nECPn00/KbWhgUjMjVdA5I7MnTU=", "FtUrv4OESLDkTCvwUinD90G5ZnkEOKKZe+nMZgEDrZA=", "LI74gNV4jlNZuX0b5VQwXgz1vVXCk5kSgb/lQBueNd4=", "HwB+8WfJuZ6UgAfdgGCFcZK53JkhJ8I1rsRqKzI/LxE=", "DNM2g+wIIHxWqAIQ2ZKXMdIDUmQ5SEGytvZcYVGc2EI=", "CvGw9w+Tu49Td9tlF8RIKsk9369gUeaP5znxYbQ4D9k=", "JNA9UiEY5UTATUnTiv/qeJ5J0usv3dFxYT5p9OsHu0A=", "Lx8OS/mtzSpPGu5c70wtPyfJtIJHlpUwJQJ6N5QkKOs=", "JIpBLyh807NEiTChA5qzIoGVj5mi7sDC8aUqZbPlibY=", "IeN0tF2lXB09icbSFz4RRpmSuBvrLT1M1NFgONy6sjE=", "HC+FxC9qMxCSygM7SuBqtmfNir7yS1RY6xDlM0ZpSmU=", "KetVXd1MdKuQMQhBJ7/CUDbxd76O1i0y7TWXPT3pTnY=", "B9MBAd9xHyU2SpVacAL+SPR+wKfArNVLoMtVHJEuxuM=", "Kvrtx6ZXlByed+co8gLVaOStEjD5HTaalhtNzU4Vo28=", "La9CamXTfMgRJcPRzKUnyynpRRvgpay35PyBsq+uWoM=", "DHdOgSeVIO7KcPins9d5m97oNxqfz5AtQ1M+ZJx79I0=", "AwghKgpWysmVYVFcg/Adw2hL6KN6JRl7RnrN02fuAws=", "IPqUR+kuT2gCXhvsUfEV+2UyNaukhPoNq5ysSqdE0pU=", "L09kfvRQzcSzlUrRTHyxw+CNFAVJvDbIL3OSk86LYkU=", "JabQJCK54AscpeEVa4e0zdpWy7s0H4K0pj7NQa/Hm9g=", "BWWDTHzwPI5ULxwyiABrqfNcVslUcLuGuWaNAGPQlcw=", "JKb4jV1wkLJKFRxort6fNH/t/6pYSqQxstDpDaPNT70=", "AUsNRN31zqV2y4LTmcjkpT54IltkbSXJe1BOY9ukzOo=", "JR0yC3YDwchrYQJJMhnLH3N+T/m4TO9wUON0VujwOs8=", "I4wr7Gz604jUd8VcDd6rLTJoFV8zY7ze/TzYrl9jdms=", "EzfXeL8PC8ABrZ2/mZk3nMCN4O1WdWhEjKPAw1Vdqdo=", "JprjX36zhK0ZZbgvjJ6LT2XTzs/XZ+1ECKAlrHupdEg=", "KwHYeXz7lhbjRxkhthDceMZK6asv5IcBuu5eeFPqGJE=", "Gsxfid/CSgNFgVb/exVrIvQnB0aQDXE2ix6K/ppoTNI=", "CmbW+Rn33OcUTsj2bOzo2+3GIyfgQHq9x71xBg+NW3g=", "F5eOeaVcwHfUvJKzjuXTV6tKbGIUayqErNmvUJVOjKg=", "Ecu75mu02VeBNAgAmEOyyWzXsC/UtEnbGJXIM6ZK0E8=", "C8eENSnhPb4wQhCSKulRWi+BSOr16DvQaGES3GRvyTo=", "I9ZE+rAdgGNh3mZci8bpctlljSmjXpYgi/U/j7TKdww=", "BINxxiALkjsaCtPwCDENvDUOHjxHDSTTrSPrQePZOzw=", "ISB7HUekusUro66QeMJl5c07EaEmVH8hROUBwYplb2Y=", "Grhu2mGmvJYG5l9FXDxI1BNrA9jNzmledQwlcQRWRwQ=", "BHG0HGQYtq+t8MlRc2mwH2K6eNVhlBxL6qHemCdnZEQ=", "H2erPXFkbAOc4J7nIyCyrXVf+9cYfrQ9WuCFDJI85vw=", "HXjaVaTAw/147zS0MW7d1/NtXY22VRvNvINrpxl9r/k=", "FLNyV8H4hSrtRIA2r+WbOhIVm4mvpeLss1BjqpHDt5E=", "ALkEseBoy3cSu2Oxch2/Wt9bZxfmsN6u//HyqYizpaE=", "L8EA7LeWk66pHGEYtwIJ+0RcX+rk9tHFiGAYoO/kqNA=", "Cp13vI9DAjO1n2c3ucAZeuzik5o7Y8WsJMrTG8xwB0s=", "H0vcaFiCrhFJr/x0+h5MphTNlJnXUCemynIAAApTm5w=", "DdEbG+/ikxEMxPa1wN5vrjpn7axOhLI4+suKRF+3P9M=", "IQEoZKRLZHnUS9seLpd2QGffaeB20eHDEN6Sm8weu7U=", "FCzqk+WUnAbDfayItmTtNqi/4avMtLMUXQCHQQpc+P4=", "JdB04x3Qk9Q/o6OmtcBEF31Dznc5rLnlgYroM56TNeM=", "FSNo6N1y6b0/APpHrQGXCWWZu1uj9jQBrps2ifWvuUM=", "IkRQpvJN2EJ9jW+d2YVjAxPspX1XR57JjtPuvjoj5Q0=", "CO6L7RpTOBEzCKMs9LjwpCucEiy46pN83B4xh4VUyBs=", "BoRx90V1hnDK2n8jAUDgmssKz8I3z38x4GNVO6sVbdU=", "F9zu2ahhraKXAxj/i53BMHShET8wdu193uZ4RWYtVZQ=", "IclRsoSfUTNtoS4ZMMuyzUB8XKC9+c9uLuiKjmzzbhw=", "CusVvdM9CceA6xq2hI3LwaGKXGofJQzuh89QbUbDbjY=", "A35m4L97fH97ALtcBnIVViIgBEyUv3iMQLSAb+hqCOs=", "JwXSl9tKtpOmXUzHPtgM6sOm4Q1XEjcBpSdpCVZHuwA=", "DfghsaOH54+OI4jK4ClOiNDC3/gRQlqUCmDgKFpxs8M=", "KVn/ypRkJ2akbNg0DbCOya2pFdI1QGiK0fJeNKmuOv4=", "Doa4ZVMGu94BdIF1tW5myjZBD3WOG8Akc+QlXYgSCkM=", "CPlNwSB24b05AHBeiAJFphSe04+Huv/aCm9LFCZLX88=", "KWjkdi6p5u5QE9lrq7JQ2V8wD9gNhtIswJXelRRZBQY=", "FVbCZloOdMwFb9RUqFo/vstXojqHncHMlbmNm8SXAY4=", "DOhqSMBdQpvkgLnLzCIPOinG7IZb7RCgeDXG/mvuNOE=", "Iea16aWlxXFW37jPWoeF0hF1mcJHr2/rV3u0TnUkU04=", "BETGVZ8VpdbzeBvDkuiOisWC5IfWDeEs28NXyWI+SsQ=", "F82wg9shccdiEZj1G30YkRergOSqq4F2VjQuGws9wfQ=", "DE/NMvu7z7J75BqUkuxVQllpyRQvNlNRx9I0eP1os/Q=", "A3pHoY3qb8dl5s5s571Z49EQOracv5IG0cL/TsA4lXY=", "LBS6sXp4ugAVN+N6YwNXq+Buy9vSr3QkzhIl1KRBS1o=", "EL2M+6zVBf/Veiv6p1etPkX2PvN+Z91UHvB+lXmE5/k=", "DyoLamZIa1X9gnOkU+9iL0wdTj2XXDTVOMvYRAo86cg=", "KXtOtIQ03FNC5MmiYsIAMxSAoCEJFjhjgFu3D8epJhQ=", "Is08xVK4MQlUtiti1PepGGTmts959V8kTThIBJRqd7Q=", "Bc9Jbq3I6gzLNlAvRDyZs0e/cCPy1/vOUS4cWARfuyo=", "HgrosILTcmGQpoePS4iJ4LYpfSfePxg6qanyyyq7kNQ=", "Kygv/vieHDqQw1m8fIATO59jQhXDDB24KglQEnk8fBs=", "E7rn6DjGOKQamWGrgVIPQIyZIQcNmgKn/lv9HaHa3Ew=", "DNwyDurXC/DbV5ZbKfnMoogm9sRNgk9/Ei5DCqTnRs0=", "G5TtiR46c+G81rep+jNrSFpag+UtXbCLcEr9jUgTZlc=", "Lo12WnD9OVM/HEVtsStCDKwNewhr8ZWWxgzWQGsHbGc=", "L2kiD9kgm7QbDvlCv+sxE3CI/5ozjtKD3p7DqIUOlr4=", "FQbp/ewUqdwD6xWdAR8Lq6ZS2zZLACDzSF2kDvgHnr8=", "LkMJOgYKWV3BMhOuchHAQbKdOUAdu9Tn/LA0GRRJKgg=", "F0JusCQV8daCc1OCRQ78dqBcagIYZx7E+j7y0DmA2yE=", "Iqio9HUpQzy0cay7ztqbbdTp5XEhdFuGV32o0QYXHj0=", "ENBmrwTncI5RKjgjEL2aEMutdRpyHGYO0PgH8Wk9aCY=", "EyLKvSG4+YJtqEgW81mfIKMyS/R7RKvso9jmomv2TI8=", "DpAzKYt/uoEGmtcIpAHMrKcTwSKnkHudLuw57B5YNNM=", "J3oGnT/FcBJJASoPwtltcMWLjwu0Wh05MgUdRUHJvos=", "K2pNK0RkZRbgUR0DWVuU9fMbU4yERVYqX3h8t5FiON4=", "Hpt+iX9jbChqx1khgRNbMGHPAt5etMM0TysyRvF0Wdk=", "CJ1Vdr8Gd5QOyFMeM3YWUKOO2uZptz7l9wTAGDEEWL0=", "EdkctqfJHzo3eKRXv7y6l3so6wi4UORyYNuz0gWtpj4=", "B568M0qjd82vK7BXAXt3atFQresnrZUDHB5tbkWFuaE=", "DuzrZvuv4lUiEkZ/vX7ixTUkRkLIfFTvrtQ74ZNE7vo=", "EYm7GBV1keWCY3J1E57/H/GAIXQ5ur8DaafWr9pTrwA=", "ChBOG8Wu9bozYnc7FdFSo0u2b8rVFpBh5MdPQvgILtQ=", "Eq6rxV8KCnOUhEByQy6fEJWnnip7h2XA5/k3IfXrj+s=", "LV+n5EjroPP3W4LRVdK/tGfBE2FTbWHPrB6err+fmWA=", "Ebw4KtbzmYrhJ2F2Tic+jlfeUkQAiWTdwc59iHs+oV0=", "L53lLhFk1XgkQwHcD1LAnc+3sSSZrXaKTJGvN/H+mZ8=", "JKFg3Ts/GQcfIxEYQmUV5/df0/1NmEedhV6IzEDyoUY=", "JWLasBly3NIwdBf4NWywluWlKzmJjXcAyQgv5mGrWqc=", "DHH8hUTYv+HrV+uLGTRIJfKADncoh0wNSu7gnTf8gBg=", "HDjO5wnqV6VDPvBdTz2P6F0nWVq1871bHoGKdrF+3Is=", "FgIhOBbGDMIA6LKu5QnaTeiVLKb3dfaVGqF2psx40Qo=", "CaBGxnuYAlVNMVgh2hw9EzgxGsqikYIiZFVoWzpqGgQ=", "CirHOjtA8ujZO4iOFa2WlaB9VvAtFy+v3DJume2UR18=", "Jkl/HLPtg/YcMnlfVGDiMgoLBWEX/i1IaL/LaRrMnSM=", "GxqIa5V7W3rzYIMzw02hJMaOE3aX7gguIdbp9TSt2j4=", "Ghzsl7PmN2NhDz/unl+IQxPWbz/aGTmF//+iY4iotTY=", "JOtYZcI5P36dbaegRg+f4KERLEETcAf3H/xT6Q/SzV4=", "Ba1zn0rnOF0YrpYZkP247T6AjeAQjK50PXmVojI5v+0=", "IOpN9kPDGzrsDIwstET/7A8jUYQYJ6ghA6Nv74HCtaM=", "B+Qm18+40O2PFQ124RxCvX0NC+ho98yAdA0U1rbZheM=", "DChBcBOaPTL+uJPi45O+IvxXErSxNOEXycv5HAbHoVY=", "GY6JLgtulpQnefwjrIbtPq9caMefj4gTON37OBvKs+w=", "BPcnS0xGDMDV141jkXAKtwaxiNaky8vcxspjHGF6QUY=", "JXogfJrwF/UMJMgobpmgBvWpoGaZf+pNY8vER50VPP4=", "L5GV6HeSzt4x+CfdQIFgaXwXSoSpzdB81ptEQ6RfDIE=", "AsMkV/HIpIEI8cFkkejaHnSuH7WYZCrOu3bQIQ0K998=", "DRYGLqmltRhK4CLFaOiH4v0xwtLxMgrNkVuE3xzXfD0=", "JzghtZ/CP1hfQj4WxdlXHni0KORGrarnicFZhmwVqao=", "KNWBOMqOHh9BAUbshAF5b3yr9J1B5Z9LiulC3G/grDI=", "DLurSiKWPtUBUK436K6cwTk1X4PeTzjwEXlzVjOuP4U=", "Lym4OftXWSctFRmhffAzEOua+rElQGk7eByTl8DaSJw=", "ISUF8dtzra396mNTs4uFdP1S3oqzy+MxD1JiqUlqV14=", "BRFxftEEGY0LZzh7V2sCC2tkXZTyBfcAXrsEFh6glZw=", "LNF6P9/xsu4VO2VVT8BqTtq3yy2HDBzawOllHCFZPYA=", "JCHs7WXkD1vXt84UerCEWIiFPOnZ6QJC7w7L5N+U9Kk=", "K3uxwTpgXgYiYnGxVn2AcFdrcfvPvg6KDObtmmC+S2A=", "IN6TsJsQ9vQNKWDzrn9wPUr/fU4qMJSBY1aT/B57V8s=", "FfOdppR9BwADYJARG5RjzTInEvX8DbOKgJir1NP97UM=", "BVoQxbLhw9Osl4U9N6zHrDIBw/abp3DJBzblmRAplIY=", "D4b4WFfy87+l+kB2eDWcXkvX9o5PjkryIxTfXqFwywU=", "LVdoDe4QTraIfHc0Xsp6jBMQIqRHH4jFTU25v3oY9HU=", "AdJecXDmuSsrvO/tmPfM+UwguXpUZAjZYuSPat/e7VU=", "Ed3omANN9dClChBn/jpbbp1Ua0JoBD9ZmL78qYAnHgc=", "DZbkUdodU1HThIZDzYKsgqkdKX26YQ4ZaZLQgEXvxWU=", "HsUOLwWvi9FpVWErfdCiKuBG22kqNA8LgUtHLOvvx/k=", "EuelZeZF4YX3yeAPBq3nFzbZkAUucsl1QNeTkSJMgqU=", "J31evzPRR1DOyKXfSE/Ns5LbeYFVmqNQ4rpws1ZWMq4=", "InqMXGsfGiWdX861fX3INCVzF6jBuUIJw/uG/ZSEaok=", "K8xBSnIMhaQvbtFL99Hiyn06pffWHE/10b0e7c7An38=", "H3hkpynnD3fMG1zYbBk8uqlBAHCGPV2jd0LWZeLeMYg=", "Kt1TOhwUtK0qTs14A5c5GsnZrIBoWEw65p9WqeTXLr4=", "FhmNlYFAUzShPhCbBNnR9WOKffJ4MA5WBZUI9u9lRg0=", "CgYKJZnraWtD0nXEPqsLOwS0YcxMQ2z+ixdI1l0UM3k=", "MC57bAq79PRLHXmXka4MyFcAeyijdIeYlly0soGCKzo=", "K4lxVH/xcoGpOUPd7LSJ9sCR6WzlBbe6MMFI4DazCWM=", "IfZ8QGeAV40eE8AB6zak3CtWJNw/ErPkpqAlcLPoTNg=", "DK61BBuFMqcj2caKmQwIOQmrlNqGXmcxIPSIRqx3v7Y=", "DVdqXdrGk5nwb9XiR0F923P7R7UzQAvHmjXhjwpRrYY=", "BtzE0g2nIE5+ist0BLa3Gc0VNq82FumUiHsDMSVhTVM=", "DQroDSwD0n721qxu3Vf6r7iK2xjLQ8s6NAUskqig1rU=", "AiF7JM2eVzyPy6RtMEbYMMz9vo9p5D7uMVZkxGX7a1o=", "GwN9Rleys8QTb/g/LedGofMU3KM+4rkqgGY26FCWlM0=", "K+fYUmaJL6TUl2LOZO+EV1+ju2IS35lLqfvU4sNZH0U=", "LC7Giz/b5LEMo0rR8cnuUpbk5BgTK/2C/Lr0NyEN1Bc=", "A1auDud41CfWqEVFvyQaaE/VYt6pLNMLC3W9mniA/PY=", "DqZ7zQKpNe1WMRlPBpaENPyYIt95H/b2rWxAKgvq8YQ=", "GIu6RnTC4aK40fHbTCs956wvVy6YSASs1Xnzwi4OTOg=", "DYIeYFBG4Lfvxifh8t2EF3pm5il0u3vTynnhQvcHQu8=", "Gbu0QGTayTPRB06+q5kXkMY3pKNMM9HJyg7MlVmAhlk=", "Cz81GzvM2Wu8o0U7q20QvyUjgKHjs6woZ7IU0GOwLU0=", "H2V4OKTd8rBjmWHJJhnur2VgJDwBFRUlh/o7YzvHsUw=", "FzlmsDI2ySGxtuTk53+6Q5A/K2i/g//SsAspdMxPTCQ=", "JVrfzPTaz9lDOT/ZCCL7PpIpKxUK4iBfnuO2g3xofJQ=", "Ktm2R/osXZfWQRpWhO8YMSzt9vaf3vj2iv5DREJIeio=", "JsgVr5uurfCYyL5lqbZpNtiKkPR8h45G1VqkH7I6APg=", "IVMAMW2Y+zvCIM03nLz0tUEz5hO6QvqLSJhGZ++uEFM=", "BRrC4Deoy4RElzgEDLXZK+wev2ThplE4x/LYYqr7u+o=", "Gwz6TJ97SuycanCaEG0Xf62P/GrDZJFKq/M2J9HeajI=", "AIT1uAzTgGv9QPfRiL3g9VJt7Ep3vKBEnxEB8AqtSk0=", "L9aAPlFuhzfEW/L0BzaDHr7Stufn5kPg1MZ7XlEJnRc=", "Cxf3MsbZOKx+hbzPmo3UASctfW1iOo5Z7D6mfiqqUmw=", "AbP7iPbKuA86+XTdSWyfpfkF2poHkBe8UpkIDh1dT2Q=", "Ixn1cnmYHQoSsG8vdUGCav/E5RpE4ZkPswFd35oYNxU=", "L03CibXn8jo3Cw9hBTvYL+TL/H0dEdE/KJ77o6PFQSE=", "G2ebc06rvm+MQq0Y2rVN4IHInWjHCKgfj+YUOJBMKrY=", "CjRTwIhC7zCAs6907o55m/ojZ5DP2gAjtYjspGbxkhY=", "EcidL1SYp4hBbQBCzvoNVELb5V8hImCVBFFoE5NE8KI=", "Cz8smMowYfYnITdgUG/nb/3YjudVZDeIg3wY2/+2jOE=", "JXXHH7isq8XLUTv2bb1KSUb04hp7LxpAYpcqCEJaA7Q=", "HewJRN/dyc/7tVwZAvhFcly5LglUV0nePxoRjUGAFWA=", "JTK5aotQgozGGd3OgKLpkw3Y3sZYj1LtXD4ZgO4DBkI=", "AOs+By6fwr6prqA89F60gcTmvWcJH1n/ofRgL8OZ8hs=", "KKbnRm2rH0k7/KGZG/uIbC75IHcKzKvsSGuWQiaYYSw=", "GLcq1sNyu4s7Us61xl6deMBIFONxO6qBMj8qGVaVe48=", "L6mOSHlP3UzbqOEdDN4YzlssydDbf2WqG2yGCZGLLGM=", "Ai1tBau6tAOxMn7c4zAk/JGDqlFPadFnLUndv8ngY/c=", "Is4KI4eiIyKKCoa5QvE1pZ1rvunxuW0/s6FRAjpn+3M=", "ClWedR3+FBXkDQIn17PdHxiNmdk1WW097CwDPeWiLS8=", "EyAjYPElyiLCgaGOIaesELGWFTI2+GxZaLMatQwoIFY=", "HoW6o3aYUBW6Y8OjjngXqwo5zSjiNyM/TBvjVjL8ctQ=", "JFCxmLBF5PDNVAsLdN5cpW2F2l/lmBavMIBt0uA2xcw=", "G/BHlaeXlTOIb3+0fVoLft0u3MEJElWqy5bvqsZxK24=", "DxJu2UkLaZNb6XEQxHYRjQDIsHxYa6BM+BrmmWB+Yu8=", "CH7UdSBGwiWZRzJRxT9puBewipD0MUF9m86Hzk/SvAo=", "ABUYUDDBLYzKQvIIct5pmYmQHiVWmGOktbP6JoLb+cw=", "G0JLlUbYfubKKPuBl6IYa24AFVawjhkAIpjgXxZk3IQ=", "IUuiOmeiIq6eM7RhWjHnsJ+pEeGIgLw3nf0g7RF36y4=", "GG4O3AlsYlOxeRAqfJ7hSW3bYGDJk/qeg2FqfapsIkM=", "FRvJU07F82y6zde99hdqYMm7e2z7JoWce8wNH3vE3Q8=", "KBkvYq2XMj5srfy7mpn1utpord26w6TdwY5puVI5sWY=", "CCWxIy5oMWePaR5+HrJ4iEOeEue6/4TbPRi3vUUXKxg=", "CZ6TUAtisQEnYJBx519MVMrXhzK0hZbRa0Tq5Fmln8c=", "DdXNOmRzH4A9p4cwV+sKSaKsFb1wV0hbQ9RzQKICq7o=", "HUzxYmUQZ/gvwhJPbWdNrvA63D2nWCK+0rDYtpC2o0o=", "I6hrRA1e+7CianapmTtuwBwztGkkw/YB7Xmof5xGQGg=", "LJgzAqxAomy7Mj7Kho6adX4qZgU7sIG8pV9VY1FoiE4=", "BumNO6+9tC29LqL8uWmCc5gL0cgI8ffeeZYyqQ/wmzY=", "Dy67kRkidsp1IQhM/3oCX+U+FOuISYk4HXnAb5+pCEo=", "C2eIWtnf2sX1Np9uMYG8x5CBmB62F32yfl1vbYUdUCE=", "HDLiEJW+t5HhvHhQQ7szzZR4S2Ix/4+Fqe3/kvkb5Lg=", "EhgY36dtmFicMnT+LXAtqDrYjO2d9EliZQa+Hu74MmQ=", "KDKsm7ILV+zJabpP9ccTxAYi+mtOvtBmxlW+IdoCQQo=", "CRcYD716GYFuj8OkX9Q7Q1usay3hn1FrN2QaaxxCNDQ=", "G9hfTEsRrnFfRaF7oh3b3H0cO6aA+5eKGyrDJb7UEac=", "DQ8qhvsNSN6ogEnSvLZnAwop1yHkwXdtQteDu8/SKvE=", "BGCviPbRGvtdGR5IhxL9ecuWEWhESRtCd6wLXvGbRDI=", "C8F4PDasyt1Puj1jTp9yxekCX3eEvT77jccgluLFYDI=", "Du+4ePbrFYnXpofpSBPZ2EI/pQ2zTejV66rBMC5vRdY=", "AaxAMZZQHwBU+o1LVmz/23+B9ClTjbm0CKPcILksEdU=", "HVvd59ZKY7rMJYW4oUCC2NNfO6jB6FffH3KcUuan5dw=", "B5nfr/Ln1jBBSn3bD97qED4bw86vPMzgd8hzOGnlK3U=", "D+D4Fu/XSn66XI3V56iUOImWJJLxQ1Phr8eO+sUO2W4=", "ByVhxnrS/AeTghtQUY1LXYrDOvJtptLOd86/gCkr0n4=", "KJE1KsYP+wnpyIZguESd75mG+UY/WoHGFafLn0vgcks=", "IG6e/MRsriz8foZsraCkxywp8jXwRNVsgkSpLogvRks=", "LnxEk+dwBfSUB/LVy0bN1tBPIqBhrI/K4E0tk9fI39I=", "C56UTVus2Im+71kJoTn157fyOhznoeVabEucOCpRFSQ=", "JjW4RxEmUjRI0LG85dj1T/W8mIoKb+U9ynITBPj2Iss=", "EN9zv92rmUzcB5IWy1heqFMME9pY1jga4MUX8t3IjgI=", "LaVPenv9ePQMmObsrbZl8mRLCpU5sndl3yProkH//Xo=", "Gc41xqEE7jl11KlJCPWx4ERNdwm9p8X8WaUnyywWZQk=", "GkfbveLVAEob4O18IfV6OIochvi0Zm1NEY7pmrwRWj0=", "LwN+c8eIjO+dcEbljZmIg3vo+so0xYvFDwIehzTFOZ8=", "J6tycZjZt6YuDZmy0REnEBAkZMP1+o3v8nYq+Khpnnw=", "MBF2NZvptmWryN2meD0713MMS0k2ob2DzFV0xpQIBmg=", "Aw6HIEzOQD7k6S4FB+jpnK4wlZnc4YkpqUMBAPxcCGk=", "IY6GU3YWlM9JofPideziiGam6ZY8PubupGwrGTaI07E=", "KyGWh6RUnrF+KdufzLV5ahHdtvsnG1pUeUbw3jJpijY=", "Ih54STnSnrVEL9FhKzCli55VWjmLrpbWotbZphbs4Ks=", "CA+9ubxLToqDsq2JODslUm4zBnjAV/fDSZPyfu0uFMQ=", "FgHmV6IriigNRFLVJ77M/bnYw+38t70DctDfQ+k+kSM=", "BlLR2Hja2df4VOSAZlMf/9R3PopcYTAfWBZRtQ41l1E=", "ENuIFojj21i7YI7Jk9NuyFMa06tYDmXVN/Tzfk2iYCc=", "HYoGtRkn8DeSUOc1n52rk6qcz692TdcKzM7HF3pMcDc=", "GcvC6lC3v78An3CdFZqp7yosD2ily60fXhyZ6iyiYj8=", "GlJ544iDtT8xP4aufrsH17sM1li+WQqjrDtBNBX+Po4=", "GvE21TzfZ2woQQBwXQSpdmRSNPQ5cUD9haLYikhOqws=", "Dbivdk7vULsd3M/gWD/3MAiPPpwsVVJ4o8mnN2qJMjI=", "FhPBS8hvleJeBfjscsj/aqIHvbqjP5EoCKxpPxN9XVE=", "D8R++S8Q950zZVCrPgp1RcdNLT4rn5e8xD5Hg9HZjPk=", "Dyy/QLNEcHzOEB53l9E3qeiwEXl8Zv5vsEdNK3ESQds=", "Lv1Xd/jKImeIOaxgwaMIcDCUqdK+RBPIF8dR3PVtjhw=", "KrTjQTeVrZppWwRpXbMbawrQvtkb/DNzkmW73CgFsYA=", "LjtthYTkJmaCnA4ZVXHFDX+nv6zsErrXr6JCdE4AwDk=", "GDPxUd5b2GymjSZNXeXTU7gSipbjgT7SzQDjItyRyNY=", "DqgsJS2NVUma1jxhxHQZyOjkIyV3Mvn2hvaxBtfa8Oo=", "CYV4dEImk3BafJgGNAxtoHd/RXHpIXTV+CwHuR8shb4=", "J3KseSivCnmTH4iofmNN1h+szPYQy5R3JOeiEQ1QFEk=", "LmIjm3kFMHVsoynGPm9DOOJjHvTizGfoBG/i6Ib2dpo=", "AmW+9rks2WIphiHiYJyQFi3Vh/iBObxg10vzY8ZxJig=", "JEhMDCkTeZF9L9i0hDn7PXCwWxVei88zCla1Anz9vDA=", "Ky1Emjq1Wrfud9N3WdtYrbyR0NUJNlOM+wFzNgor2M8=", "I2Y9GVb88acjCFglzGfKyC0+u/0BNPhhq1Up4qTH3lc=", "KPyuwPts9DpXMmHRDtMsHbtLmXVkP63gBTLBvR6g5BE=", "AUXG4kGBhanrxyzY3Q9T3FN4UetaQu3cBMqlLLOuir0=", "FnN2oEIJnvrhzYmI4Cxm6M/aN4+qZOhWJr/kY288WAo=", "DLc13g5hKmFXWVKOsnixs0EHxKjfWOpnTuf7cZ0Nq5k=", "LWe6xmFswEZNT+kH5faPDs7QcLiBG+cpBb93WPPr6IQ=", "ANvSovjX+/OsQDsRFVIxErfwEKCt9spYTXrgP5R9IWs=", "EamS1+ggV1euNrurtUToQ7AQ/dx71auqgt/dyrP4XHo=", "Iw00NBJG+3FbeEeX6d2LtzB6TEbi9EcNLDGTQP2+ACU=", "Cf7v/CGKr6YU6Pt9xOx4btJRUOwdNQezpxcLkmb/aUE=", "Egj/lPEiO9JJ2qTjoCZuB5cx98P5mLf6cH3Z/lODP4I=", "JgyjzIIPhzljzSbfG4/+xM80n6vhboHy+XNmNGaALak=", "EmVeLJitNexEShNOVc9o3N5o8Up7c0s4NHJTCGCbyFQ=", "KQCX8sBHo91mALcGN30OHEYUXzqengum18za97fgXvk=", "AsYuW9ZTgeCXJBTOAJCpbCKwVVv374sq6uG5hICNT4E=", "IzxkIwjb94NwFCB4ixkVPc8IimPo2nZcUYJklCSSb7s=", "K3Mo42jtS3pi/tucv1AQRVe2w9m+XQwnRbzHZHb4zlA=", "FzjqlM1DMce2CfQvJ8TdV9jbeLcKldoMI5TE7xiZKFU=", "LpAtGCof4fPUDaKMNYx+iQdtLdre+A4xuYle7QLKIbg=", "FoP/foSlpPHayyBvxE/JIXnmZkUMWmX1Q1S76GdvWF0=", "EylYRU4Bwf0rxD4CQk4SlrVLVdPdPtHhy884J5DWJU8=", "DetIt99zeSZrEj4LbYOh/gMYB/HuN/dnNzhDiupk6wA=", "LGg0ibMGXkrl1xBuGPRVN2LVjM3gBu6WvWkfFAsV84Y=", "HXwXtSHhWK1CDJ1pI39LpugVJUHYeOJIdkFVcnNMzzI=", "Bk3ufwTPVkMz+9xhCri/aBBjKe7qwbGllhRyZWHbW+8=", "IelOXZra2d/8wYbgMQrFT/OLCinThJ/jhHd9AEir1mA=", "Fu4KC0UXDYnF2RVX6tCyU8OahC24BBlr+gcESubitNw=", "CnAJ+CW2+hgEVf3oqQHUKiglDplIgH4kpigFOIzug2s=", "CNWjSFPd+wmfsP4d90YM5KjklSoUjaZB0OFfce/Sz2g=", "D7GYUxvK17yRSJq68TRaPrxfXe1bIcHRcjfMz5saSBI=", "CpH1DHKkIvPwwGz7FAHcrebLmcKFsHBVQv2q1A4LUSQ=", "LbM7NOXZqYivNVAa9OE3xHF0gbZzKSJG2Y53KKE7ySQ=", "G3Rf+cblPCddN48KadbA1V1ZhUnO+8dmm7Y6PUEA7U8=", "EUVU46/JbfO2Y8YiQwReJ/aiSlwmuHXnNEAUsqmFgyc=", "Gu+WjbR2W0UPCY1OGmIQtxZcU+8zaz2W9V+6xYpUK9w=", "JL317E67FttHg3GJFy6KVbNgOMUL8fOM95BVJ5IlvlI=", "KufEoWVZdaxwUtEB0TRu+hD8pbDxO6vd1i3++pgP948=", "FlzUKaOWbRvO2mFLBtRZ56Dgz75G1j8lUhya90AoqPA=", "G7PUsvZ0QKX75BB1aUW3vdyi/x3tP+IQjRJWeQl7B34=", "GGlfAYVECl81rXSlRR2mM37aBJ1QuaXXuyhNUvkDPSs=", "Ausb206qP92qYlNE6mUK/EYDBuDj1Lxhj4Hp7XO0Og0=", "Heh05xPlxo0vVtUY+OqidSKf2PyKfhEtfRok5gTT74M=", "Hlpv603O/CtopbLD0GZNqrsfBzX/Ki0raEMPTTmxCfg=", "J6QoTuDG9z3a0C+dSZvpD+3TLr16+G9ErFDjVPdDx4I=", "AJnY6VRv2JG7q1R6DsHcg4z2ISZ4jYWydZd02d5153c=", "MEOn6onR5P4U8fkbWE0Aw7p5gx7Y2GSbW6/PdaAM91k=", "DnquBNq/o0hZAk0HWjAU54yQljY2kPU+sOmbfWKIl+8=", "EP4KEcQDDe9yXOdoT9hyTgbWzw0pXbCbQZnrO2qfBrg=", "Fozfa69elw4ea9eAmTHUh2VLQuntXY2SpI8dro0rTCM=", "DSQdM8VSyFVW5ip6/knlpxKP6KohB3K7rllXy2CiOcU=", "HiXA4A23fGm4fVvLlcupNLd27CM5LYzOtsOSr+WWHz8=", "IrDlL3ZqcCr8OMLGAWHjUtiAP5IEMaz5QQ9/0R6dfTI=", "EuybkfOV8WZVZzGL0/ztenUsoB7goIgTjEBUmjEWT7Y=", "KZyP3KiRjCTa+HaBIlinVSfxtdF0Gr1xqC6sDh+/INA=", "D0KL+R1NMRhPNddwpUdd6/Q1POfcqbwidjtplDNE8jU=", "G+BUmlRwyUKfDhtvlILzxOdS6JwgPCW2JIF/Ujp56ek=", "D9zDzgKOlrIfkbyHrQUteORMpslheerWQ3jNNW3SrMY=", "E2pqmEP+EEg43AhZksDrjjCf09Fpr2ivgFjdi2BeqhM=", "BYREFYHOY6TtIXTbNTZbywG5Oy7AL+1bbO1zFKEn5ms=", "G/mrkLH1z2yp8Blb1DNuaBNaWuJrazURzJBhVrYhzBM=", "Kwv2s8yc8CO6E9xlAfAKdC1E0mtm6b173Zar+7M8x7g=", "GdGGGbtzVIWQwAx9AuyUtSu4u/GqXC7gbh+Oh1mROX8=", "FJCfjIkg951GhqFKGqbgOnG4TT2Raft2czF6prKEM/o=", "I5fzEfWY0knmzNua9q5b628Jf1o1CIbNrwaR0Kir2PY=", "CsL3o8Lkpv1Y+eUC+d/PyQRgh2PWm5TqUCiN17Y7OEI=", "Cr42pwSKNNkRCkY8/y+iO1qglmo8WNMIbsr6ES9QAdE=", "JFrkeQEHr8m5vR8Uwg8Q2KdF8HfrFalg5devN5oY29w=", "FK4RCygpEmJQ4daU8IQ27gxW0jC0idCNMrw1A+c79OA=", "IKBXbr3vCNviGRYP3Rp+ddg4dwx4CmKLHMcg8Cf2HGw=", "I6Bcpbch5I2lfTc983bFJS9m6fljxpfX2OTs21Xvgzo=", "KBPYmoqQYcMANIzvqUR/GpY0PzKfZcThZbWxOHxMZMc=", "K/fuVC4y4oCB+r7dkvSxgZG7rkikNic9wEkWrgmmRVM=", "JcFI+ybP5MPZd7F9oGj9Z+qJzFEHn7XQzTZUqRiLE4U=", "HT3SPmBIhm8IVXQZA3ZYQnVqYniXz0fZH58rHsirK70=", "CveZbPpLURY7Tqj/Se0uv4peVqRGh6jeNR78Fyyb31A=", "A3DfvZinPiSVLwII635b+oOsd2HYwLS1PsZpxpNphzA=", "E6rNv+BaBkf8FYoTBoA8vR6/jZldWye8XDqS0EOCQPg=", "BQ+0/yP1Z31/QrDIGEwiS7adTzBXmmuOnaXSKk97+yY=", "DLL1zuhcxuD5vss5G37dQsr/98NDgqqeGd5HOixn45M=", "ChRkMKmKhfkG0x6Mp7J1dXCZbbz0CnqotnUGZ7lqLvI=", "Ix77I93XzDSFuLyoEomK78gJUHjlRxUWYqu6DM4fYn0=", "LrzACO0OzVUYKWVsc7a6jYsO74ca77lKIaPrrINWE1A=", "HSkC6LYnwEQ76p+K6lYBsh3ApB3/2YoVFnYdQA97N54=", "J3NY2+CcO7lXCIkpP3lcQdnCyQQlvfGipWb55O5GgZo=", "H79pLofaIAvE/9SJiJPO+2WkP8pQT29nUZP41jxgObs=", "DzuIH7ZbMPsvhJYg50oNv1k68zu4ChXrf7iKCdl+D6o=", "ChFvoyyXYQhms6k745GQgCGb5gV6S3W8o6e9e++Iuuo=", "MDhKMbgMUy7MoS0sYc5OuYCYp1QHmmmw5E+qCjvv8j4=", "FAPnKYFK3bz4CeSaVGXta6bk8DVKmGzSfp0Dqmqf0YE=", "EXlGJ+YSWsRl/y7XHZWcMYYKotjqw/pBG2gVK8OBzSQ=", "BwNU43E4mbOK10p/XjFU7KqicxS0f4V3O24Gb9TmPbo=", "LR4B/ntJZg7O/Qk7WrJpriAw/Xgn1kMMK8xT0oAGMbA=", "EaAVM+NxPh84+Uw5BoQzI8DIi/q4A+E1BCuhuLzu2jw=", "BY5Ly090Y7xtAtbEDX6Fiw4KrPw6iNwyAYfYxaAV0Vk=", "GyrTh2LGkYIB4JPSvDk/n8UP1fRe2UOo8Rsml4MzXnQ=", "BaudOTpLt+7gByPo3maLJAShYqDhdXem5VuAJbGBSwo=", "BAWK3rWt6anJ49hp7bcDIieLCc4SGbpFaFv49tac7Xc=", "IaHHxiy47OjTvUNPh5NsOhhCQy8vGmxmEBsayNEcmhk=", "ICjvudROWvOMDB7TX5y4Q/OBhO4PufHEISEhBUKwAQA=", "JLB5LWnrMTZM3It0wQkiPBwtJEQExkpB1RYHarAkDKA=", "IXn/UuogMu/ZWsTno3qcDOUDTTytNmEFNB4W7HSD2hk=", "Kcuts393PG3FgMwMLr8pJtWYoZ+kH4geEs9KXt+voT0=", "K4kvCeqfYP1yBIUva7mV4gw1EGSL3EALl9+3zE1/vfI=", "E7rb0JU+CWFaThPUs0D04b8qA6LfXmuPr2nYaXmQyVs=", "K4/t+MNmKwoQV2ztvXIM7Wn4YhJP62LuyDxxUNmTZBE=", "ArPWLW7+oKIuLZaPkZqL6lZ5Gje58h0D+VGF2ZJscuA=", "BwN7rItmkHlN0JB/fjFbqlJe3HKYM8icZgQG3yG/tlI=", "LPnqR0k8t4Z7hpQuNTSHzU9Ms80z4xDp/UvDw+a1JC0=", "MD9aj6rypq6teA8qE5N9df20YF2PWmVSJCZEKQbtrCU=", "CRtii9/U1JMzwqnthKuj7C6rM2qNkaYFud7prwr0TyY=", "AfRo9u9cNdPJVZLiex3nohOHimU2hav7DSly+w9/njI=", "H1kjcl2ZGzbehVfSmc/ifYsHbGQMxM//zlfpx0d7iaA=", "DdXXsdDVImbDh8fhEfq46sRASyB7xeIWq2S34QQUpr0=", "Juo9xcvQG+HAbOwE7zKKfSZq/jP3a7sm2oRX6WY1FEQ=", "BnIxh1o9U2tFEdCgsht9JJWKS/HNHuxMWXwl46AKyzY=", "ByS9TVI6cAVMmVJBtn9K6k5mlFit2aZ3nYnPPTvdnag=", "HMnb+KrUXWcXjFuRoKpEcBYoskEgmQ/m4pAmoLIem6k=", "K1hBRTpmU/0wwF0lgdv7+sW6ib2niEIgjiSgPEb9MqE=", "JaG9ksnKECJrz3+9mx2OKyJ7wt1OPUbhM64mgVRnT4s=", "AcNS+9kickiXq3mmDkflu/PEtxSpB8Y/TvzFvVzG6Cc=", "BeRIMOwXCkpd/Z3oRufkIq6cuYxvSZu2doH89g9+grU=", "B3wnNqwtCgcKGhxuReqcxSYgHWaO5AQJa2nchQhuqcI=", "AwPzT2qiKaUij+yVlUT4Me5xoRN97bakt2RDAR7sMUk=", "JzARVZ0jkWDUY6K5iQCWukVY7/e2Y3KRCCxeqp/7FT4=", "DE3F7+AWSY6oI/rV4S0uAD8stOyqp/DgKRliblivp9Y=", "HLmQ2An86j2qjQOzvN8Uemkv96DY8MEU9qCA2qWjrBI=", "Ggo9OGwmw9Rn9QunM+bXkBpZt0U6SjQFbpLncbbdT2w=", "INgWGMDmrl7DA8/eVDRicQQWNMs88iIZ+ZmlS8UDO34=", "Cjm6j1fHk/5ltmkHzGVql/9SOBfPzsy8LC3lu7jewMs=", "DeBW+zGVJt/sFdUCFzSD6jXmBX5klJ+252kNPCWSP24=", "A/gqwS1b5jmXR5T7PCMiv25homLHtHCsXpfSCkpNiuw=", "CDWsYQAep5UNgOMvzCC8DHGX0Sq7C17Zk5IQE5DeKkY=", "Eg79nAZj4O87bFlkFPAYpzy1UyZvvLFWRFLfkBa7SXU=", "Ba/DYC4CORvU4sXr3aKACF7CwfNWo6XNL9I3K+bz8lk=", "D4hYKTWAJPwp0EHrKaQxMOxAOSLER5xVqzs0ZTasFZ8=", "CXUsIeKpx9bVuJY0KI4RmgxkBqvp53tK0bjzbJ7Mjxw=", "HWuzLUFLj5hYOElpSterV4XYjscL3kvNdQKHAWr87rE=", "B9RVzWmtAOk7CaxEkV9kp9XqPEwbPRdrtRhZY5+SS1Q=", "EYiGiQ99Pd6a8SBKlZDhB1DJpgNeZrmLutH7YlGBq6s=", "JF57NkOndmVmOV795uR2Aar+MHN4/QANoI+swz27BD0=", "LOthdgc6mKZhO0D3aGVNrY0RmuZO3WzITks0Nw+UCdo=", "G05NQQYTroN7f2p/UgagPp7KZpL6lwKHpTMXmQzoEUg=", "CABXuOZkrVgOpfOFEFdm/A46IiZSDPUjYElz2idNENg=", "ETHsONiWBWen+pvZbfp/1Qg+FPKEMBKrNulG1LkBsKs=", "HSeOYsWPPBfhR2n+Pb1sa5+v8R3vfQAwZtjmsP5/saQ=", "BxBDH6iOA28YDw5NRujteKfmNhojmr14e2zi9UYVzLE=", "MB6GsGk8B99g+KwVrGscqnbxPvUXVTXY+XYAuM/jteY=", "JYcDeMC3BoBBuSp/RLSFYFRIRYxNLnqHomzalMpAme0=", "EXYhjUjDnOe2z0bnYNNIhxJmAFywB0uYhussS+9b4Js=", "Hh78OwP++xyXKJFAlDLAL7D06bb24ys/wQlCOHqagSU=", "AZLOT7l+7HaGByEKKo+xyymCjUvYQCNvFDJ+GG05Rs4=", "CdlEkDRWzEOkPpgnNodVuTijHUKkfMbZEMoLBO4Q/Y8=", "GOQXk1dYjyMKuI5vphDYgkQqiVGcpxvxDYumT7KqvzQ=", "JdD3v/Iqnpl3XY84inTU/9cPnfcdl3oH2TQ3n+5ik3g=", "BWzg1HQY4sHtfqY9ewbct+cGir95R44rU/QC1YT4AUw=", "IN15STB7ws5TMjAi/LZ2U3nJU+hVH4eMS3EgU4ehe0E=", "BLl81aR4dJKOjjrW3mRCJkk8o6h6GbGC6uiYEts6oGA=", "CTdKEKpssLLK2qIenxBFn3k3b4rQ/QeDAEW28elFJgA=", "IRS18DjNQA0klZkW+D0MyCc/f3pRlVvbpZ3z7l6kyVs=", "J1HYEkBfE9IcTVk30gqYHbfNWTOCISQYlhVhH/S6LZE=", "DNkKiCJ26iuKcnPtoVWm/Z1j3QlLllAkQRKBriurv3c=", "AoO9rMFHV+KDmOZ9bnkhUplR7a8MmHIZRFYZXpeBWB4=", "FvF51NxPIQHOqNEnptwJ5PJez+T3n6PgKFH8BhCP1Jg=", "KG+R0bednmgdbFQL0Ur4MpnP5SVNmhs6pjTlRWr7cA0=", "FczfrTTSkiadZzTBc+JB35ji/XXobmHGE2nG9Zq0e/E=", "Csa5DGt6R6HtqdSm1Gayrf4HjcQcnG7dCjkDA6nfIQs=", "JUl8pRXa/DfBJe/c5+5mByyNTBUqKjD4Hhlf2+x2SYI=", "KAlIz+PsoZ4c0Pu6pf0jo45nKFR+ZI/oC6lHxHWCfis=", "DNsbZBK225fcWSvJZsbhpn/acCMurZoVfyf2AUiFRz0=", "DEONWr71BCoKY7pDGNeJEf7FNz+6cr7G/S9SvLOGaC0=", "IZ7Fgsknjnjkh5gCPFNA1SKg9+Y5hY3kygEZnERSBgs=", "A6CScwzDse6opadhJZ3SvqT1husJp77rF8KaYlu6gXM=", "EOu/w1Iz181jG2IEzcibpP2TKuBYGoVqOVqKUmYjOaM=", "Is4IkNnvTysO9OaYJ9+2jzpupsMKJKZ11RueGZttfDA=", "GJSPWANbsQlWvfbUZnwuFs4YRCoZuMKB1JsuJlNP2K4=", "JhnO7cuDS6QAiFOutqjWFE4oG3rjZ48dUtNS8EqfDfE=", "AkTHTXk/Ghbxl6L7ABvdMemG8JSoPgnVjyvFrtLIvrk=", "Fuvt1LI9RoufNsvbNeABh967FWaMGAyKsznuW1nIfL4=", "K8Qcnu2fY1IyRfS0EiFnFdKb7PUdZgyGva84gJZ3utA=", "AJ7b9TR0X4xzWsh6YC2Aa5ncaAEut9bCwdTDigZz6iM=", "GNrMjRMgK/IyYW86F1vAIRiaJaKW78mXeIB4KzFAeYk=", "CyYAoHJj6DrAdrscSwf0jywqPPa/e+SvdyYtORc1Tuk=", "J/bSD84OdHz+Q3dDMaGc/kwjTpnRgDMok/cFhKF/EWs=", "EFC6IMj015ehruyd5G/H95TLaRqbFoaKLe/+7Ruz9io=", "B93SEVoeNTEbBSSUucBe1H/4/i1BgXjsYASHrI5l2iA=", "FSpltUeOD5LsP8NgFD5qHLg9bplmgWj+vtNxYK3aiiw=", "Id5E6+SEUjwXqc4WL0L826px7UQ3+M3riF49SiBcNww=", "G+N2RKHTo5e2tUmBBWjsdjahvk16ZK4j983wfsk6ARE=", "GOexEmkyIyYKJd0Xxx5DG+XtSoq3N/N3XvYUiSmPh1k=", "ACP39xC8BXd0AqIb7ENy47ZIRz83R/HrKKeMfgOj29U=", "JHDeI2d6AWoABMbvKSBkzux5zRLLH6SZkqO5vNCiXeU=", "HR+/iy5BAAgD72pQvkCZh8b1LYtTthfEBVvSTn0nv+w=", "An9f4fS+2wZEc75Lbqwez9ZWrSCGq8MRtn86yLjJ82c=", "LVOvARnfp3wo3RArKCj+6Ar5rmUdsQFMPzn6W5uP+FI=", "EvGZR8JkX0SByJET9FFGQfSvt0qMQ+A2YDboBUmnH9g=", "LwBzZ0v0/XnSSWOOxkeGqURftZDxCI6+Sk8B/l9MJRM=", "KO1FtH4MRcKavwOyZdn7dQADepVlTu1LbPShhdHJrro=", "KSFC3HZwY5LzAGuPW0WkUfPDfsutn2mycRIRF4aDvls=", "F+qp7vPcmnBZv2zjpRzqSkX/A7fMYFy4sFw+3yudZ/0=", "GhZ9Ik9wO4PyCprh3JC+d1Fql35vLtB9qFsGkQplvlY=", "CE7r52axQdei7Pz/CHULBL1v6oBTWyoOMK6JM9mAJso=", "LsD0AsbLlwnm44F+KzZCheGMq+KQv4uDh+nR/o3tyi0=", "FlfibGGg62+LynTFu/NKlHdy/9bCwPm2KDah6P9vR4A=", "H4gnvrfayGlY7d3qOLKPmedxgPPDuVmXk3jEd3ZharU=", "IXoH1lkvwAAfwkC+RPccAX84cAYTG4PyN/pMlmjtT9M=", "BZbZ1shPdFRw/JmXxaHOnU45BOF/FvE54fxvC/J62ks=", "C9Lx5hp+1HcmSC3nauSw17QXOOsGyemP8Cd/6hbCsPs=", "FOTxSyp7v53Yw6G1Jgw4RFGcO9XRObc0Rnj3Sjb05Ko=", "CYCws9gHEKFn3xR/nUdaKNyvkYpqo8lnpbtV2XqPbaw=", "Jabe8fGnno1jVmcd8cozUN+FUGn6G15+hvJ7r97mCsE=", "LLJCopckdA5j2EiK19rWxdN+nl0JFVguenHFPlNrZOY=", "BrMtwECLF4LAUrulh8N5zrNS+ylXmyHGGAzT+zmrevo=", "CfIKE3X1bmvuUyasdWNwm/9ukBgqwJLxIUXKCI/fP0c=", "MEAoHEfTtu24MUGCpZWh8+Z2TmYswOyHi2OIJt09t/g=", "AHLtoWBoPDupyg3Lsn8AhQXoOoXrWsdTt6Z6I9JFUY0=", "HQxAa9QLuP6ADKc31QHhnxWPogXZ9jowtIfmFfRyFAA=", "LhtvcB3744RiBhqR1fZBq8x0BqX0Y4IrcX3nk0TIqds=", "KRjT/TMjcjoc513BsfgpSNKY2hRjZs8BZ60IL1r7Kqs=", "BKjt6C6gxWFEOFj+CNLJBdzURfUbEa/UH0Z2Zz10rwo=", "Ji929a+/3ITCQOaGNi8lzR80l9GVx5pAzJlyJaQ0koA=", "Dpg70gKkJPJKg/gXNzfavyxxHswFIE4dJrT3fx8QdSY=", "GoyKOxODekplfCbQ+ATKfvg6rH51FhhLTCLrev76UWk=", "BaFvJ/RgcZ+LdcScHNrzSHOataIWp4MDm8BV7G8K7xU=", "EJpOICpdbulDshONxePIaBiLArpXqxWKRuAzWQ3rHQI=", "EUvmNuEgYNMXp/CMRLhWFE6IPcigevH2LK8wDSNBLd4=", "H+zvroYHrrLxCSOeBh0YOd/KEmNKSwAb6h0RkOTsgCk=", "HPtQBrYoEUewXcuKCKpUp/z+mxIfEr026YnS9Hz4Cc0=", "LC4xyicZdZC7DUZoKsENIAnttX4KiLR5DXMcs06SbYI=", "GPKgsAtUSfS7gmXZvCsDoxoc5quuXq/Z7sLzdFvlYbo=", "BDG2xinOvc5ESwr3ffCAhQYQb3ZXIJqclsc/a0TaawI=", "DPM/wv3h4XG+FR7jRFlXBe7J0JMDQUia3GQz/bmUH5M=", "CgdDh3sooqZ1lm5q1uLK8y94++gwvLAYerpMIf59knU=", "GVudKFpY3q4wdYoXfiCkz2Y1DPS+zYEmu1uJ5nLTn8o=", "LD6sXVL69bRvylS158Fs2VA79i/x4/fK+VFJAhVER28=", "EACDlu1+Jgl9Y4Rxbd8pkxv6jPiNDxVAa30+MBRrzCw=", "CdYSDYzv2NuZopBiaPwRb10xM5wRkIJS7Aj9Oa7mbHs=", "KfYP374Nd8FkGCW0meJFL1/KPftCe+B6MiAbyzgBkYc=", "KnfZiEM9rd36MXzxqGwlA/4BlPwVlef4QnwLg/kLQYA=", "DJZQ8UnJlGcMu5ZvOQPlKmN+lWtXkvtpoNc3bnMugRM=", "DL+heyNH5oIfeI6aRCVcE/UDJZjR4hWoIuPn7Zt1fLo=", "FnxMmV9aIDV0lmePwawz4IQxEnrvkqmgBkTGHv+t0Hk=", "F7CTeNqa2Pp3tdENtsx7Ui35Vmb7IEr/I8C5qeujeVE=", "FURLNGou7kAiDVq72jAyT9QisSvQYlB4h6F0nJ2+q9E=", "A9CKJvhsl/McTNmgGn9o/sjCCNQuyqftLP9zt03BhlY=", "HFOckkF+DhGyY9maD62Pxh/RwGXnA5mv9RLYd3188bQ=", "GbkgnhBV9ARkfS8L1IF+eYlyln4fdoiHf06FdAD/hSY=", "AU5zJT47XSyQ8ZmVnr8HGxiTJvOdF3KYbeG6edty8KE=", "D3aqignNBCVZ4h7fZElVV+gGWSodct/oyj1YOgT+vQY=", "B+l+GXf4c6BYHtp1eVXJMnSodFSmXm3++UQLvhLwFIk=", "L9U0r53zEQnJSNWl2TNrjXvFGJXDS/zerEj4tW2ss2I=", "G3lxxkS3/VFwM7jfIyXfgvoio7eanuADMje7Q/34dyM=", "DIMJacqR74e+EJr0bQrWLJPoCxypMH1ycJUIyx/qZKI=", "H9uG80Euuxh1Sh+c9N8wlssRuonnmJYilcyiVMVl8ug=", "LJpcgkgcrc3qa/vaMDQ9mBUiHimuYXow+VDSmDStJlQ=", "I7GavB2+NKl5NTfx85o9gZRNG4z8TyawY5yk+uzZjSs=", "DNaSLzMEpNA4gzxpewd0FHlyUWvcj5ZWeymmR2lxVIM=", "GDIS8uQn/BCAwje/rkID7xJHKgbIJ/k9ul1a8k7DNqY=", "BEF6DdbT2M1tLvgcyDMzItcPJk9RAIdKTBYD0db4OdA=", "Huf9hq5r/pFvvYfPCnKkvkM9TT9bO5ZwftoMR6Qiw6I=", "Djht3dhw+AQd/mGdTdju+FGmORz0nu728fFEPuoXPRA=", "CzGknpV6w7x/8PZe5v27TPSxRd2KI08NfmwGOb6gB0c=", "F77fnxOrnOim4oGQR5k5zSeGO4kv/NrgVHighZx+7cE=", "HCj7M9md0bOuN/iE81UlRqT1r65WL0hi/h6S5wJAnhU=", "FcbQo5QWaWfLw5KAUF65UozasOpS8VlcXnhxgV/9Asw=", "I2MDFQ+edlA8zxvlyQw6SF+Q98H/rrscT8uqgqBRm80=", "H7vgdHvSu8PMu3Us7ZiXcxlC952adh06ukoWloHjD+A=", "FHFG+m9GT35YoTBEQdK39kMz4hd5zXH4gJYqUOpjhbo=", "IX4CySiUFRb1qaeOulFGjZO/snjRx5Bh5mbfSjIJLAM=", "JGATtCPMiToWtowiiwG5OAtHsK++Tb6xtDQPWAG6TBw=", "K1IlSWweb6zVt08ScFyg1Ke3fDDByDEcPIGDcWerRe8=", "CpUPVydJtvrW1sMk9AVo1yGedaiE+bv5QbIO6BtCwCI=", "GnGIjmZNK6m7paoi+8OA8pgQ0JJ9KGr1kRB2nwf5l24=", "FcXHIO9vpbApNjdsKYOUu+3OWYJNbKn8Jg9e3I6l+rw=", "HISYPKsy+5bM0CdtJfy1qXjt7mk1IMCxygl3ksvRdC8=", "EHWbenROgTIvg2j/+mhFEChn4hymiT2XtGMJTscqHiQ=", "GrQ/Gs8odjdn5YdUKj85nwmYtNIPUy0fWzk17yyj/Go=", "HTLy4MVkJ1gN6WLxR2M4ma5yN/TM/N1S4Nm3sDfOIM8=", "IUdQbgD74PZFgRUSbfnusa5MMxpKOBkVzBlb7JSIjWU=", "BOle2NilVGlfKoRBwXXyLGGrBBqk0n5IIQYrAveimrE=", "LMGB+U3lcZ/izvIiJ3fdmKranUy80Haizss+p4+L/q4=", "FhX21YJsqqZ4xOXAHO9JtEJEgVfSxlHjscmdMrLFHAs=", "BUsOJJHT69F/f+4LDc5nuCNG0iSqqkd9XZj94r9d9dM=", "IQUv4X8/gzkK2Kquzki3kk5UuAcLYwT0tOirn4lJNxM=", "Gx2NkFxxOVjdMVsMhKZdR59vuNhphjDn8JY0K+TxKb4=", "CHZd+SFBzHtRvQhz+1JZqKzVqbUIKImuVQvz/x6M/Dk=", "HdHiwGi2UyA1Qv6jdGMp7KlUueKP3L2JWHCzLzSBEFQ=", "BQWCr/38Tlw85z10ZoC4MKhDk5VhIWdn5O5jQlAuKhg=", "FRVyptH1feL6nkqqVF/7hCuxhK0+CwveKScbVXMuotM=", "GNCqOAw3mo5wAFMqZtVhQQ6NEY0ur7bA1tP68tyOhb4=", "JCSlhrtXwIg+5MpOxzGWnHQiUCyKIZy5XO06EgmwX90=", "AXTWZDzLYyoUsRFi/DVwBgTFk5nToAf1+JFQS899d80=", "GCEEyUFmBS/cdI1JeZAROHkVspngSoDjPmEnQHBuemo=", "C3DBGFIw4i3LlIQozt3p19ycln69Ra9NnNYtoHvVIvU=", "HbRLbgFCuuEHD3NFIrwdQLmc/FHmL/ba04n95dxo7KA=", "I3eVmBGfr5IzNqLp/hWnoy1GAKix97vHPN3xD8qBqrI=", "DTENCNSMBNx4vaaH1IoAWYu5Y/CbGN87i40xYpt7ioI=", "Kov04tUkduxIgpqZ+lO0fLEEW8P8zr6yUiGBhhYcezw=", "E8uw84Gm5mCcP+QHfc4NoyE4lm57ooEolgAYN1hbLqw=", "KuQSZS5EFycz4ZOf0y63gEZH0pdop0szUDayRVNXG0A=", "A/Qmpcdwen2hqDSPnmwObVstUHu+mKAG9xW/LyjBQzM=", "CS/R/T2cW/zL0VgbShbsCoCRXtL1aj1AmbI5qbREnNA=", "ALHoFt+4OaizHdzlGWPzUhExpayhz8s9IEkvn6T/K4o=", "DNqjpjeugexfxrT1krXgT3/Y8fZ7kV1/y5XJxb89fHM=", "Ef7Vuec2Vik4pXGq1sG/mHiVvSXVPvtek6iVidY40Ps=", "DQa5A49dBBqe3RFLPWNGrV4R2IF9+j50A0+4L8+8hjI=", "IvebPZ30JW/INfI9XhbI+WPrD4DXa5DEevRjt+5Jry8=", "K7Ls10vjyEfH3xShyDk3+LJKO6J0SVmi83M91Mt3fms=", "EL0dYRcH6+SoLSypYuAFS7K3Yx3oXjRo+vAFre3CuTE=", "L0A1/bFiLSPRucuC2mT59wcdCXMs8XpTzoQuqkLzZcQ=", "D6fYwX+nAYrRTwieuFZLyafBV3ALvQfDpkuiWLjnkg0=", "C4ypNoi/t8GuNlrrNEYwwZ0PHnS2Zt7CsAQ29Ja8xdY=", "ENaFYUqZpAVBPjVZ2CYXUgWgP//ZsDfO2QvvCvDbGnI=", "Bo4WLGoCyu4CHW9EYftOHKHWCSqF2QBEw+sU4HxOSoM=", "L21qDE7iEpZJb2mpZcuP4jm5HqgXZ8uCBkqKpeJ7zFY=", "DGpDmu2OyGtbpfKkoEX68v5Iu0Qtn3UhvvSY0FfCE3w=", "HmsNS4jjk6nZFcATtP2lp8O1iYcsBt/dogfh1mQari0=", "GyEW+KfeaYHplCVEbBtyDLRJVd1L1G/MbFIjYOHGvYs=", "BQE/AMhnc945wBujzO6lwM2w2ILxmVafqzfEQOJajlY=", "CD1DDEiexoTBZN/b/FoFVt2Qq7sRqLoQN7kufDzkLNM=", "Gw36XC8PpzmwOwv/QGFsm1qyRsKWlEc9biO6XF3ZgoY=", "BVP9zqFJjyipxKWG1HsCl7I35ZwsDnA0RZ95y6SykEU=", "FkwnLELh+Qe6n8evYuWp3INunnEk6sxtvFz+7jt05eE=", "Lu7pSTgrdCKaOl+GQgxZa4IkIg7pwdCTz5ZcIAPHc9s=", "Gqe4mdtCi2SfoeRnJYGQnxWgkcMBxSfsSlTDwJPtYAM=", "KERmcJJWUVfyqIoFWEUK3MOI5hSNJBfKw9/5Xr1wcwM=", "JHwNhljGpX7Egq3F6e5rtnlI2Wx4GtmDEeJ5uB9n7zU=", "IWIaOzxkiZkbAA0e/NxpsKVA0JaASX1h6WKE5mjJq60=", "La6qsSWf9lltCe5LVnzaZKsPuIoxeDJm5dFASBGOYvk=", "GQbK/n309Kg1mkgYpO1bZ2nK2gouBG4tYTi/j4RAn00=", "AMKttRYAu6kvxT3CFl+A9wU6E1C+UPYmjb4YsQ66KzE=", "JrKFFpIlZY+MzDBAzYXDzh9Efkfut76OO23zjfPUS8s=", "HCt+LbVk7vCQncd1NgSkzF1F1kM1XjxgMh0kqA7WzK0=", "Ldo+n8CdLC5tUqdr2oTfEG7SNv+VbxJ6gE/HAlv83fg=", "EZGbj0eX4O6J8F4EKPV4M9i150EEgUpqtmTeikWIfvY=", "EnuywehVKUBYID3npz8FXG9CYBokdbHXX5OVmTraex8=", "LFkxjPQyuOSZqZoIY8kU6MeDaiOzG8dYAoGC+DKD9hs=", "E7JGd+aK37hz7Q8jsAJbtXR6X8dENTAl0hKNRHAXrH4=", "Jij+JrTSvF+OkGefeYzZ3lpHvS8EhlFLbbTHDPPCR8M=", "I3zRYKHWrjDvIMk0dsnODWBmwOelq9Jh+qpLzM6v6rs=", "HhrVhKtnXVtaSu08pbgE1iwpczV0y5ya2iV32Ha5nCQ=", "D77XMaghdN576eBHmFZzWAq2zEGUiTiEyfUeoR/+j1g=", "C0QcjxQjoppxsdyxb9rQMW1TNKKY/USAEl5ghdz/EHg=", "IU5XOmxX/32jlsCqFe+qIfwJMMWZhM+cjHTa3jr5YfU=", "G25DZFduM6PPVL8hwQqRxI9+3b2RBrUFlkro4LSKXb4=", "LLYNwwqvw6mfH0Oes0w46KerJl3kb0UAPPJgDzpGGaU=", "CBwLXFZxHlQb3qwVCwZEp87iVRAqRiLdmQ80ENFoU8Y=", "GSD4R66Dlpr1vjlaRZg4mEoNt3MQssjFM+tgKQgyFEQ=", "G9FMtbCVDTtHg8U9LHM6KubpFOxgFVFwORKLFUdGrvc=", "LKFnAOZxNL4O7zKfVh+wV4Z6sMZqf6Ha1s1g6zwNMvo=", "I6S9a+9/TSHCYZJHVUckVmP73TolGvyidjbtHe3pU2U=", "AJAgTL5VCjbxHJ0SsqVqauc5nP/LwWgtdknN+hK1s6I=", "GumUVtDosjhRalIGdVnlmSB9ooXQN77Vx0jzmm+UoEs=", "LBizoPxL81vrmkAGSmnH2Xbv9FuuLBaRAFy4NawH9E8=", "LcqUS5EBHqnyJP5eBhLsICHi4xHfrY2NUjdrYN0pY68=", "LqkM5/NMhkWWYX/sVitM2foKy3EWFlWVetRhXr30ZFo=", "B9Khb615XzgmeZmnDr3ZsrJN6FqtEsq+EIVcK9cb2i8=", "I2RBX8hk30w0Go5CZ6Hz6DLqUUOk4mhuDYRAwET/hiw=", "L1yIuWrthUzABJqbpHamumF4nlaSzy19jZp8x7nQy7E=", "KZAqrr8+OPDvOcN9615PsPMvzyO3RRGmIUaz95wl9u8=", "DhkOBX688CzgNg92/Vsnmk/iuoBkbtacx9VoQR6By1E=", "Iwl7gsDHXlPLgISGnlFAC/+eHw11tSUumIq+NWJwL38=", "MBgOF1MLhgkBsf3K8jsu+8E+vUlXTmmqbfFZ1KnchVM=", "EbpgWVmvtd6S0KDPaJRbXmYKWebJ3S7kg4qeUt03oJ4=", "Gfi+6zYpyhdyDoMmnAECeCMaMwMZvqvnk+mvQVGKNMo=", "J485iXzINhAzDbJl9vlZ7Jg/oTg4uoj3aq0DTC+QFRs=", "I0nKvag64r9VhC5yuASzZDWkngsvhQHwCFZgXiTew4I=", "ByebdfenwSEAXDtit9GdrKtuFUPxK9NmXDGBjF8seqE=", "AGpJzsBQDAWb9hlw06A8TsoHnzvqdr22UsnBPrOlfyY=", "AId9wptQQBlkRIVXZnDzjKUxSWlbWqzFxNUBCOJoMQk=", "KUlKSZ/XzE40cwxIsipimyTXSnKDAGlvUjvvrYoyn3c=", "BiCGo6JPPdByGbOJdcRRtIQJ40M+yobAgyBwyC9tuqA=", "KwDTnu4rQQanDqYYTZXcGZkaD8IcRycXdAwydqmpBRw=", "JceI3t7jazgZJVA9wb/IHwmHY2S3ZJifhrmpZCyS7Os=", "CjOdfDOZ6wCQ+cqIcZb1Xlkn3ehoLDf8noUAXQyhTl0=", "AQ/d1NYo7sxrtV7E7VY8nJ+9du9FxZHCIeCLZvRMlXU=", "CMrX8J/NbQp2OxU6a6E9CeT7kQ6Yp0VwcJXEKsMvfNU=", "K6jPOgcTjAhkMmPi1O3PmkpHMov9oTft1BFboLMnTXg=", "KAxarbkvGGPAqyDKFLAbACAbId+3HB7TKVmyEt3o6K8=", "JDxDvmJYhb+6V1S+/9uMTicYvRrji6w5tmiDogMkVH0=", "H7in25bYgHW3qzbnFmlWixqIwLzFcqsceAMDxWnkEIo=", "D3rfaifrl50KFHtBclUFjj3TmfJU4dFXHlpgJdhdWT8=", "Kpwgv7AjTdIZrFkz52FgQP+Y1vCZtTzp27dreiHGVek=", "LbEaddhkmSpt9Wy7HrVp2jaSf0M2Lpg94St2YaqR9GU=", "Kc1j71f/iXrFt987qO1y1Dok/xigPKpNmfHlMZDNI5o=", "FNBSGTLoc7bbheajqrABRpoWjpeO60wak4YZDddO3nE=", "Amo+g0BUy0c2cj0dFaJBhp+PI0ddN35p5KNzFonN7RY=", "CL2Cd0WejgqDWe5TI1QbzBRlsnuWhfzw135Kpz9KXqI=", "GfahtagCK9Ek0mKndJliERTIexvcjorHFfDZBrX1cfA=", "H5lHfbUDGwunI7HAxtFW/ojq943gkkHx9Z4INPkcCBc=", "B6h+2tUGfzYd87dk7zf8MRdeAX2WNaZijO+RWPY9RLM=", "Jk/hYcmKLARRS5LyC3XCEiOywiZV6P4vduTOjSVjkQ0=", "Jby6g5FZVL/Go/5bzPbsVmiOwgnPH5dqSEVNxt7QeZw=", "J0KoLEGuL/aOUkgDpD44fkJelDooR/1ykifNAbcH3P8=", "CkvKIp65zqln21+GUPOpITp+q6BmRSnsSMtIFqMvPkA=", "Fi279y8x4q9ajGKXXWrdDddHqGgXvtCdaQ0glawfMCo=", "HZDTqXBcWpoeBsd3yRWNeGA61PmxDO9BqtK4AI2Gv8U=", "LpfaEI5BkgxxUH0//EGY9OQD/AgOMZO2NHHoFtOqZVw=", "K+p8/P9Gy3mCjRvVvE0Yo3V2W9aSeSi8/76iru5FRRk=", "Ll5U4PxkLYoKId9IMQ/onT7Lgb0tVksrEtN+pBzmY3Q=", "LfSkS+XvwMYcSWqMtyPp+v19yoXvnFulLHGnj/KlnZo=", "HdqcYIM7UmdsyUduy8s07n9bdZ/A+CKfHWReOAc/4FE=", "L5Hu4FT6UUMh3ArKIf8lr3OByj9O8JovonNVxPvYhss=", "CUMnp5ci7hFqr4GWxIRORC5/NkROqcgWlIQQ/xEeNQM=", "Dg3jKevAE2hGcapo8PXFamWjx+MbNK8o1C59tgay7Es=", "C/wb2uo5l+Y9tj6U1DB06jedXV+WFu3Z8ZwXh+SHWTc=", "LXQlbUcOj4k/WmoScjfCRQLJ4QVnuJL3cUmD0ULQB7Q=", "EIUjBipRqLQo7sKmYoS+vQfcHu6QT0NHCD/REgZJ1hY=", "DFqAXS7H5rMgHklUGE3dx6k9OfwiH9hnSzO2jWXKnkg=", "FyoGIVZz4MBDLJiszhxCbP7WQIUBl+cv6EizPvvIgIo=", "D2XQP8zHU36x9P1sXNBfsEtAOW6ZMoqenzRMXb0qLps=", "IMMK09a1cld6hzOZYJPVuTn7gPLnyqU/DMlnwzTc1vw=", "A3P+veECYP78bOlnCRSpzsXCBaddI972LiL78xph3qM=", "IzS6wpuS23acBjCLeHlDN1un5FYP23Qaplad6NFkF9s=", "Cj4gyKYci/rsvWXkOxOlk4KwITWM2/epmAXWWCL0N7o=", "AOp4umVSiscDXgb72b5jpQ4Mr40GKPM8eyKdCTGqbwU=", "DRaC+gqSS5s1ERiPvI8h38b5747qGJFgfyKx+RZyBNg=", "KESo77hTsttjSjzzbOfP3DMefzKwA11nBd7BVLgktM8=", "KipXRmH5OebGpJ+QEHorVKAAICL5Y8IMG/h1PIJrrb8=", "Ec9i7gbkq5JsSC81Ulpd0wCiWb6tTNj7lJbKBqrJBlo=", "KQRcf6nHP8Wx4TSZ0XGhbzdryLgS8mVJCLXs0rgmF2k=", "BX5EN3ZC1PPHwWJd7C8/TSLpFcfpBVKHmvAW96FmXyE=", "JYxGQKwdqZW9BSX6kWLXyzpdmyZ9BEqMPDxDEOaJcf0=", "CV7m/1Vo+lNQktdMFjEeR3t8Yrq1/VhbfU8b9lq0zGw=", "CAaVEIjW+DYxo3GUhib2ZiWADVth7upj0NU/HEauTiE=", "LoysX+L3CwJthPOfG8gPPr/yCTYlodRNjJSYoxcu4vw=", "ESquPYAyroDf4CenCWHATRfJlgmjjCpuamCevTEqEUo=", "B/G9KJqu4fTCgyvNiHRjQ9ISi5gm8Y/0egLGBOBLJW8=", "Ag+yUfKUrR/D1VPPncUyzyEF0otBnLM3m+VPaDhNNlY=", "CnYwnvTzWg2ULSrbQAQhAxF/ipL4+iJxPlyPRjCjOv8=", "AuM4puJ2OU5iCFUTfSPYbnO2qcRHE1Q+bvDKNzAytmI=", "ESd8Ah9LsFZhEqYtApifMGvj1qYaVdbCvzK5stbrSI4=", "DkFvWXeYwkKBPQfwL6P1r9PNI+7ovsBczzIoDS6vDoU=", "EkboCh6Q2vj1DI5woZcyKcHAR2omLfeRNgh7OyUjJac=", "Auf1asUwAq/t3S7PSSULUjTUDtJZJM4E2lL7E9gZfbQ=", "Czg/RgtxPRrywnIe+G3bnul7TVEoGZPtt3RyrO5VKCI=", "AUxGtKPyW4Wi0Qhc/agSyK5VhmALR2rPXmthRatEnFI=", "C6OpXTwos5LzlXVpF522NVk6n+XqqqZBAlnK56ZqtjU=", "ArvSrTELu10lRjKIcsVLZOJasF40d+BM4fAwIe8xuQs=", "HPBjf/Kr1ypMXYskr5mY/CnV8vpiq0eRTfFOiXRn0KM=", "JjrN9F0HnUOxQ2Yl2cMinljYLa86QL+J4mcv9nhbpYA=", "KBHrl6YA8TkSNI9OmvR9MNvggFDqCDcBDhdOw/Os24Q=", "FeaBlgg2hRsVyOmJbpHWX/sbwkd5TFkA5oroLxz3Mq0=", "Ghv117c9bLPdsPzRBlUGdM+LSSqGRA+QmUVDRx1VRAU=", "CRN+hzZJKvxtcU2FTsG9jA/mPUAproQObKBfs6izYkM=", "EAdaAjbjxpOOis81dZ+MGchjAmC9jlhxbt6pcOwCulg=", "EmNEtBy0z92dePkS4C7kcFnAkVn5fEKUPF0rc1tnac8=", "BHKprH9mAIgQiaF18yh//cAf7leAo44eCIsG8EcCTE8=", "DlKxqNxmAUoUr0gLgMiz/ZlZJjPu7Wz5UG5PbKm7uMY=", "GQ4wfmYmrHlu18lpMoANPxVcqJ2EwDkrtIpgsAmGdUA=", "GQF1KSE+HLMxodB2vjJUyO5dnqQAXpOVcG6g+RhJE4Q=", "GInez61WyxSm4pKAkVUKRQT7q81xqfTjiVNnrcz+x2c=", "FLN5i7J3E7P5L7CGSSNnM1QkxW4Oe9msObVYX7GNAGc=", "IX+qC3hmxmCnAP2vPvBDis9E/HPLfqvF/BkLZMqXBW0=", "K/Rly1Jx/lYxIbuQh3qCHVKfyBX87jckdOwCzzmPm7g=", "Bqg7bzNBWTTMR8lSt5EcV0DY1W3mo0g33PgpK6gjgR0=", "JrxLcVLslZZ94YFi2gQAorNpyRCIg1ZZ2pV9HOK0nno=", "DZvDY5qx6aUCNMENcEHqIiC758lBYxiPqx955lbROxg=", "ExUvBxTt6Xu67zop1E+0Qa7oGNrATxHk5cak3DHIyzw=", "GvwSmmdLpKx1Ut/q2a6NLVhNx+Si/yzOXTtvE1DgjSc=", "KEmLBF3RubVuVYBl4NcQBnX6FihKwM7RBI4HwoChdF0=", "E/i69u/JQpTIKCn1naKshhkbAxu+Ky/jMs0wLNXZRsU=", "KwMU7s/PYa19TG2Me5Xsf8mez4pkjCHiP8XxlGQy95A=", "K9AjKfVz0FvRTrWXH45t+UOOireLLTemjdsahF1M3a0=", "LxIe6kYuLb4lMYQDDEwaWf1Q+rGsXEnr9iHzI0fbwMo=", "CxHKFlc221P//XLg2Tmxb9W94HoDZ427b+EwLf86vi8=", "JE2dm5vb8KYiGT31tT5TOuFGrv+7lYFcFN1ENA4ZK5w=", "At/4NH5kwJZs0yfEMdQrv6jkPtZdWNRS0khvKv+0/Po=", "IjYpkbq+1Zxd6dn9lqM5rJiBgbJWvxrsUqPQy4lS9xc=", "C13coEz2YhpvIrlLkDlaWPqPHPKW/lvrQEnHVl9PKlA=", "A7PtxrN0TPBXiy7EDROpnevbbnGXPgpA0mW5mlTWMQ4=", "Ld/Zpd1tqpBRd5Egyxf/kEbt5dqiS1wzNo+4S1W+440=", "LpKPJYVk8RvXIVa2J/A3S/ilV8SfiFmKyUAifKL1mDM=", "D5cLTihOlal5CUWaNKA7kNyXA7JPnPBftSUMGiSGEHE=", "AnqALq8vna/khF+bMJB/2zn92cRMXRgWEPVYgrezgd0=", "BKx7wDGCvoApqEQO+HWiSKSAmF5pP9Tq65JjfHPonjE=", "B18xka+9IdUUl6JsUkZl3nQxVxIfCTwSDZPhgFgur4w=", "C9O+khMSH3ecKysKAkvoK1GOG7wTSmX0QMRHap6vWF0=", "DJvOlfLVln07WPk9fgPJMXCRfqU7X4sn3HCh+qtHTN0=", "HjsE3uauZjVyLjVGVfYDLRpcoubXr6DHewvhkvTwxvI=", "DB/DO5MZXyqsA/5u7z5BEHhMfEgyLjDuUcvXj2zp2Ts=", "KrYEJn2uEklFUOHvJzcI3RHBdmZ3D/DMfAd8k1vyr4o=", "HGmYX/eFWVGaAFLqBeYI41ys5i237Mu87FWvPbkVZGg=", "FjNPzUISVjmM3u4IqTRaUn3stxoB60NST4092w2yTUg=", "B++N12ZRUvhdAJOc+6vP434rHvineoRWiu/gHx6bXqk=", "DcxCbciL3sjChI8tiKIAVxuKASzQhw/G6guYFJT1gng="],
      M: [["DQZN7oJJKNOfKovn0vpYMiPDOZV4TSKIOa3eJVlZJZI=", "Ky/18nUxtvPWqF114+CPOi8NrDaApsJtVey/gDyoBWk=", "C2WISc5iC77v8jO30SJYAV6p+HpTkPVhSYHrbky0pfo=", "EYEy+8HNg/lRZ8tEc9VMa9LEF+J4Ll7+oW5y1HtItw8=", "C1lEdo1hwbNWKldJ9PBsTdCFu1Yrg41+LvFKIf31JMA=", "KwTW/7r3FEAS2SxcYhKAPAtbzA17GVC4idH6bz5WRFo=", "Kb4qQoNK4y3jMg+w7ka0wQKj0a5ExdzhUv3qtUUMnEQ=", "GUb+neCpQ9WnFurAhWHNkfkDH+yC2pq3KIPHshixHrc=", "GvPKYkClWrpV345Jg1uS+hfjmtVwHvcPgUQQn4lL8dA=", "CB9YqRpODRAOA2n92BoZADU0L9BnfuG/UhXkf45YwsM=", "IqhSr5BoCoypaItx7SfBV9ArQGvWx/2BIdfHeTrSMF0=", "Cye6gqD/uYNomBc2rpJ6IngomFwAw+XfjBJ2sQAQiaE=", "BLRlJiB+3HCg0jyEOLxJo2VjVVLe4kBmGize75ZvIPY="], ["LYxwA1cxrZ77qSghqIEZ9rgYOjYr5kFympPWoyfAOAk=", "Ce80kq0Z3R0L++sZEzCogO55M8nTs2u1+gIoO65dYF4=", "FFjeUWpTQZDFVQxqG+069TXDiyQuuSkTcwluxg45wfE=", "E27yUVlV/2YZSY+sWUJIFhifiWrA7Wm1mFTRBd9HxLQ=", "GMv94M0hwYN5ei8IlZSoHNgo87B0I3HtAuuD+wBk3UM=", "InV9qegiNFKXvQYKP3G7HnDOl3BJw5MjUDVnfoQ1cxQ=", "FiKAUSXd80TBjjUdEegikWGLl1girQyQPvvq2lpR1E8=", "KXZdjPd2GaWAZY0Sf7b6pE1scKD01l26qWB1S0GV2f4=", "K7C2sI/BvREHDtxC8j6Ae4LouI73A1Xfx04Jan/zgcs=", "BJUedHt65rmdklAQjF0rcBgak/8dS/cjeB4bk4Apgnw=", "F3gLlGnoHKcMfLtDR+f7QMY+9o893lHQTLR7O4P8KZ4=", "GRPVHZxx0EK/v2Sdnm5upf3YK0/TFz/y/gK4VYJSiRI=", "Kp40KlbItkZtP+UzuJ8atEG2Lf8xU9OuZQDCw75jZeg="], ["B7YgyKeOCeSc5UeqeDqnjz5FlMSas91vYCvGwDUdgj8=", "J9a9GHA9fKkqokB20xh7bAAo0LYhPZ5dLGYRUjehkFE=", "KWnrUBbySzGszxc8ogRmjcIimEW/ZEbOoAfBEzSb1Nc=", "KcZ7zgS/0CD0/36sq2y94DSyL7hjNGdaNh8FnlA5UxE=", "EkR0sIgp2bcXxQiEvIlc0/gdUZhZ0hI116dEUNCpQns=", "LH4o9Z/oqKO7L6KyseEUzig/4iqXij359ioXHLHWXk4=", "FlwLl4tLtkap/yJaxJAFISkr5UyHmILT8R6qMQM0FIc=", "AgZhNLspnZ41nLgqg4D+tjtg5LmFnZuYcu2vkVL5LU8=", "CTcu0Yuhp3Tq/hv/be7EvAgUsImcYZb6Faes0V7MXKI=", "HjoTDoyv+bXlY+iq+EsvxzZo41HP0oz2b1AS3mE0W1g=", "JVVDoxSvxaKZFBMijHXq45i5BXayO2zYYShmXMO9lHg=", "B2VHRJ+gOEXxheYVeKWo8mg6GXM/wExzrGoLib67hFM=", "L5i/CB4Ot4+AJcA+6cGZ8ug4xR5aCu/TM+n3z7OPU0s="], ["IxmWtZJShXVWfTnQBkWoOxOSkJO7+gDWpmHkppA1HQ8=", "GT8yo/g592BJycvyQUWQaYohGOg2WDJ8QziqNkjY99c=", "Cl2mWbb8saQnPht+O1RNLL02LKxJev0AS46pIP2wS/8=", "Aqgyzu04N+dCGW4JSR/iPj9uURJuq5rOyW5xlTEC7yQ=", "CYuyxMYzTf6kdNBMsul2GGH2sYqAWKUrYZ1iJ6JiKKg=", "EBdJ+d0mBRkcGWPyVpSuJn9rRL/i0a80/vy2XpWHhLA=", "DHteCTQ9tcY8EQ0xddAbtJgpDZcbHm3A6aDp5xWDVrE=", "EWoxPQDPmdwY4h+TpbsZgBi76kt83O0+TSEJcd0KaBs=", "BATA+hvR9+BZBUy7h/a1xp0RRX5Z+QQZzkvRC7ioA98=", "DBwhavMwVMSX7wQ4H1hYIpi1QzX2Mr1irdKeCAZ6Wdk=", "EcsgVE9DQ3poin3LVzp9pPjHtENzSe7fP85DKm88FlM=", "GG8WCuhm4QxL4Op9IEzWTlczfGDECzTDo3HXU/L/ABo=", "Hh1ZIO3P6day0N2y9vdBr7BlkDQPwHsYLqfD672TOTE="], ["BOR6cuSbnFqj9p9q8i+gq2QMk/xSTdPFCEhtZvB5hSo=", "I10OcaNQ8fI9m7UYKsROyeRhXneAHlqtyrgzaq2xcSw=", "Ehl0DEJHQ9u/iWmW8O56QHa6lgpX6Ndnm4KEeSGFcNE=", "K1AfEAPieqgJ3J5c2El2o7jBacHpxjl314I/gNP4I74=", "DzTbk+qNKtfR7/httYIMx62ke9zYyC0Bgh9cIaPqIyU=", "BNAqsFgm+lC8xfmvnjlkd+aFQtB2toPuYbhYadRTWJM=", "K8yC51ORvk6pzQ+KUF+eT2hHePx6mxvOt4aLspnNIHI=", "D+KbW+rVTFu/QmuxKESikgiErER5BhAc6piImGoDCxE=", "G7IJGHCk+sA2gv5bHi61axStbkj0Z2/kFFS/7rD/1Nk=", "D1TJxSKlx04NTgxjYRp1AmV1dbepY8DnhtKnYcToRbs=", "Fg9awLJIH4AZ6V4LJkRbpk3AOkvooVRhSWJH5qwpACo=", "Lz1rjiNhFmCJUBuRR+hKtrCXkqwXpfCA11s+Mgr/yGw=", "G1m7YOmGGUmH/OoHBJi8x8k91WHOivX63nVM6sB7FwU="], ["Coy0sr8/DF2mceSPg+XBswGPDTEgCm8Z/VGV2yLu9/Q=", "HfXJ72lK/mG8JTrpCKj2rwoIzbnnip8yLCI4gyLxbCo=", "E0QxEo5f/Aq2ATbF2FGhHc3WPNzxetZP13UXcB3mdfg=", "A+pOK//gLaWXfO0fGm6FLpIavi4BXzWzbOS9AkbCzYk=", "BuA8oRRnBVIrtencc1YO7ua5tL9R1I+VP70fAG11inU=", "AUxJnuUZJbIx2hfue1WnX5b0YuQxZ17jbHvk6bBp4mA=", "BhHs0fN5oAYrBcSu2xALwBUkTGqI8WMaRWzCrMqJMMw=", "Iq83wOSojerp9/rYOBmRBzXLS0kxHgquEct1NNC87m4=", "KZ75Wu2MdUlNuC6GefvG1aPS4prs3PaXmpsnKmB91d8=", "EDzIOEvhvhCHubtHwOtgSfheBBP3tAjx3C+h5vxK+Rs=", "IGz0KQrJhENPp3S7D4kBojOQVjK3k8gLHVmWbpanODI=", "Ddhdzwj9ONIvMW2R2BLLKohDCHda+p9mfGyoCVQ5fIY=", "JM4Ky1ItpSfT6rcoZc8HPZVLq77TzRcGqmnXZ+mv580="], ["GLuwArRvLl/sKxIPr4eCLKjnes6U4DqrXBbEuTFzncg=", "HbICHso6NiSn1FuxbPSkTir0+uDcKAAw5+vlU5T2nYw=", "CXxhM66o/kjzpfxBa99eRtBd4HI7xJ5Tufteg9NQwpU=", "FQ756TKnS43r9nAIBkEzmxJoT/WjA7L7fB2NVvVqth8=", "Ejf0TwNrLaAGepSUczTjr6KsTPEAmJZ2b1sZHN4oSXI=", "LZ6pnS0jcygmbVndfgGLvWvMeUHZ/18HoXuvAJn2FNI=", "BHf5UeGfUxuENK11W2eD1htnnvu4f9lW45TbnENOI1I=", "HYuLp3LEzacujvmxnEJNVdVyUbJHxjK+olUnGvz8cLY=", "IGqi824ysrBta+SK1JPTVMp0aHU/Um5r2CVJ/DbNQQk=", "KNqTCazKED7PGd9ypyITTVMLrmxmDbPDZNDrsgDCrqo=", "AblDWFXWzEM5JA6fo4GcL/QgmA1s8Ucht15Msf5X4Rg=", "I4gy5kMVjpZom1gDsLd2AbWb37SSYROjRV8f9N9uK0Y=", "C0O4+sxDz8BntVE6vM6EZQS5OVzcFN+WhhpSilKuLsU="], ["Ar+uGwVO8ukk11qKASg9opEDxXutEp7IOWzidLpFJN8=", "GkaiZpGEHCYQmjKuB+tYSmuK9lcnPNxNihEt6gvMhc8=", "EH2geE37MU2ChZvkTTe00rY0XBdLkWUcZcmESWgqUgQ=", "K0WzviZ0/YIFFqzWzGGDxPrg9+36mvzQLf7szQK/7UY=", "IILpEDzEUkWSQokRFScxKGD25+6UV48BGPSpIND41SU=", "MDqeIoVdldB+gXLzoFNtS5UUL5YrAGqKsJ57tjNehIc=", "KWNRQxPwRvhE+VD/6oD15bQktwfxZZlmLlouNmjL5fs=", "BLf40dXsi/aJrfEtZWuU4VsLIpwWOMnEdX+vDRj6ZDM=", "JZVHFotksqIolBpULzlKJpnAgcFJRj3Cw9If2LLk8xw=", "J5Gd0vnT3J/L2hojuVzyPjYw5v1SEPrKas9GKbiOX/E=", "K5I35ZQeFlfvpQe4ksO43Vf8jVKHbstZndXhBStrHy8=", "IC445mmINhnsvGpqRTaLm5o+mrZ+/vUPiW3+SLeNPaw=", "JidY+z4HaTaZX/MUDvfRsKHg/kJApQdH4sPBINl386w="], ["BtEBsZR30WJ7lUJYG/DN+rOLBc3v3LgZZcW+ANeA8ZI=", "DK6AzAWu22bW5kmwV9vFrpdZ2l17Q9XiWkAOH5Lp0ao=", "EiVrO5nTHYo3KYb5XWbME53SPpNUh9oms+JJ6ny/ka4=", "I4ll1liWevorzlD/GMu+U1MnxlsLduUNowc53tJetJI=", "I6bhQyhOjyOMS2Mq14rOWw3NlKiXywXR4pe0iA50M7I=", "JOE6OPBNXg/Atrbg94KmpSOos7ASciS44jdRucufiWA=", "CQENc2d2IKrhsPqAI/8cgSMTrpw79DBm6mC8GrR3p/g=", "CkHlpEId79Xtes/UhAE5WkCaZ8Pt9MFozjNo7ZRCEtc=", "L8fRfzqa/B3iia0PlBJq7sg0SYEgYpzIfEWGxid4AHU=", "H4bj6dFH7WBMceH7bvhFnPxAABu0/FzMJmFmmxVavro=", "GC2Pke4qmiYhWzXzwO7PjsXMNgEkz2uQPnDKgxJpddw=", "Bn0rYS119Pl0MS0Erg/vQ6NbYO8FTA9HUwLFX8EL2rA=", "Dqs/JkF+a1PFMgct6S1Kp4zN8dqRZgpGGrsPn9e9zX8="], ["GK9h9hhP+F8QTCvvF5s+xaXSQt++vo4nopGPYg6KW+g=", "GVBXrxMZ4k3xuQXG4uspVwA8/DSwAcDlS53PLqXfa+k=", "HZUuv/y+3SYDbFSh6KKCj+MgrfB6KG5/LCEbR/bD7oY=", "A3C3V6xs3UZhDuwMItQ6VD1eBIJXe73BTnEJAwe19po=", "IuB2o6puv+mWugaL9b/7F/pyQzjNZ/Z+olMwGVxigXI=", "EmhR8+rcAYMoinUBU5EKQeB0s1RPBhClEnOtNpi+DLk=", "A2H0CCt1puvSP5pucwnYxOdSAVnaI0Qe3WMaasFMIM0=", "Gr6LrbLRI1O5u5gVIIapQht87hd2FzDiWsKE1rHtezc=", "FafmSlpG9Zc+ToKiY++QXtZPGCsgQbqgChNZ5+nF7ac=", "DhVOvVDbPChk2+HtcrCBYhCFG4bDU2ktF0TLM3K/py0=", "JVKNXTHb13z6bnsYR/joTIHB7VuuKlHJ5APMdUxUu1U=", "IfDGuJb7FCINgRRBYpx4+Ojid0YCYiDjMczriaDuiaM=", "IK3esq/SDnUqOdLyHr3cJ3J3OwYpItyN07oGiDbbpGQ="], ["EeOnwtX3Q3G+sYjG49ehSzMSivjuModUbRLXd3zvcMs=", "LU01rNnyij5r/WAUcpSCk8Hk8ITHFN2xoHXy6unOIbM=", "JjCbUstV9upakDCwE3j2XS5repYZkm2bGx4hy6Afp+E=", "KqhMHvnoSKZPdIuA4nndz/hx6cTD4vr6r3kVmwtOQBg=", "L+MbDfBPJ2pSW2GazEpbo+tY2MMhxiOQ/rqwXs28eY0=", "J8G0Br0Z7RPVM1ULi2IRhrH9R/Zx5mBGgDF+ZjiwkeE=", "DOvPMJdbNyZ67fUh7ivHU8NCTcS27fOYT7Aq4erUTa8=", "KRwNpzHAFsDWxMdThwMKliv3ous14VqsAvrfUwJ4o9E=", "EhbwVgfgMuSQOKwUWBAOiayFGaWjzuRUWwiFDYvxYOA=", "Ga5llFodvtOWXy3jo5/y1Uqx3uDzM7iPtJ7bP8mseJk=", "L5lq5iDQCj1OVe96bOC2gTiPG3/zh1tyWupuuQOdiyU=", "LIJe5WHEq2oiMxF3mZyJgG+8NFGDh+gHwgw1lzm6nrY=", "B1SUdDbDze0ppgyeiYI3whg6Sdt+cOfrc677S1xpMkY="], ["LeXWp6JzQ90EIqxxuNQJtDzLC2cul4+P39IU9NeGZAQ=", "Al6y7YTFIKuhZOM/A1O1ExiGwPvRjlVpVUFRLexWOgw=", "ChJSXweBMiNx/XCwkozObi6qpnuJcNzfMZ3yXoAZpt4=", "G79D3bWgsNKEWSOxzhKCkjWcuzE8WHb7tS9eax/LcDE=", "I+jDYGrugY0q+oxEZdXsucRb3njdgZwPNaYgWTwfQuY=", "FYiA9a25bdE5gSi5/zOfPYJ9pkY4kcyhKcASwGsWsyE=", "I6GsBzUZRql0yIQekgkqT/xq78f6mI48H358h+FRKpA=", "A0xGD/8ohi73pQmhdQom7R5ZYPy1jE9Ix9Jnx35Y3WY=", "Ij2xjzHIXpjh3XtyRd3doP+OMZvX0aZ/28fu9W1meBg=", "AJm5fIeM41yVfQG0PasH+AA+LDebQcphpuVqkgT7Frw=", "LCsefHD+wvWMoBvvWsN8u5RxrnkUvwjffkfdjjvDzpM=", "BGJfIljt8CYroGR8rkJqSG/IAdwLWdIOwPTQr4y9I84=", "I5ymGm735QGBCqiatJltvqj71H/S96LJaoGOk6PDjIk="], ["Iny0O5gYkk8qJYiWSgrX3fo99iKEtLOxAZmlAe2XBiI=", "FsfFxhYe2jLGW7NHZVrKqAvMmL/AI/SrEvWyqJnzfj0=", "J+N8aKAVMPCSzTfEom3s4nN4aNwsNRlDXh8suI8Htiw=", "Gd0cbUUpgkitSZUx8zzgAlBUWNdheOyiYpjjmmL7lQE=", "IV9VY0ZOLfao2qjDRHakZeTun6CtAfxDmbZJsuB9Fnk=", "APNtFm6ZE5ub/BrDJwo9mMSvqBv5dDYHb1c4PaUENqU=", "Ht18ferySeD9P1doqpLp2tZBGLSRvM4SNAxG8hCwfO0=", "COF0Gpf2NI7W1o9Le8bsiy2/A/QmdpzHec7uS6G+sD8=", "L0qoZB6kE1Ax9Nl6ei9nmoy8pWK6aqVOrn0y/30E29I=", "IaCkPIjOJu/7+LmtZoBWtbA2LlAJ89gAM9tHMij7f8g=", "Axs2nQEfIZ5Kj7Id+TUoeNk/+ANbzag0w9zEHDwt+F0=", "AgpyCDV5BZy2WZUtPyoB7ZDSEAInW16hHyCcdjuqhFc=", "GfEXcQSbW+gbQ8qB42EfQQikudwwzRIkQfdDGcOtzek="]]
    };
    exports2.default = _default;
  }
});

// node_modules/@selfxyz/common/node_modules/poseidon-lite/poseidon12.js
var require_poseidon12 = __commonJS({
  "node_modules/@selfxyz/common/node_modules/poseidon-lite/poseidon12.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.poseidon12 = poseidon122;
    var _poseidon = _interopRequireDefault(require_poseidon());
    var _unstringify = _interopRequireDefault(require_unstringify());
    var _ = _interopRequireDefault(require__12());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var c = (0, _unstringify.default)(_.default);
    function poseidon122(inputs) {
      return (0, _poseidon.default)(inputs, c);
    }
  }
});

// node_modules/@selfxyz/common/node_modules/poseidon-lite/constants/13.js
var require__13 = __commonJS({
  "node_modules/@selfxyz/common/node_modules/poseidon-lite/constants/13.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _default = {
      C: ["MEwprrbxhzhHh5V20w8fboo85BCCwVx2Mt+SDW21Fk0=", "K3OA2LJbymSbP4u9CoauQXEJBpvicGb0b90cfIfUxAw=", "BMdyAOVJSxy4o9M09prluvp+h3W6GSTlY+/lke/zAvc=", "BsC4lm35MIDDrBV2SG5hqw0CdjeqxBuzXkgr+hDjT8U=", "JMc/QlkDkE9A2/9ZAiXyUc4ZgKWlzi0HrkNuHQkHeNc=", "I99vb0RIJzx0XOU9XXq7XSbEZySljWiETTw+5F6bkks=", "HcGxrDiSgBiOk3VmBxuEv4GJuVXQV5tt5eqKUTa8Luk=", "J/ccXKd0ziACi4FA8URHIEORfNSRnP9k2EinRb1WkYA=", "IrLuU7MCui6Da5h4PhXrbenRWnLMfKo3TmG1HdDS4sc=", "JU2FBl+HJx6G17QR1qzCgPntJXwJjJ/bBKLKTffH12Y=", "KGIHk/N4v+iB4Ji9LsYr60aJnzelSr0FPPsLO7jV51Q=", "LBnybQg2Y1sE84+jDuXGSPoOobIC6whGghrNPGmc8GE=", "D57Yfpobp+58KL/XrDj/O6EISfsE0zIomLqf4BBPtEU=", "DR3v9CJjt8rooSOhZBtyWAFUdhYauIHh3CDhZbPwRXk=", "BbJ14HqeI/R3qfDiKUInKGUo3dptx0SE125qqnFNtaQ=", "G8JVBSrtnc43dlvFqV3neSc6lvS/QBNUJYiwl4Pqf6A=", "DsIobLqZmE04w9+4DMCK6/eaSvjsuY/8U+xKvveepug=", "GwW+9x/DlvG+l8gsCC0vek2LMuzzDBmHVAkFDjrTWIY=", "Fuk8fu0NwABpWNGCTQ3HQLXPuMmG//zxth0QDynraag=", "GsSevADjdPxkfGWYHdk624mY1hKLkXpiNapWI+pGEoI=", "Bye+u4RfbUdE093xLCqvbywqWOBFcf8Xrf2QXNV8YPM=", "HVZZvk+p5xPT5CjCnTT5/6muDyrKNHRUOiDWJUsvAZk=", "ExbkcLVPDc1TEbapMDR7/9uDOQHgJEipQZ8Sf4ZC/Xc=", "H3GCkG4YS9iFlMolif+EnrLaowyvjL9SE+0/pHR+RYE=", "ExlxTs3H5rqyt89X2LCICUoAPy1PiO2w0L2EQbTO8xg=", "CIwQb9rrMjp2+UoJEq3RtmviFghKQuFL7FlySOAX2I4=", "D7irW9xhaNGth2kiVkHQtetP+PtcYJxmHajug+oqBIg=", "Ld7d5ASFjE8JfGyN22agA4FjXE8VUBTTASrR2veQNF4=", "EtkrfHqIyYafefxh5OocHIgbsTIMC3eHxkN+IwtY7aY=", "IcrVIcGr7EZL6Zp38MD3kqWq76EEu3wDa2yKQFBQqk0=", "EQR/un3ipVPD7FUlF2gxRABwjmF8m9/zOklmPKLesxk=", "KQRSn0/AKRRJw68Y/J9UcirSx1FiDY9uDh8qE4LKxac=", "Eh/mLFP2hHWqLMvijViqdKKr67JlhCLNbxRcJmLMlqA=", "DdseTqem82cFbu2s95O5Sl0336Ag5lXpBxEwbccULRk=", "JotEh18Z/1ihXdhPS7ZOqLrMffwE0a2GGRD7mUKjce0=", "CcF4KEJd5ek8nuuC0yX3cJNd6MJFhFkbdEgIMWWQMZs=", "IwFE0pRfFHU3a95+u0N81zWNUBuclU9n4GwKbpCrPEQ=", "BYUaiEfN+8gCiJreNESldyY9k3GLIDigWwW76JCpiJE=", "KbWtLGKClUzjVqp8MQheuRtsxJ7GvxOUIsOfpU7/ALQ=", "Jl+hg4ri9tWRuPM963jT18nKFAFBcP9lBhi2AUQ76RY=", "HofLhliMab9Pnt7TPwPUl8FdYbDkjdBFlN8zbYeTojs=", "JFlPEVBj+aBjzLGlgOjp8EJSbIzPbkvypqJzr+oWfwY=", "HQUrDdVxXIiRlP4X6Ddjym97x5ogTExABzvIpRb5NMg=", "Hnu2keZ0EKJFB92aXMMjwPhvl7hCvBPs512IyADnYEk=", "K3VY0Iq4cNMLGGY++ccQ+XzkxJRU00xL9xS+iGW4DHY=", "FP6iP9f63VPJ+vQ+HjDB5CZmjQCA5wY4n11E+NDNtEg=", "DY+F/2t5fpoo9KumAZM3QS16d4w7fX/+BtTiCGRJGt0=", "FdcssSqObTycgA+W/a1RzyRSd2jJ0TNMYICE1aByjMQ=", "JfdeNhwmSVvZ5RRorqFo+fCXh05WLXJ/AwqM9djFhVo=", "KGI6aIaGchzPztpsnXhoMuAmVIWbgVDiHPA2/MFUGSw=", "ADHnB2ZKQyvmOZNMKy2qV1dQzEH4QEWdhabW19iru+0=", "D9VV1VE7jGlF+Xu286XTsf8qwtgadhLxLu3v0iK+4aY=", "Kh/hF1O3qNCXcDi+EnajVYV6sgy+RISwixUKRsjjktU=", "IueXDaEAjbV3K8+6Geq0U4VTjiVF/CDZUKYPhA2XAqU=", "FUH+yFCQsH2IVkAuoiThuy2Kip0RkrmhPeyBuPaWgrI=", "F8N750YixgjnAwEJLtxp69GdF76aDUS8eJRKMJ8iHNU=", "JgMsl7u7XJIOEghZKk9SRrEdTXjWOqGVzjhihb0NtNw=", "LmLXPMis5bwS9eWqI2zLcwgw/aYtbdk1xqPEIP2cQOs=", "LwJqgrFYcjhZeLSca2tIdlnk9cw5Tebm7kq6JqEE4ik=", "JdKXYcweSbZhSsQpRE4ZwHC2okupDnrHJmcsfPw2MnA=", "G6l7SGBeF1Tn4X0a9+5JbndQ++YWXKuhUpyJzGfyeRE=", "J15a7SVGQgLxtxOFK0cwJ1sc6SFT0CUGPgoV+gd7UcA=", "KzY+Rdo/83EyQwQJyACOxoWyLr/oQ4320+1KeHp2LmU=", "EK2j2SL5lNiK/MQM2d35la4hGZYd9rHa6622ImL0Pyo=", "CjntFkKG45sBKC1lGc0CIRHb0P+D7xVWJppjoBAIM0E=", "HDfWCFeTowxH2SyvZ3wM4MrM0pgrz/GAeKRrEUjPYxA=", "JVLK7oBGmdTWynW+9KWPdAj5fqMHtEilxA0xEphWImM=", "ByUpkD9aVWyMUeFDyXhTVAqVa9O5UCsaQ/39u8ZqWyw=", "GpYR3msYiUrZZ6RPEp9Ir4Lv8r0P5AsLvuY64HvIq3Y=", "CgFMvt+TviqSS5qjJT6PgyhFqFYtRZrJMryDHgQlJM4=", "CGQtkUclVyu/5+t/e0XZF7LR3r08RNNjbL1mF8Epsk0=", "CfgTjPA/3WvREBScaNzk3tjUUgboAW/H085uK2b3Q6w=", "GvquJgnOfRXHrkdQl2doeljdwhFTZxUdbzjS7jNzAW8=", "Hic5KcJ8o/b+BPu0iPu8HZRUMfppIHEA28zb4mEPyYQ=", "A0X+C4/RMLjjo7I3mss073P+7RQbgGwHRiGk4FHBSak=", "F6OpintwpEWjrvMBY16OXosnfuoXcwYeucU2Tx92dzs=", "CxJMmrTe9xnklhmuptN0uyvdhC1bi4TrVWZTNMFDkXA=", "IKy3ppz87NYHM0Jq5adHLbm4huLxE2mqnw+ScEQMwc4=", "E3rGiniJOqRXzjr3n4SlLtMd90B8X+tatLTZqrPUecg=", "KCLl6CQ8IO3uOMsUK+Pn1+AF0nT8NGUi9THBzgsFYOQ=", "GcU75rcMtceePkIJaLRUiz7lXc3g7SgHWUWyro8jMe4=", "JwqRySXt5FwAi9vLFi2dUycXV3oB7pSOCpkT7NLvnSs=", "Kco+aBHYA3owkpaj+tzXNx6Hq+IerLN8j0rHyY8dSKY=", "L76DKHTmoESk5e4bY/19okkQ7WheHdEkRLgMlflZuRs=", "KxC5Q7xCsTBq48DJYvrBR/FY2eKt/tB59Ki3y4NumY0=", "BpJzU86X8aLHW1eqQtdCl0pg3LsTWG+ZmeUtQre8pDM=", "CIGf7gHJt/jx2Yf8PyzHDeeFSs5t4HKLp6DnpdchkX8=", "BVBKFngunJXRhwFm1uyFPc0oWdDUyvptMgcJBp4iE0A=", "CmycPGnlWECJMSQIheTt+R5USCMKoCCllyHpTuGcSxA=", "FjiiRbY1Rukx7nltOtf4/bH3NzFpgzqm3dTKDTSZaT0=", "ErWrPUUHHYRTm+dyyfRoyM1u/vFRo/WytSuGxHyUgNo=", "L50Ex6r4VBgLfJlDqGq3ZvHGH4Jlv/uEdyY7WZmaTuQ=", "EXCaJCZX4Xcn8kKcZzbtG/bHVtu6iZqk6uXstshFVi0=", "ApZo9fXEoyRrw6hvIhMvwM/GJWZvmeZA3qDh2nqbVnA=", "K2E9SAT+q95H2nHybhPWFCjyeBuc4f3giJAt7PUV8yI=", "JfOJLrV4YvAIdVfqDpOGfSvMAiD32ivAc8onbXUK2Do=", "IQP3pSFPQOL/ZEdFg8zgkU0umk78Ai8Hzly9eR9UMnE=", "FKhxEHKorrTjxyv3aFEg8jJbZPkG4sHuMfavrWyBUTg=", "LYIAEQx0DdUb0i9CZ8q5eTTlrbhtrxwvBAXCeBvafr8=", "BbKZ5AUTG7VjEHI5bFtXy4f1DQcPGWUzvD8FBsj/IYs=", "JZXk4iP4Q90BtVDFUyz9xRkx/cNAoRytEBn94IQ87Ic=", "G6krx48m3zFI2pIMe0CE8BXuFkZipauzyUrPNveKlX4=", "CSyu/e1fgEkkzPHmNUPWHf1XAAehBSq7dkmDIzzGPks=", "HA363j7D1FEZI4x1xwC4JqQi7gL0VDHsEQRJ8fdWdbc=", "HaBerEZ06ZuVRodkYTaayiDiieZ9BSzOEPv0GLCgRCs=", "BQhpKMvQ1JQDv0rW9MYmy9SMHZx6IpVzBvC93OnakZs=", "HTL3Hk3Zk4WikpoCuSkSCFFztIJUjhvAbvs62W+jEXA=", "GP6JRcCB8amTfiA1lXjL2xk0OtCsUENfJtyBk83q2/Y=", "DCehRp18G7YMaSNYeoG/oFF1h6Ow0zVoJqRcOsiv1NQ=", "GgvNsnS61U4cPsoeThTq7Tva+whGtP20HAy8bvpJAMc=", "GMFaO/6A5Ig2AWZCiN9iFxr+rX3K7sD72Vmz58ao92g=", "I68q3fzs2M9AO+6MTcqB+3yXj68UfJkPJg8RWy07yPU=", "GG77NaayPUBu/GI34XXa4C3pxE5dwol9VjPP/1cck5s=", "CrFx6VxgXG1TYf/THnb/jk64L/LaVtZZxmkC6dOSh50=", "EiYibVVB5ghvt3WEN4fKU326WpaEuofsDeWSz9IOiLA=", "JGx35tKFijSjyinTWXYRrfMopKIhH3TV/QTc7KmDDI4=", "DXSVzfgHrD1hhMGN2ehYslD7s3wRop5ikcElQNXivaY=", "IwhT7EftctH//4Or7wO1/3Z48uEEuSltjSlDAUDolwI=", "FB2GCIxjFs4Nw6VglhpQ8Hact94hZokHfPZcYkXudqk=", "H9T9pXHqXbUL+aN1t+g+4Y2+3DeRSwZkYBSlAJKoHiY=", "BZfMFDKpc9g4lvq+mR58KlNwRfmorGEqx2aje8r5ydo=", "FtyTI5t06riYI6r9kTl96npcL+oH4S5WKv4qlOfzPLo=", "Fdc+7ubUgQKggYz+cKsPKt2S67fI2EeSKq7wIFQoBBQ=", "InyDMOLXp96Qfuvp6C9yZMFt6X+yP0vA1WOnh0vL9Xg=", "G5Uvp7DZ3I6fPFKpV0aPSSoqrUXLLUpQN6R0prMjGv4=", "Lf4ZK73l2nXBdawyZYV7zpBap+zFha0g9Jl/Z6UELkQ=", "GM4bWL0/K8VUt0bpDxiKZwX4Qr4p+FtqZyMJkJ/sIVY=", "FG1fODsu+5li53OvpLCGwWSwqlMG5Td0XxVoCoX2obQ=", "BRMAgq6ncgOrHigZ1HBPDp1yPQbEV5sbz/e55wzxyyY=", "ASLSwcSFUK3myI00mNe6g5XUR3YxnxJkjBTKy62mzDA=", "Ar4N/CqewoRKWFY/jwEVlE6aOaj7zPw9eYMPSklKQpw=", "AjYrg+zVrIapCFM6h2yhc4yERCWCL9D14GRsll6UzZk=", "JzQ6DKg7fL9M14/sfCv71kUoWfsPe1wU9iORqPu4E/c=", "JfZuTDGq09Po+JQDAqdx3ncMhVy3/OP7FwFiRJlQBZw=", "FygTWGEmHj8ZlbB4rwoPEjbrRX/GIBxazrjJP4che2M=", "FTtNdWVMX+YE+i/Ja7tqDvEkDIKB+MC2QyvxpSn1Dro=", "HvKU/nl1aPVSU8L5PEoyq2k3oTMrscQSuMwV50s7jvg=", "Kl8wLEmoyP1uTc4eJlvG7A7vNMxGE2+cymZCc6w9jqo=", "IyFaFBNjNgaoyPIrpkK8qo+1WffNMiywiq55ZzW9UnA=", "Eynw1vqdgOU27RIIWNrm5RN2Ykx9quO6eXlaVSWmxIQ=", "JmTpqY+vdOFBaqZFtkWJ3eyzvCyF+aiWiK99tw7GAoU=", "MF2UD92lJfSeI1rm0l+dRHHjlue8OhM67s4eVu6qc4I=", "EnGvb9AEuGdITeod1Dy7XVjXMdrG3o2/uzAmwXMx6po=", "Ix/Z4RqmiOMxJzGmoCfswTMVFtANfjB4jGNSGqkyYlE=", "Dhn8uGOCi6udFS4FBM4J+mH6o+CiPAJIDvb4ZmVdV14=", "EwMGVBdrBq/LYRIDojaaRC6GOzwNHIi4nNTH/fT57wY=", "H81guaUix0BXY7zJVGLXfAo2tOlSxGG7Luvx6EKFRVk=", "G8HMTxIuyhe5UUUcdzRy8KP2pXwYUxnOHS3g0Zuh8ho=", "AsAxhWPb+ZrmNrwBK/MQF1yrt2Y/Kmdkz8PWfRhqIfc=", "HLsaKkkLYRdvkEW0sLYOwD8SsVswVVo5Mqo8H/6ms7c=", "AGeW8Q6bpmnf+Ujob9Ri3FzZW6gHmwLCsrStHmL6N94=", "B+ao/kpDl7pwkhXFqycvPFQUZcvY5DZT3OL1nN743uU=", "KE4JPJhWV76+lr1nESDJKZW9vSyZHN1JCTCcw3IrXtM=", "DSBx2t/Sac6odAzAKZMjy24aZL8SPf4a+YoXh6bKPAQ=", "GUW29bnPlLldk0H7tri0t7RhuWOGwenPPHxOOy8INVA=", "FXammEClDkflq08hqznVMZADhZTsWZcAQV4SxGkrRng=", "HZ90hBlOkEOVjW7nyKVSwNJflYfmbNiZ0s8CkXlkFnU=", "FQYAPzm75BLhoKTypX2ynimvKrYQBjgvah1Ou4w5Q3s=", "IkX3ft+es+ItZHhTaYvoong/rPkrFLg5LnNopFnaYtU=", "GJfnTG8b8xOQYOuASblTKP/06duSYOraHlU0bbvezjs=", "IJ/4YIUnPmgM7ZV9Dk4WXHi9lnCiSWnoOuiw2xJjjDo=", "BiLunSOwxhsFhFsjhT5A2I1zWTq4Uei+OzOMp86M9a8=", "KuBlnp50mkfj4NJEhizPX9b9bhrwsoiUtOxylAd0vZs=", "AsMXFOLGfARUVGU/G9+kfbA5KEOdROMhIyAj/00voPo=", "HEqCeHS7SkVdeQzXqGZyY0A4uvsS07iVTPOj+qh/+uE=", "E02n4ZJD7rCOD35o6rp2QemOw1+Kt38TTdEKityEma8=", "FfZTaeURVe1CoNUMNHnXuIDP+H6BdlqXzorSi53mcl8=", "EIHcrhD9f+wSozKKYGeMLXYBM4YM8w9eRaD/9bqV+xQ=", "KCBrXNRM23vxd6Lj1grjheOrLHyO+dqps9rjX7uZJng=", "Bdk1Uwar6noUlLSHXwb6n4H0+wuFUkqmGwOqBTuvQ6o=", "CGmuhoModCM4OiMXzlj8+IQzu1RmddaXHKKSoPAKrzM=", "CwfYVmrGHfnC+r6NQGLY/ka93RXQhzSk7t65HcmHOJE=", "Al3VepvuWjDvEpHwrKddVfINEfjg8uaXBAE4MPJsIrU=", "HJ4u7n15t54ZoB9hfzfrj9++BCDzxf7FhJH/E2tFny0=", "GgU3Mc3fvy1Y1yO6XVD4dBJXVciywjaxGi+uPrFdFU0=", "EJ3WfwbEkJQDlt9kEGNvZTXqfyuOubr447464doSs3Q=", "G46Tmjz7dgVqR5PoWxtC/TgFmFbBpDSufskL4EB/gP8=", "G7RUmHMZFwH8dDl0ZaxImsWt+ZBxD5rln8doXEifLjE=", "DZcaMHZRU0F8tkgpjjkvT2He/KBqBbTkI7l+RcjOFek=", "LFj3IxZC6G24LcNKEazg6Hwk+aG7jpzZJuBz90qWo+U=", "F5fTfX7jXlDaxiq0NDTTwQPHRCsAiR3T+L8NrX1/RKQ=", "FHsc8LRO+wjwO8SSSHe/Ue9fekzxXhrcVyU6M/AGxgc=", "CXZnoDXjswRwKZWo5RohKBORP7lMjbiGxsT63VJht0Q=", "AdZTrpbcV8G/7HzEJbMo5PSn4BdiG29SgYjS+8WshGA=", "GznNnxEziDZMd/dVvx+kK3BocNYdvcQWg48mRZ9KJjA=", "Jcve/YJknOUZaItOT4UzQcEeFOyoO3DGvSfv2oY1KTE=", "BCKJ9RnFx+InKLdMqSr6jOiQztwHpwVH/bj7fkZ8hGY=", "HPlm6U8dfGlhP+GHHycE0jnhgEF53H7RMB2tsOEO5yg=", "KATSVbVxuas/VAEbaf78B3Lbd/Upzv4n6wrPHkNzURw=", "KydLI7ZtnVYdBXvbetOKljQblTlDpLs2GsV/gWtEq5g=", "FjcFe6fF37p43Y44ouOopBQd3C37QVmJI/ZrXviGy3E=", "HlXN5YZL6l1g18HtNOYDbAB9dtkdCSnoHhkp9jBTIrY=", "FpDplKoUiZ2T/yGrmP/K6Wktfj8AyiWGhCaMBrfIBjI=", "J99DD4VAkv6pGgjrfkBXA4JWOxbHjBK46Dnn5+PXI/M=", "Jiwnhlxsyykg16jX7xgRNs1fd4jK56ub4jx0mNI9ng8=", "FNjU7GVQBCjrrESyZ7Mi5B1cvcq8J37Nw87ng4sId6E=", "HSdmVYGVo64wMbv9MCQ5sIzIXWCLvjbm2Mmu6i6gtm0=", "EcK+ivMTFpUV9KhV0NcegOthZ7uI01M7cPgY6wyUXMg=", "IMlpL0o/rf0K49L3p46jAKRBdpbjIVA7C2rq665+RUk=", "KM1OLnwfPsM0PkT2yxeGwl3/I97LeFMCgg0Nvu0zArw=", "EfNN2XM709CCLHY13JdrLML2cH6vQXhWHdxdT1Y6J+Q=", "AtbHkJZVgqBfjjq/0eBp5BSh312GpS2w+1fekgHZuWQ=", "MFAl4cA6qhqbQxI/ufNTmcbtzzDf9zmDIKeL2pILG6k=", "H5qRaRpKOqdlxzA/S3q4zKzU2DT1yOaAaHBT6se4YyM=", "A/E04Bja2LgMy43XgMgI0/ux6yIiw2SgoxKQSCWdKdw=", "LZzcOzyiRnwjfe5mbze34txY28WeC+R3JIlh79Z4KyA=", "D0N9jzzE3Eh+iXGwOKETJLephMhcv2mNKCOyw7cfSFs=", "EkE6pj3gOMwEJ7GsvSTuLObNGbNxScbKdhUE/B45kE8=", "HkLMCytL9YAXPfrGO6YhDRleB4iARnza2HdJgKGGdW8=", "CNYrTs41SZtg0b7KTyOpw9Ob1nmN2YGPlanwLnB1esU=", "KSSYhCKzzxPumMUT9P4knDw/uUSAUoi1CGTCbC45iHU=", "Cnl+kBb49SeGBX8bKjz1D+IPH82YNGqVjkvBxQ7otoU=", "Bj2CIrryVNrRZn9r2yTIYOoXozEhdjkI6KsenD6kj6g=", "GBXY6c3LnDt9GXWciYsHijPfo6OPPCLx/0VQNjYDy7Y=", "EAVB4+qL9ZIetmlRlDtftEUwB2Mw0ZxszEnV/t74FYk=", "E+1KD31aJsBSZlNfjuseymPjRv1+8g24jt0dGwWsH+w=", "IX+0mmAdB6bnchIgdPe64Rb+IGExWWbuOeezy09R4ts=", "HrkIDg97tvAbOwX5xgxi4L+naCdunlnurrY7vwb14Sc=", "AhHQLp1FPehCxuJ0TVzmVXo/qmRny5I3VdVDq/0wIJQ=", "DL1ffLYJx+Wtzbsl9vDLdNpiakJUr6QJudLBlhtN1LU=", "E+xtBVAlj6kQV7DcBtjwCkfUDAWqEk3NESTFn04iY1o=", "EljKHnfPnWeougLR9mW7QFs4hVOlzZ1sQwN9CCSsS9I=", "KMWngkORtSnprbBi05g4Ju4ee7vc8gUKokBFstWs+O8=", "Gc9zpUqx8uRCHPiKy6RHdt4XQaCzF8teHiAS31coe64=", "MBFFXRHEoUM+ap9uqaxVlSfXoXoBkWhpcbeDajFwcxo=", "F7c3OsXD8+INcbNJr/RJxz1B808dAIFA7VgpyyZVSOc=", "IEqWNTU4/gjagHKz/ZfWSyReBk2byQHwwKGO+6rgmVw=", "KFpymH0PDyKMxpTRDe+F0iujWOdEglUiGC2q+xT0wlg=", "JHS7n5H29UAfq7zg8QL5dM3QYaXlengtWyOc9/iSWpY=", "G0WEHqtSpRBaqkLPf22KzsXAbqiosO4T7WkUdwVM9aQ=", "CjpLi8d9RYyOsmNS6StoXgBgKmjdSp8TysEOiM6XLOk=", "LKtMNZ2JCh3sGIHSTf2/+XghgANzWhA5LL9gSdXNOCs=", "DQ/QaU2md/magJ94XuHvBndRMiwoYTkpqPtySdPmeH0=", "KeTgnZdbUCAcQKi7l1DTHzDKNgHhENF7shxf+GByelA=", "EV7+ePiypy6KITwksfXG7+gPY0cEOeZ4r3IaDwQiE3A=", "KbPM3xUEKFg/6qKEYc8f8aTkmqkvkMb3IO4vqJtYkDE=", "LrdUmQ9ol1hn416ViUNkFLiKJUQL3AiGYj8aVo9RYHc=", "CYkzW8/UECDKhWzPYa9QMh6x0hzgTRWB2wxiBD+iCbY=", "IIqYV7hZw/YgFpBXUZBQcZBDstQsZp/9S2gaHlIVkVA=", "Dn+EaRhPQanuxpkEWSIbERsBxdwPrQmpheMVduAABBA=", "Jdr6e8a+Ch+f0hy9caZOVr+kb8fyeyp7E1kEoPdnLmw=", "A9otwgSdB8TRhaFqKYAPeFvPYijMiR8c4wFW+zF1yho=", "BHtf8ZqXNAL0Yh5R/zFGUTUFaH9yDi7AgLbkTEaIHTo=", "KZwB1glaHWYNTgAaaCH4AOUO+hNmwlZW0UTOw7ApTGU=", "FmLX+gB+ox6J5pLr9SJ5Ti0QbNhE+PDdXQtfWXWeRNY=", "AP5M0GUJDf70DQdAOb0GIoySXHe87UslxuspheptpeY=", "KC5J4xTDG20zf0F+naVKx7aG+mz8H66LWCczU75lhng=", "DmzXUlN6kYC4b8u1uoVxgUx3gLLkhml7GKjcOhWdn78=", "DMcM8oZvEjos3yy56KI4gTsBEt42T94FUtOAYjIL2l4=", "GspRuUx0eYUNP2fQenEPVe14TUy7728EVCK4C0OOXQc=", "JnChzAkL+x2xbFKMGtUUeLWNtmrbHru8v+afWuR8qEQ=", "FEtWbTZn+vDq4+qcjA5L5VOnkXu2+MRZOANmETJ1WbI=", "J7AmT/WU/s4izSbmCSVC7SiFGnXR8VMQpAkb2/7Tb80=", "H2CKiOjS3Fu2zJG+L0dOrEw6ZZ4L3Tc/nG395Nagrdc=", "Ei0FCdJQjGDooqaoP3cPJ9JKpSikBCfbBpCT/o54oGQ=", "AV6jd39h3S+NSGCyAtP07drQ9qWsUIlwW+DtYBNf2Yg=", "Dw8caeUrHkENSaRpOe7b1IEpgIkj758F3gJfmTdBpLU=", "FtvZY/oZj8mjwjDKq0WAs00lxiI9YRNRyWV3AuUWhUU=", "AdhWU76sYWCfCNSpiLhcWBpbV0wmmCHmaygVsxUhKFw=", "Cf8J8MyaU8h4AoZSmVILhjn1m2pcrwbLgMyA/pYJUPM=", "BlCuiHVLTtSNNSCqd3H0/57kAoC4XZ52fT5TztNq4NM=", "CRdBsqQl1aVrL5FLz8p2meOFxzS7pgbTlCYbY2exAmM=", "LvSBCLvEx7Z/HQDgReswkG7eADKpg45oBnWA8iwVo4Y=", "Eb2oRqXlhov/9l6TMeC+x2SnLbpVSaxmF5pFJPvW46s=", "K2s7yULaaEpYEkeNzuXyvAE4OVy70KBaxrBLbp3wgm4=", "DhF/xYl6ptfOICWldMjk8WUf2V/x5jwy3x+tQfKDBHM=", "DShcZFZbxQKs2up0eVoKZKRqFIuQTvmGp66zqebcVtI=", "CYFBpXyca3LqoLzcmPIDNZE3+6G94nr6lBgddVgjxyM=", "HRE8//LN8Sz4NTcBUh/5IOjRBIn0d9V1NrWcYAgSoCM=", "E7+YOHlErtPiaNCtFbKBqCsoD9kkuNTrQ6BbI+Dzbr0=", "HIQkmozs0TYaS2a20ZEWNa3mQPSYGs4s3Eu4WucZkXM=", "GIj4aa3fKpEjC+oDk+yAt8+0pMvnoqBJ90QB50ef5Ko=", "JXNB2GMiVddvKc17M9iQsMVLDpe4zWiXiGtuOJqNIwU=", "Hfm7+0msyZxDIDQDyZkjpv2ci/f5qmy7kb0akapNfpI=", "KiiM5Lj+0blMvTetyLb4FKMlT+sNC8aHITwQd2SIGdQ=", "I9unyZbeazwifCOnB4UHn9QjKhfxnQMR1WE5XZk6S64=", "GZIx7fIoeL+IDfMFQS/9ijzmpVWx5+gcfDxyqgKzWMw=", "LMPZ0RB+el+mqpSXmUMWKUx9MYmNgOzDt4JXPYGTKHM=", "GEfo5o1MGD8wlIiN6hUAemvGs12ved7Mnwzoi4jcPGU=", "HqeR29mqo9KtVuWQqnNEUU5FaE6jIB3Ju6IAoEbDuJY=", "Cjjp5HEt4xelM+PJKdbOdJMH6ISRN+Pr+ipNC/bAgM8=", "At5CZHwCMveHDEEllrrOvaCL8n/hJOFvFYXPqdH2G9s=", "IIx6f029TALRG7aECj/ZareP+WI80KOePfOszAP7Xcs=", "Dd0i0seiJ5hwcYdhWpH5Ewpm0sDX16AV/cNaaN6444g=", "KpCy1YamwEE2LPJmfRMf58QmB1ATwzkjsMYuP/pzYMs=", "KYqy41Pfa6YoQhlIoClSsq/aaMRjv6NgUKfBQYoCZkM=", "CNptLKYZgpZygJgTphzFMV8CRg2LF1fcAU+Ue3KeWAM=", "Blycdhn3GM3tGnhPA3P//qEUFwMQsxBeJiju1iGiVhw=", "Jc64v9oBEyNk8HBEwzr8TRR1Xt0b1lAlKMNnSXwuHbM=", "AvrMeRc6oHBZNXnWSw81hB9lzaO0fErk5nUROp6rojE=", "CS8VetEj5l2ZFASicEqRsjvOv94UKh4g2I4T6P3Fmd8=", "Lkfqjhu3cpLAbsCQKcHRJFlJ/jneh/QQEzhBfdP3K/M=", "Hjk2lBk5O4/6OJo0OSRJ2VOpktevsLo0r48hWfE5ZTY=", "Cs5GrQ38wxYhGlB75OhxJ7IYChayRE+okXRZlhwDBZA=", "LiX+fBnYSKx4CvkSqkKZzVmlXPZ5Yl//6cFNT7mU7t8=", "AdjTHZf7Xr6Qwlqz+0M/ioK6n7tEQ6+Dx1SdK3aIwX4=", "ApVhyAyVJ65IpfYF22HmmwiS5DdB8n44cV6+FFVHdsI=", "GRBMyOOadxVqVa6suQBYpCsAHnQpjegfLRjMYXdg2wg=", "HLLhOIYFvdZYOqE6bq6y/J7N4TN63g5W8+Lj4/geJfg=", "Fkt8Doez43zQJ2UuL+84sIl2da00uqx6d3p4pZKGYPo=", "A6LFxS80udYDrdtjI4NHwgTpux5l/tKy2M0JQozLBgE=", "FDEHvvpIA7GgQmnQMCM/aNknZ2gyARx1Erv+KyLDV4U=", "BgbOJqGjt9i8+t8A8w1P8N/L/rFDfqD7NfkYUQscN8g=", "JM8TN7Q8gn6pdjPjh8eUjfkKPEKo9/J6HvpeB5A2+YI=", "HCYCiz/3q3PdLMmd8Kw8quSp+BvkCRrH+uV2fkQ22oc=", "Hg5NJD3ZgsYRY31RD0P/ModOpmgMiCRqBTEh+g4wKo8=", "AEBPORgWVzBuHq6KzVECEjiXE2mGBrPIxlaybNTyu3M=", "ETiqJOQryIOZPUxfbreFqMWct7sSABhrUZOvvhwq5Hg=", "I7Em/N5QLfVpoDb51l5lGAXKBAsOAXNVxqqZDh9I6KY=", "AudhI5o4mlMUk/ppncyz2GElUzpGCGiK0vFZJ43KyQg=", "GOCHBZ3g6q2148XEuSec123D9tig0GBVixnDz97WptI=", "JzZPJ3cPWLbbo9PxZm5QSqRehnswruWRRKU8soFSiWU=", "D+AM4WeeOqX01re4Do4gIrwvgEXrQ6T4/p8EzU6u6U4=", "Gv7elIn1q5RnHSDRq0mlrgrupPop047iEuCpyvr13gU=", "L9sNfnVzHtqT/JMejY9Zdi4MvhW89uCj7h2g6JlUalA=", "C3R5KtTlYk+Uza9SKNj3t2QedZol704w6ALjB2rQkAc=", "BAeVCyRTyXRYC5ujFK69SdiQUqHY6ypgb620BS8tnd0=", "KbjR7IiPJ921L442bLB6OCmoIb/VcpbfZntJaZ4klZM=", "JdDCCpAGu6vU9RYPqeq8ZIx+QVUqB2K101DMFR1sQCA=", "LzVAreLlfybONqzbu0GYzwoX/PBMbJJrwyg6EaZh31E=", "FGlf+NogkE4H/vVFqxBP3w3Lr1tpo7g0hQSKAFflgxI=", "FsfyhTGn3GdOjyQONddbCMZnOZWka6dGvHGPQpEv9po=", "LiwmFva8AgG+kIlByDw43Xz3nEeAX/k71kDrxVLEygo=", "BjvKLYkQChECG+w58RWQ7AhIggbgFiVwYcz7xhM1cGA=", "D4xQq6OZMQ8wwgHXvmmQp7UGHVLh3sXftZ9p7JPXr58=", "ELZDVCGi7bRNgEWlEzKwUPE34ms31CmNzDMhMiW/FFI=", "DaIaCOX3OiMblOINxRPyaBuxWtEvM7rj1fcaTA7Ml/w=", "I4+tH2lg1hmUfVCdl+/ds+LvPjDxiiZkLigoZKfdtCY=", "DrjBfu0uMwMpQBtbpZZrus4RXMyJNCOybyJPuirxF58=", "GX8SAKKef881N7GHVU3Ont0iXLvYAxEgxX/amiotbNc=", "AH5Z75onMiD7ZwnsjRuDEGmzIWnKqY5/Mq/6cytVuCc=", "CHmPQSzirsqlenN4KVVuXAW+qCLOgfhW+cwJXGumV0c=", "LEP4rcwrOeJiwlLDMJ5f+9btc2vA7R5FlzqvUvfgBj8=", "CMHQF7zx7dU+Td3AEPm5l596DQ3D/tNNu9iw78SdGWw=", "Ie0vF5e1GDonGSV/8+sdO/qJbmEZkp396A+jQZdiciI=", "KGiGtgZ9YnlHiR5ls2+NS3yBxccWrZX/ROkRsDQesMQ=", "HArjiliwzT5d+WyOX65fmxm3rF3Lg57cQhOl+pbJX2A=", "BUPyhrglTtw/UyO/bKRwq1Dq/0anXgluqaIVUIqk98w=", "Jbza+01bbddz17PPy6QPjMjbdnW8VB0YfCFTf8LAo0A=", "KKgQcYJutPFmFZZDBqp7Gt3QM25hWLMN7Cdz3E/npmI=", "CyrpLZbRk35dG0LIMDiCVN0n5g1RL+jEF7hfyoybA6Y=", "Ea6zQP/okIi5ik/ucgRYXX24Qj/dsbQQZLeFqtCih4o=", "FBV+LasEII7uFtqmfzVb2wT3AUA208dYbL3MbBQwuC0=", "FUA1eZJS9dM16xWva++eEtbzfjO0PUwJnonlGKQYfEI=", "FF7kiFKBMwslUGh1ZpD4rzxS/+OgPG9TwQGoQafsr4M=", "CMYLBAAG6sjwGTB6/esAqpMUu4MGuPpg+MFDTADSyos=", "Hgqr4APoNJAJWKE7R5FKxM+PiVCcABx/j/76SZ8xgA8=", "EqDRMvYVt4sHd6qRNuZ5uN0zQTcCf/5euygSFOu+SoM=", "A6d0jFkat6kdjyWFngbnfGbMAIjyurBOkZUIkz6E2Ys=", "KBWn1Cjxq/ot3XtnwukW48yLLWlQc59RRoToEV8O8Pw=", "Kk5p1nORBS+OLZ8Jzwmw8lJhv8CwqiCLFTLi6yVzJTs=", "KPQrtegGl1TXK5fywIuorOou8cIbOq1kLFywTctM7m0=", "IPtywDLyzbPKrn/4SjiSCXBTrYwu4Jf85rJHRQ7MOYc=", "E2nJWvOOxRTdpn7Z6m6w4Y4OETf3DoaVKON77Rh2hZ0=", "HAIfJEnyXccYZz6pPmUgErFJWP2bAmjDD+95NCm3Pio=", "CuOBXqJq9DwzVn5B+D4wXQF5oFn4miKOgk2xaExUlk4=", "Bb0r4xVlhlAzR1sOVTvi9HwPexIW9zk2VGkXT2f4+YI=", "I2jaKGal3RfRh1ZPvCpP/oaCr+cUCp2VcEbCvaGg9mk=", "ITeEv/bvHUTQjLfDNgJmakACrq5JHdWBlrC8nXMeO/o=", "HcgkvjNioYTujtl0iTM60sXsisgPwpyxo/6Tck61mF0=", "JVsqHCAqKFElCrnR9BQn6AMbY3ruKf9qQdLxbiNeXS0=", "DHr2YT4ewuAGeA/vdLN6EDnf4px29jdMgRypI5YvHeI=", "AVU2hh2HR0KQTLw1ambzAzpDMG5nwzebPDl7jXOXlxM=", "JUnHv61FyxkxCCjMvTtbgDJYk/P1N79pALN9lswQJis=", "F4U+aivpK3UhSWBek4xZ7VuYpRteKY2/Cj9C54XsYRw=", "IvuRh+gm+8NAVhVbZCQdGVoCHBmbzpYUDEWgZrdV7QQ=", "DgHbsC0E3tmSFRHuC0HUIqR98az6hczoQ0GzoaQVFz4=", "E+5674c/iistdhLNLOuIaU2dra03kX6NMjy/f/hdvxM=", "BnKEBaHZbn6RIQR8bp5PqRllzVabilXJisqox5kFhuA=", "G41MHZDxORmd+NoE9tCYs46PCP8IFcfFDscPDyIda4Y=", "G/UPl6KQ9T3Zk4e8nD/9/i+Hi7D/ex5HMdw4+IBtRps=", "BwhWTMbDmd4OO5bcwG74d/g5Ipqq6hUmUnuKu36KHHI=", "Bhz0wiYK/iRyCT4rGNW3pj4COg3SMy/BHLnHeSU2nhQ=", "DBAS3S9BaKTubI21x7UcjziTTp7INdD9ErrBr9I7/6k=", "AQ0seycvax0CFgvXip+/VW/KbNIce8huI6vXSXeGrSA=", "GafexoFEDalbGGZ2C7ikihe0kfcaYb1Iy37NnwzyosM=", "L+o32vfHiFWHgqLUY2vIsSoCHWgGVeFtRBlOiKKEbh0=", "CTGBMCtE37wGT+t+9HnReIxbnG528AJHvMH08o2HNk4=", "DVYvfcyLGle0fnMWwoMkcER9RrGgXRX7h9NVDVLjELQ=", "Ax12gCW2UTnepXyCNCWfqv4ooaSt1fTeCf71sMU6gAo=", "DIwlLsEEbyiOxjuiPcrGi5FHlSge4t/OXDEor8Z5k5E=", "JJkjrj2tJkcPBxxW2T6opMRdnsvDNcGDVeDIlhqPN7U=", "GP7dr8mWEezgA64G1+08p9aafM1a3ON3ue3a5d8gpno=", "AdZK/f3pm+hNN/rrN0CrSETV2xeYNG4+Ig6FQk5OAxg=", "D7jebKQz5YbHteHLCjgHaea87PeK5NnhwJh5/Z4oJHs=", "DVsXyURwUsiYovS7Ie2CfrnTbqw05Ju74YML2pNfA4s=", "Dyt9Uex+pld7LnM/A1Je8ej+xr1PJcH1eff2VbqTJ9M=", "KyPVvjkZmXZJPGRzKrZVWJ4FUyp5pRl9JOBGwoHA3R4=", "GR62oz8+gPvSJ/vcQ2+4seOqN7A2F6fIdYeiywaPsqI=", "C9GbhHkcdG/VuBD2jxDOH1FOzgCg53SVN8EIRP/KEeo=", "JakaJxSnkGD3eyUD8NMHD7270YfTTWCXrig7y/TWXAs=", "LlB6/58Agg4hdS51aQxhm4oDseJpnse8C9VQ+sn2MTs=", "CwsFHPlSbEAZYS3Q/Sr+d0qLHoKNsuQvra7W0m1R6hc=", "FWtMwEZrlT+fOJ7/mhx+Jh6QKsA0vZ0oVVnpxY61Ep8=", "AviIfcfBbBEUdRMcQJ8izasUQO6mhPt2FI+sfzOupOk=", "Hzp8Lka9T8F4bdlJ3tLi0z7l+9UxMPhyNSMCCYGDRrM=", "EQJUbxxl+zhDEVIXRhNgjf0XVkrq4XZPFXD3K79HmVA=", "AMsrZ8H0ruv1TpJ++QP8aqDmrPDUsUJwQOmBoQLRX4Q=", "FveSTCmmHReQ0j2lT6TcqvHiZORtaILIXU+9hvK5fC8=", "Gol35/n4gzIBBLzKuntpINT7Kz4V1RNBhMjAb/qcu1w=", "ADjd6TZmoG/231GFekAhi2w082jnvMUtRQS4Wp7qmZQ=", "Ca+LfsdPlnQPjtqfaepywI9eIxHnjAYzv/eIdmRtbsE=", "DwbnZD+m/QsBaQS7EjSFXa4GBEcqofnnsSsO9ZR4D1o=", "EP+w8NZZsXyrWLLnSRISpzTUW0Hdq4ib62VRjMKyo6M=", "CDk+BYG++dsnK1US09asFiiabVGn6P7o8MqFS355aMk=", "DNkZ8R45QK/Q/jt9aH7XEXtAEA+Jpguh/Hz3Q5Ys+X0=", "F2zS1d1QOa/k+cmvhPGSDefIPx1mOj3M76rDwKzvpG0=", "HM8gt53ceNxjLkHBHlN+WZtBjUy5q4inQQGiemaM1Go=", "H4y2HtOAYUEcdQrLTDE9L9Fn+63FiKFP5qMNrGcZoSo=", "LeN0TvLXEU/Wu1j7A9CWm76S+/TbSbY2oqSHZBg7Z5s=", "FS+MR+hjQ9l4AyTDewhEaBsabFt23HqjpX6VftwKr94=", "CZ5jOl9V/LgONJTCDmxgf/Ec35L0Ws1hNAEe+W4j1OA=", "GPiMfdXcUH9jJkYQ1mi42jsccENYM2cYvGjqItX3McM=", "KeObQsMsZC7zYQBFEhjaezPXy+e8WIJWGjpMLzC5DC8=", "DavmeBJR3wIwpwDvv98lsHdrW1XigWvpthTDQz6ibFs=", "CaH7SMdXXLIV6YGvr2+k4PBZSfr69+w/Hrwaay4NYf0=", "CVStDQtrnGY7GTa0MBGUqcvmd/mjjtC1RBIjNLxQnxI=", "INNAvaJxvuKfCT8qXi8ldYD313Ov4/1gBvtdnJRh0zc=", "BOF1qaVoyaNHMib79n88jb33GJGDP+tRbtjx3JUtFD0=", "Fu/FPqDJYOa7tnpJMLdxSlBNus6nhQMD1mKlYYlojJw=", "FjZCs235ybmdalNQIiE5QG/1WMSGRFpXqMIABlo/hfM=", "FohfLWfdLqprbm5KHLd4/ls40knR1mgVbAM+NvjzW84=", "IVTW8krNDNoRMm4nnun56E3bTKS8Ee/XE2rF1UVzqTM=", "Fiz5jAggX7X0oOnLdsZURbMAgAAh2x7zsteRn5wgL6A=", "Cm+2fCwPMyDiK0EktP63bOEzD4XauJxEd6zXghT0crQ=", "JgIc90oCsZLwxO53k45PRSmF8CHEabboT33z29hlNdQ=", "LIuXBMa0F2nJBZI49R+zgnqfsUa6Qk4xirNZNYuuDXc=", "KPtshDt+iSWcE+UViYBMpAoQ9bl/xBhUSbGmGmMhUY0=", "HiNMF0BYdhVOGvccLOQDMHgJlwXPy3GIZrNH2A3tCYs=", "IoNuNxYu/Ih4mtSlYV+OMuFqBfsneABkkKL6+zdDp7U=", "KKcNKv9nnfckbbpfxdjkAccmESnooZZcXF7Vfy7lp6Q=", "IKWkFsQQH7HMrLTxAeyTwIuK2fS8wM00xRjWvBNtTWI=", "CEBXo6OdyS2h89oaG+4pZ580MJYofRBE3uL+KcyIsGg=", "Dt9E2inuQYbD663RFI4QEbUIqpSlRJFfl0b3XFffd34=", "H3XzyzJaU3sRwWACySf/XYx1GJxjK/5meTJS0kIiDUs=", "AgrLaPAVvWiXed5qbHAYnkD5KaxIQ9HfHXjmzyX2dT8=", "FWwGjzLg18qqMOhuqXP37MS8LVMEmXDJVrCu2jr4iNc=", "DrXGbIYwocOxtnoofcMuuHTXuJRPfi5LbV+BupqGNR4=", "CGQyymwQPL52RJ/yes3Axy71U1s99etyjh1Mqs04Z7M=", "JZGhKhuy6FUm8rARCw/alwM3v/PEKw0OCSH88S4T6R4=", "BN3I4VIULFfHZrUMTIuu6raBNGfBy9Q65XyVsPS3TLI=", "Fr7zANh8ZYKVTwsuX7dLsEt4UrLQmvU327h/TAN9EU8=", "IrtArJUSftBdounDfxTtqSWGtQSF77YbtX57BYpcxd0=", "IVKiXjKGFuzGP59iW+StTuN6KW5aWEkm8cHmqZ0zX6c=", "G8XUG60XtE/FqmlQqmQ+3gHTc7Cu3HA8JqJ9+mM30Ew=", "GZk+I1L+kH7O+L0z5kLVSfl4RUXortUSr37qClcD6k8=", "Co4Amrgp+tNOy5hmC6BV7UbZ4ZpUV/rQ5XE0bYMgcnY=", "Dlq6o7IOvt3b3hYwJ1FK0i6otkUtHg/f5dbJLKGLzeA=", "Lew8FzEnRpiPeDsU+S/ZAPs76hN7naJB4taFjce2keQ=", "GgW3gYDzv0WZT3hEu7WfAlON06BqH0YrOoWG1FJz/84=", "FtIrh5M0RIeFQFtudOgj/SPOguaNsrOSv748p0DBQbU=", "CJB3Gs7TmYRezFuc7GSm/JJfKOOeSOoMtHPyrTi2cPA=", "JTD0AOc07YsWW1kNsWWAYMtFF4/Eo7apa99iQ3xCFaE=", "FeApDX7MVbJ19iOmNSHTl5d3RCoU8YkU0fqDYbuuxmo=", "IEf7eNSGZblsSIXlVh/YnGykQhj0qtSt8gLzKj40Nf4=", "FQUHpILJsC6ciISzOxVPTYViKGVee2TQRw7rkvBwUXs=", "JgmNuFK/2wczwHcn7pRZi1t1+WFw8s6kG1EIjU/OuLs=", "GWk5T7SmV4TDyksf2dJBZI5qpYv0Xa21hIubVa60ndE=", "LM1boETgmQLlQLxYr5mIYRlbjRuWvelvBZziFYuPTSc=", "DiQaHojBZ2ss0rSP9UpHPTtejJXaOcJOhDdedPdkDrk=", "DWT1W4SgpSSddFLLvNJle8LO3omTgBae82rPc8b7Qqo=", "J2z5gbPISFp/boqFoMN7/pSF6v/UZ5aCnNFw3x0l9d4=", "Elq3BaDzWmyecON8+Cy/0bdKR85N2MY2Ug71J8/UmW0=", "Lt8ryxgrbBZdd5RqIZpUKvyTg+mXYnGxnlhc26O0wDQ=", "AwRFk+URXIv0tCvMc3TtofM2sdAM8w0Mbg2LigLnCxc=", "LJKI0HuGR0y/JNsnt0Qh3UE7kIcM/AE/AOzA2p2IAIY=", "CAlt232sXKvdAnlOBlPe94e9y76nNmGRWyCyM7E7STg=", "LKDGXt3qZDxs3Sthd1L3HFs2MUr7VuLXczxU7X392MY=", "AHIO8Rt4aN5hclQZZVYJUeMPnqyvldoYPnk6xEBceu4=", "FXdRaCEa4slQXN085hiHgtAxZIz4EtnrorJM7KNid8A=", "Db1zWFBUeeyj/nzns8dWFQGJltAJks1DvSc2vY7g+ms=", "FRphQ6C9l2MpKmrq98CZKrZd2rXTXy5xMof71nK59uk=", "EZgwp/HhblOf2XYC3cln5BGdmkjW6EKBrQ5yE5wKVOU=", "Fm1JVfbHQi9T51AIRGK7gs5WUWHHinH2jAar/IDF9Xg=", "K/f3eRrYSObIgEETy3igptxfGpRzQQBt2/6E2/luy8M=", "CbJVDalVwnRus6ABTBFuZ7BhQCByrPLN3chK922iHMU=", "A64k5Y+Co+l/rIs5DGRDRyIyWzOMbeFqsH6oPacRW4k=", "IuqY2ydQLkFCgkozPZTil+ATR1fzFtutI3HMLwrRjSE=", "LUICC48CYX2a/QaT3YzQkADAKpSqoUs12OzYCO38FZY=", "DZSMAyjWrens/xORzJJtpzEbtLMRzYk6n+kXZAsm58E=", "HqHCyMKCSAm95j3MYvawahSf0rm9raY1pMNe3iannoI=", "LpCIcnem5ujZY3mXmMmZO0Hh1lhFwXhAvBZpw0MsZLA=", "DIUKhml9mmCdJvAqmeEWwWTz2DldO9aZ+DIfdigHcWU=", "FtiQmducMtkOZ6dDCLhciGfRzfC6PJfHo8BQMi+RIyk=", "EiuLt0obiyKcSRrTFjLajguQxm9Svhz/uh9QvXQBSK8=", "LLuy2mKpUlKD/aX8V4Lk4RwPTvVZxxV7g8WZ+lHBG9Y=", "FkTC0K85DHg1v5of7AGuCHvd8aIaPZiKdcnF2mAGrNg=", "FHzSuuLptxeWPKYjzy8rf8uVZy0FbB1z0q83LY3NbPM=", "C6pNDOYzHZK5i+ucKPavr6C5wsosGUufcKbTtijj6iU=", "BG+aSq+2VPSmuRA9IIFOSFsKAIGfIA+LL8SETu65uHE=", "Lm5IKBNJS3ei0VP4zprIT2FIceLW1kEKfp6aeGIQ6dw=", "IZrv4FML8IMziGXVnkJldZbKaM4SBn+8hFxLkGrm2PA=", "K5PutfXe+qLNzxZckdxLLGefCoJ14STZpF5O9JunhBk=", "L1JwrHWB8hhv87zFjG/L5Tw6iRKl4rUdBzsOPipeBIk=", "EM2/X5az/3GW+KbKoOh0VJMnf6ZZvMRI795ytx6DI8M=", "L9OJC4JWywYAntwcphTluJiWQUGQxKyRLd0vsKVFR+0=", "DgFYp3a65s/sWGVEJqjgh00qC1FYAIhoJijYW49ijtk=", "EdA551cwlG4bQ/9rGjbKCMxo78FjpEr7u9GBrqHj92A=", "Bx5MSPxGJXXGdGO+TeTGfBeOaQ99o6AlVfEk9yLyjAk=", "Ih0RqY7rvyruU26jLQKsGNU5rVTukXLkaiMqAQAXsqI=", "ALpOT2nDSWNoonfKNvay2OdAKVhDIZ6Qz3y6JRhzV/E=", "MAxMZITeA8s1/4WLsZn3qEpBTw9yjehHQqiHc2QtCqU=", "HFCNMUzOeMJdN8KZ7bqzDtdSThkCszW7TJOG9ZbvP3I=", "I4PqpdtPetdBijhFlSOyt5Wk8VFQW9eWkWxeBcC3tyE=", "CVAHybrOlDmU/Qqfnyvwn45XaJMlauqGlp0b0hDyJJo=", "Lr6kyUcMWXllXDEXJN9qDkUc24TLLvsFgwN0tP7pmnE=", "JLfnP2L5fBPuNwVS8Pvm7wtabmR/QtlfPGbjHgsOAiY=", "CANZn4A16miQYzdsGrms/2IgP14MG6Fey478MPwcvbo=", "KrTAqekRXMEwNTBzO+qDZU+z2KitStu8obN60h+NmzU=", "EPELDVt6IZGPhCY81krcEOVPh2etoKf7WdcZHDHWj0w=", "I47jLlym8pEQR+B5f0/SVx3NzXdagb+UV4ff+Dwfy2o=", "HO1q1bpGbz793rdJx9CT1aWiQ0jJvttRPeYEdifKLSk=", "KEKVVeNOe505sPm41osJyJy8C9Yd0wGqlR2kK3ercvI=", "GzpOPbTdZ6XfgwNbpuVa/3H1F9fmaSI4CR/9HaiaFlU=", "E8wggrxgRVHvT9AagaUiYfeXnb6g64Qpby9kFtV9Rg0=", "JjuePNjcWkQTzo6MVzqBFt5K+WQr2qo1rDQqyHBc5f4=", "GrOVIay9yIqrrVgvoiLWrfVjPLFvqFPm9O4EFN2BQ84=", "D8EzAQJwICtVCgMi5WmpZToh8DSoswWmGBnCapy1OLk=", "KRh10Ae1zdQVrLx2xpthIshqvlHBjuowE2v2ZXFYghY=", "Li+TKTRtkgqYOG8sCjZ3QOAyRoaW/NWsbizGYi7YHWs=", "Dwk7QoxiRFeM0HDKFuabNrC44qWF2r5K+Jnvp8X3qzQ=", "CFvBO2mCOTELBVAc1Zp46dHzqtFhVBvUMIDZ/IZ9gcY=", "E2IiqR8clIfz/zILnjuqUu8jJ4lfQUxNSyuMy/74LQ4=", "LpNB5arE2jmzNj3uk68EgiRLR2ed5O7LWlRlXhGEEwU=", "KJiLuYo01RlThERdds++mnzal5aT0lyvaBlzmIjP2ns=", "E7TgMX4/nMLz9J99wUyXE3JRjysFPeNXYiJe0mXNWzY=", "Ges1xwIeFOlGIl+seq4JSBVI0Oq/iTBKP2LOkVdop+k=", "HTfR4ewNfxGb0zpRFuGbB8y0Kmv3sSm/KqHcrwaQlP4=", "FlKhEks6b8ICnkPcJN4KLjBpaLEgknh+PVeO0dhR2xc=", "LYLj1iJY2xoDXmCuz5DPw1wqaKvM7oRtbzDce+ExNsc=", "Fxe/isYUarFO0y3Ho0D4vAFlve7lUiLU/A0bm46HMT8=", "L+qMonUbFlAF/FeZy5ySjT9XGf03esPVq5iM/n/NC5Y=", "ExIgICYWOFM84dsYGOru7To+VGGSXfr00a0lPQDA7ZY=", "COY7lpFvyIqrMxQPbtR3QkyvG3kqzX6kPDKEgIizW2E=", "H6rQM294pRjiIJ1+hYI75T6tUG37DrSRBmQSH02219c=", "CeY/LH+hj9tvocJjrV9ssMOedXQalL+fMsWYQ0c2kXI=", "DVgSvNOxMFHypYEWCMswlo3k+cNt18T204/Kqa694fs=", "HO9IsdYSJriYgUgVnoJvlC6TlyzjYFH1XQ3AGfnr0QY=", "IT0/SoAXhNQ5CbVHnNFZy9Youviwdc2yy+9VbcEgYeE=", "E3eISlFUTaeKILyifAM9ZmwFF59vDDtXoUSk18FU/oo=", "LCAoIGxqWOprP7i9cyk10hBDn2z+toO3+gtfLZBB+Gw=", "KRwpyCZRTSgH/mVrwurbCl8mRBGxOBsNhe4hXkgGpP0=", "LH8mfTkGnkkCWXyeM0i4SpUPkdx+7pGoBheF3gwjFyM=", "G9//9HWXM4frjNvcua3HuhyfYwAKMz1rWnfFudDvzm0=", "EIUE3mwyPXvWxqVLPHssvmfi+GOkg6/PjOxNZoSeKCI=", "FDgwdYcC2ih5GRB7eW8+LEIIU3cEs1XvbX1K87FlGcY=", "IMug9ETFS31EbpVGA0dgu8sh6U9k1rTJqrQTVto5/jQ=", "DQXxEB2omMqANCNMV8G42QqEBoz0JC06TcPsanG1apE=", "DVjJnnOW82eRuSHva2Wwb4fDkbZud0v0DaQq95No544=", "Lw01uRj7rlIhJnTSwIasNf/vKJ07/Xg+dhg48RmGYhQ=", "LPSGgnC6PCiPTeKemF0BF++PIDIjW1A5y/rPr5W59u8=", "AUze1VZJJZuSrBKL1uGxvbcRUmRMTYGMHZo6DjpG6yo=", "Dxb0lmMzQdFwnhRN4phG9/saQOQbs5CfQeeRt0l5XUk=", "AgdmCCcYBBN+DJ9owbCutXHk002jlU4H5gZw4xz01pE=", "IUFf1HJ4noDLwV+8Sl4/yWVn1VJFMEnzuooKQVjYspM=", "KNgMnWl5VkVouHdFQJ/Qwz447+BWUQh0cnys9l5/QGg=", "B/wyiCp0hMA83ToOJKv+dYfvAsHMUrEcVa47Ym+LBwE=", "LY3S76mGi6Va3nlyJvp0q4jc0M1r2UrmhfANQjg+X40=", "GphtwKnBJQN/o7MLoLtJlZ0hzrIKxdM2sJWXxCJTeuA=", "IfOSGD7tNuARuFExGvwsqsb+dszh62ykK5gTcCvwFcM=", "FNVvHOSnczPmHhDUSWRHS+x0NJ0iwgm9TB48Cj31Aio=", "IybtZTAe8cJP606WA4YMqs2cb4BoMwPK6wrX8myrCXA=", "Kj2fyrTFCLByXp+4Ug7Qa20ptSLl6K9ORia6KB7oVxg=", "Kc3P3kD2/UuEuONni1HtVGvoo6DQAlv4kjV6miN1vP4=", "Hvgr2tCbn8T32EsdNV8JMbCWyj0Nt87I4z2v8rQJOoY=", "C8/iiutzWmZKNgEgsJF2hjN0w4fWwP/+pYcLwOqHfNI=", "B/Pj67DX+2C9V2rZ58skGqMQzKDV1FAUlkGX91lL/yo=", "KsVsI607hmf7BUaTFwIwNcuHumSsBm+gNcc4N6yN8e8=", "Hi6ffjcC+oL+3bFgNrlEQu8WEcoaLxyi9HM28W24D58=", "JF1V6u2DHL6v5FrYzrT8vb/J0O+O5v8D4xBo0IMjmN4=", "HqKV3s/anApADfFEg6s9rlv0OYftkmoC3y587yu2TqQ=", "Bbv1aCSfPMrkyY4lSdveY5iCkns55PObt9BfN/avDQ4=", "HBKRqrmJPkbSdivuuxv7l0ZdAPMNps8z6GB4WHTK19k=", "F2NNHM1R+UMxUmNMNZdz/Pyfk/gPvmW6pZY3cDZG9+o=", "FPyPcjT2kSxA+Cob286T+hr40k/Per6wwtT1qY7XHCQ=", "J+/f9a1meNX8W9HacUOwdlmLkNt3dyqOnPXFKV4K97I=", "BGZExOcCJYDoPu4zDHIoRpt+yK/RVKR1ZPDMq5uomHI=", "LADUV/cuNFLIbBrjZF5kXQ/uLTT11QKtGzq00O471DE=", "A9JNfV9mjgx2MwswCz63d2etmCqHj2Q8qTWgB0KiGuU=", "A96UHfgH+xy94PiLnsibZMESUu3dzlEj0kQ/2r3+xTQ=", "E5aO51pmbvvt4tzcHN2aXhVUPL/dPQRUhuyrrTYt+C4=", "KknxHzYDDrKNuxwSPAC8EkkaRhEm7fI3HUeH2/q2kNk=", "D6aAwIZhzgZxhH61grXrswXGm2FmotPTLa3TW3PIf/8=", "BtWguk9jhAt9vu4XB3LbwGDE59p4WA9/At/428q+Kt8=", "H2JIE/9OTqVRsYp1T7CoUr5q3pGAfobKbe8jjMDyPyA=", "EEmI69ZXeDmisHoDerTSDisA2utkUeIephAosrasspY=", "BOcdy3r6LoMkh6x/E7ee7ETXeBiX6QdbkZjdqYTX9+s=", "I29rAR17lklvp7qrTF2+dDJ2vJdMDS0XqB/weaSD/yA=", "FYdmPitddA6u9Z42KS2FaGtYVAgs+QPk3kvrU0DgFdU=", "EdRYlbYjm6C/fWjtd5BQKq2OE8i0XTE+Mj4nQy4svPw=", "JTx5Np+yuxY62Ix1HoHQ7ZA+D+bxXhLA/PqaBu7BJHY=", "GJE0WLWdN9rNDcFoEaNPhEtyU+i/TX2+zr+XsFScKwE=", "CNW8oZaozrHdsWWSev/ODj5X5CsioTA5K8UiFHSSl9c=", "DfHrAitE88jzWKdCQCFAIDPrVtQ5uvygkgGkY3Eva7M=", "HsmaSj26tYFI+cwwJNoof0CD1wqRlmpcdrRrCie9ZRw=", "HO88YZxscAvSlZNwYzlVAc9OIIGCIJ9nGNV9ozoj5ms=", "KABkeKIRfdNQBxHPhD7he5cCaIRoGlvtBiHBV/eKE7I=", "H42xcYTpqjnlrAMG5HFAioMVQ0Csb5xYXtkQ0NiXrWE=", "C03XJ94GoKWUaWG29fwLzvAmP34uWCndtuSQCMvBsWs=", "IXIJ+omW2GDaofnCEOyiWA6z8c7Fqru1a9kBs9n8hxs=", "D2i1O7uLtHmNGRYI+VQoScGGl910AtsLXzAxfSF4vv4=", "Du82tqIF+76L5oFaGYPmzRRuQileykbbsxb5dr8FluY=", "DqifVJ6Jd7LKmb5S6f71cTpz5aBmY5GMg9IrzbAX8Vo=", "K7Xxgn4USF2iGDwsANYk3bwB3v+8MjWHjwegSke+0b0=", "L2MHEahLmkcDVrPPwuoLngm+Ft/Jp1CGtLWXi2no3k4=", "LRpk4EEdZmwO+fBrPrHwxEKRPKYhpUMHlhiW9h/nRkY=", "FeuF3DgKDLgfFRHcz6/4pQee0xAJB3cu8Hb2S7T7H4w=", "KTXetEEoc5kbYiCu3D6SPAXrh9j92v3L4dpq5HYHWu0=", "ISpYpfKsVTCiUVQ0Q3U4iFIYUirEEkls5fhan++i0HQ=", "DcuHP+K/j/1k+nYAECNXKZe94JN5k7yYIpKEduc1Vh4=", "DjkwjBKBiZ1xUAktHxFuQbmBIyydCWER2CdZLjLF6lw=", "ClZ50JQYRmpzAOigqWT007uSKViIUUe13ssUOLEBz4Q=", "A4qPMmzIpR3UEJL0DqOqxK1yKodEEB9AaBOcXZEV6+I=", "HcD7ORwZyXkzfxmDsH2QrSJRedHGv0/YVgH87xwYVK4=", "H/6w/e65xyDnvlhCoBlSdomzuPXj1jo94lBalkIjopI=", "LNZRG759ydKozAUCJbc9affCB1piP9b/S9Akwqaa0mg=", "IdRwZZCxhU2WK+xM+laVGuhEHL6x5BdfXTthuNt59oo=", "EtpZUoq5KunwJo6xvaR1lJIOT1pFJieEeN2aAQe9/68=", "B67Z4W7dQarOk8IHi6EzNFdnZpfOuNd7WDMSGupj8Go=", "E+nFJ2HQ/TVnePLJypT2rBxxQyRDXgEF1BnhEtP0LH4=", "KIyzwuRdNTIz0mgDZtSRPBJefyzGu/1lBpU42J9NxHc=", "AWr3EgdERcivdXjNaObjLg+IzZ6Zs/RsY7hMg5JGju0=", "HB2bEFhKRGRjuQXXGUx4Bma5qgCngezxADpqDIFoX30=", "CnyHb4OrTv0NBCSTaB6ZOmZCDyOw3GM3/Y4f8L7e730=", "G7hDXNLm/Jx2hEaxOlP97O4Fb3ntjQ0dNuOnhM288lU=", "LZC+GuGCw/RAuF/W2mniHenrKSnlS3USIW3c4Ipwlb4=", "DJ3joNvS0UJw+KFsSGSVrlrS1EwDIvDZkKxKTgJL9XU=", "Hjl8GCEW1OAKU1gaoQjlv4gPj+BzbpgSSsqShzhAOZ4=", "IKYR1Ps5LJTYVoRZDqCqo45IANAnZQ+CO92g6Ag7ogI=", "HqG4gql9cymRgFrkaTUjPutCT5Nj+eX+hk0wI3SE6/Q=", "E/Z+5uj/xv8mZIvG4xBrg0ozVO2YnTUfTwjyeWkQ0bk=", "A11uEf1xRYyqHAp/doKOM2CtKvLoinqo5eX7KmEQpW0=", "ElS+tHOKXo5Q9F/HrXPFEhZeDCDAx2SxdH3STaS1GG8=", "HgsjH1lZWJd911ceDmmI3azBSsH76YrHhPhoShAfQX0=", "HXh74Y2T7uvKz065jyImZFzBqkNU5q9M6+rOa0QAGWM=", "G2Kc4bUjSKmGWr4Y5sU3+IskVeDw3jOM9R3/FOCZk7s=", "ECsLgq/OytULbNl2vTrKv9NO9PV8ePX+e1cSfRZlBLs=", "LE9OFDbYXpFBYr1Ru50Tv8r5+dMO9TvXXY9lmCASTrA=", "Dl1ijnW5zcOpiYxHIgI7zSbCMH3Ny3TQl/T+ALrQIdU=", "GJjv27u2JZgtsN1RLoVA/5hpJbt46pcMtdBExT3t1LM=", "Klhq4Bk9wFDGimNA1jh7WUTSHLeVZmEMoVzAr7vr1hk=", "LI3zqDn/Ky4Qcf+XOWPhY8veWZTaNwDSTAlCofuPPoE=", "LEDnP0H3ranORv7XVLmH13x7nJvhyGbPDlBJF4X5qoY=", "EKREGaJxBDvknM9Q0YcwLzAAJzY/IBh5JduL3QqpzF0=", "KCUM3GHu7YuY/PD5qDmwyymfSoD4hTQphmCQKTKx6Mc=", "GwG21DgiI3+ohruG+l0K2uzeO4NDJOk6AlcSAtOcFsE=", "K3gDhvnz2psj+I3H+iYV40KSiNnF3kgD1Czmns+2RmE=", "JJhKx7DTpANQDwqIpz7Qgvh2LBaG83nVJBtkxtHKJsg=", "KVSCnnKmk0f0oFteS7Oj5uW63G97lj/t+VxS7V7MSI0=", "CDYH+eBTpcd6uVNDwaRiA1cmKJHSghlbzE3tPdeIzss=", "J83I8GGN03inymuJ/Mhs7ucKfMc9KTZ9PUU5KRtzd14=", "HEUqdCazHvnBhpBrJSjeK2+LJkxwg9Bxlf7jJA8M8II=", "KnC496T5jJTf5Hg5bCTAxzRFFTympj9BNaYaenFJIJw=", "HdrywpBgOEpk8UKWT2jDjqmy3fFMmu+StwGgD014yWc=", "GNdj9ZVWacdWhdeLvP2ZI7Hiim/iLRnlMYK64uOHpLE=", "FUh7KLPwaHRIxz9DLPyg21VlAamYXbl4KtHxYBGqVYQ=", "HNFX9gI81yAYDlnbnc3R1tas7/m22xrHIoTApUFXu7g=", "AvI2j40EaxiTTdJ/Kbv/KckJu0gO4P3LdwUnN2ahib8=", "CdE6Au5Hk3hZM87Sq3C7AzTnpv5lPo1O2Xg/2/ml8b4=", "DWbGH4tQWo79BqhlnR+DkQp4EYKkODucc09RIA3E1io=", "LTKupMwyb4Iga5HJhhgfGO08MXGlMXckPy38dHGXa3I=", "Cv3l+FoELr4yiJxqPgD7QMQNmhMl8vQYkWsaRuPkQR4=", "KaPD0Mqr3MtsfTWFk7z/jcLgUYqeQf+tJRtQ2bOXzuI=", "AyLDOGv8vqiPTDIu2waqbVkkEi2FjfNO/mNzxEt8vWE=", "FDjFhxrdesDTpJrNgooAUiLOjI30MFntz+OZ2Q4oE2M=", "Fov6e/QA9bwMwUOI3ReAVQmA5BNHAaLyH+Ds7rpZxxI=", "HcBzoXKqlyjFI1RSRfkWDO8aduTPdLbqx9ET/fkRljw=", "JsgPgeLxKjAuYw6eTT/EqhSn70FQjks1oLWPOmOAkpA=", "Lb9K+vTF3fsEyzrnqqprxiRMV3kKaTnsD+viwXvOUys=", "AJBbv71hrEIibz2aH7/S6Q6wTcZl4CPqI5Xisc951DY=", "HB2qA+K1vONgf/FeN77R3LteGJsHO2wgwnuhbuKrqBQ=", "Gi+OjVUzliPBE0CuGxNUVGNcccvY0gtqU2o5/3NqUkM=", "GFNcWS5iWBF2o0ZHg88Jn2uQ5cvG2A8SOYcI15Qe9FM=", "ACn2vEncWZHIyJySNuBTX/1uwT4jBCvSeEOlH5/Ss2k=", "D5m9qJArwmMKQYhKXEd/6M52l/6GooEZ1aF77bmthao=", "KTb0GhmBbavEEyddlD7wnz+WG0nhXvnWcdEZqjnitNs=", "Kz5cH6G8os/kP+//rvre5di86X9SSErOWbEGVJCaPCs=", "LPVNooZMKNxoFwAKqBX01YWCF4C7J/1nYqxvjCzlA5g=", "AxjUq97RH/RC4ylerl9iuatTx4OwUJZDhDEjuALSVJ0=", "CtXtrhickJiuU3NFodMUW0Qqd3Y3Dsb9tswzzqZ4nGw=", "DALsZOkSpS+YvJZ/Z9dOpTN0oZXmuN8tocCr+V/tHJY=", "ELNU+wXge3LX1lVETMlkEw4+57Y3RJgePFplJ5roBfY=", "GBNaNUdEOt24CeVtKZ1qtxYAympn1z+5A8RuofiKeKA=", "FpstHJUz/eKPW2FyXrHbLfUjyKfzJoFqSKBrSS99CXE=", "BwbMaEaZG/pQqlJ0fGOrG7NXx86qSzigtr39xIzHRdI=", "DyOi3weaOn85Cf/onyouXUjgjIH1arqGm4oHOxNMJ2Y=", "G7LtTNaBBHp9RJpDWxQSoaVFdtGimdgwfJMl0NlXZlg=", "KNQaKsezxxl07gWMciOgp84LtaHkhdvSaGvBMAtH4h4=", "JatQ8g3TkbO62D//DulpIlhTbaIoGQtyMHPVUxDEvR8=", "J7JLNG3hb08oagVqJCOYla3eERh+1cfRHnxTW6XKYwA=", "D/Fq/dnaAoFbmPuSxXY7SbDr+xa87WKbj/LWNxCQxJU=", "CKEyn+tU8ICS0Y2yKR6RxOF8fAmRP+1MATD8jn91ybQ=", "DNa9cyMH7FMUoUJZ01S/fSd/BbrbHNByU4ZkctfpB2k=", "EBvaHygxHCl3zTtFLfaqQpQkuHz0fJI2bNRdmSagq8g=", "AsOTGURZmfgOe4C1o4Y5oM681bB2b2QjAif2gJKA724=", "I+ev/9DG/i7JWjlK8stySusIglAhTAmTQyib30ZdRvI=", "IXbnpUWiRM5LwafCvcqVMS2mL73Su/ja40fGEWcOp9o=", "HGBncxx30B0/qGfo3+wriKy8F+fOrdcGxYquOCVOouI=", "FYiyWCEx0F7iC+yhzkBclJ/BYpIhlEfStzxij6wAzFg=", "Iy9lg4R24BvhKHty+Il5OPB4PtqSufTB6+ggLrKdyIk=", "AitvLGJLY36EPnSnbDJbBf/CrkYUOE4POgzBhWViRnY=", "EgLiwKc7iitDRpSV3ZUx3MgHLRbmOtwCkjxQsUGhhO4=", "AU4gPKZNwFc1szB4rYO5aUIblqqeg0fOLlIus4iG2yQ=", "BAkjISsbfjfJN3k67MIz8gLWt1ePxvUndLFl7WeE5HE=", "D7/EW+fF85Aave+FPS5iFrcYNcNl8Pl98vNB8PBJ6So=", "JzEBVRkrFyZ1DFv/cRfE6+wgmcmLDejFU/WN78MLoxg=", "GcJZQyjcqVlZwq+Av7F50lre9Z6qSnTxXtPxk0CgjMI=", "EEeWvnQ2M8zFP3KBRLrL6/Wgm1vAcXujP6ad7z8xzXI=", "HJf5HfHXmg5beAOypZ8VqxdqIH0c4/aG8uMiMUuvz+c=", "CiSq+RbODSL+Aa/cX5bLHEC0nEjJlmk1T+LCgKM/jLQ=", "F9x6UwPqeXGE+2UCc/qsRHKEvrI+KTOdPsnZHT+MdrI=", "Lhs4fvlZ+CoVD4B9/lo0gPrvbn950V7GX5JNCu0oClY=", "EVPEzhCItRNZ1xclgj0WPOaVQTF2EOBJvroBXyVsH7o=", "DYuJJMukTVce9TkSRVInpb/6RgVwGPtoMU3O7r0IhRU=", "FR6Gj14Z6W9tI2cijTiK/YwIB5TQ1cd8djvuzKyfwLM=", "L6PrEqdw54N6jmkLcV9agR9BAvPxS9MKMIoTmGqS19I=", "KDGOU6mUlkF2Hqh69sgVmg+5SRUIPRoTCL6LsF3t44k=", "K8OBkFOtmmZWAG/eqH76lOT6o3nonEwdOKoS0KFB6bc=", "HBJHdtK7c1KD1KrRStgr+o6CHsVCqvcGW0dld1esMdU=", "KgAHEuSpv1s5Xt2jCS2wBA1EoDRheKoBKJl0WYdMS8U=", "HggAtB7Jw5LC774l9d587trc79EtQ32HTcRq+ZeuAIc=", "KrO1Ch4XaVfcHwjdRxhfDtDZqt3sRcXKt5bdLZkenhg=", "IZCgxVdiZxVuyQgZYTOKRxoEItVgNbi/Oor+eHCjGWw=", "A8t7t9Ojin/xq/jJKCKYpVUcVdKOG9tsTnN3yqA0lh4=", "E0MtGApLgV/4w/OvtCUMmeiclRhBfOXhR0QN+A2T5zA=", "FZb01+WpufW39eGkttBotqrJCSh3uCDr6VoVxZgw+pw=", "K3VwMkmQFvyF35QNfqeKa2yKG+8EF8l2VUZAuRTcm3U=", "KxUov4eonFQneeHWZxomkzGiuaZLVlAaZSvvDcW9UJk=", "L9FDGURBOCtNr0htFZ3vWPHJhpqgo/0Dq9XZySPbxgE=", "CE5b2E6fWj+KwaC+QmnhyrO+p1plHrR2sjrwqUNunhA=", "Jsc3dQIXpOOU4GOBUnXz6Zv4emM55DdlXOkfmaP4lOc=", "ABHUShSiF0VLfLmwE6ftnueNOAhGkD2rkwqfOcBypU4=", "LP8C9GsOyAbEe3yDTgwzeBcsoPdxm2LeF/WY748EdzE=", "GNIVnjoEDYrzmQOJS8nsUdSaqm1Xdtsx8c1N+mFiaNg=", "GPARCuHQZ+703QV3Iulr5mFrbF7a8QHbUpsEmk5hJuc=", "KHDnyiY1tcP4mGVrzY3YU5kXBOB60wFhL017sXS+0vA=", "JnT1ntH95bswPNAQqsipFFi+plop25oWO6OrMTy9bHY=", "A+NLLzOxdrN9jojdNQF3Kolh8Cpb2ymBRYikSYgVfak=", "F5RMDH2RRlGBV/kgAJK8gr8sVnLchYSCNlmwegzvN+8=", "Emeqp3zXGZwQ98K8VYGkLzx7CDceOqpgu0I60uJymDA=", "DvrDzA2qI/HjeNHcvbLt1qXYSVTdAFU/rJZBYlkSODE=", "KHLvRvxXAEYfmvApw2EUAKCoBJe1hSCvtDeU2nEyapc=", "Gr8/tmuTP+XENrLpDcHbxqwv+nTPYLvRXRgxNPBptC4=", "CT2okKakFjoJT7DDFAaDupho/M+OQr7wpR571Xe9oPc=", "JSDKjeNEKJCD9dASZP92pa53bmnWXWcUQvUqaAJCpE4=", "CPN5EXXrRUlCul4/1/AEY+uIkA7pwFPRBfnIONKbEDU=", "BDibn8+bJqDVKnqGsR9Q5M1JzHWP+cHJNSSBwrfPVbU=", "CL+sZ11NFiP1SGZiuOmnL9tJcwZNXMZXKjb4aRV0z6k=", "Ko5TEIpeb6Kwv9LgGoWTI0ka7lzKRZgdcWjxrR3UKl0=", "Hql+SW+mGcUsGdWzMHbOhNUe2UeXBkOwpt8wEQIlKps=", "KSEJewYzZZQsDWpTTiqSqkCJCLaJeUXueHvOZ+RXTO0=", "IRP4cbcTx6se169jmCz0YJWCHiqu9hNo7uEzrqYkXyc=", "BCHJ+x6n0FjAHCU34i0ccX5AwDlsZDvj58ApwFVhY3Q=", "GBxX2QE1VO69Wz6anEqJp/1V53LrL9Sy9H5fAVtSt9U=", "IQ+8f65JqHEbcnRKJYeNHs86iEAdvch+diDvCA6bG1U=", "ADinMDfQSxnDzb90wyzb/xdZ2rV/3UKVSjr9mAdTfIw=", "HE+upSeloUYXDMOoUolHn7IuW7WtLBkAmZ+qkIC7vuk=", "ILx0RX97NpVvJ1mtahiwDsYCoDnADKeSkwSv4aoAZ4s=", "GNvtix69FPzyhY/ywTnSb+kBzk6LUPKMFrpqVsvWw98=", "KQ5fkYzlGCeT/uBi4KyCWZpgOc7bAyfGnMNcSEpgtS8=", "EnDxxJvwW1cRKZg4rLLXfk1SCdZQ3lQNAA/gtjaVclA=", "JEvwBxhEkQWmEv2Z+B+Ck739Q3WKg3WqxkR9Z6+gfUs=", "JTwSZ+Fpd2ncW5FKNBsC6tNYJhBH/adJ7dzD5klqti4=", "H2IFkj8V1mdPj6P13L+bauMAVHGvvNhXGgsCU1JG/3Q=", "GX19hCZUyOlYKQC1tyqbvVtDFVwDkUBkawj+0DKvx7s=", "DcUWKBQzjfvcN05tsvS1QcWY3jpoMjYfRAA6ioixP0Y=", "EYwDhx51P3UossCDQSPKj0PKerN+sf2lNLuzNOlMUr8=", "ISqMKWd6kZz6wrnarakjRq5Yi+4UJlT6g2NHI50jFE4=", "Erv0DSRk+snmTdBNZTmfpu90+FKM9qOuwjVVqCryOFY=", "Hh3rtPdvPXrBVjPja/8J2hjfH56og687y1q02EtKeY0=", "AM6Y2x2lQxuNzYre5wSWP46Jo1s/Ag5pbXkGiuPPsC0=", "IZRGJ+YMqHp3Dq3dVIbBXKXkh/TdGubsIQTeg8MhboY=", "Ijykg3dKfF1PHOOIMg4dX1P/ldxc5TRCru2UvCYl05I=", "JQG1DH5/cpx/TYllAeKU3JHCZr0qbewMuwmvihP8N6g=", "LkOMbvB/m8ywIYZJqR2pNzhwpFrEUkxsvwczGaIZT/8=", "IOsXtT5oDCtg2fPVW53Mi121ngS2Kvy5aM9hR+Nakcc=", "JWEYJTmE63HybXgVBLhNgog5gpPMQZrvWehhPJ+vzUI=", "ILwXBufeJ7l5FmxQ87S3E6oHpbho9fzJ2k+vegZv60Q=", "KLo4pIJ6qN35NJ3EZA+oAXsMrNtFapAQZaps02F+F/w=", "BWH41pl7g2Ui1PGGA3mc3GA4H19l/Pp7znYguP6MdGI=", "CRSHFGWy8PPIPEFlNaUlCC+OZVi1TeMB5fTt9Su2qo4=", "Fg4LSda7IDaLKkiiDFXaDSZZqUq1nxdN5d1ME1BbBNM=", "CXGsL+HzhIPScTf3kva8DvURCNKoeHftsBIFojoYRj0=", "DbNulZsgibN5CIky+lJR5l1O4fQVrUl/VnfmnWIMPz4=", "Jg5rrqBqU+eUfhY/D+gz5RKAL3hi6HCPV1+2uqftbMw=", "AQPnyYSarhLDZCunOHIUHAv7Zb6Jamzg9FrJrI10b/Y=", "GYU6DvDEk4EcMWjikoVfaQEAtzBpu1DdMt3gbJaku7M=", "DigjhJ7AB3wujLJQRvajh4DpQ8o6/9lzyIOAniJ/zZ8=", "FWaeEPN6PSUrKPjAX2ZCCkvG6br3pt1wMoOJcr982eg=", "HaO0Z8EzkSxU/STgDykWqR1TPuRuaP/wdNGhRnF5u58=", "KMiqqAaxP44kDpR9SL6JxgnsJLQu+bGyWRZmnrYT9xU=", "EocwkSbc8gNMszqg0Bt+XhsCCooIrOG64zUw1duM8Vw=", "Jz1z1W/EmNG+QUQohwqS8AgmWNOBAT3nbME8gKLNjeI=", "D3PikUnQ+l4n/6U+SFEYemU/LFsxDt5rlZjky701pag=", "EVCPqi/0+GpOzf7HdOnT+QTgTQ+5yiW5m+MQwj3HS/M=", "CK2jYWXDp4z5POTenH4TvZ/t8isCIuXnCQfBdliOSWY=", "GmSfKnYSGwCh/X1JReOR/Nrzv2lEO4YfzxXZI6RWWPE=", "DH+43MKl2pQJlod7Z5CEl/4HSpiqjWAIBBvbH03G1v4=", "CmolSiV0uGhnv6nlBV7GGCY2jAKOUmkyQvY6gxU6vTw=", "AChoduLz6Vknp9zXbzfkyTe0xeJ0vxI4AfBWm/pv40s=", "IJXC0qnyM5XXfxqGF5xRLcEwHVSZlqMlAID1K5cEyNI=", "KskK/1K5VngsqFmMuysioyhVlrWJGh9g4UEBK/KBLvU=", "EU6RL94h+8EjSL6R4FmLBXQwva+wtOuc+T5n9yNXSaY=", "MB/fDB/1vpgHtRqRYUVBvAaWzsf7FqUDApz7RwTZaW4=", "CaV5w2+LuP4SwN5lwk71h8pAeWyFAFPAIvsBX8a7Bys=", "HG+T1VP55PlqV1MlrtloKlPcphuIUHcjttKt8s1oM4g=", "AA7UGXKPoxxVxZRttEa3+ng/ivWUFY7GCtjB9miTwX8=", "GUEZlsuDvdleYa/y5tSle+mRIHg+Qf3ElfNYyYImiQo=", "Kh7qUyH/xgT4fQVbZQ7mNQNYRJWSOkUbMvwkGsEU8uM=", "IdX+h+OQW2wZw4TUkCv/Tlc+0d+WAQD+L2MPWsckljY=", "Ii2iH0t8gH6+j5O2e/UH33FfU8OyundUYEv5Ou0jp84=", "EbyzMpTl+Ogr+rWBUuqiuR72NSqdC6VbrAA9xzUXJik=", "FfYrjlrBd+fFL6ypHb8k5qkO29pT6gxU1q58OCR7JLA=", "HjKerrQC7PJiWaElf6hc3xB429hYOUwG29Hke5iM8lc=", "H8qUMoEDXtcdiY0WHrwkb5zwQTXDJVy4fK/G4R4OcVw=", "IRJ9Vvbf69QPAm11iku4WR0+HUjBLih1PMcUMaHbHs0=", "Bqad/euegHlqY7SmmCZgk+G6dTTrt+Kw86tYdR0Mv2A=", "LApXpctJZFnlR9Q2bjSp+JrauCH0GLmmxwqhxhUSzmY=", "JhhY9zf80IIBUZZoY6EQNDtgZZJrEzhwkSxZXQ+oA+g=", "B0li1U8moCkJ+ZvDfJPvcAQ+fMUedzpehz04YMV/6eI=", "KX6yC//7s8Pc3PtW8LDiIe8o/PT68FKlKEwEv3dqCHM=", "G4xxGwphCan7quA0wN9lDDLdgM/FmBgW26Wi07qIQkY=", "GHLAz6zyv25C0R1S0owwb8zVPCV1qaJTS4PdJxhiE6Y=", "CegCBjq4wLABJlzPnlvNmoPeD1b969OFzL9cu12oVms=", "LQF32el64W6pI7wpw7NPQ7l0O7BOCvOF/kAQ65Kz+u8=", "IPZO+fO5FDpNynfNssEacvjjvvjK03puB9FW2YLTatk=", "FAheMV/RG9QxFhO1Y2WOGUqN5dzoKNC0AZdNpiqPWVM=", "Hq45B3cijAPr1WP8TMEe4N7XGNCtqO0yfUzAmjMH7ek=", "BkctOprdrbfKVa2NKG1+8GMM6E+mMYMgCfLc2twxXaY=", "APzf2zU9Opm/LCE9mmh9AyGETiNxpcpIvUH3sl6Wtqc=", "IkxFH3Z0V5vgRWiVfa74auv6uHRrjY1oy7XU4sUwGeU=", "DjePILcczf+wsgFJ30HigyxXu/OF6VPyyPVf1UEpGhs=", "AF7etqTKemy/9cXZJpS7RmmNLUduzBeHkEhj9JkU5J8=", "EVvda1yThZVaiiDSRMQGKwjut462kurXiTSCsAvv/ug=", "D2panDnnYjxFg9m3IV3U48yX5ajiQKzg6MX6g0MGDvU=", "KuvnN3Qa2g3PmYDoTwIVBtX1L3pAgvDpfTeUASOtC/g=", "GxzpI/7GH/jaKsSsXTwnksmhrfkDldjHYaqWc1o4omY=", "HCIWccp48A9Y1dVDnA0Rv/O590ti5Adwp5ja6XCl2yQ=", "FXcKkwFuh2FYm21uW8V9yoTLkRViImOROazG8lZozrE=", "DFMNn7DYSisE1P1dI0XFxYfoYDYfgI5dXmDX9hdbMbA=", "Ccko3dMQ8BOgF24xTS126Uh8VjEILcTIMrGDsUNjB4I=", "B1kZp3QmXvYki66AcEkpRWMUsqJ0pE2L4iwaF0fs6Ec=", "HMAls6WfvZkzGNvWXyK0QY+vill/vp2cRiYvW5n+EEw=", "ECRPDpW/k+gy/lLknhwFgw8Q+6kTYie8e+6coQq3Jmc=", "J/xIxf2P7OSFHrX6sojU/UGz6wzOVoJ9rMejUJ5PpMc=", "IZQEz4x/7vdR255dLE2x7JbuZnAeeEIvV7c2+vJZM5g=", "AsFjbWEu4Eji3x843GeSCr0AZ2qXevh1rmbqXVJ3oTQ=", "Ex5AhYehs3Lct5yE1Kkyfk0ak+Il5oL1qMHmrQ95sMg=", "FkBksFJJtsyH0e2vshyOK/F3+XnUa2iyv8bS+bxjajk=", "GjLThhFM+OqdxyBxffhVr0EGUzq35CfaPW+AkeppWQU=", "JhOXaNO+0d/NV1y9XGH8V90s1FuPclwl29h4GRKfI60=", "HSTpdNPBTZo39lo2zioqWT8yHN7IGkCljWXxLaICw9Y=", "JWmv+I5NPyCQYcsCPvqTwmpifa7mbRtnuZdAaCoFf9c=", "ELYh0gxh5wsykghZNxILmyjEiIdezvS7VuyxNOQn1ao=", "K0QZrwNTvlB/PTEhJ1+c6aGjyEAD9HNDlyJItcDS8cI=", "GHNpeFZw+6Rz2nLqxqa4Jf1FgbW9UseEIMskaGWEW/U=", "IQOjKPSiZzoMMpsTb7fwCNGh8AXtXkyibbdNTX9J+8s=", "B5nHvzAHV1i0AONBCFVxQ8TXExlOLfxtilAImxy0Ytg=", "IK7FbA5biUyq9OU31wjKf4+h6KHeYAmnov6kOnBRkjQ=", "K4OeTL/Dv5WU6JPgQZiUOYYwJwVtuRiHwtwJNz+AzBw=", "CVwcBqU5OlmVhw3aLmW5CiBDPc2XiCWHqsAs+P0EQsE=", "CPLPeIb/p4EeFM+LT17oyigZa4NHje03GcLOyaK03n4=", "HqJ2PZepGbxEw/uS5hQ3/kCTJTxHu/sqnlWyUs9/nyc=", "DI6fkWascu3W18uA6AInzMrh0tIFbWqFapBFX1b9cGc=", "BXuzRq8ov9S8I0HWTmWxpXNANK2z4Qmc+fzKec2pyAM=", "Bw9jCvJe+o5NjF41hhNEiJvrx923kAFBE8HCoiHhYf8=", "EdNbtyq9kABHTUSP4iQWyOv6FSwI5qD/z6Ihf7hunBQ=", "LkhhAChJMMLpHB0ArdnGyYwxFHObE/Oz+BFxc3LCWiY=", "CMOf9uYI3Os1Ej8tZNaLI8SoFoHlt9C4uEB+mqHFCtY=", "JwqqtYUtoC58HmyBZ3ObHXGfLaOAYRj+ZrCLUQqh654=", "CLB+2URfPU+dUgVTDXtkkEQGUwcMb0w+OJaOgrk7pYQ=", "Bma0gEcq2zF/WxOKkqTSlRJ778+4O3ZgaB1BuWxAjdw=", "LgaYUFivnhE+siN5zFW2ehXhk2EzhbvEd1poxsUmttk=", "BSMZyRnBlUxNOKfHd0GUmoObPxiGGfdAk+MYDRRMcls=", "L4yAqMMh3XTYXy2rLLFyoIJLmQymN2XW4XtINzTEpMs=", "IpsX/v63FwOnq+gElf9922FAFT9351H/8pAK++GRFL8=", "D5mFrsJjw76GZ+TJPcDYgS+HTO9twyGCfWb9kmga6c4=", "CvFcVmtoLBDMg8O7quPOYh0bw+C0UQgSbMDfmcYiXHg=", "Axd3VME3JqVAUCeH8D3qkXycCWD7IFR4cUyVFdahDoc=", "IshIhdpoWsa3TjkUv+Jmj6CCYu8k8a20xV3doM21gMg=", "ETu4eWG0Scz1WVz2gynLGTCejQZdAT/bAJqw6QZFGG0=", "Kr8ZJHr9f89o/jCYmpo3C5mh8S35svrjC2zTOD+NaRQ=", "L9T+z05G0v5yZHvXCPS9SAn/lh2J3P0q6R+BLgo7n6g=", "F6F++7w1jFP7QZMAAnaN6eE5jznfMqiwbiMDMRTH+a0=", "AiiOKrK4ehLVWjGbNR2YdMMu1EzBbZOmpj4IUvD2Rpc=", "A6w5+GcAtmEfEZImPZRC6QDREA8mAxvLio5iVe0an00=", "ANUyKjTbMAl4U2bABgxH0pphj+CyyulF3vmjXz3a0fU=", "CdmnbjduGU0FNVSiZzRrfgNKbRNEeDTbaNHBAjZ7ks0=", "Kh4L/H84d4e5PLObvVHNnwI64Oc4q8Q96By78SLBPl4=", "LJuhJlq+intX9p+LNjK7E653K6HMmMoDPVNpZkxA9aE=", "DoK3hN9Uc5NlFWht5c+OoahkVaaLO1Wr2lhXvVUn4+4=", "A+x36WS03BE6+/od0u6tu2dvc+J4mfAzxvrKIjgCSFs=", "Cm+e3Mp2x3pdaZohfde2LQ1wRIUjbtkSzmuN4ik8HiM=", "G2KAhND7j+dtY1O/lIK1mvl790im6ARujuypqKn7DKI=", "JID7sEuvCTvMHJFi94IUv+FMNklQDXmOh0d/9x6pkVk=", "LJLBgekWJLyyb6J7bABGBU6ArrzzQt6CLfd1Mz4rGzM=", "Is+8+ErIM5Ijl2Lc2wPoR3smG+Ge9X4jIsBDwIk10nE=", "CaoND9ACfVisrK8g5VHnZDS9ghbrHqazF9Gm0jpTseA=", "FE2OVUCMiYZG8uDdtuwZK15BabsxJZHSx1i5cgdAmsE=", "Dxo53ceFywiBQg9C605rXswQyB9JC+F/gV+dfzTl5Uw=", "Hoc68YpVZjoEyERwSYskW0bva9eB+7Lkv9QzO6FDq0Y=", "JKR3mIahyhqlcgTh+1DgM+Mcf5m4CE0oWwuakzyws8c=", "DnOu3JpFeCVfHQ+FJ3CPnTETEgXh1hQO+XV+jgfVk7g=", "EG8n6CRXuR6fozNY7ZWh+6+GquXU75lUoE3UY13cT84=", "GpUpR/y3fAqwfs8y6/QNltQOx/6Hsk65K0yesW8vz30=", "GXue0ajKhIe3LR6MzlAtqdK6eMPyLPfAXYMUci//cuE=", "FghVS7MJdyy8mgqrkUxOLEANcvny5drUZt+h374F1cg=", "CEgoO9ggGDeXbUM0HUNXj5siYJrC5FfgJmTTSDBnHjY=", "FL63fP4oVAGeBRYLkh+WEZ6U1hbpOgYHk2tFCj4DO2Q=", "A0oUlJFOdpgYXViGRYK/6C/At95q1j+TFxir+CONKAU=", "HDGd87JoC9jHFmlrXSz1A+DupbEdXd6OlSF/SqtqvQ8=", "EsKclf3r8BRjEhog6zOgZCXpFKqexhv2ZbwByiJY4cc=", "G83/tBCwCe/aZ/QF+jP9Eo+nz/NzCzhg3ymyvVYeGsA=", "LoqbgMzStDh/DsJMqg3a+3sP7hys40LOsY6RIj7qduA=", "IxSetlW4ZAt/52scDTtIbCdJ5keo0g8ptfkrL8ZNeqU=", "KmUGleN7/qisyZiRQzX/N23NKXWDJiOE4n+4BaIiP4U=", "KQouZPTh8XvznV1FGaFSgB/8LSA11Iu6DrGo+COOhpo=", "F5eGAZ02kX6Lr6aClHHFgdUyvxC+faHokXpfcKdyThM=", "IrxowIVe7frvVRRI2jtjknEAjQYzqp54P65SQE593LQ=", "E0DVts4GAHVFmoT/f0eSDNUxj50Sf55STdH3rB0IK4w=", "CULJrX3lVd2XYniuu/HSLxvq6g5cortbDm5nnyx7ayI=", "DmW7y16/I6QNbiVwOuApoxcitkoNIQSW3BfJAU+d9FE=", "ARKpGb0M64RVd17kniFltSkbnk5ACnXpd8plZuagvWk=", "G5HE2KVENpsNrureJ6DClmt0Gi1GEx0xBXQfMd8g6hE=", "At2FeX4WjSH6fluWYidm7AwCJGv57jKKkV/y4sjZdCo=", "FiJHJDFBR9R5rgy9JqOB1FhKis/TGF1EObUnYZ065MQ=", "L+hOWXG/06kZ+tBCFKy8UNB/MBXZfChAXd6SgnwCU/M=", "LLZzThmz4CxGqAPVYWcwrWND09kj/pq5hJKSHb4Uw8g=", "GoV+F/LsG0whCt+2q3DHs90M5v9gO3dB3Sp+7UdEU9I=", "FM5jo1DSnl3HD56i4d0JEvjXNNMoM3I6r+2r9BvrW5I=", "ATHS4VLH/D5lqJ9KIuc3M17U9oyCxdzrQ4tRnDUhMrs=", "HkEK8uDE8tITyzRkFNkWnL9IHpuk1EMeI1kRnXlnEPY=", "LJPBRU0MyG60HfEiTZhpcA7eeDZHVhHrHwagNgcC0eQ=", "C9WDWBOt391/5S9MijsQsVfKYwc+4ngvdPQ1BqtY/FI=", "IJRN4b/Be6keek5X6syxKoZPDwP0l5u0oxqEQlzEwOY=", "IXh7VM5UPppx0RvgPh7jrJzN1iIfQ64NJhYkrcK9mC4=", "Il50oLwCPIC7Ja3xEdUquDPqTkaWcoEGQGHt4PPXDjo=", "GfYYlHMAtWHcPUajzWKp0l9+mzPzATh9gasSCf6wpUE=", "IzpGKH1RmsVorfmbuGlHB3dbmZptCjq8qNbKZOAYSEE=", "GNDbqqmNtnO0csitEbSQ+sdvYgieEN7B4lOG49BNz/M=", "F3qmvoZFSttORfZJZyQjGJ6u3zRDkzyl2M8tpLwIb+U=", "AaAoEKxqdnnkAmbyupeMYnhftGe4T7FdprA8Qo6hmE0=", "GubHCl6/JR9ffkoSQglqMm7x1VFMOEM/ASj9xmg1dQU=", "AiFO8XrLoopxWHR2zndfbuDTvT+l7a3piVu16OXQNVg=", "F2lIaYBIuJ7d6MQaAtQZj/Rj12iBo3ibSw2+iDe91hI=", "L6jqeyuxNBXkF1jwS3hJc/8I9Ivj1dz/kGn0id7YQo8=", "AUTMfGrSj6LkfrAnWhpL7/6pc4z6j45zzIkWNJ0eIsY=", "FPmqtcFvsCyayMFDpB1+wfSWj0jujfeP/k+Ht5ofPF0=", "Ief+Dzj8rTdPUlp+WuwFtHoz7umXCX17Z0yvxKBs3cg=", "KLCpHkSKvgkFh298S3z34NWCw5AWENcvov00RTOfibs=", "GhaHTcZ3VUr0NoP/Cvga6nw30Min1IAmaYZA9pRH9Ew=", "JCKJHUOrcfhzDxwURzIOUPk1IT9QNtodLKMIuEpZTuc=", "HaZlJRN86PcrrJ2jauT2ZsPLejsp26nYL3soa0TDL84=", "AMRzGCU1erFfSb6L6Pthukqkm7xmueqInedDPojG1Uk=", "MAACjEAR2uvk5vZO2x/TMzY4r2nUDw6V9IQWWGjJu7c=", "Kb7ck6uztiVp2vyLiYfyld4lJwBvp9HtD9LxSB/WaHo=", "DL50OAUJyKx2aIlYmfwvtrf791KqSD4dnczCUGC5YP8=", "IraUvGjfK8RomkgAUxuxydilNih88emRoDwCZNAJ/CU=", "KtjijC5L9zyHPuhGPqsvO6re2TKlQ9ULuRgvJG85Td4=", "C70EtDSlXUxc2raE+iuEhPihuDpXCZhWaOLU4Mc5yAI=", "K9FUpgdKFbZRth3BWpNkCoh72eEXBCY0ZOy5/sPwQ54=", "LVrxerJYV73XYEQgvQDx+XIy25N3iWctLKknoIIEa5I=", "AvjnlOGy6WHTssx3zraEykUzi+Zd2Y9MzRLnfTRwjqI=", "JOpPvn+bnmbEHMDLG7XizjN2EeNgkl3TzJSVNDKiM84=", "CjfdW8yYvf5PxtD9DsRSDG9EmvWou+T4E7XtXdVEFo8=", "CGpZI1/iDbvhDMYD9pp4t5ZkfLCvNbxyBsVBpIh2cho=", "K9dNbD3Jd9wjCaCnsMfNrQnVS7Rmsr8MrxmCGN/OrwA=", "H69EvQS6v1qy5xUo/bzNX9kdssIAHaP152FiMTYI7Kw=", "Jup//4b+VrdxK1nnDlAquc4JvYvqmAIjY4Frcm83QUU=", "HbI3C18UvkhIXhv/kDOFPJnYBzyxi8nsCweMLNkFKP8=", "JPW/dX0afCj9U958jKvsXLYuRMNzoqMvN42lqqB9Ges=", "C8us7Z754LA9O4frCcQFAQUsS81fwy5LK/e3XiEUit4=", "GrdtrrvtxfHbRAeIYWGHyf7UOxyyZo5T3lFRdhs5J3s=", "JJ3NW6bX0jRzwqFpx261gRhTmfkhaqyt3SRj4FGf5tY=", "DF2hcgC5CgsSWwOe2SK2lU00uXk1RCN0PmAWtbxdgCM=", "LfkIh4yUAv3QowFDUbCSjxxVl5Cg1BatJaJhbBoHPNA=", "Ic4uMwiZUbAa9F3zgWyA4gSGhvHoAUwlfJXi7z4nU/E=", "G77LYHlQxU90pic2mp+UVIhnd4YE3Y3kBkg+IfYe4aU=", "I8F1R5lls7SpcZz+a+amEMDHdnDlhsKrDPCDUB5p8QE=", "LzcNFY0VtzZWLW0EV8RHBuZxvpqqUkvGs7/DQoCZYQA=", "DvEcv/UN8eHTa+DI81WIu75Aa76jGju25pt/fE9Ooac=", "Hy/xF2ddl1NcJNGaWLqvqwOQ89QRSpZcQzUMF84JWu8=", "FHEtAciXWQ0u6qtumOGOWsGVhpKgTBtRJO4GroYoz6I=", "Jo42F1LHKkrZSbKtHvnm8ugGN1lGuLnmM2A41PhJws0=", "Ed4ft8Betjikq9tLQ4JhhSm5mXisxz9OhWPCgxzeErk=", "DSpyNDqQ27UykCOVgbL/MSBqArnNmLrGZn/SR62QlUQ=", "D8aT+fj1y2obi+ZonbwD9QMfXfSjB4LYCR9zjcfh6d8=", "DkHiqZf6TQ+LdS7MDcY7OhIb6B6g4kIVTf5n7ASfVwQ=", "CHssqNeJMfb94IN85PpYlEWW88nPKtq46uMLRJROF4g=", "El2TrM92nU01FLIdTGY7FTniJ+nLxFlkQgNh2NIgIV0=", "H5GscYZIzR/a8r9vEa7v972CBs7ldp2IF7uXAznojrk=", "KZFKts7EZf2S+PLIaeHOnU27P4g7KWhQY/M5WIESZZw=", "AtpKEEhu9tDv/rJvhpvvmfbVDY/qoeoci96VmJQp5dU=", "CCVX0/UPpRfeJxDgSYpoOTDbW5+yaeirakJ3HVrn3DM=", "HSCDLpYPVQ1wYYcvbNlnlvnPYfr0+AffDDc0peg5Iyw=", "G1eoItNOStBs7E4Z3/Mka/hGvDQIA22rArwrEso44EQ=", "C8eYyNz3nKmnx2yw6Lt8I2Zxn+dAkuYeb0DoxAh/wLU=", "GpdbF5ZJsRTjxFWaGxQSXjXjYwvx+Dg/r5rygsk2cAw=", "DKrp9LZrReRzLpeFGROllFQHMPJlKYAVOcTUSJYHX9Q=", "COPagSTGIeBw6KQfD/Hxz3XiIRCHlVOS2FoXI70txB8=", "Jg4xVRSPiSt/lrLXTmx5ueLBo82c0HhK5QeHXkomeIE=", "Lj7Y0n7nG7QeW8mPtGbdT/nQ+KZohht3Ovgl0mCuOUM=", "IdD7fONk4Kx4Gx4R2Jq/6gBjksq9IPB0DRVr4eRefuw=", "AwGhqsxPhmhOPteg6wI7ksx1r2+CFJEPhAxifD2jzXE=", "Ee5TvrHo7k7BBon0/kDr2TzRyf4G2BLpalgzaENewrY=", "AdQtLdnSNyUwww9NYSJzLRzvjeqeLr+zsmeenw3NBMk=", "CGHkSLkv/nOOGK5noUOHbVWljBYvdNjlVnFNH35ih5I=", "GTeTv+XHuQxtYUdeic8NQURxKPKA2MbF3Uvh/JBy7ys=", "ASawXuEkyFqiscEnPCHDzv597TmzBcXgOaNfkCTMElY=", "BWncwibC4hWuaXuMYAEBHLrnzlNfRagD3GD96dpQyDo=", "D+YXLdWv6P8OfjP2SZkW/Uxf8vq5aWN64y2OTP0/79Q=", "B0/yxfAIBg6J0wllWRJgZ5zT8PWu0zFirJrJnaELq1M=", "CG5lRE1TZtghM9jK0KYcIAZrib4chw3Kv+RTZI0rawY=", "C5vL1St7iZplGgLDJuBkrGqXvnRXu86JbkZdc+k6+5o=", "AmngNcQpxL2u3Dk9KoeXihwvjKCyWwhepEzlh47FBrs=", "CeG3ckWDsOFqebp2cGNvh+oTShniDcPscMAce5RmTa0=", "JkylZRrnuE9D2IQc+ylry18Z+loGosTSGEtUw9Y3CTY=", "JOStjC84//37UDpN1QV1xaEkJqU0Y1njpWVK8BiPCqI=", "Ct/KzvarJi+PydL2FMD+SjJzyCqeczXl4OCADYHoeHU=", "GHrduXxKZDcUWGbPJw30pXunBZcP4eBhmg8BaTMGXSw=", "BxBwLfhB1O9eDK2rcZep7xnXUkgIu6Vt+EWi6PFBvKo=", "LgZkqrx0tcVNnQR79UcORevHhAJhWSc/HS9eR1nABlE=", "Jxy3qukUKtcYQqdwzGXfGdfRAtkjVFTXxgCnNaH6Tac=", "L/R1+dUiQcImG59SDSMi9SJo0omgKOl0dC1An9i7OwY=", "LTuyz4Uw5pi3ce3mZXigFJ5WGzZtUCpuecI7M8UAwqQ=", "BcgLWha2pZ4eNjA6Wbp4LNcUB/gyc/N8GepUqWHgytk=", "Fwd8ymnu0o8h7q8PAEhpLNMQ5rqHtlt1lN5ZAqgp168=", "Ltvk2ChpYtkc8akxdfklsXTPU9hVko8vEM9G57rx+ZQ=", "L5V1emLRpSicagh+XIKeVNW8LgMIKthiFkHYL1dYJZo=", "DCyhpPFoLaP1ZJDR8VQZTr5Aq0QZlRy81QjIYAXMz6w=", "FRtVl3Ptv9SkmkU8FzIhKVXcnV/2FOgOdaxj0GXdDMw=", "MEOuCGnrjRO4EBeLlus3yqJ6hHB3e92rhQAjhLbhqhE=", "AahD3/liFIfTU7cM4E2d7UOPdsUBP0eAeYBjpN9tt7E=", "Du+CQVJ3hMv/M/VR9uLlPRa3RFifUFCM2qCELgXsoB0=", "GuhbRScBfUXYBaJbE54/Qk03RYQc7K2kZY2Xs4zvxMM=", "DtQ38PEZMr8WsM139Jg68VEeVweEJ/7tMoeAgouNhCw=", "F96aEXFhuuf4JDFN23pJ1Z4kQ81iDg568ILnJGpyXpw=", "EoWM6lHu7C5PulByqQSTGN5A6ppBefp0x7/B4VcGgB8=", "CM9AQJH07l/cBo/1Gifnmhj4rpOt2iO0Et437tFk+9U=", "B2OPdVg0sF5tuvG5kqur4bV1iX53bq00caT+aNnnD3o=", "JGEFVY9FR56M1Ul9kkCm3ZjZboER7U5v6K5IHMIhOUs=", "KZTk3iP0c3HGjNH2AucSlaNqNluXBwTHCyL4qBaFC18=", "IsjTv73zY3qWMenRsIUG1g/uaUWwA466jy2oXxD+8Mc=", "KBwvryosRJu0CkvEc46mTv7BGNNL37OGUvyG5VKXoz4=", "GMBFzdqrQziTRLTv6VJU3OfSX305KwUlbCuUnkfKo/0=", "APiafxrJ+zeydTx1itAmXJTv/n54OMXwNpb74eoZzWI=", "F6qqa8cbLRqg2ISwCTTxKDxZkBHpbv1G1NYC2V2Gn4o=", "KRNFcXUkElXZTwAuxQpRg4YW8nWNaXI6kb8K3Eb60Os=", "EuujTFLJN2Ui+ACKZmCKtPCEAaq4XRY2R5H9+RumYfw=", "E16TeWk/Ttvp/IaESTilJRjonbn+E+RXWRMoco8V3Ag=", "L2u06RggseE2f4MTTtYygwMHBlrfda7uFmbTpZvqp2o=", "E1Q6mOWLG235gkf0UuAA/gcas/zbCz5rGpGa41I1KBg=", "L9gffYRLmaxh6PCT3GX+DPRdwqXN6+lvALD0O9C32c4=", "LVVSIiztTiDMgDcaAhBBHpUYDMSzEOtmIJwqRmgafwc=", "I8FTOIvhIZa8HJfYjZoY3trgmbyw8f+ldphTeQIqGyE=", "B/DSaes03Wmt3V3vWQK5p6ltzRc7/kYIKO05jvs6Ovo=", "DVEWkbbvezLWtku3DiGYJtEFwOPfuQWouIFkuOM/Ldw=", "KH3DYJd0CW0rnZjG8lMJRpANnc0F8APeHS+LPLjn0a4=", "EVMbFN20mwZvESmAjwQ+PJ0/MgieOuvP4pzknZPQ11k=", "JwwH+4WHHzAXxGiz9HAcQsViu3miy3Shtj+FcJCTMYE=", "CRz9eQ1JBJci1IISkhHwrsOhCvPRy6/xrMZ09ZjPvSo=", "Lh+bVGXqXoTIyyWbpc72PH94sER3vq87YSd0rdYyXLo=", "Bk1a5w1LhXT/MHfoNf7kiAF8wxfKivJiFj/PnxNIaNg=", "GN2UVqdnRJxlfD1WY+6nHlTl61s4HU4BWMccoOOo+yk=", "AVD4tY4GNbyo5URS8+Mf9ZecISLi7WMVx14uHvv02VM=", "GcH4IhNfu1kyuuuGImHTf1hhPBrG7MbRqYWlRqUuYUI=", "LOsqsldrK2beZMmoxWSGn3kQCng9SupB509DZUfP1jA=", "KJ7zBKEAI+Ty1OR8ryV2YHkQPltwWfrcxBpHWTfqR7c=", "EGRVrBf/WxYlE1Zj8oYn2RnrrpEMaXyUDpZ+kXtm46k=", "J+GUFhodDeRUyfR6R9hiiaEyTzBp40agoUopHtH1D3g=", "A+o6zhMaWAxzfq13J1qqsfu/NflXul/6QOMZARf/vxk=", "EI4Tb2wKcBaqPJEUAXhmj4vpKuqL8ipYpgQBvwN/OKY=", "E4S1b2nK6TkwCVgoXOrVz+sZcfQrtzWFLSHz8/8ua9Y=", "F6/FvMOuFPDdqqCtfwaHhcKohnKuJmnKaNVT9LVhHac=", "KvK01uSFkMtqs3JgzQYowwXpVxoQSq/FowCG7Tbrc54=", "BJZfyLuXB9qu0geZTIjSNqM8wJmcfhFlEvw2w/PEhRY=", "GqJ0+TmuklvayAkXnmBUe6kXbQzE07Zuxh6lkUYnhwQ=", "AsvP9dC1J2nuD+z870zdmV5mQXCU6EyUeYVngPsdlA4=", "JRPyrVm5kbkBW4dIkBo3Am0uUR7K8SpxZkOBAye8I0k=", "I/4xLnu2ow/tbNAPoNmKIV6QO0VgPuwU/5ITUtaUTaY=", "DONSwVu4Gzn+DnJjhGucC60PmtspNcESpMpPWMELRgY=", "F4So4WG+jMhSV0pAxkhirfWtZARo9FG6Ed4/2sNeyt0=", "FIr2a406BtTaS/0JEhyrIEXPoaluie4eI9xhRFNm8cw=", "DSgpWxd1MCQ5XFD4C+xmiQr7xFiGaFhHT1dlz751r1Q=", "CbxWiq3yXJqIQE2ifHNzKBe2qmyb+9TOhR6Jrv0Umd4=", "Cw/1uWlN7pzsZphi1JgluJNPc96uQEyeWmAWUq+P1PQ=", "Dn/O5bxSmVb7TTHpjaE3YnbK55UDkG3Vs/mHv0I+wNY=", "BXkDlpkAEXwoeynKxLMVKX0TeynvKIPjnxftwxhSmko=", "Hc11Y1yDHPPPW+rt1UUO1j/7F9w120Tr+gIHj8VcNt8=", "DyNef8NHgOgAXCQsyEKHZL5uSIyOuGBL271+BkQ2FwE=", "AdhP/sRlTd4E3psKCThdUJzCsgIWJKWdJ0/Q4GOziZ0=", "CALPNoTsJkbFNcAYMFvBN3tDdZCq1lSVFRnFOcMNVN4="],
      M: [["DjCndMNTosvyRNPQFNGg5f8LrF4kJnOuM/G7IDD+/2g=", "EhhrsiAArYS2vykXmt4tTn6U/wflFifglYBXEGH6jOg=", "I5n6pkiu35Akxqw86v6iSCFuJKnlbK9azSnOJUap9rI=", "A63Sn+OY7S1E8jMSXs0VCePO3nfmvgi5SvT+yH6z5I4=", "Ehr2H03FuySJCr65JR5c6pR3CrBi3Awou4mV3Y8YNjU=", "LKj/7i1Y8pRSl7AM0LUR2hZwgNU5SbPx/OrKlha2FD0=", "LJnvXgZBR9qXgrkUopS2wU0h6n7sH3LodhZxBp2CoTQ=", "DX0HzTeY9E2DKmVxwhcGdYaT5ek2hM4tGl6KU+DMZwk=", "KRlRFxBmI///sK9SXIOGhtDZcln8c6UZRgmse3sXExM=", "AbYtSxfeZzdbWPJIqI2/cHzJ0UkbzgCVZEygIZoB5Ao=", "LhaBvHwi0kxDP4HdOjJv0CQr/H4r3rYwfk0qyjKt2h0=", "AGWFDRHQ7Kh8Npe29eV/eMqGlSutHJBH29Lra+np2zA=", "Glmza5T51yNXflBNYAxJPygQ8OZxEmcsdDq7sTq/Q7g=", "GksYa3fNU/lhyMy3gV2Xgc73pSr2TQv3RstSJRLT0K8="], ["EoJuW5vhybhffJiqypziiocGh9NijWDe8KswcrV7Cbg=", "I345mA+QB7v4aZ2+zgVP6h8ZdmvmEBiF1CH6PqRrU0g=", "BUD1SSSXWV4TCA8C9rHmU+LlGJUWD/1coU0mrtk7hnI=", "Erv7sRDsKXEAfdrF+ONvZVRl0F8kYplrIRTvrKxwr7U=", "Ly7FHEj4tzxRsmSnDSugtGvbQ/kz3g+uqKfaKpfLQfM=", "JuNlRNC1lS3eQAfRGBhGW96RxNzmWrwBXnVWuli5X/o=", "Imv5S4axd8/n8DED1Z4/nOI5OCGVRwjnxyP4EEpoxmQ=", "JeMRs3zuaTVF4sLvwgQ7wHNVIRWzoGXO8T02VHtrncU=", "DyM24O7kaFdByiOCjDTCTwc0kfDnLBOWEFJKVvcapAU=", "DZu32rShiaO2mQpVJsgrCuULp91Vj5Ubuf00PLtLDhk=", "KkpsyITP0Ir0sNvom22ODlgRMget7Yy6stB1BT7+mYw=", "Hrl4GbNTHrtkDta0ITQzVBkQHR22DdGpJO+WZfepGvU=", "ImuR41LGXeT87hEkRb/yDkpnrw4RCVcxmyhg1Qh0Brs=", "CsW4YSjuR5RMEq9THPFFgELDWt/NnltqdTGXNxRVnec="], ["Iv6hKXpKXwiQTVVcLhXQFhAqTtKcMrS7EICe8Ur0LHc=", "GAjL593yo2hNihZP4tFQ32Igb2vjPVd9xXmPGTru16E=", "HBzLRP+KttqFTpJx9L7ybSrCbNdEHxtp0W7uDXp7SBs=", "G40gnWayway6ukNeMEriBmLTNtEDML6zNVz4AfGUcz8=", "EXOM7TkzxLJ94TkR23HM1Yt7MTRO2RU9vd3bkfvbzqs=", "HpfOATr6punJk+nP3JquyRsGeHgZgwmFpy6ffG5Rarc=", "Bmq4vq2ue+vSajOtvWuzktaCXaN6Z56K+a6LxIE8MWg=", "IbN75SGDXDK2c6Mdca7RvH8+qW/h1MI/FGI6CoUaPNg=", "HobsCGgFvHcSt1EN72USSbodSRB2JB2Z0AxpKIDzmnU=", "B10aps0rjRgcng9CJ1yYhK5voJGG/iJ+XEZz5W46zSg=", "FCqDIGdHIA/bAnc+dm9QTGWvgrIAwOf9lC+SviPVhr4=", "DuRoPI2lNra1B3Okabu94uQXoc+b4iFSCvHnVZaNf/Y=", "Fo53Hp+PhgxJNn75GaANTxKLqwHBPX3XLOjTa8bR2DU=", "DCpDkGcSFEnB7z26a+H/hParf6xLvVStdTnmGCbKGXE="], ["JMxnUYlAh7gxWYtbx/nbPLtIzilNkgjhqkNstfougOE=", "AzzM7wWwvPe3eqVWCg+UnJC+XMLFcSL5iF0koRfGP5g=", "Do78hc/r3ilc5YneYK7A20PIH0vn2kTrJvpLcffLfuk=", "Cp1+5+6RZ3r/08pPxnRiW+iX33n4LsQ46A8eAAyLH3A=", "CRdbH6+s3A5itflebKZ8P/yWom43z8c0eVuS8eRhJNQ=", "MBawdMgUIl4tXBCRqDA+7kvkdrFFitVMFrThaR9rRyQ=", "DAmYYVReATpofN1Jo6KWqNLC6ZaRwlNdpxLTUdXmPBA=", "C3Gga7dbChC/0oo3iL9UqKFEsyh9+cWRomQ8QQD+OI8=", "FJN4ecTHEnZEx2W2Ni+LmM/TL4Vy16rZzDKb7VtQemk=", "KPngBY688VkbwAfLAqw6zeCFFCfbIMc1jb75+pxXwro=", "DfZTUk//kt3o7ByaUcG+wwvzak8B6bO2LrE/j/33uL8=", "At/PsoCj03LbwVY56s5FwLrFYsROKS8UKbyRZXj7C/0=", "CzRYkLM8I9FnOWxYPRLk89nvyQTyYSAlEjUBkKsZYcU=", "BPfx+v7hIbuBE0T3P1T0o1gwdnOd2d/EYrOuY0PJPLA="], ["LMPQUDoOHalSsIG6XcWxF+ZGvtVypkUmbG7DzgoUdLk=", "KFTIK0tfXfbdOHLj83E3LeDRLhbpEIdmkgtUWBBedr0=", "Cx2BD8xyFVHipZbpAJNn/GqSSFerKbcDIHsIyV7NAB0=", "C26yJU7frh11A8NRjmTPGfNEPWzQO3HPvxvlk22k4EY=", "IQpKgObqp5n3zgV1K72k1P8FIHQslD4e/usSqRIppa8=", "HBss8R8NOjoSG+fQ3fsk3HH1S5vvlDruMpY5ZpIqg5k=", "FXTJ5cqqimp/tIlNLEXRkB0cQrMhT+mnL9PMZo45n3Y=", "Ju1f/wbvnhlCvT0NO6aEjkfsBFzSb5MEnYDL+mvMc7A=", "BZ3oc8WYBvVRFLw/gwn5tkz8unQ0quIgRH6g6cSmbaI=", "AX45zLo0MqE1wAddcgxklWLuTTG22i6ckL1yoDl2XnM=", "KufxQU8UQ3NTGBY+G/seG89cJx839qvxqoZ2ay5Z4Ek=", "EuqSGs9bitxqTja+hXE1dtZYCZIwsLF2bGZvEtkqsUI=", "GBXUwuahj08/pTigBBRtf1QPvoCkYFhXcU+6J5VhXfk=", "GPbEDjzPiFgEs3RDOvCpYrKWP7mqAei66MyDSz4Xox0="], ["Ee7b5aWWnzNEZQNJS0aaK4P4jTqkd+XW15Y6gzOmExU=", "AJtjx138q1ctKAsFf7w2QNNd1fFiRIY6uKMeCVbaiAI=", "Cfysw5mAZRJN4Bv3wMi6JqxCQfH33soe7+XvPVAV460=", "AamrP8IFmwz/fjzEMffbRfWdj39yTNEKA/MaNmOPi1I=", "Gbr9DXlCuDnzatPXDZyHtVZ0ub3uAqfcMOT5nrzB2U8=", "AMR0gkr9KogMaoWnt6WkNKxCLHpjqvjdx8TZMl7e9A4=", "A6ZakdNbbod5CNXEGeeFD2RfYrHJE3ZaIUuw96KRW0k=", "E3kIuqwuNeE/hoNKv+mNG1S3wl1shfxsBex83tkXVRc=", "FmLybPBPW5ac3WuT6JDvK1sRJPUYIoiNwhZ7vs98Mec=", "DNCkwn3hGutkYOMvoryyicuDMhcjFVMEkp6wyk7qA8k=", "IDC3vCpwkF0DFnTvtCAzb6uwdprAElw13+L/NywapOs=", "C1NCUDr0Ru+CTfTfagiBlftnJ2ZX1CDm8xKyYo6SKYY=", "KCpVX5rU+1dpj6ofwyebuMKMH43IxpMiW9hSDbQxNIk=", "F0waEJXpXU8JjI1ggmd2wvc2kds37DuTeDW2WwG6E9Y="], ["GJrp6bFiqxoZ1ZnO3O9Ci9EyXHh0CqrWcVtxC/rEweY=", "KP028cdh6nvOKebwAGf6QLMuazGPUGtslLuEe/crW1I=", "BdLwo8IjEirAEhQlAyC1L/Wj0kIRjhl3iyyM0al2xhE=", "Aj+6I6tLwk1IgLpab/1utQUN+40PVkdtOjApDto3KsQ=", "JrjqsN0NlbeoQ54P99NDinOie1mT2B/OznKagko1IbE=", "GXdex4H9QImFn2t/EnyR64Put+yereFGd7CmsQuebiQ=", "DAc+rdtdP3nlv4O6wA83cAvWRQLYv31aCZ+z7/fTsD8=", "FDmR6DhtYjNMoNh4MqCEW0hBbvUVjBjnuduM1q7iI6o=", "BfuJfXHt2NjrHztcgjpYgqBtlkBWr9Uy5siIk6JfJhU=", "J0WgWdCWLxvw3eHhuX4Lv0xBQ9EP0/3rjSspXuTXqd0=", "EqcQ3m0X+Rr4kBAiJoU7tkIJ8bQTMaHRcwW/W3tSFy0=", "CSZfsxSmdraz+CfwcoOh7U8wDo2Q+WeyD/YfRV0qsv4=", "FIqxWXKmkltxRgJxD+nmTAoBUFOsuDjQ6HakbLVlP1k=", "H3+XBMqxz+orJHHVee+Z0ZOyNK+Q5iygm1pnHCQopRU="], ["Gq0RRJ1uLG4a3PnokRTDNsAUVSjzVqwEn1L9jLCENwo=", "K1bC5E9wOjsUPaA8JXSTZ/dSsWgXJX5tEjsQvIVUNDI=", "DHUT92K2QCKhUdYjAgmd/9UXkdmv09z5bL/PYDWiwnw=", "CyZwD9TpUMJa14/ttj/LDZunPsq4WMBxZkhmqQlvFNU=", "FzmF/hfzsPuF3mEEwCtGw9ee7p3Ci1Z/AqsaHA3exXY=", "IKmmKEz8Q4F5XjsGg36VloFf1bbxYr3gL5fbaHyEef0=", "IXqkALK2Jbw2QypUXlMxJPmcHLmOuF33RzGehdUwRwo=", "FI3JM19iH/+cjS+nKpz1tv66vh9c53aJwaKeOTGF+6M=", "Ds+sqtDBR+Czx+BJdx5tQHKwLuTRccDlMiQhTRet41E=", "E2WpBMf2chAC284XB3qJqSu4A4vSevUzM/RHxM8DWoA=", "H7pxO5h0IxHfs/o1b/g+7yNM6L8rDUpS3nr00lGfLxI=", "CrkT9l4c6znti4O9XX/ZAOeFEe2rz+YjFN0Q1WeFjY4=", "COE8LmHERrUwJNIRarF2yENgDQDmdkAsRkF0UVjCQ/g=", "AfoCYWAkzZvt9kPqNtJi0bJPOKVXp3qCxoZhjDwz7fk="], ["DX4eriz+xAZALTTCWeWWb24usmHU8I4pCIMlprtmmmM=", "GE5YJGieT4FDhWffQ1854dNagZBB1+rzr5CEKb6yvC8=", "GP3mRRBiAW7eqjLkCo/DB1HhfpusGS+MqJHBHznr/4E=", "BKVyuGEF26UlPX7R5201oSbmcYVRuXayCPWT8IFY3qk=", "HZSOh3SxgPpeGjkyQ53+jF8ypDdlfSEnfkJhS0yaPcM=", "IEQapfTVY45k162ZgrG/z94Vj2o81q9ilB4FzI5TMVE=", "F4pY/xItFozU/xGkcoCkuOXNsxNBG29umpR8f7V3pR8=", "JW4UU3jSYE24xQndpFUkUrbEqJH6xdoZnHVgdo2UiDY=", "JfZNQqdQlxr8uAIwcPbsl7sjYrGWparir2pw8uezV68=", "AvgSEh4urMx9Ub8mY5jVuo9gGiqm0zXrafeGRkIXdmc=", "AMj4ciiSovBsWrRU5Ae9VX6cLqd++AfuDj2JxnhbDTM=", "BAfVhaan77VhN35fOXIxmj5yheFGxUme9shQSj0LYuM=", "EcuD4B/1gDsEmitZrpkVs+AEXh22lKbfnenE5xUtGR0=", "LhwpLga3+KbkNE8QVAZ1pjyknkUvaVZfz7zUO6wPOvQ="], ["B5aiOtbtKsmVEEoNPmx16XfOKauh0l5iqaiiA2TqG+A=", "EATF7Lq2t9Eva7TK6rM91Wwfgp7ij0fCn7+7FH6IRlQ=", "B3VZRzc3VJ37IBbfpyVYuywcgW1zGHY6Xk/VFrBJFOg=", "G8vmftX7dSKt6v0dmhUPjVetohjbNGkVyG5sAMAOOLg=", "G2GgPiGDYiBP0gtnU25ebKe5bbtT1T7RYCMCmIYUh28=", "LT0mnuMk58Q8EaqEzRW61lRE74Np3xV0moprLIEh4rk=", "DqRdIkee9Xc+WLD+dAho/B6LUL/3YEnVtu1ecjcRhns=", "IoAlDiEr4qSNKTeWqIrGKwVBEBL0amb4egIgo9/z950=", "IL5wP4bXwLna2Y/4u5/JL+isCoTGiXp12FEUb3SEC3E=", "IfjYVAkd22AdqxsB+zDD1Pd8wxZ/ozMsOzI3egfmqsg=", "Db0JPcFuc4Mr3mLQXLsG+CcfpHIpRwRi2MGM+KEk+es=", "L/W7vAItG3T+GEwGTljZZ/Gq0fCSbJBqXjVs/DuBrSQ=", "EZgWhiyCJunl36vzFns7K/f7PRkGOYmyShbZfJS9U9c=", "BvvO1SV2qRPmzcXFyW/cj59Okx+pC+60bZs8LXdeHjY="], ["KZuOhiHX2MjT1ihssSazTuU7LcmjaXuDgMbkf1cRNFw=", "Cpc6ZlaT7QlDTtsssKlxrSd6grM4V4hVI0muCei9DIU=", "LenuZSnlq8eu6Tt5TE7v3VF8T+EvpWvOBqNwjYYza74=", "Lqa3pyZcUD/LKEwrsZUS2uce81cSXDrHVca8bMN722Y=", "E4C+rHsGLGuJkUqXao0LnTJ2oTyCwj+iH0+kQD4yZ80=", "GlcY9Kkt2NF5uTKwgg9lx7uT6rzjmPmXMk+YrHYyO5I=", "HHy/JEjecRTu1wGwQYCQNOB7lGoDQLd3JoUp1YLCJao=", "CcieBsrVQwFT3VLMZq5PUhv0FF3wSGgb6y4Go4UFARc=", "KW86nBBCImkqRK0k8Pb9gZACfgdVVn6acAnsce9EDqA=", "AYOTUF6mIwZpqAMPbnYTChTBBwqQG6W2QLiK6A19MLU=", "HcowYKa7xMMk9++6IidP2NHyVgpO66jIsNOJl+DZxGs=", "BtptiMIz4xgsX6XM2hOSwPiffGvsTmDajfgFSAfrCSI=", "DGHsebEG6dxklKY1nxdf9jeDnKU6yOehNHHFZkYYA5A=", "LOxn5iMgvGoMoyUY7IHHQ2OkttJZvSdaY0JdbO3kaNg="], ["IPEe6B0qyantHKxh2c/fEL8bSc37ttIyhyod8UJ8GDk=", "ElR4yJc7w5W2SMgiCR+N9GlQSnHKT98dq1mnCND+Rxk=", "ErWRt681/9mXs6YTaH5EkiViXdXRAc7y1vKvAtnb1tc=", "MFRO2pwyLGyHJnHWZ/xfzwnPuNNOjlgStuc456tA2O8=", "IRDBBe+0gbZ5zrLxEtbqcERCdjrirGXt+PFc/RacVg0=", "CP1Dl6qLOoTdG6Ti0Ot8bRxe2h92SBS1/+IEyOxzVgY=", "JIffnV4Ga3b/yy8MoZCr9fweWHLEtqNqRocOkVkgEBA=", "Cq1owg+t4ePiv3D870tVC6ANY5niDYNAL+CbUt3N9Sc=", "BjAWebbNsXqmwhLONC7PaBq3zZa/C/uTNQNoAE2Xw1M=", "HhUf7f6hFlnBiaMbon8sz2lWCEGI6yxMmbgn9kXx22E=", "KRvZQB3iCRa5ACoAZhFLO/rk08gwirpK/czfCuwS1mo=", "AKqyfmJ5lSxykfA2kY8LJ507HZ+OTorDgNp37C/CTqA=", "Ho7mQTCLpv5WALLfSSzy8U+YkroQJYJsU8d663vNsEs=", "J24mI4KJSeai/ckX4u1F3ODuUDza/8mt2BX20dPE+dU="], ["CkA+l5lDuNL5R/btptQRcIgTQbteT7uztP4919zN13c=", "KwaW1FmAAgoqQhBzRA46T9Oe3FKI5pAKWVjgzYHg7uY=", "L5+I/pvjZFfopUZFWqAKD1EAp/MlgLePJqd70LdhIYE=", "IGcz4yemS3jTxItvdYDQiHwXeDQ7Z3aIWeJTLX0cRqc=", "AMJy0Qry73ipjf90hsSddQXt2IySLlZyo6uxXMSfQTQ=", "GjJ/8sRvWWn8rLRjUG4QLWglAjgfw/mZuf+9RSC6RpU=", "LAy75GQikXFSyhkGRivLWhPvU2MiqHFSN9oJuMWUysU=", "JfQQNSHjbVXkGBYu+Ov+xtRWlVIO9HuFSLo4tSon+/U=", "AHlA6wS2HsU0HBcC8DmT+u0Wfbb6LOqSKQzYIbFf5MI=", "KuHsnglXfILJe0sJFCrOUaqtHffcNSzU5YE9jO6cmNs=", "HJf8d1+WL+Bae2Y0a5PDJgyPapCn9cYyI6M4bhmFLq0=", "J3N/zXbdKWwogXZG0wsRaMTQDh92TEVlyqMnbe/RXH4=", "FrYbJC1B4ZdYQzCaAaNqFDl9fI5760r72SM7RTqszbo=", "DHW6YPjg9q+hJudXA7g9mQgRYUe4sttF7yTzFWuPGFU="], ["BGRiUzgPS/ZClyroGXd3lFSqCDP9o2sYIsucCXGePdE=", "AmRiXHTyo7u9wZSBt4ZnV+Y5wSS061YNpTH875l3OQM=", "CXFOcX2qPOs+l5TSSrzRcoMcuhgGbEwEiwmV6ebfHew=", "FNrJBZyeeNlsfvgHujQrlGhwZ5eCIx0q8Pbkq3bL0QE=", "Ep3Wd8H4qi020qfVNAZF36w0pkrkVvkbl96fjpExNhU=", "EIec6rw60EXXb2zVsmtW3Ee1EtZQlFj5/96Np55mSc0=", "D3w/PMls7aA55DyGwbaAx31vSfUOlN4j5NtC+OnK99M=", "EL14JPwbiDs9oActLGGUxKHllXFWWU6Qitv25rGRK5s=", "CQ2hLhWVVR0lAPkDELdwHfl2dkBBE8M+R1sud0mtthM=", "JM6wdm3iX8IniShqCSh750AxDEF0cyC98utclW4EA1Y=", "HH3OzqWeb3vrbXAuL+dFiEFdMOXcCZcLstVqzI4IMo8=", "EQpehN4JIJ6TY8A8IrU3rGp6q6L2qdGh9r+rcalgpYM=", "E4ItzD9icbcVScLNkXuFnNrDavaEiATRWjVNTeD2fvk=", "CF44CQXrLLfnU9CrD/SRiyMsc0QYtr/hMx3kkvx2shw="]]
    };
    exports2.default = _default;
  }
});

// node_modules/@selfxyz/common/node_modules/poseidon-lite/poseidon13.js
var require_poseidon13 = __commonJS({
  "node_modules/@selfxyz/common/node_modules/poseidon-lite/poseidon13.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.poseidon13 = poseidon132;
    var _poseidon = _interopRequireDefault(require_poseidon());
    var _unstringify = _interopRequireDefault(require_unstringify());
    var _ = _interopRequireDefault(require__13());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var c = (0, _unstringify.default)(_.default);
    function poseidon132(inputs) {
      return (0, _poseidon.default)(inputs, c);
    }
  }
});

// node_modules/@selfxyz/common/node_modules/poseidon-lite/constants/14.js
var require__14 = __commonJS({
  "node_modules/@selfxyz/common/node_modules/poseidon-lite/constants/14.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _default = {
      C: ["FI2eRUIGaxJdptaf8/tnbr0n5qOKH/QoG9Y5yXr2/9U=", "C2CiiAUyQpX8r1G7iNlpI3LL9O7xy6i4XLwFk0ZpGog=", "LTj4Eq0desecMv3VelbtuGGIXyD6S8bQ2ULC9B6OSn0=", "JXOKzRFjWAAzNn/Y8e4ZnX6zw3iR4GvCDmtHagNXWIs=", "JH9pZ/ykJomujiC1p6GY1jCGVJt4wWIKUfXTaCTM9D0=", "LiKBMHemaLK3Ukm41RWj3Nk1AgBmlCRbsIf/BzJwi5M=", "FSPqib5hvkfhw2sOAkBowoxI2nS/cGmrLXc4nIPUdPQ=", "FGaVzhOCMOCHtT7xv4FgHyWR3TRKfLUJ8TiTk2ng0cM=", "EtBdlXH6S0FxiG2cLNRMfX/FpBJRlefSjDxHy1y1t8U=", "JCchFHCE1GE1Q3iJdxEfP95siTJqVW41vM0qLnPKxos=", "D9khuoOVpd3oM+bbpBczhQB7ONGvXjhBo0XJpIDJ0pI=", "Dwu9x6OeUUaSny4cqftKY1UM6o8SEJwdguYBl11YH10=", "AA1lAIWIsu4aTe4DE7bUOWlS2QE4Xy4a/moKDe92XcI=", "CupWe+MeHELOM/WJ2QM2OkgvIcHD2P5Q+m3wGKLcfCU=", "AvozR1ewPexr4d91jr4DUzF7NTFuz8cpNNBp8YI0a70=", "ABcyJ4Kzcz43nIkJrn2pRlXEbdK2sGG5JT14eh6qm48=", "FWgW9I4++Yj/4EzHesTImvj++EgmBOf5O3XB+xFk1g4=", "LI/5d6JzUrXX2ewQP8jwxye4SnePQa33d8OOAYAK/aw=", "LMIly17kuitwU/mK97O0iFaQFuz29JQ9ZLqEMJLFkik=", "DTTXqLj0mr+kjHOxDyk6yhngl0OoNF6eGvny1j/q2Wk=", "KgNVqwS+3qYf6uCDVhBn7fFHayByXPXgMtuAbTPtwgQ=", "LcrrRlOgzK0cCHL3axA79Po49tYxGeFDfHmCA9KXaMU=", "ItLmOQf8C2VkhQEiyOkkqXLegn10kekt2EOXsuvKd3A=", "FZOltQPfSDBf/DYMT0nOsCU2xz12tPL3dPnaPVuNzgM=", "ItRfEgPMEeUrkVV0mnwKCoIdpLBjzdyCBYAoDiECbr4=", "KPAaCttfj4UjbhoSn/r7LN+GrrQFbrX/WgaVHWTD1LI=", "G6YCrp08TL+t0K4sz4/M51n4PP8pvxK1PWBQp1heaqo=", "J7ygYdgVd47YcZxfT1QGMhPFAFpG7XrtDJedKtFVfDM=", "JVk75Fi3WlNppL1qhrcK55h26Vq5NwXSRBAdXfPkVwA=", "FWCAMOi7KozsX25pSJBkzSH5s2FwNMl1HFMFbMETwEs=", "FKtlfvUncyabQAK3osxtAepm7I61Gpfgvejvn1k+qsE=", "GvGFia6QBY0NsVafTU7PdBVDhsu2/pBWQxG0NAsaEdo=", "H2AQb4j6202Pl86ezCTQkQpFdcWnEAAlBLSPqij7kcw=", "AGYCezZdUSVfmcqrgtUAmuBm22W6EDli98ZfLy2upWI=", "GBMB+jh+Uh6JUaO/d8WULFu8So/MbDlcNLT0kakGirM=", "LcBMs6gKUjmhMpnupwugJlk/QMz0nLjr1z2imnZBPjs=", "K6VeHVzAkEMCdZfk/FRqGJIrr4XWqw7G7/HPE5IrVZI=", "LVsPAWOuR2k85zFWjNZ8VLgvJJ8qQp5YX2VADwx63eQ=", "A3SsR2n6b9C4Fm/WKhEjV5AjCKEnZFRT1y9SScpck2g=", "DnZ9YX275BCWhwj1hdugTplag0fvI+oQH+oIhQhAOqw=", "H7OO885Q8VhFHje/VIC6cKkfj87pMnSrAh3+1w8uKCI=", "FOI5qnO5Q+Ocm0irsgXMqk/1nWj50yW3F3kWZhd9tls=", "JxLZQBlUD18NYcEcLBbT36sCVzhYlr5Zwx/5ejfGVVs=", "Dm9SQ5JFLrrUCXOpgOCPaaveshTl63gw9yhMHRPjYDY=", "KUcLaSq0pVBSO0SGhOGX5r6byIW50xEMKBV1wbvGfKI=", "I5EIJ9DUpB7osTpxGuGbWsYEQBoiFBcXLDAYpJ3pWfs=", "C/WGL4mp02h/L7JGmAVw2W7SWOhBSsp+DJ33zugz3YU=", "ACcNSGP9AfJ7BVhGi8qVZIvI2zylWqpf6yfChq6tsns=", "Lfq+x2ceHpMrB/Fkq0nmnmPxc1E/LUoBXOjePhaMG8g=", "C6smrLxI+GSNc2Nmraop/eSSSAAC9QIMYiD7GH2uiJE=", "K83wgEMVRKTtJcnbhog3otF4dv17MAG/zCK8toZIO7E=", "IGSn67fmrenLzFliAO7JfKXi+b6yomrMZzuTohjxasc=", "BFHlhhfsiCeZsrM6rTS8qraocVOMIHggCbXaKjd7kao=", "JYL5V2tWsikHxLv6fkFVtOKK4Dh2lkzUCtsOJVtsGhQ=", "Gvc1FbZhvQORW1w7XYzsBgtJDXQsT0jUPtkHrGXqbIk=", "DuthmwFkXLMfH1FF0tGsoEXmn5qJdCz4X6plqPMHgcQ=", "G07muagfvwwgHQiYppSKCZXrzQgODOqDraPY7WGCqxc=", "BavgU5koivhO/rhI7GHVPdDwdDmYLgTjpaMEFmrBcw0=", "LMAsnM1j8j3OnsKzWHMi2kpM6/nMkkbHANtmEqp2lnQ=", "DaZPk1W8w8z4epaWs0TlaDytP4dqW55fcVoNcKlzAB8=", "LQs/OpAfiK2IwgEsKzL0658Cu9rt9M0eN7hPQBb+q3s=", "HVZlI+1n5xtf8Mxc0XoyXTCSvWalJ3OlN4luPG34bHY=", "A301RG4Z7tZiorYoEmsoUPfaoIeXTiH609M51+Lcwz4=", "IrWVR8M8N+bDAKNVb4fbumZ72oThuO+HQwpSKldt6fA=", "GW+Nb4UfW7zqahYUZWs4ow5by/8mHO8Z9uNAZqy9t0s=", "BXbW1txpLZ7XIyAF5j+VTS2hHHfm6RmyudzrrtoRtQc=", "Cdz9X/8L4t9aUmWFbCKsIxzt2BoTEjBPWJbwkJzD5qU=", "JveSKGzd6IjkVMHd8DWS1tYvS+SEOCNSZQmCn8tJYWM=", "KZkh27apIB+Kyn5p2BkCONXkqC3adDrthcojXKuAwWM=", "KGOiI4Vr3ULjUGnSBqUIjSF7X/um+6CTnKIoWM13Deo=", "D/pWCdG5qoSHIdLh4q1toF1DokHo4Kf1lQj/qbHt5DI=", "EdklJ02Prn1Rjf7OpYqaV9iGQgYpaeZ+RX6WLj7UoUQ=", "IcIZIEImvEPw2yRINJITqeVj6U0//yiy5pJojQ9bKxI=", "LASunyULoBlL9Z7KlATjr23NZN0443CgOPP9Hjl/UQQ=", "IjzKgx3HYNt7lU1BgQYUum4sYr4x6UiE1Mfl/6Z9pcY=", "JEs4lBBOUaFRpnHKEfyzQtGsIl9Dq+6DlGl0NFcTPYE=", "JPcdWgrASjh7dYxpeCRJ33ucztthY6fu2yHvQBRS9FA=", "Lvs2DZyg4V9SqkAz9MQj4PpcF1zdBeSuvMJ4p7gpa5c=", "Kf/X7z0BjJXoA5wumQ5M/mb/CTgQrUUIww4o6LuXBiA=", "Jn/3WlMhI4PszKxOijvy/J6YK6837ERHhgHPqm9BcjM=", "L7/Ess5sKwjLs+N0n7Iv89aNO7fTNc4OQuxtwnCQw4U=", "Ji+T3iAAXE3i9KXY0FXI1fVomRsKhiBH5a2UyIaLo8o=", "DwgL4np5H80XVXVPkx2bh/WtjBljoCqnyv3R6NMblOM=", "Iac1ITqMeEl25lyjvsSsxCJFJ0k80WJtI0YTOriHX/A=", "FgqS+2pgfV7nlJ/NVTfIQxxEnXmqUbuVWEXSy+aEu/w=", "AHkVn2NkVD62Q/BCRGHwATVzmBOECsdN6B33yeEMj3I=", "IoYkfFjqpFCbqvhblH5plQHTtfkBrMhHWn2deUFgbNU=", "ERBCUZi6BsQu+9tulYQNAcALXQiFDwzUZDXNuhvczqY=", "DsWhVXGVDOw8MZOsoBV5FgS32uGF17nYmS4CAYX/2Qk=", "Ig+YM1WXSTwuf0/jvcDNIp0MgbLQtvnlZcz2Xrood+M=", "HC+i0Xb01wcP5Fz+ao1LvQzmhaoZbkuiNypRleerZEo=", "KYwf4/Y1MaqYtqrQLkOKjyeLytTtl/PIKgkfrqkQ5Qs=", "LoFLLwiNkAEr7nTO7xDHATAzrxKDVt2kiOP+qzvyUlM=", "ISYJlE7AR5JfMcE9fKn9Q6TlSjP7CabslGPLY9JXDmk=", "FXu7nQVG+G5Ki15FADarCoTWEJ1VBshfI5Jn9LpYS1Y=", "E4782zRLW0D6qcCkFWZL/9dyQLWpy6VrSZ2i486ms9w=", "DKUOCNJ76lCPICcwIfboOc8SSlQ2He88mypkWV5Y/k8=", "DTTS1ZdaLanw3XLoRteXqzEgIjmeH+cJgPmD8Vh+98Q=", "AN0b5PP7A01GaagZIvoBTDwcXFdfOb2AmHfbK5//l0Q=", "JVQPzBYjB+OQarrnuiWOT6hP9N1P8ZdCoJadCAGLIb8=", "JPV5Npea4qO5dS03wBdXRJNSSiVKW7wQITt/prFa01s=", "Atm9YmR6RTNNtzYx2p2Xon6MYn6RG4Pxli3DQX3Gzik=", "FJnCmUrYOHcO46mvZDYqEN5sTF8y1atbuuVcoLKfv7o=", "FaZFmgju02vT4jFX3VlRK7yEhH436KTj99f9vHviCXA=", "FI1lpqdfvvszllvi3wmJ/gMfR0eJItJUbx7hJt5/Nfw=", "FtL0hlx204N5+1rS77Ied34BdEtOIJwJXTMuQe20V0g=", "DIbGnpSgA8xFTimQp62BZ8O71HMuZG+fkelhEUvGXDc=", "ALEiJ6MQ+GIsms/iuzIoqgXO5hBcQmjCZt1Bds5/jiE=", "La+R0iX5FYhObP2rQqy2LSdjQZh7w6JUGBnsd3TZDo0=", "C8To1VVhS6wbjMmbrn8AjLfIK1zRo8SBpVPK+Kw3P24=", "I3XzfQAwuJShqCmN0t1Z4rfnNmfzGxVuhtmzhhdQD60=", "Ho48K9DUhS4mGjwPqT2D+5wh1EtJV4Mw3LlxjL1UsoU=", "HoDsyimzRe2Ivo5TygQtbGKv0qRiTLrLO9B8hYOTMrQ=", "Lh9e5wM4xQxFb0MHchYSX+8xTGZTybpyx12ltTz+2pk=", "DpujGuE2+wGZ+dng2FgPVWBEnyqLap0PIj7FLEEgQx4=", "JN5S8VayII2BvxCceQ9Am6qUGreXivhvvA+JGl6QT3U=", "Bb3HIFomvxJwBlZCXrrEjRFQ4C/ptKywekFgnXFo8E0=", "An+BBlQtmaH5A1gq11cHbhivzlYzZ7Y9XQlz2AmTo9g=", "B8ryvDeF23rWgbtsBd3yRSXBnRUZqYG0QEWl94y6UrY=", "AjC4RGYQZsI0SDx/32MkSZIkU/+47zeXV1Ca3dgc13M=", "HFE6f/i9+UDvDQHnb9TsGQhhcOiMZClPc37yC2YZgqw=", "Dg6Xl5roZLVfJzcebG5hmre4h849hh/t2ErhEb6kDgw=", "Bi1GrcWRNHhM2vDE37bJ1zWPMV8JSHZcj8vJfsPzjrI=", "JkLO4jQIESeyi07bA4SXp5oqMTobdJ/S62fjd5QoNkU=", "JACzmCyS9/whgYiacIfA3JRtsrLo2G00ULwlT2UY2zc=", "JNqItPLC3HBV9KVfeDIjktgIwHby3my2oDiB8jVOkQY=", "GjlRzWklMWSBSErDmzG4NielSEwlnIGO4jonAMbOrJ8=", "LOyif7mWzbptbuHhBfpd+LprZ7hlkxwBdRX7QpCN4BA=", "FggdBL1lvBnkGt72/Y2ngU0rsM/fsuzOXfgqi+qHnm4=", "BO7UuJwO3hvViFGpMeTeeR5Mac8rERb4o2srxVkADkY=", "HWACG0E3sgd7MRc3hwBCAfILBwFBHEirnhRBj+Ju9Ls=", "FjbCnYVof+w6pBJbtm5dXxVWVXpIYMHfhRJ3kPCaYaE=", "JccW5epc4saitnGoY9Wss7LdSWOHn0wWPaagb7JlzEI=", "HezgAoS8aY6ir5fePUJs+QEQu0m+caOTwc5w6pcdtGA=", "KSoYVprtPChoUAHUDLQt2BU/qZABy9UnKcpvjixGbu4=", "Ju2qCrf37qyHdr/xILRIPOmmvOhdCZkx7JMiuh+/OIE=", "BdI/0HQ+DjcIlYg5LG3wsE1a7y5SaKsZwunps6OvSSE=", "MAu+wwLJuLfkuqBpkFcf712tJq9hjQd5tpl3okTFifU=", "Jp8tnOCY7uieaU1T07LZhhSQzxhOoJuvZA8Ao5rHKj0=", "ESKjf6DDeGNDEYK7gne9DoSbIXioFtMcdgT8UhnRqmI=", "FOLbvrMKOld6CyKZzprwU50I6uB0inIYgKrKr+GGRTg=", "L5JsZ3OoxBG4fcUZjDCZA9n0kq9vCkOlryAo5Un2yAE=", "EWnxEM/0lwC7X+6eUkpJ41iJxGieOEuSeYTplXxYf+M=", "AD/shj9AMnsGbmgFTIfSDO+h6xMUBSDUOmebnkoUemE=", "LodkDOtAEqmtoxSCx5oI9kurLiwBDLA2u6weSofIAb0=", "A+B6jo6GqGOxRxlHvS6WKRSbVVAqas2r9gntr6C8nZg=", "Izl9og/h3QX/Ico9IT/AznzkbEaVN8GiqvUilNL9ba4=", "F5czp1zhGv6KSEL4UJ5JMB90KNY8qDlzuNgVb9gqtpo=", "EMHooO6BEya4g8qOEPOtsSRCj/zFx9x56Dx5B7Kh6uk=", "JN+TaBtDh5pLthtcYoD01eE2AoeUW5eOWbGD8CMzh6s=", "IhQPNC/s744n40WEQ7qn38unrDXL1KGgmth8f2PXu1w=", "CLr4WJSQDsCDIiWdUXWzcP1K0z1fWZ1gnJXi0Vwm+94=", "JN6UiAgbhJFO/759VgBFmGdTY+NLQf4Om3gQeTAxLhc=", "HyUpEJOFb2SicdvYYUkxuXwx+OyNpxIbC7gsqnH0U8c=", "Eeq+TH7+OuxZKlzsaz9t0QlfnThOoM4EAmLqwPBTyRk=", "C3fbBCDsHjK5ug6ZBKKJIfI23tSPP0mqLXYaYxwlA4s=", "FonjWg/eex06bm0Uk4D/xrfZdygHpVOrfFBz6y4+3ho=", "FiI2s0PCwvf0izbz56fsl8B8zPIuMlTczEs6MPM8abM=", "JIyVHJUF0s8hNvayTCt0nHdRoBqxzYOTS+Evy7jQXIY=", "CUhwQvAUlMKvBGuUEFtwsbjl7RrF8VhAgwmmanemq6s=", "CpqXB2xdU0EcPo//a7U3ApCAtnEySBn7ivM9ltQyrOc=", "DEPV/AAgKS/S7NBoQs+oNz65vvip2YQ0i0P6lhSzLiM=", "FG0QrlOqr1lcuOjrKa3j5WyS2ptVo7wkvs8qL1+rA5M=", "G6y6QtgMZrOwYstd2mpiMEkthoWGJEfGOMybTsN0M3w=", "FuwWjbA3KpFE9RHF6GCwcROmcbMjlSqG6P1Acix/yHk=", "ARPlRXqt3+Gjk9diWtBb7EDp1Ep+GF6jrytYrmlat3s=", "GLqBSip/3RIG22ow97mPPEXKtZM2K+/csNKolqx4p/c=", "EGhDu8NuQGSFbrZojY86kKQ/+n9zv+Ywchab9SAkgyg=", "AM55D1SsLTSibKF83WQqMbHUAFwJdSxrxbQzBkzuYyI=", "K05Hym+JfjN9bVLB/zOlJIfGibq1/TViDYPFZ7V6YAo=", "JyGbg60kWbLfn3PfXNHS+L5mUS2VxPPYG6h2dAUZ2y0=", "IswJaAZhJVPlBH624OyNAXWbnfI8lvU7b7yqijYWuo8=", "Jz4KKlbkJD8hM72Q5UaSZHGEqIBf3SzrVBoiAlOniy8=", "DUSa60HozJsvMoVvidvxQJ1WBfxVfEPHz1c1cdWu6hQ=", "GwfPxg5hwWLcnxLeJTt/lSqSRr0sfERco1uFcuXXGaI=", "Dk7rUSw8rIR1NYl67U+57TS//YfAEqEX8qPaqBDfseY=", "JwIecg2gKGthwjt0jMfDWPtogtgQB4f7zmhfBuEQRsw=", "LqwfotEhJiS8XgCQ4lrA4BYPLXOQx5Ci3ndAd1gw5UI=", "DMBkWHaBf4FSzNkBCm8mKlFq8MookzCjQNtkdK5m0mE=", "LM+S0jpqvu5ueSS/DUqecEC3FeZiF5oYL9Ebsm//WMQ=", "G3ad3DERqdON8x9ICfMU10m4vp+mQtKqo2lh3N4L4jw=", "LcCaVji2GUxtbLecVu8gWwvh58g/yu+Ysc0TZSlcfS0=", "B+/KmtYmh1SgPvtnblk6jHWjq4StkEaFBlSlSIMS/U4=", "G7c7TjRbB0FUjaKqaYeDqMh+kjqxsQCOctc3++f22fI=", "BjUXO3VR/U/oMGq9dkoWm8zm83Gd1gbNC8HysRf8Nv4=", "GJ3Tsg0/j1Pw9aKtl/MA+Z67hAkKQ493OPKhJuqKRQo=", "Jl6N0fphlGGVLM0dOpbyqpSQbZ3wc2XCjdPpOiRPbuo=", "FDoFj+OYeq8cob8sN2tJeTEO9Uwpo+ZowSTlr0N5AsI=", "GG7I8cO6cK2DTBHOp5YnUNdse+hpHmeb0ZWmXf5pjsA=", "KBjrAxmYxVTJVwhCGARY0UkxbxTin+FiYAUHseUJUq8=", "CM+bF90sq8It5oBysPO73kvqxctYtXUhnHD5P+HsXeU=", "CimKnwRKFZC/tKaDUCfJSBpAbHZe1chBh4pcFLHE9O0=", "L0BQ5LOxUBfGwZ1Bd5DiL6bSkmnTO1TYAcSvmM9mLOk=", "Hx5QNfcsujoCJqBEf80oxrshHaX96SKUWMj305dKBqk=", "JXY/vJQhNdqF+vNU9Hs66fwnYGrXAb/n3j7nBNgWD50=", "DrYUK9oqXya0n23tq9y3qX8gkx/BQlaqheajsFmcg4M=", "H449ibXJcyWnBjxwMBQUSvGV7DfLiwnVRHhutnIejvQ=", "GgJ1g+Laet/7NTQJVwDcb31v8qehmwbX1p1+tj2kFYw=", "KCPTgiGQFx9ZJLT/5TgwUMswH7rNdFwuB0+JFSpTRww=", "F/znogX0LxfIChRqo1KOdKPPxEShKJz1NUB/72z6Ho0=", "IRt6EfHTbJwQqbPnjuUymuh+fv+8zlloJgtkyk3NBu0=", "GGE2i7mOoyKQdfSsjOrFERIOw/zoTq5jKwMTikS0vV8=", "ERtN+arYG0La1QTPB80pVsxISOft6M4QB1U494y391g=", "Et9uCEfbjQGziWOWA8h42RoZ9EYRf5pK78qQOMydFH0=", "LV5HQRTHxgIL16224VM3xOcvbvFTJBBudYXKP4wRbE8=", "Im5lWAikBi+LtHwTHOElus/mjnhA9LpkdoQQQcKAiYE=", "HwGp2YqtPZplpTc+1tK2cgMNwcqbRhSbv58ISn0k9OQ=", "LzV4y6g6rIqD80qvXGUbBXEZnjpN457AV55e4zmT/gM=", "GDkdQjxFQBlALPDsezbMEzJH65i5u0OcnBib6uv91aw=", "Jvz2yoEe3yZ72ADgsA9rSeYOWhPKlEgQo2YyWV14gYE=", "FA+bWFmE2TH+hWvfRRgF/KZK3+NNVbpPQUBIC9epes8=", "Eeh44X8fhnrek+kU5YAkRkOFq/ZAP9SmIuQfsdwi49w=", "H5l8beZk6c6wQsVb0iySMrhY5A/07+tAgsdvvWLd2OI=", "J3MoS26xxH8U3nHyMpicqb1qcKrhhn7glSmfZBnO5So=", "EGa4cwCvQ5yrg2YFIe6dA7BqF8mgC1t6jVa/xAH6W90=", "LxMJZEZ5MH6Y1iB2aihhzuWJ5tVd2XDIxD3nrYTX0RA=", "LxBDt/nktuw5qgdkAH5QMgYX2XqHvp37jwC0zCfFuus=", "GzrFUL/cb89O+YObZrMiO6257Mdq45/pXJpHwqEQLKs=", "BwvjDkN4Tc99meQzQQKmnEDHmB7u02DVuZaOfPGc/rE=", "DlUpxf1k45IPYRUH+umfjId+klf8Nnv1TdBz8JGjxlE=", "EdiPe1ZJpLDh94jInvGQ7ZF9vjnKZMxYzehjOqR5uV4=", "L2y/8YqG2LQPiXOxzjC92s0vJIofR/H2bTIB/UbZPRc=", "F2gjlieIy3SOEu1ZQmutjuiBOBAkmT1XA8LBB5wLeFY=", "B3w6wRUM2kOUquTjlR+NCuvbb+noszbYme12N0WHWtc=", "I1XHIltgJRaARasfnPfWdU6DNlVj5FohGqmX0bhejzM=", "GG8La21gQKfhQL9yt0pxsjxt3B6EluL3M3V64ADpACc=", "FHQIQFFrgNI092oC3DEn+aX/qxs/I0aqnJuRAFhDXtI=", "IgNDO+BmgL8u8FCE9FyvttjpQVjGWYqxY087pm3Rbko=", "IX0+mENVqh9t9lLxAbvcKBxpt8dRZKE/0pd2uAsqkxQ=", "F3fwa6PrxH76Q5WfoIm76LrOZPmkQGk3YAwnPb4h5NE=", "H9ilTfTm7UarXSmXufqwQOi0hw9XVDZIUMUIqeVz52c=", "EdVLjJSe/LmYFjKNt67uCkEsfQdKmGoGA+qvWs/jKh0=", "LMQeUtj5hu53xZsd4mkK5OR47/JdTxA7FcwFynq3RG0=", "BHxf6/d0xiIVqn5sw0OYmPV2BB8ZqzyFALB9XBmnb6I=", "Lphw7VjfpX0QCBkRY2i7+6gcaaSQOoUXnPekwqjzFEU=", "H63TvTpcYVik/z8K6jdPljX1IRcwx5s50Dn5zhesiUU=", "KlyBDWxDqy0p/xxapG5NmCwbZSe2oug+xVzQzE1F0cg=", "Efr+mDQwE8L9O0Nk4eWSLbW+XA96/de4ZF0HtMkdQQ0=", "HRqCqLJdUD60rmXWv1ETBJNCwMEOLzy42pU2yVsSEcs=", "Ev8YruK6N/RI6J3LUHE1VjfV0VVFz5z45guq8suDJ5M=", "EXN+ZUwzdK5fTrXHTyA9HaKqgSu2CwxcrLXwHAsPY+U=", "GvP6+LLalEAQxeOzU1WrWT1Z+q5AQWWgfOku4RNW0rE=", "BcoXmtDaNZ2SJS/zMk6ISvJbDt+b0XAOAS9FtoO8LfA=", "HWpZiFGx7LudOsRw2V7L1YijsyMDpM2KdoDvXfK5X10=", "AWFyDc6hSq1+BxCmcVGSG7nVxAusE2Z0+GLBxDiZ2VQ=", "Izhc1J21dfc1UHWfZ530jL0e0daZMnABed9v1hhw5Jc=", "EzkhcUnadNULJaQ8yAJ0IOJy/BNnJXAvgdqINdC59BA=", "JlFlmtabN6R67Am+cUgbzjyrI9wEwxYRjUBwBVAbDAo=", "Aoc3VeXXmWmFTMyqNs2EZqqi4FlOO6N7j1G7Omybh9A=", "C/huykwEjVn/P/1hDIGn+Zh1zg/x4ZNBX7wrzENVQY4=", "EnI3qgkKQU8mdrxbJndqQg19pu+RSonfsupDS220LFQ=", "Cq8BJZP8AUyriHm+i2PiTqgpt4D+nNkbaIknBRAtrgk=", "I0lRG88+FLWsvJc+QAY9IMGkL76eXe6Zlk39UIadAoY=", "ChOHfoL9VL95RX5wOjxXgOqxlwqbN032mIEpwy4u+4E=", "LxNETAJGYT5KjwbFS3c6VTtu+Ur2XTQ3wE4/aFbubn4=", "FJ+fha+hIKql2zjhOU9TbMFTD/tjnikq+zE2+wURceQ=", "Ca8ex41OqlUvFPpuftQYQqQRyL0rSclyHc1t6A4WSbk=", "FZgwbGa2miI6FpJZOGIXucVDu2OyJsKDfINQcPpu5yQ=", "BS0ArGA64m7f19iUWv7iAhp/jNNxmYL0Y752XSa+l8o=", "LQtb/N2+mutChqyp0Q+aeDF2v4ud3lUAjiMrno9FtUE=", "IudtYXvGknjDl2FF++yKEd7XDmu5sUc51Z13RfvoATM=", "EOByXmLmYNxaZ14tpgyPHOdWwWKhC1PNoJi7FH2vwTg=", "FS5YedtzLvAm0nSNaxfCEAWiMSXswBrOSyrUZ0S2kY8=", "LAVkzSBDpQeQG1BU2y5u2ijJRTYBPOZupXZ65FPAnVE=", "CmH9uHSCRfu/Am/jzWpCuHOBnIOQXEKl16AbPOMKYjM=", "DYazieZj2v68XutyAU7k/9IFhB+75D3LVaBwG0LCHnA=", "Kw6gbqKbXr9ZRv8F36VtodufkRh65niaUSgyhrckK1s=", "LJ09ZVkantB2GN308QdwWWo/zyXd9HISbIyws/iXVnU=", "BerqlmPNMZ17Y5D9N6W5FtCty96g72DeW+o9tj6XM3Q=", "HOsIjcjkdu7iIg316JyZQ9KPmvNq2y260XQfGdBkEJw=", "H4jHE/p/nq4rqA8qy+5WqsgaJFSt1msecL7h5TO96V8=", "BfwQybOrpCN4YhChiajL8GOUSNI5CIkmq5Y0bMVD910=", "CX+ZJ3o9j9LZVN5sLVjjP2UgilO8NtE4PC0XeXtJtSA=", "KVUIoGlmGngiJ7oqdMIS1HKPuOhpXxtIJvh0CKxNCHo=", "B2C9XTCCcB/Z59F9UwpFfUGnvlXOa2CK4jY8PEXbRXY=", "D2xBP1EGf7Mk2gSyE/qJD7lTMy6GPfOwb7/j1d5zJnM=", "GwqEKyP18AWaAvJledlSYJMbZDhb5CVVNwJwy0YutV4=", "CJjl9NYrtZE/5f0uO3VECIfRFW9BWu4YzWf8nXKBNOI=", "EPiFJlYFX2NSJ2QkpU7ImfxubYekKZ7QzLkAEcrLEZg=", "FbEurbEAOuY4Kz0ziFSlACwVwD2bsChC4D+7ddp2nME=", "AFjX8czd8m/fpu4K/TQJ7BA7kfSZJRgwCsKnu/glg/o=", "JKz0MeZ6nX8b7UQXVrA6d3qZ+nKAsR3vEGHN6yh4u4s=", "Go5y47dkaMQ0u6TxkekBcKZCzn670okIfRh8MF8TpM8=", "FVqYHxYcjDx1b+IE/yolzg9TRpV9afrcaFXGEH4CqNQ=", "HHR7lNuljDlwQUhRMYpv30yGpfZeTZHo1HcvVntJqIM=", "JZ+RGfr8/zwKmNgo2qXRrCEojG68jhb06Khd/P9EL5U=", "HFzRs0BADjejfeCbsgdT1JeTIuI/2snHr/n4IJ7qE10=", "KJcuyBmsA+ZbCwDFLr6sA7XveCgf5UO7P052LnkExvY=", "J34t2ikwFMXHZmKCbdPXbMfGYtKLKQW7se86P1CB3Ko=", "B24Frun4x0nRqYs0AvSiyHvihAZZpRguFcqH8xgJyE4=", "JrIpHDHc3MLrVfAEweq0lkkNAl8SJlvoNfeDqWE63xQ=", "HsrFOu634spDaiANqvHpdb6KxoeoECviOn8pHZJEhB8=", "EXZgA73/Xs81IBRQF3bQou7h96iJhAmyGr81pwkvRhA=", "C+ytYOjqsQeTP5JJXsblBwsmFJ6ua7EAUZdVYiUjn5Q=", "CM+8Xh9e//j7Fza/EYz98PvYHL6H6mGTHc8MxwscSIo=", "FfYwdrIKGfVF6n+dOGxj765hne/ZDP2DR+Pn7tprLWo=", "CpichsqX+UZyQNkjmlGuuox3cqS2izf5f0+6JpWLvho=", "C2ZnAnxBUwz8HPfGtgv3T9FaEYb/wLd/CXbV4dRQGpU=", "CofdIFgwvu3T+L+SI1zieOLIUp658aRFMM4bJibEnAE=", "JKgz2PXbfPSeiJ/iPFGFEKiVgB9/KHU4U4ujsIKPgQE=", "KgEWKV4gdMI+G9gXhCWG0RXPpxA92YJF5tNkyp1WQsU=", "GCckAkvRtIenqIZgTkMS8l3xG7KWPqFSZJzttv/PQ9g=", "LsT9Fx4JJ9yTMVQOH2Y54VQetODLdMZs3tlboF5xi4w=", "K+wp914TrnACITu9gbqYSFAdYTiUWW6fo11zT/6a1Q0=", "DKj+hj+yNsEK507AlKif+XS12cxJhUb3bAvxpRCo+YQ=", "FX5q3DnphP9g6QT/2F1LBsD3yV2LIk6rsOEJDAgKMgQ=", "EzfmuVABiulvRiFEJSEJB+dXiuqg9i/jr7mHfuMQF4I=", "Jn8KwyWTBGHe9q/E9UttCeFj6EwApBQHk40tJj/WSbs=", "HASQATZqNSHb/fzpLDJK0CHQNXZ5EVdPvUtOkACumk4=", "Fn2ybR+T2RFBxIsafs94qz9xRIFZTz6x2rSkt4MpcG8=", "FZ+iPiqoG3h9cPrPQWB5to3muNfA4jRCH8RQwvGRclY=", "Ka2vIM9ZwIICCadJxho2uE6xaCh/esZAo330pWnD3vo=", "A8OQaUunq0gAuTEhu1OjbWVNzqj/m9pkyVdw+lRdrVk=", "CR+UKS9rUlJXK7QZ7EVdVDXqsUc+69ctiyCuP94BRsI=", "KdZNA1a2zQfKvBjrXeKHKMJGZjxgEz3Zieia+X9dwhI=", "MEiXqlA2s6gHdOQJmU9dHnGng29XeDnTuS2ThZCIhpc=", "El4N2PJJSG8TO4vLkXnFUlkpysOrCbuu/ZenUby4foM=", "L+9py54hqletwHSdMjEOu8OSHXX4tceZeKXoPWaIjm4=", "Hjr0CL6M/ku+A4SacR/K2FtPJ5d3M1JPK9NbcWZDhoc=", "BOZV32EUZIIg86KgVoBaY2MHuAl3npOXlT2/2LlHe1Q=", "KkMinmZgk75hhOKStKh9YFzThgA3+irvB0htT4Vtyow=", "FW+a7HNZ5UJ9X5ehZcq0R9JwidzknxQB6Ww34VlJDNE=", "ISRYJB4pqD0NEcZP2w0sXnA29EHlOUpiX1LBEA+NrqU=", "HdkJ9aMqZXqJ6vlIoR+O6odO7M9JYysxAxTXftcsYlc=", "GdioH0hnxAzSkjRN+NLdZLB/6tQFQQdBSkW7UEu+YOA=", "HyhaQ4/HymLtvb+l+a5if9Gmto1Lu9erhnw023PGKNI=", "Bu3SyXy47123ETYHQ0WN3m1F3g+0HGRqcq/g4CAzqd0=", "Lzdx+YTTNMcpiXPpss+qGtWYnPN5vEH3i5ZAc5Vbl48=", "KrvEO5IkGISVzZ7IR58512O41WDfTp3qHNexYY/Oyb4=", "JRePCDiRU6ojbh2jw7ul5AjVK6kTw3GBKKWW/EB1WlQ=", "GygEXTbOlMpyrVU5xU1qmocuZv5iBqJRph31r9UOPpM=", "EcFmRjPxL9k6NdhVP7jh6/Prq3NhRkLaSPdCSDwNgUg=", "GTB8aYDGrbf+HUU5wQ1hVzEK9FzqpGGMDUpn9xpKjDE=", "FPrkbQBzPl9+jr+zYIUzEfAh4qJScFRTysI9/Ncrcu8=", "Dj0UVeR507mbyx+LZipDyIWpkRsjjgj8T6a9EJA2lJI=", "Dz4oXoVd4HnC88VitQdNCVtXJosKsaoHxPdlAlQIfX8=", "JK1YULT5I6vWh9vEr+dbomA599SzPMQ7tV9gC+X9Lr0=", "CiIUPrGCF+GUVeAjvVcdHnV8zImFBQT1gOQzy0Cv3ac=", "C5aMCyePMunuG0rf83q6PRXVlDp3rHeDNTOXtyxw1TM=", "J2mQ5dwNsDC42IpYKKSzQxd9zVVPzoo2aS90/zj2TGg=", "HxgKzqp2byS5JVIkJEigEyZYCpwtvirj/7tTDyO6Fxc=", "Ld30oUdXso3gPP4hC+M4z+O2P4oC1/sBVaycbj4ra9A=", "FIGEEQjoCZaweePpd1eEQ84OqImdVY3ZLFzyAnl5Xdw=", "KjpqFzQByoPTOwmX6qKAW/eGnMfeukBPOV7hTgbao+I=", "Edc3LbW3ljYylsa5kEDYg61m9UhitJZfXaDuAie7xFY=", "Az51fpnj8cqCbJpkinPeN0oRwoOAJM9zbdMcW198CCU=", "DhuuXnRt7VEOqhFFV0qEaMOn4mkaezJKm577NqnN1K0=", "IYGLH7qwy6HvICRe2ZRRyh3MqJkiLBR7QxVTAWoJ3EE=", "GiYExlees7HoA0JySezxdCqb1ypq2aw4RRkfjFNvfZE=", "L0G11dNJ6VXhX1C6DMPT6FTpBl+NYkYTMszXRry1eGU=", "A5T/8sAlAnY1z0p8t1iKbvWH7ZlDFOn4E7ermfjUwyo=", "Cp0OvdjNw5K6RG1tzVyTgN/yl18nXjD2NtyWQbKiNio=", "JVSYy+fJ6JWAVI8NkiVf6aF3VWnDgKvRjSIASAe2iHQ=", "Kd+xo1/lx/JUkLbi4wPXEYhwUcCSqOZCwH3BMK05AbI=", "JaWZWpjvD1QCslsgMWmER/+JqbYwCU1xqu34tfxMzf0=", "A4/2Bf7t96dA6JCGL9WT+3EqoZtHIdDZewqF6nfytiE=", "GqINcw9TsDWBPxUEqFPsh/ibtWsF+3s08h3rGq1MGME=", "ESTysz4FxBWn2YgdlIueFfWJHIFqBJXo5i6JCJopZz8=", "BR067yRO068YgNaGWLT6RSqj+Kt5600d4qG4J/teo1k=", "GMORHT4l29kBpzdzJ8ViJSKin1b8stOVxMmsHgVAnTo=", "CeCkdz7Vq/JuR0yAUOlXjFOYq/xC0q5mpyw5V2It4Vc=", "LeQ2yKIX8yvl0UUb+/9+P2s61GotpY+EOZCNKFya/lU=", "JprSjLH6wiOGHaZkrN8zDBcy51zp0agAcdj2I+ZodY8=", "GNXJ8KjDwcYqMaEtlFrFYufyjpURRdcAdRtZ9cTgRt0=", "HuwWnqeaFJtqTFs6zolPQhd53J6bs2bo7N7y6zxT/Tk=", "CYLOUY09LjdJ2r5rV3WP7562Y6mW272RrsDthOqnXt4=", "JyAH7p1+x++2yA8lohEPlNIKxDb3xQweK39r3MdpCfM=", "EHLT1UDRsA38kj3K4QLyts42PlBUs9/ivs5Pls0V1kc=", "KLuNcZTUEjdnc41rTXOgWpTI6Tx+CPgIw6S99WRCASA=", "BLqhjbPbUB055CxJ8czjDdVhnh69FCZoV+OKdTxj3eY=", "Ewx3Y3vfGjNtm0yDEE7R57gYCBQqC/GydxtTDu2Z8D8=", "AsDOVtoSz/Ke/7w9ybBb0H161Cdk/yg1DHxIzkitSvk=", "I+rHaV/qI6ovLsnh6ntiyvXnHtYQZgCb+Tpu8/dAVqQ=", "HHm+QDgh9oD6+CiYByRKazwE0HFhNNCJrdRNu5facXI=", "BaSKvCgfdx7DbcpiaPWR67reBbI/uB55YcjN/11cglU=", "Airvwemk0GzHZOlJhjS9qXvxHu3VhQEAptvIWGGdJrw=", "EA+0AOKq7KaMy91MsFKN07jaggfWvOLUG0rswfByBYE=", "BPCx1fv3yUZ+gmw4VCS5H6/35fa1njdlHcS8pQAyfMU=", "BuM6ELm6+gTyDz5ZbAwdmGg2t8FqVspIZp1aBRQnAWA=", "CBvwVjNbHETEYcTW/B+eAyoYudL38kAHJNsGOFvfB3Q=", "BsoDqXpWGKxnHU0sGFAeXoWIvXk7LDtU3BVNH0C/YnE=", "EUvb2IeY2tWNy9uaH73BI+0bVkkKAVt8KUPrWq2e0d0=", "Ib0o/UnLEVG+GvrBy+0LcFt2BYeEq5L8s6IlgpF4BIk=", "JVFuNYBFKQ17zOG0Y2yjMJUULUsB8i732U4oz4Hp4p0=", "Id7mArJeWmeInvJDrJyJG3PrxxfH2BYZlddL9OW+wH0=", "IFmSEB73xcNJOuv1+463rNATGVJN21b7ddwVmgE+nIg=", "BmfPabRtz65y9/5rXYHm0Rke8CkoCAPuwDL1/66xIBk=", "K3qQJ/oFJD/7qkhtqsrvhQxNAzuEs2QduY/eATFeW+Y=", "LHrtE6qQZOBsTdkplHn9L79W9z7f3koRfLjbVNx24TQ=", "GfdtDB9bHvxhxkUYDFRBtWmpCtcRD1EnEEbGQveO5KY=", "BHSdLMPTxWEtdYbvEhTeOPhI2LPZr6Jm4VPto5IOcsI=", "KFjgQtvVEtnsFH/NXMD/IVcLtejaOyD39prL0oeFYQ0=", "F6XPJQj3htc0l/uwHxoC3Yvt7Ymio8IXC6HzsusxyWQ=", "CMezJjz9q+p4TSGi2Ii3sQ1slaKCoQFpyF8ioiu3jmY=", "FgT4SQviTmrbw3210j+CvXBlRtTnjAjjnBWAt8BNRv4=", "BNLk2xOtrUm7+TCtJDFnx3KXq+G9c7XRSFKe/XXr7gA=", "JJNhiIvexY2sU/nAF1LF9u172X/Cez/UHgy5C5spN8Y=", "AB/yV/i5D8PMP0g7liPKJlGeTgSubdOO8kJ1JYp/FJQ=", "J+nJHjC2tePDCX6hn+U0FyeivY3Lr/ONBXMTFp4/vsE=", "AiFUAV3/nfqU96gzn0/xGKj4F236ssiEaLLKx+ORTP0=", "A6CEcpRKTITuf+dqxhuhKtG17Op9FNTe3IsveoeOKvo=", "InBmuJNQqLE55b+LFGYMq6NpsIKLTKulhgD4DKzoSrc=", "GIVB+hLad+IdBBA1GQ4K8ycoGTGI93Ip15oIzeNeEfo=", "Jd1cHv0WI1LyWrd2mFsP/8Bd63CUu20oedkly6Moz78=", "Ep8pLpz8fNsbKuLHwww7tJE0nO9PfWWBLWYJWunqKqY=", "IGqAntp9OW0DTomBNxmljKrjgOufIh9EW2fNWnUU3UQ=", "Ln9WahjFxCi1W0t9S9rsY/chtZxKMHp6dARY3NnQXZo=", "HA3wsQDk5yip56o09rDbDaa4/JnD03fxVgqhVrfyYmo=", "C4daNmcQwGkYcrJtmpikmOkprMLmd4aMTM/2Yzlc+3I=", "IUFo6R07apTUhHaxtCTxYkC/yP/2dCSUzIlxA7p9JFk=", "Abq0it5Ga/Y2gTY0Yk2vc7bF1mFDQFQolXlcSXFjUek=", "DIQl4bJHDKQkOXz6ZmZfuGGjr07WbbkEX7tqf3YUedY=", "CHDhOZT+MflLgstJI+ggoTw31xHVbcxxj0sVoD1ifXI=", "FOu8/Ke+F6Xvw1aQSjGfSWm01BNvECb1dADNfbQk13g=", "It1epppQNv0NT2MVOvOG/rI7y9AhEtC3V0pjFbTdX9E=", "HnKgmeies3RD5C3h/33vFUlICFJgDPRVL7F0ZqvYnsU=", "AY/mX/D4kBYDzq6kp0YvvOuA32JgKpwTImTFqkneDPs=", "G2Sf5goXeSJSp37DZe+DL9NyJQXuQLCJmcco1cbbKmI=", "GKQvJ2Mgcbh1Jtldy33iY2KqKKvqQmxzz2eUULypWeo=", "Iqt+pwDbKyh7MB0BASTB0q9Y92Q0uLxHxZqohiCt2EA=", "Jtrak13u+FUam91HSYVZLipunqNSLAevxL85V3IRAR4=", "DG9Bf4il/giDny6LkAfiNg4dYY4bRqSXnLpZ0ptxlkQ=", "JHiP87CMTQ+wtRubQ1j8DL0xyjG6BVFYVaM6KC4t4eA=", "HbP8riSrWXIe/5rKXV1B7p14MaeaRa0+04WxMip7J4U=", "H0X9V+gR1OV0UWV12GUBzmvpJG9Ykd3vYrfM+DW/3KE=", "EazsCxPQWNxscjnrqQNKozcC2hfeddYwbygqGyvRaJI=", "IazbBdVa4fSq2HPsWttrYHgXAGOnDNLmMZ6gzvgzzyk=", "EQ2blNSXmbZZ4UJpnnZ9lWTORRebUiZI+oqDtF+NdtM=", "GNsrWLQHQfLgB/cBGOOhobwhUOBPo05CHbUGjeGePyQ=", "AUdoxpNBJtDr+97zQbV+0ikHbXA0juza2GR7HQ33GR4=", "FwTS0uGHagdbFnpl9swm2IN/fi0/diiqJtP3aWliwjc=", "LLgUdnD3Pi/3mtGRLINdPT8rI4H2DrN0RKbAwXO1N+c=", "CQi54iCIW0F7WNsdoMqXTC1le1CuHDxeEUESqSWnFZ0=", "Dw2FtFhhYet+E1P763qz4xtbYucgN57+P2VJB5rD5g4=", "IQP69mPDVJyb0HPeIUWFwa7b1QI+SlrmGZb14isKSmU=", "Enygxk02EGOmx9o3xsPCCAGBtt6l+2NGkVby+khuf/o=", "DD6d0Jn5ymAO3gOa2nifKHle9/xlDoRUAvwV+Z1IwAs=", "DqBbXU2IubX+NUBvF8obtKhV4KbufWCzHjaioh9BH84=", "CWPEvgccMv0GpSEkwNh67+WVwdsrLmwsnO9TRWu6MLQ=", "Cv+JwegUEEaPpR53dvI6B38nRGvZjMchifZBtkVuzOo=", "FedTAn1jM3ozDCYAAAguoHVIpyTcr6JV5nt3RVdGJKI=", "H3rLf/RqfGIzgRVcaCk3S7d1h6vR+fprh53zJAlUrXU=", "DGKj3gu2gRB8TcbZ5iPQViy2eE8kA2k/3WRiIgOxaGQ=", "Fs5YIBbPLhg425fcvs6HP0n4xgci11bFUa8607GpM7w=", "Kc1eL9K2hOR8B4/Vb4UrHduwfrz5lb6ZHpwiWVOfoDI=", "Euj/k81cPX4EVdnrDn6f+UBXXEHDXR5eRB5TDqiIqQg=", "DzxACGchnUDmq/LvIqkJAYEeyVxhkGxzDL53d2HOEvg=", "KmH5a8U8IyjdyF5FCWyVMsAS9HE7i4yLH+Eif4/XYMA=", "HKlKtwblaaT8G9Nsm2NFfV1yNbNWvla9+u8k+ZN4tGc=", "K9SiOH5uwSQVXeRwCXieG5Ra2jraxeNRBzmL1WlSQJA=", "AEVBULo0VIqFGxkfsanzWHRk3hes/bDd63FaLmQ3MXQ=", "HyKzm+3RFalQ99eExwMcoOw9GmpnN117bt5IDFyhRf8=", "B5pmFWz7mcwXxtOfycIhm7iSR7bK+TZY1Zxv0KHRuwY=", "F+5t8IIjcYNMIi+VTwOwFrjVrU2xvmbz+UbV0CjmUXY=", "JM3hQWm0p1jDoSarP48YB3+9/uDwP6e8z5mZGd1BeAQ=", "IK0I01WMnv4DyIla1NyIv4q17Uhn4azeZTPqL4bZ+n4=", "HQ6H5gTQEJGJjW6F0qua+brgOrURo0zZpiDwiP348eA=", "AxCjGZUvP24lAVq8zkn6gRC6ODwEhBPImaxNICw2uAQ=", "FXCxHmRhT9SQRyecRUB46qnPuIOpQ0oGT3Y0IbJrJwk=", "B6aFCrmXukWDekIsHARm5s2vdvrCGZ8T9jmGsqGc8tc=", "AsJTRAQ2QsY0pMAR2YGqp+Xxec6epOkh6NUtDlcWnOI=", "CfdOioXCk+6KLnH20jSVvNneVsLgA0FpA07uhVlvWno=", "B5M2NjIgx1NZCrIeFkq6UYlmp0gMSyiQ9FJyNoqyqXw=", "H/BGr6zRT7o0bOcu3yPlQNEIQq1+48czRnd5UYqacNk=", "EdZMwXwJXknEXrHKK61IKoIDJgA9ScjPnpwC7LestLc=", "LtIMC44z9X3tVYHPk3pAVfaAt9ctZcVUwBRWgIfVdy0=", "JZy9JE6oyYQL7Nct8p6W/Ym2w5x75ysWvp8OQ7c+724=", "Hn0vIZFylfw3WFQiXmOtUD4n6NbJIl2zXCujdc9Pj8Y=", "JX4xp7at2Qxhe5MyW603En8HMt+sTQrZMzH6eZkhKlo=", "Ha1U+tQnPpOXHe/33D/nSr7xz2wwKmRAP8doOWaXUBk=", "KWoClnpVE+GCfinHcoW+ZGgqsULRPG0rfrWMCSDf0Ng=", "MBL/YfYwoDUrdB5j1ijdvtR0rmmTrNwPnjFOjspZD50=", "D8uPohZ+u2tPQiExqO2EEwazoIQPJY1o7bR36OHr+io=", "ATV2fl0xEuB3dgfBxbkbEUi6ZB3OoH4cI1XCYChbocw=", "CRlDCY/QyUqv6r9NvElLY4XjmWnAbApoVN4MfmiMTXc=", "EwEGB9JOeheMQ9m9aCEhV3djIdlUONVyo7bvdxQeEbg=", "FnmdaSMbmAJ4mt+dIkaEQnZ0YbSdWU6alQ3Y1cpJ59M=", "HrB7cEAf6TuB35eh9FmZR6aoEuNEmL8qu+sdJWoo7cc=", "AFzdmnl7zx3vI+jKEguQCnYms1fvhpZE8or+DAU/Pu8=", "JLINiFzZpjGCaarql7JGnCtg9+o3HGqcIj7u2uy6SeQ=", "KYawujo+IyEp48RE6UglhP2D1tan2b9DEgpMVu5dsDs=", "GhiFN7eM6fZj1ktXVdpTz4jsruhSRCdn/BYCX/emZ4A=", "CGGRNHSYQZFb9fkswgRev7EkUGubJSVb6BSjso++EY0=", "ATXPbDzQxpRYH8Lkd9ZTinsjP4nSJjc2IngbApNA8MY=", "BPmlJU3/dlygQD76oqzZCWt/WfvCADkThmC4ksgIBoo=", "KbzdbGcvChhwcI036FEwIlxfyCbp5iFGMT++HuLHTR8=", "DB13f47tkR1MwOUMP0MM6aHV1xdoAL7cNvkrfkpoX+A=", "H/6Kn/vHbUbC6iq8Dh+zgx8YyBFEvOYCgR3jliPUpJM=", "IWzT5m7oKx2mWFSfTfE+w/OM6TQWc8SYWf8Ogxgnp+E=", "BrgGiDv2k4ixSK/XO0iA/2O8V+CJ7yVuSla+/nir27M=", "GGj2UhTOhZlGoqhusJJaZQzE1HqVuYijvZilQG+q7Is=", "IBsss/sAAlhL7/afqoooloznMgf3MTNqPVaGC8jTPT0=", "DxyZj/1lfVr189FQD5ghRTdD+s4Dri/9BVvt9iS3Zpk=", "HY1YT9OT0qjF+p+yhAASpOXP0fypf4O/bMpGiLOTH08=", "HUxex5LQ+eEhwX/1dU7/mAokd/FC+7gVkBtsWX9fUQE=", "BYKD2agsv9jwFnU3OqY9knnpu0Y8IlrniVqMUaeUvxU=", "J5e+SMmcGaFB5XzuMreEX1U5I7CEdHlsvg6555sF+OE=", "K1SJYRbMRd+qRyBNUVYHXR3smM/KdEevTpNFfsHZ7G8=", "Gy+tLte67j+z0hl9ap7cow7OQpJfE0geD3gBchGfsT0=", "BrVOP914XgmfeRyU+r/GLDz3WWPCGnWmDmXaiW6jfcg=", "LzyJYzZaQFiovnqR5uRR3LHXkzqoSEpapzWWg8z6h+g=", "L9mSnciVkw6wmGYe0NFS8oaL/qE+iZLQimklO56a/H0=", "JdHr6OnsD8bRgrkG10dJjLn6VaKY+Pn2ybTMLrMmrck=", "C25lNrowILviWfRascOLL102hluErIJBcg0ozfvDQSI=", "I7i02yLo/5k+Etm4F1fR5+3Gw53U3kfvbKyhR+n61xM=", "HCMr9hy3096Ldh/akwTCRCCwWf0B1Cx0aTGSrXdjTWk=", "BtAYSiH0WT2vho2VYORke1KDiSUm9qf5xe4mY8Zm1Wc=", "HZbsrcNPDvn1qcEGUdb/4/r6bWxxB9ipLt5AbCKd75M=", "JdaVT2uOWExl1woNn8W1dbX+NOfKZtgnOSjtS4/RkwM=", "ARVg0FgXtxFq68Cw482mUOaMD1KPYlk68TWH1oO/Pjc=", "Cke8VWob32Oa7g6v5s9+e5AWebGxSkfb/6Gxmv34d6w=", "KHr0k9L5Hv2eEvO8fHxODgTf6J+p5oJC/EGNrucze+o=", "EUmAMk7vhfkMOHeug6SABau6sMPA999GsyRNhAGbpas=", "Ly8HTJvCdtn6FyqB6VS2Fsr6yhEJDaTDMPN1nGjqwqU=", "E9GaWXKK/dpFg6nhgMy5sJX1tXKehmhRmCcRkDrc/hM=", "Jg8Dilv5R5CyLyeW531l1LUxQKsYxhevfaWbseutj0Y=", "AnCUSFS3cRFb6drjuuYAeDjoExH/d+M0dVw3wvirzLE=", "KfupCA4iAaTQnxeZGdj44psit6/xGjw6G6i/02iAcy4=", "BzXVUZ5/nPr6npQ/9U+QS63TwHgSpxFVV502GAOw0wA=", "Ej2IunjV1jOtT0547CgG1kKtjSSqm6jW6kOT04xaeU4=", "Lyw2iabOfRw2qkKQbdi2lL51Kk1WQ8yGNVAamH5jjao=", "Cp83yQFFayow6NVtZa+vfL6Qs6abRxEvapCe4ciWwLw=", "BpbRpSzZZcYbgzPP758UfafL2u1xvl/MCk7tOs/70D0=", "LfZCBtnLfnY9lMcuhdom5hR8oCI29nCju5fQcFzb8f8=", "D5JO7sCQsSOuZ4pHqj1Muy+8M9LqEK/8y9Vb1YAhzHA=", "E3aOnWuoVMVXEk5+zy57mmo7weJXUcXbULaBuD9eTms=", "BSV/EhNTjRGK6EuJ4q3efkAD4EKDb9oyplqmPJanAqc=", "Lt24VMTeBYFIJxV+nXYA4FPGhjRlN3dlkskanFHvrv0=", "DFsobkanD4EmGheZwDbP86E43TGvhH7qN5v9zoz/3cw=", "KM6xMRrj8hEsWe/y8d428Cf+dI45jmHi37X0FgUZW3Y=", "ArqjxCjU854d1RFyhAzsr8k4aaXU0sRR7yYbkdgz6xg=", "Ev3fy6TtxI/6Cvkn5dKdZ4ytQ7HliJ5JZRJCPFHHUZQ=", "H/5KQldlrLtN2PZx8Rw6vtHkPMhynI1yWKeHNm5pNb0=", "BRjhFnY513Jt6BTlc/jW5kTeJAGQ6yLaB6wqbdGkn8U=", "EIgIjKOy7F7zQG2LGUmECSU0I6DLqlebeM/iK40v/dg=", "AUETLmOb45D1T7RtrxvDOmmNoxtuISQawlupG0p6I0Q=", "LTDkB1eWBQwPQARABZs7CBQaPAlpVcAHIPN+M0mxADc=", "BsD40gUEENeXl046IrSNe0qg9MEtt8caMZrexDYZQbM=", "AncUBZs8olMeOmXgJNO9RoaehUtoiEprFoaRCallMzo=", "EUPpYAM7KDfjWRGyJZZvs1Wfhphop1h2hM1yEOys6dA=", "JFYQIrM1I0Evt4US45YXIm7IdAIZOdPQ6bekAXlGMrU=", "Ilo6I5BU7wYeZktW1l79Yt2+XP759VvUAqMni5TJvB8=", "BL4WWlM9GbSaAVHnGDhopRIKLmQitQBEEFC0HEhjBbI=", "FyWFcaqHxj1HfRDmTQaf3yMabkfUox3dpNbl8ZM/k98=", "KppriTQ/xBbil9u6b2vD0oTbGAzd5mzpSwuupf9xa54=", "FOBZWI+PivIil913u7ARL1flbDt9PqR0cTNNNOIYG2w=", "CMCc9nv00P0MIRKY/kftIz5qtS68uhtST2ba0BNm70M=", "GRbtS4pfl5FUqRmVZqizYcwQB1Ua2dtFUV+KbA4bJwU=", "Eax6hg15P5eHDpUrMkZMtfUB4hXmaRql1LecHEz8zzM=", "J3DFpbg+9AfLefyeVWoxC9aqPwgea0XZinaD9gwyJ7Y=", "HUEtFc3990jzqX2tgph2YN05pOqTL8vFGggiM8FW1ps=", "MD3vLq8Wd7XHuc+2eYKYBNZzTavNetOndLv7moM3vEU=", "JB1tUL5J+3lvzNNiqvRbNQvP10Vz0UTHPnq0LjBHAR4=", "EUcnqBzZEHM1L3+APPYhgg3nec18bCuauHy1s4JzfUQ=", "DYGE7u6v87L8oaTNqznklR46VzJ93uUWN9xtJEZIQvk=", "KWmY8WJwCazHkTrwVrw0KANF7GqcJ8c4BO4UL+CyuZ0=", "FFsnPBHFdsdXiksCKB2bFRU3dYhLtueIQFxIecDtwtI=", "CXPm9Rqc9Pvsp0FlVi16ZW249kLEEFooQbG5NImx5zo=", "EugbAB4ekF+dzqUStR/2PVVIjVfNJf863UAlzzqfZ/k=", "Jy54gKF59XcdvnCufX1RyiiRQSDqHcOrhClWXNany8w=", "FVtNOnix1wX2zmJL9GXYIyX+9wFnzXeEr4cocrNIoCU=", "CSA+YMMdr2AHqe8gyy407KnRydk+mQIeCjg1mL/nc5I=", "Ea1ID6cts7wWlcm9Zy0uCaVOcqyejKn0X/ihxz8PdfI=", "Bf5O4wDEiwzv0DuHBxVCZM1RPAyIO0Y5RN/tMEDFXc0=", "GCoinRBCnbn/ClJYcp5wb+koLGt8pgRz6iNMoToxv+Y=", "HvTStmih4c5ETSE/GtTSPebMu/bPWpPTFoflPpZ/ndQ=", "HPLTvyQOAWkcxvu/I79I0h65uInGKUzBjR+3nJuaU+k=", "AMEQFxqPBkKsDtsH+Drix52ZGjQ4Nm+YwywtEvL5Skk=", "DYKmiwVwrIy0tw+/KmC/F5Yv8ohihO3+WquP/YQxS/w=", "CjHFhZOWaeVpfGsWZ2ftrHTmNZ02ThJjE0kQknZIrTg=", "E3xbBluNOnFhxju6zWDeyesuF8Y9xpal0Ve2SFVLHFg=", "CQZYmRzOCa+b93vx/AUGNG5aA+MJaSHo1DZGn9dbtvo=", "CbMJ9jiKf2U5O75Q69YRCFSpHGdOoFGJRRz2r9SP26M=", "DNIX8w7uJZjKpzidLvoYKkdW+t7PZ7g5Fa6ksMNs67U=", "K5pQ0pc/Tsz+JmFu7qj38qn8Hwno0oU4aRlEAhebqnw=", "HURO+iceEFqDsxBdRpyh6u5qJ1NLmmLMIQsZlG8I4a4=", "FuIeCBUl09vA80V3/RQ2g3yRLTkk7XVVdxiZLRTfz0w=", "FXt8/XVWCgvq1neEPFJZHRdVTY74oBW+I+NK3DkEUdg=", "G8RmasP0zR9d1yvP0dzP2MYP43IqNfZWggkVht0oUoQ=", "IrEPXCGU2QVCIewqnMahv8H0RBhxgx1fJNPaaG1NXp4=", "BR5UhGnRkpCiP62E2u3StUlVkfIsPca/Rn8erxKgn1A=", "Fm5k+n0JOckSeqWLeq8r6mHfuzE4vN892cyYbpyk8MM=", "Ln+NRxB8DzEDHeFfhA/8e0O49kgV3XwQNX6FKWPxTIQ=", "FVmKayx6uRwbp2hYXxHWTUyaP2CazpA533U7TPkBaTE=", "CDAIB51ZAM9zrJ8FAc6yfD6SJQ7MuI0Q0OAcWTIC6Mc=", "Ao4wCWZU2hb9kK0sIAgPrbC7rRCaPtGJ1COOr9Lfw8Q=", "FOuZNWWJTQVWGJrcUJtZRfEnX3B4vslpl8NjC3Q+k9w=", "IDARww2yGF4/71M2BY/22aXQXFV8PeG2J7tKrWUdubs=", "BjeQGsZHW4JvBz4ThkmJee+6mNS12vktKpq7Y7WuqnQ=", "IDyz/fPMI0py7UyGmTJ6tsrA6LdHmyhMCMcJfRYp7Ac=", "GhpAj4mchBRbE1ygp6Q/Nes8t3zVEkMMMlzkShHd7do=", "CQDCbahVfgdguXHjWvWGbHzElKwvvyDYYhMESexB+bo=", "MDpFUIl+23lcamO2DqM8xe74L9BEm2ohGat01V5JwkE=", "FyLlqENIK1mwea7LmVxD1rgnXhQT7AilXyGLgA+zB1s=", "IKiqGgwvtM0QqC1wLCwwEE8A3lrZkQOnJN61Lp2AHWE=", "L5gNft2rAsBrb7IDmOenrPYTKvGmBdDK4BgilJUvUjY=", "GBSJhwZJSR+EkSx13/3VXNDcALCHJOof5DFH4Zltj7I=", "HdC5VK0uZazFykZhU5GueLbdJTlXap3kQXVVNW+XlL0=", "GU95zqYk8rylHTaHBlIaYtxHOUcgmqXFAIODfBbuxqU=", "KunCROSwvOQrG1UFOk/Jbuev/aIyZ5IKiOh/FiKf0TI=", "GuamqMm+9HfRWiEXautCK+JOXQ8MvYycs39LkURRDjg=", "JODmoAsXXiJAfeZoFb3dCWtC3XP7VR64EPhOAb4wTAo=", "LxarVnEIn33gu9HhR45FufpihP9ERM78i0NGkYe4Pl4=", "Gdysnc8Hi2poUj07zDQSmA5VGc5tuNErbas5B7vX4Ow=", "ILC7HykBNq6IvbwVs8hkYksH7T3/V5BVwWgLChhfawY=", "COiT2K+Xig+6KkL2v/fy/jp003Zerf9JqCBW0BTb40Y=", "DqyZ16903hrR/6qbX0Pso11gg0lVNsCsvpjLry177Co=", "Genm1WkjczkjoVzX+KQ1A1LqMI1hYEc9WTfpxLULfP4=", "GOQXZNu10g+FgxqJ/cFAlO0DQyFvYCZh+lpU2+vAScc=", "Jm38bp0xBAz90QiIQPwLZRcpdvWOBkDqb16tso6ryqs=", "CfGsH12A0UPZzQhyc6lX8Tye4m9bds8w0/tzw5L5HPk=", "FJU4TFk+xNokiheqRXvb6M+VAgFZ/0brlzprVYptRt0=", "ChGmPlGR66FvbMtOkr1jickprRU8U6EwyTOkH0a2tMg=", "IxoiouD2qyBGZEUSnZakD+7BsplQmUlYjA9Yp2bZs/Y=", "ADo+sRENdblmjQ2KSNoHbn3NLtD83rnMNTjBF3MEe6U=", "KLUr9t2NDFQTrnvaXx5rXT5FSKRQXQjjb3e3JinZd5A=", "G6GIMUM8sVQF7nJLtCgbulQSmc+t1IXGsX90/OQ2z1c=", "HSlZZwhChKISuEHqLr9/8p3c+ujb7r2d9Ytfhi5/2Ag=", "DoY1Z9eI2sHdXzJEVkrtkox5I7q4liRSvHiFckqTRy4=", "DCFKUFPqYJ5WCOmm1UNDoyzQLTJPYFPjOLNNwHAatcg=", "Fv+w2bXz+9a98dUDg3I83XLzUw0+fe0piDuQAIPGCP4=", "IOBYNVUOajYmBvUCUdisBwbi++V+RrSXflLhrfNIni4=", "GJGo0bB4ZQUhsIxBYhbKoIbg6YNlqh1bpB1K4HaAet4=", "Ab0TGeqBqPieLaP0b8dHnF7+oeQje9V1T1b3GbI8EH8=", "HE78OywPJmnLpUlgCsAj94FaldJPlHZYn3NK17lPqO0=", "JDjjv0/HJ6dD9MRAlUgkDm6FKTnwPoXjUsMco4bEMvw=", "KKjSUKCiqirPSNeeBD4lLu4V8dHmqE1YvsPfrzfwuFU=", "Kinn04HY2AgwQ5cO+4qlYYaDk4UKDzSgp+vNPX42vcw=", "D55XntBN+F6oArSIWIdpw8DlN2xCqWjovQsC3CNHJJM=", "AqgdwD9JrLpJcJ6eeAxWqqnd6yRf5gJteExHzdiaFb4=", "IHEWruHntwIqkKyCFDXp9+y5T5+5Qve2/3xjQqAkF7w=", "EbQx8yEIGGWMusgY9jZV3Gwx8AZAxIcDGnpmmbVKckI=", "GXpQr53sIBRRiz4vwmATpE9wZGbUWW8GJD8lW6OBgyU=", "Cm/QK82/ywIA3Yn5uGZpv+hifOZ0VLJATUlm8XJvR60=", "BfrFz9Xi9WkHBPM7RA5vc5+0/0RFxb06aXidtlL65Fk=", "J4Qs+KTr1wCc4tfsNI/3g4MKzIdHmtTkAe/V5zOdJfY=", "InhoOu9mKgfUJ9Cjbua1LOlijpkUzFO8pbpKwkk2Y6s=", "KUz+5mx7jeUF4MduIiVhkGbqXr45r5Lbp6t0uHgIU6U=", "AMa2Co4robd09SwfWY0Uz82a69yNctTIfbnG6u7E3zc=", "L1YR/ZuKnLBS07bvKy7DLUghiGLapOVNYyGfzLngrE4=", "Jhu2asmIyjp+Lf8CeUT4/LPey52YWwW7yw/GBiCAyso=", "C142vbV0LtoDodHjBERlp1H6Kb4oBO5ps4wvKUOGJNc=", "FAh2DGUE412wLXbQtqF1VxnHV0GaSUuqWW5a4KSzEhk=", "L4mOWUfxSwZV8EvONd/osIqkEwP2AnR3SDU5Wbldfbs=", "LV+tKcv0xCDmGS/36v+Xhi3lUjrNaoGuYRl+heDyILs=", "JCA3ZDZPHrzI9S2vZIr2sC3p5GKT7y9SuJViafWjBFg=", "GoYnp/pVLBzQc6pT/XzDT7cSBRPip1b/czW2qyPUfjI=", "Ge3P1r77P7Xf7HaLXErtKyfdkxHEvUntroSYOG3ls+Y=", "Hszs43M8KoGgBpdbnkM+aTHacMZJ/vZH82imdoLhpag=", "E6cosL+ysyLIr2ZahHiRPy8Wk7OQd+6onrgd5BJa4eY=", "F3O1sJZV6b3ay1CvTzP151x+qo9L+kaAxL4RxxzCq64=", "HZEQfs3V3jcgW/6CfngAyEZvZXK/YRp31NUCJCr1sjA=", "EJ5YkisC0XLINj+IxbkiXMASL7mA4NIQuE10pauwGl8=", "AKDRstFNhh+wTAfoX0Csikr0gcpgK9IkustEIpD/dLI=", "A62UpeOPv7W77dLTYX5vvP9PWwv4kyngHoy5U4+Rwmo=", "I1JpoIdScSRx4tiyBM7L9jP4obCHuNUNQ4a/3uR/0Mc=", "Bj0ixG9hJaIIIG9pkaflU+zd60M093D2lxW5wx3v7kc=", "JEhSvQ+IOCWUj7pYx5U4n4Kgxsq9kF9vZZbWC4py59c=", "IMnD+tCKMNZNrKJNd8yT4H+pUxqUWLZOfDbiuNXeelU=", "KPAsS1PF+7m4T5vn8tEVGj/qQIKVlhUux6lZHXt39Ts=", "BjKC5FybL6XGrF/Mtk86lBIE2KfQ2/tuLyBjunnbyT8=", "EyKVeAPoFP9lYoGolqG0VPg+51kdBK5FxViU79oNRnk=", "JvkcYybF26LiMy5l4lrc+oDsRN7dsc6/YvXDuQ/OB+0=", "GwBqiigvX6j6gmgXQFj8RXuz4icNv6vxp3qxD/GT4dc=", "BEtHAaiX9oT5c+81+RPIcUsjoLxokjmNKZnVuJfdzzM=", "KQ+m3A4J7E2ceFlIkTdIB/Qumu3ccQ2uY8npqCTxzzI=", "KBtkYxRwuYVypndjflOBZu3s9qSEbsS2aFeqjOqdYS0=", "G85HrdWH5gftaIaHwBedoXxUynP5tPYJH4Fu6hcnU28=", "Fcju01RpSjASuCJiC8kfHWjHusDmaF8KFcSO9YlBoZY=", "GG6oLwmB+Mo0fwqe7AVtq6F2pERly9hee463vQWA/4U=", "MBR3fftjoRo9m3NOekek07asT+QG4ZXzujKgFYF/6Kw=", "ILokNW7/euC5zv8VYqSkFYWqnKDUWRUgTkM/ByixWZc=", "LmFhZDsbMdw4KUSGIt+mrHzXkyHuQyOZh33E7bJe2zI=", "AktRLGMgcL/OPvqL0vNLwQDw3mR9D1UQJp/ywBx/Kbo=", "Cpruwi79AXVxr/poQnciof3qaSiAhvnGk60qQudztZ0=", "FckI42Srk8FhE2GthPBvoRxTwjEf/R9GlNY7K5gsV3I=", "JWK1c5FwxfoeHP3ofXpWwnlaHfnA1uUA+ms3WeyoSYY=", "BBNZZeb9AniNAPmuIYPxngk2KIgH9I30WtP/GnD2nj8=", "H7Tu4zKLqdPHnxr3GjiVLEBfPecUWM9IhW2oPgapb4w=", "GKXjU4TU5HlFmtQFwFUyVTwk/tkLg5PzowuMOLsqs8o=", "D/9/c+QqUuu/MLbnP9TUXCETPkziKPU0/240ELWznxc=", "FZo9qmZsMyoSxsVue1bmJtjuqfKjbqaqzpWDTObMUxQ=", "FCSHUiH2jL1PDeRHK6dr3l5MeQp6/3grTrEhQZ1h9Wc=", "GLMgkgLGdXVJKWsBCVxcw5DXrie1Ix3YQU5pmrsYYT8=", "DrrsnKuSsYL2WraM+rTPfhqAo2cUvK4weY9hGHpqkwA=", "EVVS/v8XW24yiVFsdcch4Vkizu6DQlk4eDQ00S368Uc=", "ItAEh1mF7rM0F7T/vMxolYiwD1+5nHbPYFoKJCioIYU=", "DzlqZZM8Za2bVArOFBa8R4eqS2yj9/I2ak7Nle8Szjs=", "AO3X0o42Fz8MOyggfdwLVfoS5PVNol52GYccqNhDnUI=", "DX2QCcPWeXCQ5uEFmTPiE2LSzwN+JR+/wrbhhhGHW6o=", "LjaMFT+jWj2cpowhp8pYqQuiirJSoY785aLVmVHX5IA=", "DNZ3SucuBxoL7tvq56RJ7FI2L3blsOCkQZ7tGHoxv+o=", "E8JYU9loDS6NyMaE70iyAueiJ1kvdgEKINWT7WcgKe4=", "F6cX0eP1hU+1m38J5vjVE+Mt24lGRn9wgL64yhD7oHY=", "CGkRF+v05nGAAh+9bfYjykjAZ+nokOFzmpZyouuknsE=", "GcrRLERTQTTD/roggqKdr+tVCSDxPzdsz7ZZ6DXOirE=", "C3x10BD/mOx7WtHjoXoeCSw1PFRPjn9wf16BZRn9b8s=", "IFUVYUXEQR21R775Lvv9S4obtf4uExk+DZwH855Ydcc=", "Fkr660Fmcmlk/loHmhszJReYDEejOgTOIvVsM9A0Efg=", "KTbFCYL72w9WzObU9XWjFmX6gT1yJSRkwndqcOy8LG4=", "BN6fS51EJM3oYK1VNNqoOXsbg4Ndg/ADcvrE43bm6Qc=", "DGVTAHVGgW6Gx9kFUqbsIW+aNJh75iK+F65O70VNWl4=", "GnBB0FX5jb4thzM96KPQtPY0j06ylorsnLx9wzQlh+k=", "FGfO8XbLcX7q2iuEIwM2pw6kXg9K9cVaRK6uI8pWOkg=", "JQqtw66Ynz6C9Ksa8E6lrT2SqYFR0GBGtjVPmLBGEQ0=", "BVOXKu5ZPr+qRckyvLFT5i+mOBZ7RlVfmop0o2H3iv0=", "BOVlayZ/jOCxoxX5SThz7qNcEZPy/r2/7N3klLaUWDg=", "GUAekArOIllB9sWBgk4zj/mNM/LwtD87dN+8CVHsqGs=", "CHJTshFuj8tF+Oyhs879khEF6c77M+PMC/faAGODuAs=", "E1vYBoL3cVcr9XTz9xTzQQWvsh6H1yxAovRuzYUYync=", "EcI0l3IA22xoj8JUBTrTAWOQoCXQygl10TN7wHfbOM8=", "FqW3W5cOSKXsPu3S37CNK2yVtzLa3/HhyB6Bo9ybJLg=", "An7davs2Kp2i9gM1IH1yltA1nTOdQYYCqMJwadFn0jw=", "DHpxjmPB+vhyr3YYfFw/j/yFXUCV9cVduqAFM1FbI4w=", "GE13w9bXI22zLZo+SMlf1EiloMH9PlrRX6/4uvEDkBk=", "IDGFnb4qNompl1tBGW/fLv8aWHqSRzYeeLewKXY9Y+Q=", "MFaQwZ1226Xf+uzs4oIYCWoymAzeep9CBbGYn+qA3G0=", "LeL7SUGX2cHxRRZB78JHO4UwDQXA0n5+0YFt4UyUqbo=", "JX5+yziQPkTxpVi0n9ACLDvdkyWYRyyKEmAregIOTDU=", "AyUHF2+qBJwNzHSo/8ezJ6wpdDZ58h/1UxcK/dLwS/w=", "JnIClrSDcFklega9w7CdJpKBAs3lfiPpHRVAz+/E/pw=", "GveOXpGJYwUKQV2ySrRc39gVOcr3T770uABHOmI1oOs=", "L8e3Fk/0CWWT9FzGdHZdtV1TbNToZxEIX8BbsqfP/g0=", "Gkqw9FFbSb06pK2wP/+0UU2a7CJPZ2gxW7sjZf6Z3M0=", "HeIW4vraTCTX/Hj1h0lsJKjut6qD/LnMc3kZ2es9he0=", "GqMw3E4lqNDJEL/IenrQUeSMguYlhhebGMLOlWyLM1o=", "A9X7HKrZ+1BJGnOXTI3LKC6GimBUlN16H/my3xawzW8=", "BF4TBCTY4NlDwRiPlSGm95kzT1fb5iywXuRpQ441tLo=", "H6+24l9+kaTyADnCnpR/hjwJD6KdxWZNn4ppJhMn5LU=", "KHpWAYzQj11ik+FlLbjL9AJJzcdZqE3Xys9Jec9N9Vk=", "I7NQjDPpzTc4dNqC1sFcJQqsmdM95RbwNR18QhVFBXo=", "GzdFsE7A+EO5/Yctbe6XyMz+lSo2F3FiMRmNi9g39E4=", "LdOJ8Itv460Hm8nR2u17FpgBHXSpE1Arx8en4dc5/e4=", "Cozdub4AxuF48+yDFIK419vX6Rtcjx2ifxOGBo5Y+xQ=", "LompDMSt4+IVDK2GK2y8StQLj+Z3mo5h78SCf15DqlU=", "JwOBUhfVf7YmM9pk5HdyKbu2Y/zKdijqNRAaWm75kck=", "LR1XC+CCDo2Q9u7Iu6doIekO8gnXBWBNbkODLch2ApU=", "AtkFO4hjumzUas/6CJHAcgvZt4+hZivA+EKh4F3mJAA=", "F/Syb/MRsbTVTnT/pFrSg1ZbZ370Di5OGaY11jjY00Q=", "LmgCDKgpYwha782SUHOmQnBQ4EkG55MMEz8YidEjAm4=", "JXTDDaEMJ05ljeqC89WvtY2hqDTNJbf/pcWWZTALHrk=", "FcNholWFImqGZVEB4PDzE2x7d3UhrCQJ5W5mbKRJdj0=", "C1ThyL/ilKCDKDldxs06NTEIIhFhzXD73xGMOVTKuck=", "GAURXx1bYBkexahzPMxbG1tKMtgccPI5gt8qJZlSiRY=", "KTTXPb/aRmazMaDMLzj36D7YCTzynREe90p6jXByxeg=", "AEiOw6ZWNTZpYTTYoKUahyz8Su3EWMROtqcjWvkmPJU=", "ExnZtPs70BQm/8sm8la0+GNODxj5WX2sN6D1+aAMu0c=", "CrXoLjReMEsaig9lf98/4D77AGsuU/yOd2UGeWwzWBw=", "A/1o/3RyKwnKxNWLN34IGGcdn/UqIR5EmrFiw9DPh1s=", "HnxVLlqPNgVgnDZnvB+BUwmfRuyO3/eL3c/35CNy0Ak=", "BplS6csm2N3Y74RIT0//hJVgFInd+c+8hnMcoVvCtCs=", "Bp3kMi85D7SzxBFllvmo9RsA8uzJ7VO4zocDel2Ms2w=", "Ei5TU1HQN5C5oUEevNWViha69hsBwQb18VhGHbpCclg=", "Iv8i8BH4wibs55fR42sSAUSTOPvVI/xGulL6SLMie2Q=", "EWHTBJDxpQffGnW+hqXflNRIoiQRHzwxOsP9JzFlOIw=", "KuL6L8OWLyL/a71DdrZHeyrOP6ljWGY31wCuk22Svgk=", "Kp3Am78sQ/Lcdatvm/7TZXA6Q7nDWBAffrzKIIJlOyA=", "L0AuYK7Zxf6FufrOEsKncEg6zoETL83J+7x+/0h0wws=", "FPNS6dykbWXv6L7De4mlc/ZfCqjgx1O80Q0k/QRf0PU=", "E8cMO/Qs40w2iTOQUAuC+xSGow05IbTssfpHwIXyD9k=", "EYYZuxSlOiGh7O+RE7EOfGt6NtOzj35s5auql/6Wv1I=", "I2pFsnIyDOpqdCgPKpVOOxVxdLiS1fOyrEtuXE2684w=", "IP14qfZi074HwHuZ5NTLgEl0s/rhreY42IAOg0kLMaE=", "BJkq+LkDA0+sykACWGRmE2pnUiIJOsNIp3hMi/vN2aA=", "I1Sy7Ix+jm0ak/cwc0LHtm3WzJMT5ds9BsOA/rJJGTw=", "GsjJVYiF36fX30kOEbEChU3z3lsUxfv/8veqPzH9Lig=", "BjZ1l6t6LlM9maREdyY4jDWYG5l2MuVVr9tJF0bYPSs=", "FDY2PIbOShdqiCuybEt19a2NpGmTWn+zvoGCfQte1JQ=", "JR5h0Aq07yMsM9VacziO7d1l4xM7xPs+3HCXl+lSmxg=", "JzZWhwx7i4nTimOpSFZjrf88Rqx9Q+YWBuJvUZHM4Lk=", "LsK1TJqkQOD6AXvCkTXrEkrqCXCGS48deU37Fvi4yxY=", "E0xlT1o47MsQcKWniDG8AFumrH16O3blVVgOsSM/lJ0=", "KbyONLGhD5eZdQJECXmxGMXPKvKr2XJB20BpR1BQgPI=", "DPMRKDLEXEjB3LXthmpRNltbt5ScDP2arfZ9El1POrI=", "B43OUh07uqrlx5x2j/3M2LBOER2LRsHy/6bS5gLvMf4=", "FiQY66Kxkwoamluf4K3mY0SBiOJbKKyBQQ/wjCLHD1c=", "C9O0mIytKQEsnf3cnS11gSY07goHRWQ18aD3PALqCMw=", "EeM7WYjWsuVnLVjFkh97HNcpBjVnW50+DNB+gayy9Ys=", "Byv4GhMIz1F1nychfJaHRrMjJLydQpJwwQ4Wcabzp1k=", "BVhToz0RUODhBhYP4df8ZboY+uXL5Z6PtryMx71mMhY=", "IIP8GtNQ2C8dQ93Vx/pHUmjCkn4PAua+ceUJD4ITcWk=", "Jsp5qFWVjkXhqJu0VG+Di2fZjcTIySvsJqDv1nTKYhE=", "CcZpqg6DFXK+WlQuhJgJDvaTkAu015pYiq3VzcvmJpY=", "AmHLkKt5amI1qS2preu8OdyrzQGHSvXWPZDWYDe6O1c=", "B8FNKIzvyGI5mhFW5/py3vz7wEZuB2irzh41NmRQQEo=", "LdzW2s3Lv67zfLLUxQYPDvNvERCAf9gcQwic1Fom2h0=", "Fi08P86PMCBMUieCwMrmb5EeQyyLRHYWazW19TDT6Mg=", "CQ+6/h+GX0P+OiFgm32EWf40jWCkxHHcYqCvxVXMJkg=", "Hb6OUMKThGMFxRuqNHPinazlfm4a9I+7I9gVVuq1czs=", "Gf/vm9WMpUesAvS5U8uUHe82/YNMH17FpZQYstIt+RE=", "DimwR5UbaAXBm3ohrH0kEpyo+OKzhXMbIZTBkF8h5AE=", "GY07qso3nbYQVnUFKlWjHB/USodzqdfHibzgbgdxnTI=", "Dujeryh3ika/gYEEJ2u92btIkmzmmb0YXGSai0p+wWw=", "AwPZgxjBhshXnRgDmE/eMoR0SrFh8UvEV7oEXzwTKa8=", "Jl1/qIwK88Ld+sDbPUZMMd8JXNqW3DkUc/gzrPT2SAc=", "DtrI2Bg/sOoxrzs4Pvn5IaPCk+i9v5VZj5UKICpnfLk=", "KfqJ0WGQ0WNHBMwJbwMNyMx8XJ+G0T2Vl2tvF4/9IVQ=", "I0w+MfQS/B+3yaW3Dr4x8ztZh8c1VfwOTufnUoDYQmQ=", "LgU9wYZ4bkRx0KxvXhmzP2ONyPZDkHfizzaNFNT7rmE=", "HWFqxQWH/wxzCxoJmo2qbgXDLbtdw2ZJ2ewMH+7ytTM=", "A3dx6s3IUxJcsLyRdhDAw9OwZVYGALSu+IO9FzrcR6A=", "AxxGIWYWrjJBhR6C3s0EX0ColgfFeMYkgJizDFRuHnY=", "AEgtHSmH17/G0lavMHK0FpYDilV8mGeorSZwJ+w6W+4=", "IRXXzRz5qE9D+2QmrruJdleP8+Vkb4nyQKSKzRbw/hs=", "JtqEdPW/25yI4NcvMiJ68sX0tjQMj/yWsEI7EXLH950=", "BjbbWv3TNeMZWKcOaU4XJF33/I0UjRy+Gf+IDn3Ar28=", "BwlrOVcB+ss0kqwkVkxGgCblh96rSe9jxSj0GPfkcfw=", "FIvG3582S5KNaBgKpqJmeimt/5Zs7z40DDaAgDMzvDE=", "JNz+y+IDq8ZzE8gyTGM5oiqaH3L+lEWRyP4AP/KhliA=", "INuTuQJGCrYRJW8o3+0+cAOz0/ujbXvvmT84Hz8iMNg=", "BE45IBqpkMTjLJRAnBsUEPz+UR8vWryUIWsNnuqkeh0=", "Kq+QwwzmDhkIWlQVP0Z1khuOZecSu0sKBA1MEepmU70=", "I/oJCNfYnzZz6hQO1mT30e7Kdl+yNsqKeO8rrTBKnPY=", "HxnBQQib5/1z/QvLw+Zy+STp2X/i7aQp/iX18fjB1Hc=", "L6W4hKqXRrB+hyCdECNYJHhgOplPH/7DwdZi/gljLf4=", "JyvUNX1E4uLBUvaU77vCOBJfD1NPx6jOeAOn53pDtv8=", "EnD6WAjAyhQzQjuQBgw0reAfOpyBt21NKzz3FYM4Y50=", "G0f50/LrD81weh0px/D8QEgftr0uGSVxNYrQbkKZUhg=", "FmG8PtQERcm49aa3TKUsgeMHIRemud3q5WL29Rv5uLY=", "ADjI9bunPffZqtTwZ3WmVqjreAwLh4P8pEBjHYfUhuA=", "A3l8lFVMcUIb4OohCL1dwtYXL5wLUegYzfDJmOdli18=", "JvgBy+rSwmvC7mbJxWHWZI+dz7oC1XMxaZgHDUNJIKE=", "G9nrB4Gu25bJeZ9wmgyrqA2wz8FVxDfSfe2GQd4Y5ho=", "FIXIP3SBhsG44jfq7ubyPgk8JQmDhDbAhMbvC4gwP+s=", "GV7WTdCoE0aUhY+W+hSvtAIY2sQKMwR2IyW47+A6lIU=", "LuMQYcpxYM/P9BSvZ9q8WtFWqd4mMla3kScKas+fCWk=", "FdDw+4JIYL2uXwGJuwnOSzvAAqf4bpO/hWeNXJvVF7I=", "C/sv3BnbLZ1+r48lSaya646dzYPJHmegR9D6f9NvOFw=", "F5zWJItcCvJ3s5LGI7dE+GWosf6FHfJ8X8Kkegqh+g8=", "GfFGn5yBcHZm9tuQDo2QEjtxXnSsAiStw1fM3qhzf6I=", "ITOaIgOvzF8ssf1W0u6ReWN85Fq9Lf3Jp8VhzX+vtos=", "DmVybaa+iNX5FhVNICrT2+P/9dZevcKcfJfqgtmYfkc=", "AlZOiw+/ZfFDap5xal7H4Hnu0tbbcbfZSi8kNOAGhoI=", "KiNmR9zk5FxggJz20WA7qkNilT74Urj3he5elZAR6kk=", "AXSszp5zqa1eyq7f3Od21NHGt3YfsVmcz5cDKlnF8/E=", "EM8qgIA7aALPKmOjfhJ7VWtw1lu7YWV/aCHKRaBvJA8=", "FhZ/nRs6sJT2fQy79AoxX+ObReRUB2jz+jXdbVW69/w=", "E3sbB8tg/weyGqFRck+bxqUOShemjyrqUS/B6TloyJc=", "ANWQ63qvjjDc7RjKMX/70EipsPyA03xUqL23ck2N1kU=", "LQpjaQI3rTRpq9Ry5FDBH+Ue4UQNO7MJsilcuVTv09w=", "ItVeBLoNhV9CA50YodwU3RYwWuUWxonVFBqc5XILj34=", "AcxxFp8yK5WViXuGRDggi2anGQK3P5UYgmFY1xRd2lg=", "IflJoWrLNRlNnlP9/FrAHzSRd1FwJUwstLkXcvRmNts=", "FM9TUcFMCHpZz1+lMDxXUsM9RGtc/zF+RXDffWhaqvI=", "EPE78XJ61+kGn9ZwFQb5WP31n9LQiw/FBIyUhrQ+tkw=", "BjIIXncfdN+Pz169B/lTc/gyy0HsmAiX2oqGDAXpsMQ=", "Fv1nOqS0mYI/sXPZ7+zm5rYErgO9WoxnfXrr+9c79ZI=", "EQ2pFaypyHosRhSx721vA9gifWw+LWO9oCjeGlgKQ4o=", "Hm8SXz+BpFRZNeUg9eva9vmaDAO0hfWC/iOlOsZsG40=", "EsBpqDtVtmWqkJUvv6g0fsFXwRU59JZA1L0jWNpYmzc=", "K3hOL1LDuVIt1IuvbD/iguJoLsxQ+xZ1X/iiZe9riC4=", "FJSGG66tAFiAHUfvVoQnI8a5bQTTguR8RUc+7eur5IQ=", "CdxxdR2qWhRQG7LDy4silT86PDyIy7d7GTEYF0HccJU=", "IdPhLF3mUl1dq1oVAAiI6M429AvjtJ8Dskz/pwxzkxE=", "Gw5wkp9XcvcurlbIonLTGVaJ7EaI2WVwtG4Z+7Zocsg=", "FA/ko5Rr3q/1LAzT7/Yo3EDjCvj6hTTGem0HyVjzPfE=", "DHNJ3W15HUhxQztQH8PFkzUv1plduk+mh/UB7ImG8N0=", "BLCjXPYmxA+CofB7kWB2wNNZi0QU9zyfbJdEICREGj4=", "HbAraJZO6c1SopNsx4PMEviNmLYOhYyzY2ZRn6ASs4g=", "EOLpVpk+I/k8Bzx8pNsL/Hro5Vj2dribHuZghiA8BZY=", "H0XeNl8dk8+EAoCJDjae9uTFqYuaf4M57P32BNXm+C4=", "HLuFvaiV3BciMvfVmEXG/BcQFrgskdkfQzJh/tTqnH8=", "A9Pzu4bvFhKV+RNL/lhEHdcrZGG1++LVeHkC4+WrHec=", "D/8CgU1Hs0UW3YTtF6IAxErXL0CA+AV9p3Bg0RRx6e4=", "LpQW0xYeT3sCO6Ycj2Y1YXhV4wjWIztOhelB96Xmyfg=", "BccO4+64DbhFAcFUTCQWH/1VE7ylzytcdAAR43k9jOc=", "BmbXM9JJ295P7RBbLqLW1LmRmD4rT1itVJEJI9CWXcM=", "J/lFuyLcGAqZpZZEnoOzLb0Q54v0NnUx7BHk2pNvOfY=", "EuJ68Ut+zpuLz3vBySQdDYX5+kfIMVODbhmeuolhVE8=", "Co1sn9gMeZvuB2F3ofnXvrpEarE7fHmVbwfZlGd5Rvw=", "CKDTZGxHYmkHcGLcPER1U9YaRkjzBtIOVvrjLRCYhvA=", "Bz+q1XVEmsNc38UUcXJRvxaOzs8DKXUtt0A8VGPs2E8=", "Iu4i9DYHjeBI1ZP0r7q/VvSj/U4H6KZkX8aFQfDl/fA=", "AbUCNa07Gm9qx13jqfdfTzmGbmASQ5ycAXmrAyxCZqU=", "Ls9PPIT3XqexDsEaayWWFmzptaKKUm+AzQLWZSJqP+s=", "J+x/PsViTNMxmrhfffE4AoOlmzbr8YrDi+11GrGgS8c=", "DldiUOFWDHfKtnKvFOv4VkAkaNLpsKwD888pcJ4T2TE=", "IlHydv3nfJmNQrXa0FqiX+mKkIIAtEC8t7q+y7d+f/E=", "Ao3M93xGfHgYGS1Hh+OEi7BXxJvgmfYCkaLx5I3hg0w=", "Gy2+kjb1on7VyeO3DgmUMtMk84DzkVjhGQaflZIRM70=", "CGmSC49QJsxDz/GL45D3TDVYbNK2lDsp73sXvu0neDI=", "FvT8sYM2Gb7mZyBqLJHL2RBVsQeDBZsL5S4bZW1nYAw=", "KlDNbmlC/KdKzRNARcKIOIOHI/32UdoCvzs9d0E5CCQ=", "La5M6CmnAYLb3EGo7aiWURELLJnGBWWuM23yvSr7220=", "Lb/ZRH1CFPmqy59dKSTVRdBzECMMFGmvoDsoO4x+2To=", "EOe62VLIpjKt4dB3SQv4CxJcGgWuTveRLmnxUtZAbeI=", "KNSrMJf+jQN39KJngmEWa1uyTFHwTXaAguzus8ax+0M=", "B3KxwUy5WqazneHUwk7LfwjSY0OxSthYIbopv1mDsmM=", "GFb6NW/pSEf1dgL1/UHanUykBPhY4p5yN1aKjx9SygU=", "JFe4Ip29tJwgfloSCLECsPhsnyp2tKSiPA1CMwS/6dQ=", "BF+/5rLIdZqCNOFvD0w39TMSWW+pCyt70n8LVdxa73c=", "F/Til1gjlZbnBHiqqLY/8SanQFWsW4DHdcD5JNgPLGM=", "FGzal9Qf6ji8Y8lVFEplIj1PVlLFG+4WDa27xoElJxc=", "FczLKR47dWc7qo0sSEbuVtoz3bSXZhdgxL8Z1SUD7C4=", "DbVgxek+zRMbeyakt3fCgjTJ0VWIzF5fIASID17XbZg=", "J3CR9NaMTbwbi5NXDMJJlz6JL0jbPDVqllgWojsoaEE=", "IwwIeLjmcGcvI1mLdxfO8bcipEjZ0U4EuB73IucrtQU=", "HXquPNjdP5HifKtvFbopdP2/cngoJfmUBaUME6AERGo=", "LIfkuBFzzo/ZnJvfLwxL054yRdhMvYnXnY6fp96WNYk=", "KzE3s6dk1fNgQjLMF90uirltRqffnmhBm058GOv9Wo4=", "HZLRAvT0MNDhiUi5cBtUTlQT0LW7HgVu4mchZb9SRZ0=", "C/90ygTmVouP62oDSUMRM510kKddBzNoJCeE6nHwUg8=", "EE+zqn/ID3zTVqlkAbQVqrkcQHdCb7CI8qqXKCL5eG8=", "IdXFMn+cCsZut9qHunpjok5H2OA+tJgXq58QcNhk9gM=", "Lym+soEg2b3E4UeUbPfMJgu7vl6mQh19O62Zr587FuQ=", "FmHZ06uY5yBLI1XgV2jWz0Nn8w8URtjLV1dscdj4PLM=", "K0BvK58TWF4OXkTbUhCt1pfL0/C1IySaIe1jSUCXvPM=", "CdUHtQByZQsP/Fw2pjo1loBjdHvXCmVcnw4HtYrkqIE=", "F+ONt2fP99+vyBPptnc+ddnxJX6L/sHqnoMp6AqHp9E=", "IbXBEpK6wmYnmOYJjQrQ8p+ObYJq317hM8IVBM4Kssg=", "A15HOGEgr2ZsMtfE/IcFKzDvGM/CsGGTfpNbCQMTT9w=", "BPmB06mEyi2F+VgdenT4WbYcPgE21sRQ0XdoyhmHypY=", "DCojRX9ZCxJq9qTFTRragQEh9MtJddiVbYRM/+Clulw=", "G1yhTNl229EOdrEre/vCilSsiv22aWOd1MX2n5HoqdM=", "GD9o0andcGEJqJNvqtgTqJzz2Ec8zcd7POKTM7eqeqk=", "BqX5XZi1Vz31KnzyCw4zNmgNtet4MxlOgqkuvMarA+g=", "IUA7JV0SVsDHNs7sUvIkxrdj+LbXIwspW0oU6Qge9rg=", "Lw1uWZKwIebEgG4HhJTZhTNaRL0EPCfsj7liEMczpsI=", "J2YTf+3WAT2G2ck9PY4F+fdDSqLbgNRENx/+yo1UYbE=", "BykqHcivyUhS3eS7UT6pOAlu/hzMC2D1O68DHmTOeus=", "D2T0oCjjQZ5FE4DE/b3OWwP/QDWSB/W7EZwpU0M9UtM=", "HCs8YHLzRMeuy9s4jaoYRj6rXLWUPSxXr++rUYJLN+o=", "Es3KV7lMiqbCFHA9XEVt/IgVlAHn9m0UgbAPNt2Dhto=", "I/UFzpM/oKdIZmT7AOXKVLaFII37SZndNG5PJqaXuAc=", "GoS7gt7WJVxu3jdYXk4o/nh9IIRN8wlP0DyCxvLMC5c=", "EKZlW++sVESM0uDn5SpWwXjT/mcLEcWLFhCft1n079I=", "GiZVbVFRlawo+IN2jz6meQTsI/dCzlRPui+FQxO74U8=", "I6ju8IeRbx7T3wf3pg2c4sKhltTpxCMdDpvBbNDjiF8=", "EJ5Zy7pwDiLuL6C4UQXlKDPHxwvG0ekYgTqiQhoYjj8=", "FjlSjasd0fDplFtjt5JG0+hywLG/Y3o7aA2YaJ2Zd1k=", "IxPo0zHPLjQuEy0qdezg5xKvrYsLsyGF2RsCSTyHZ5Y=", "A+lqA3Yq2Cc/sFgYqyjPrWJqssOwFGX4yXO0J18lhfY=", "DjGGN7fxU2bERSbTrjwNM72hLClKSHaYjCjQmn92CLc=", "EqHx3DV96i2kzWpjJc0lQiiXNhF9lHs78C0yBFCFNU8=", "EXN0tYb0aSsWgvjQJunsczKkP3sJKbvVFUPiGzMD3mg=", "K6/Xv8IE2eVbilO1ZB5HbuX8URPWMXNre/qjSeYY3CQ=", "CNB1yEukjPNZeboBLDeavViCfxu1YhVbGbyloJ7QviQ=", "KweFRDotXe7mbu6is/irMX3TeiNY0YXb663VozZnYkM=", "CvIoZQqljikbGbURIlwfDcEcXJgtm5rlej4OrVJmes8=", "C05+NFTyuSF2mGMv0x2VpQEmOURTyJtpRSUPjTbs4KM=", "Dl8nbBQ/7pEBOOFxFb7PRYdYzpu4EtmGx6ibKXWBrHk=", "JBNB+EqOMWKVkuPCpaM/Wo+FP2EN84hCuAln9U6z0wo=", "IGBjANiwZD9sDLS0r9ttNQPv7bI9aTscNwXL5Gwn/GI=", "C6yZ21YxDn3ylnYIZlAr72/s1MkMF+5dwTpwTRcVliI=", "IXGzw0ii3xU/JnaOIGEUsMSWjDyZ6PuefV0GlgY5j4M=", "Bf6ZRc6nHrgCIm/myjg1frc+hqdvqy9m2Il2yCJBn8A=", "BDq8LzWXFqQdbFZhlQ+jGtEc7Q7/Gt4C1DryPd6QO+0=", "Kh1Nm9Fk1LPbzMd1kbaQ/H+nsH4J+lsnCYhwYuRKk8M=", "LxS0qe/0GSlqZFcWtAIstvw6jzyXzwd/pgFAzcQ71KU=", "CGUWgkjHsYqps4x2d00YCUna6i1kf84Pg53110nYVIs=", "JhI6DqOTRQ9v6mf3wRrNY4SO/QLQc4DjZMzK6aZUjU4=", "IsY3/ykHq6Fcz9P3e+Eu1o/DL4vpZpjtdnPogbcS1Do=", "EX/e8HxZ75yadwdWAnEEcw7p5rQ5h0U5OAShdiaLiiI=", "BwFTyWsUjMQA+VU5ZTZvYyrJI/ot3fadO2u+UDzpYpY=", "HoTHmB7nqP0/fyBQw2TpIfsxCgdaOugXwAp3+HO8kBE=", "BmH/DN5uWBZg9fw6GBsANTvQusqAFtb3X8omlQirjUE=", "Fb7aXR65S+5pbvhtAoPd/mk4f78MDtdfhR61XJyXICo=", "FEIHh4PEJhb1TZMn9dQ9ZZcT4sOWDtpFLcuJ7D5QM1k=", "AmBnBTbOfmTNMcl7I9W5bElPk/s7HAqdGrfeTd2uh5Y=", "IDiQI18gn9TItm4wiocC6WTFLC8CGOur4dsRTmpxCBc=", "AN5FfT/JphiNXpNmedqGBqEUzlRRP9Ed6oSX1V3QhE0=", "CCXyxC3yymkn72eVNr3Q2BOvMHClkWslnqzn8hQ47kw=", "L9Wxb4nf6+swhBYyuYkPalaByqZiLVzE/p0+yMelQwY=", "EC/cQWe/tKKuTtc4hk5bXB87+7RvXAypJqeRv76ZHJM=", "D9uu4KmqSWSb6YdJXPc5L0hXoEqtKf8lZJ4BI6UTzYw=", "CVn4RwmqCzhbfYklktG24Xe9ioOY/8a/B6ObfAxIowo=", "KYZoIGRG6S5H1BFE4vTF0A7vwD2iCgoqMD5XUMzG77k=", "GnmAgdiKueC9rAMnArRIYIc4PV/3XA1o0fi5uY6UUvQ=", "I+lHEVlOfkxnHfkPJg7PY3cKdjUs319HHdwx6OAGSiQ=", "Le3mmkQGSf4XMiuLzPTBzoS34FG7gumbgUB+vtuscCg=", "A0ditE5Hu6/Vrj1/gXPSqgwdoXKRNwvC+EZZtMgPSDs=", "HqRCsFRbpiQ9kuqXWaI9cyhd2Zhz6MNlfmoAajznzCU=", "L1MDhDLuFMdSIoE/M4DwLqSW13y5vc2tPTyF7PnpOn8=", "Gdff8piCWTf7fEwX0j1TEZrpbtPjl7HfcYD9MERhtQs=", "HnH/5uUWtXtIIvU38DZCsjIB5C5bDMIjlzMGetiQI8I=", "HcRtQ8KnFdVl356UhfPf6Si9U/h5XIsDoYYnc6fPZ88=", "L1Rp25XLjNdSpoPk0ocICcGr6y+EFg/yFkgVH3s/AYg=", "JzncwuSPttsAKi8Nck9SzRcAN0gW5ZIQRXXtQi+ixsg=", "L8VlWtrPv4ED/FjIy14Q3TDpM+z7oiY7CHph84aKSk8=", "EP+ERJb9WpKWVjD1pdUfZ+W242pksrUcKL9MfKtAOr0=", "CbMq2MHhDDHpJk7s7v1hnoEp2cMFMD6O1NwM21IqbvM=", "KdsVDTZ6UyPDUkdLtV8jVyCUPf1s+WjDS3P6yfvXeCI=", "IF5EtUC9NXqoMR82x5Lp3VAKOkneTjZ+uIW79ohitWs=", "HWtn23+LcgCoL/uyvSaxjb2WpTvYPFtCZO25BdhD/u0=", "JTZ3VBOJNwvUIz+AZ6eKadbp5Zb1nigml4N8wUFdmJ8=", "GQhCkj64DysiDPFeP4JF5KN4bvJYT+YLw+Rco06kOAI=", "DyXe1jHwFvkUSP56otDRPdQPmXIsUICF4xSHdIkedWM=", "EWNzgJixx4e27NoGkvJ3202veHLv/oqexSMNjZiLe7Q=", "EWAPDtPrcR3G09mg2W9Lo8ojmb+SSXhu9zkAybNOEbQ=", "HI2/VUfVUeMad6UCseBYk0Gi+5Xa7YHFAo/vTozBas8=", "LkpcGlV4e9wEa+5w9Jifj5Nd5Y76SJDYE4VWMdq8lIQ=", "HWA1wBC7rDvMRUk6zvfN9Abi6HbusyqIUfYgnDhaeMI=", "HWtvucLxh7Hsg3OhjQd9NWPcHkgpxz28ZWNArgxhsso=", "KEgMpiXuAkdUF/v0/GUTWbA031W1bcYuzrmnm9vO25Y=", "DABO2cUJ/Xfw+YQfOfT+Ea0Zknfa8MQ1nwArx42XTxQ=", "IZuVeY2bLtLSMHMsuvTKV7fQQHQxnXGnOfyptMCDvd4=", "FE8UcsPHpjndrmEbLrW+Iu5t8lqFmgUpLKgwf4YYw/M=", "KmiBd+llRcuR+c+7RKehSyQ3Z4EJfpVhMUzO7BbHi3s=", "JMiY4DLzPX4HSKVEFgIGJYyXhlvlSJiWyXkKzOklHhk=", "EKvh4N8Kq5bV1zcEBouSHswdz/eNYFoTcnzp3YsOrug=", "LoCuOeyhdw3KNad6SKmRtt7b9UkkYYdW3wZNSzPytlg=", "FeOej4pMf4kNDMcH4oppatad9bSPo3t0BJtQeRoiwnI=", "LV56Nv5osYRVK7xFK+tHapbHqF/SGWqpVyIIosAqVjI=", "FDnwQLTJB8UILTMKtDneR7S5nxF5ukasIBElBqgrwUo=", "LsmWskegqMFoLR0JAPBJ1w7QsB4WnnXsJ9dpoWDgbEM=", "ASQXEJb8taql0eeTxThnE0/xpJxqkPJSFgHE4HvDSVw=", "JT6iaeRJm8sKFAuQz3HN+SSEPTXrKG3AMFlkf3YRofU=", "CDxPqzwgV3Ij+sbzX47Vm/42pHAtpRSRSCm8Gtl5IXs=", "IoT1Rgd/MVQvcWVqRU0IvYXggNtOzMREkPiN2J0ZHEE=", "LP5R5BTV2Uw+KkY1jGsfterXesFM96b1O0YKcFioOTw=", "GoX+zjsnq1JB4qcgMu1ucSJBS77pD7QHIQEa6zDpRPc=", "EIKaqFtkB4qE1LiyFz4MrMPPH147jx4UiMG0FrvcuOY=", "BHXefYjd6UQhiS2MSGg0AkMcysQS781W/tAbzdo5xdQ=", "AugmRHj6YSlBGTNn2gGFf3kbN34gg7NhOlskPPOOZfk=", "E0lqQ90c+XSWUXCi2Bu0gNcWHVi1Fw9fE06+chAp7ws=", "JZqB6STtRsVEHtxaWnXmwgf3PDQ+aFDXrvmDm/mGmDI=", "AtLe0+WOuEPrOaM0SCkUP1Btz550reO5fy8Nxdl3kU4=", "Bl/no879fcd1vZbTHnWGGd3Dcd82I3DqyYWZdkvMvHE=", "Cc6Va1hMrqUcW1ejPRN3O3H/A8MfrpvBSal+KBVUz4E=", "HBNbgFXydza0yJygnMtyo3KU4GGUusxU3q6pRJrBfFg="],
      M: [["BFI78ajyhMbZWzEN7CtU4OAOWbVx3Z1GtiAcGOG1bf4=", "Gakqxgh6uJmC/lZQ5eeZ+RAD/YtFQAdI0sJeQPBMV40=", "MCYI11DxZJHfWihfX39qXOa1VPXazwtp1FCyS7tJZ9c=", "Gjx9qmtK9WYtDYQHsodnTYPq5bdWNAX0je9JmByYxCQ=", "LbHJhVrCmsxnk2fb9w8I2YiUB33yQR+R72jdkBd8Hps=", "DwbuR1WPGC2BC7yyFKJdp/cKVnoEZLNI4bMOyn3pnSc=", "IWbXjZSNr6ljOBzxVg0AvzoKHCiKdDNEyGQ6WNr4y7M=", "KSm+m/4/k800/OrmZdlrHeGvsmvK7qL07cRUxQy8RAE=", "EHbUOcZ5l8N8bB/amjfcL3Yt1XeUbzb8/czXiY7GfNQ=", "GFya0NqHz4JGJNAr7DukZlgioPazsl3v86/MaHzhMh0=", "JwKxvjnpEET7c5JsEQRxn0wDeqQVGCPOqyTwzsSfRkg=", "CvcaUc1GO5+u2pOAPNwDGGx3gYRSUv304BVXCdk903U=", "KGZ/nHMyBz4pPIC5jt/64Br09ntMUqtF5J24sw8YLSg=", "J2PDP1ste8OiMECvvNr5mLsTJUwnKl+GNaEmBqWcLlw=", "D4Go2OCHWOijKqgpJmbEy2uj9fBsTc9PxQL/l/A6haY="], ["ETrYtGw+7CDJlltaey6KUVKYcdBAG03m9j3p5SEWI+I=", "B5MM1SVvird6uSsIu7WxlaRKI4LGbidRRhnvuU5kkRA=", "KPgUS9rhuQTq1ws7cseUMDfea0hJDv0xd3g1lO3Si58=", "JHT1Q9Hy8zte8/uxkGURNaWTkMijZh+uLfHT8UQytgg=", "IXFahHQsAtBXrEH3Q7Fm2gIyKEJWgZUO36/4WBIBoJc=", "HvDgwfC19nZExIb+zwIjjLf0+mOggqPAMNrdzmWkuCo=", "J46NrIxWsooj26TZD7qR65R/UJLUp6nseAL2F3hIjoc=", "D68zhD5nM0N+mJleb3v6b+76c9dBDYWFkYw0fzz+kqU=", "K6Q31q5sWIxrcVBsi1CDR+Y0tlzuMXrx+7nMKpl/wAY=", "JKbBkZ+Uq6nbmKWvOP6qU5HNp5+d6/rxGGcNeSfkHbA=", "BNgOfvfieisTl2eKxCq8xuJmLIgFA+RkP9+6zmcnO5I=", "F/ajrtsABamwoljjG45uKkjz+VUc72gSpJB1rruHhfU=", "HmICkSlJLIvfhRSUWVBoE2FZGp9e7cJEnl8inIW7l9s=", "FrrndIZ2VuZPyV88JJ+AHxUP1+4o0ZW62erkN0OHUng=", "EPAXJ5m+I6j8PxVq37bFErpBXjUWe1Y797GG/RKkHlc="], ["H8UKFtvfocO5kDj0f4GhxdHvbnsiHUzMpughIgEw4AA=", "LY09kk8olxmeOOr7x+EB0X1+VjSIqfMZgGB5auhMGwg=", "Kqmq5izbhSSQxlD/nifJsz1M1AIMpm9eGms3TmYpNbw=", "GEimDvyJllBzuVdz9GdmZofjjVm+II6Dd9MZA5IQV+Q=", "DIk4CBA1SdIDDL/gAE6mZV4k7nGh+MHwctXPbheuJJk=", "CtgHGMbp0cZ7Sje54QPbMvIl/kKpumVf8GVhi4e4Kuo=", "Ag2HR28SQ/SQJG+Ic27l/W0zGR8FYScUh+lpP8/Xpkk=", "E0uGZC/yAjiPT+NzVspPDsOAVWa31NQS2JN6NZ75tAE=", "LASHi0y4FW6Zg9EVdO2Z3HVi0/uxh4JXq7xohS/dJoA=", "F4OkUhWAWt6dNZIyEgsYPbVLQ/mn6PuNzZW6m7q7ulk=", "D8ljAuhmLeI8xcjCKKyKwtzb/EiKWfTdQePycJX34ZU=", "JLIuXOZxznnf+N4W180r1jddfsqgFuz1nP6yRtrIByA=", "BSwz/OCNSjn9gFFWyK/7hDSUKLpJIM/S55At3PmwVX8=", "APDUdSJcmXAruk/QEnYQK1yr/3vU0UfA483uTAesMbE=", "EYPpG3q3Ny8VfUxHdpHur/yeiGP7LYBlcMZ/SxhY/FQ="], ["EhSp1tcoj+hWUajLgwSMdmnIO17YLKJkL/8B6FKkS0o=", "HA3iv+r84WTJg4BnqN9jQPnZft8BIjMxWbcU9Fw/E7E=", "HjlNgAZ/DhC6qV3g2ZtOOSBKGHJ9FAG0duyXa18XOoI=", "LKLYsKeT2Q7TGM219pcZMTcVW8+5Qtgr71WL5fqzWb0=", "KEJ6sAemjHqxI3HxO9fboKz36X6m5krlLVIZIQ/oorA=", "LP/DeNLOx2unCAs3/GcaljKLzfxGMPzC8hM9zynHDdE=", "AM/KodfTguH+H8uVDhTfICoIeT1xhSVbAl1WLrjZdUQ=", "HYckxeZB2W9uNydxsKd2u3Qv08COGuJQQyJGzTvQG94=", "D+6PlzE5eXQQCDRknuh6J6ySvno4EDA0YBQar7VCpCk=", "EW8jmr6CBze14egrKs46Rc76xImmv/CE4yMDb1QncQg=", "KjHK25GNeLltzVSLOUQlpC4qp6KKa2PlCSYb+ub6JbM=", "JAyvbXqy97arPRXvzzB09bIUKh6ATyUBLZiEVICeCWw=", "IiTIXwwLQJMBTbHoF9H/FpGPFeDNIxuEikjPgzJMQUQ=", "ADmiiJUaA4HjqvWY7xMoU7XWlHFsINuHkj8LzxTJFKg=", "F2INQ4SZ9sCma7V3rdTK3WatOeM3fTAr+D07uhJrKso="], ["DUIafCWvVTh4j0lHWDZxKvXaFW+IxYZ1aM2VjjBQJsw=", "IOSigwPdVeXO4zLzDuuvvXky57NTHZQkVMNEuLjBfN4=", "IL0CjJWNV7eeNSGP405Gnr2qjo5xTpGNWBkfZQRrlyo=", "Bu2YoYW7I1jzNOsleuXjGDWZwFTBtOICJWm4No2hq8g=", "BR3rSyNIkOMfWsjmmh5TJFN3Suk6npNg/gCe03eunDY=", "IfH2pjBHHjKouaxLftSwTFa5anHuIKZqVFjGuNXG00Y=", "DDnb325tJKkaCkX5IsiUviUrqhJ9msdpCfhtwLzGimY=", "MFYUqs39QWfNG/3Y/N7OaJLYTUpl6G5vfGNJ+3Xki5Y=", "DvmuZeuSJgXUJgqyAh37tHdM1f+u3Bt53GgSCL5vhcU=", "GtzLiY5f4YtcKaRwjEsRK1bQ+l0pm17cB9b1vABCi4s=", "GKJmHAOrmw2PfQEJHH5WPvwDMZZ0fjQTnT9cx6wAHpo=", "D4rux0FE0Ao8o4v/ELsPOo2/9K9hl4R9uHl0WutXteo=", "H1NRSpfotXIE5XvWsbHZVV87UDaBVBVOZ8ITT9MVFZE=", "J7zWOcR0gtLci20T2hn7jWPz1sh19v6khtpv8u4R4Qc=", "Dp6DcxFK0lr5fSjicvxC2EkDc8q1ghk7h0oQQo7mzSE="], ["Lei6g9K2q2pxH7kjCt7hy6Rt6MkwyG0masuMHLloTiQ=", "G7Fe5NSSqOLPGxDbG3OMZ4AGbqg0er5TY1enI/bPV74=", "J/ohIEMTecvYYgX/EU803S284T4cKgqORqHcJ+e2hv0=", "GrUnYUo3wv+wDA+tNgq6pEesEGP7n8ZW0BSM3OLXw3I=", "FwzuKYP6PT7O8vgG9A7tjY4TXO/wdvxTC7/uh2yefx4=", "KIhRdw8aE4IiUdqRyE4SNZP64cnLzmxP8jF+cLtlggk=", "F5U4TpG6+lVN7fUVbNeZ4RIQ/9Kv6Be1xjrVuF5/3QY=", "LNomRzz9zRhbooz9qhXn3iNZZGoCh+votg1wLfAJAQw=", "J6tLQJAUZe9ZAHEU7PH7+rYVfCT0AiRrhqYDlyZzCPM=", "JxIngd97sF9q6eFOjpnaXCPcd8wGEIwOuwYeXRvpNiY=", "JoEqzQPbNBLK1Luhrvcb1EsAlNMYrOA2bHnnKf8OsuY=", "IT0p1OG2wB/A0QnqYWlJAHbRMdjgNLMED3vZw8Nz6hc=", "ITL3GsiYksmEoKc2U/LUUiKto0GBqebbzqDWOWH5NPM=", "EhOVAjkx9rs+8otgY+t6LteDngg/25LB5Vk8g+3/X1M=", "H2Zboz2kq52YBsr/d87TnJviVPzExdqPVwCWER+xCbU="], ["Dqe+gvHLSTsbvYOrfKKFvwoVWeoFw/WYJ7OwE9CpH7I=", "LM8xpXJBK7fZz6Y3cHhTIX59tVULHMMKiUzfSDo7Y+M=", "BWRlG8EXkXDjyXr7xPSTYXAXtDshPu7Ya5sb/+Uh/oY=", "C8dpzXs0/NG0VKv/DAC4m1QKYZuHyVREZ5w6xr6E1FA=", "JEtrY/gEGll19GQLGMfQZ+SgYn8YdR3JBgFriJPDUSM=", "L/TuEQ7hvmLicV3NEZyVuVQTN26I7D3cPwb8nbjCepQ=", "JmbsGmfap76wV6oObooQOWYBohiENyNpwBK0mq+EkEk=", "KwZmlx/ZEVKecO+RjQGfRLXJ13RCttGGb252gy1HiEc=", "K7W/A875M+Tuh/UR3jmFz/AyOre3GNTLyj9Cmt2/MFI=", "LjenRA51tkmgeZz/63+drjj638fKtsVYXkqE9DdynQI=", "AANx8NSTRt8tiLnxraismd2BJc+mww83OPuZMqhTJo4=", "DQMntZMELeBPWOD/kzhtFgjTOoaHLB0+fgiRIKrHpP8=", "BNvEyN5wjlmqSyEW5TlEvsl+1CMJtKGEVh2PMtKR+cE=", "KQ7ZrnR5+b4TrxP5i/iFB+b98BhxDkhZ/S5IzGb/myQ=", "E1qjgzm9kn3VBk5NVy31WBGyJrq1SwrK7lEdYK7bAvo="], ["Hjrn5XddNSZR1xPr386/nKjpBc+3kr94dCOUUPkUyMU=", "AdSSw0skW8EpQbsWPFEYv8+FvE80QEKyAx7YZiofb/o=", "BzM8vQ/xPIreH+vnKJLZrUNce0UapyqMBacII5WIKGU=", "Ka1SNv+7WYovjSOHA2CNt6SXp0U++dV5+/Bb44+PdvE=", "LnKxsRTf7n6NfwFhJVxolfp4YHDOYtgGxFoi19mKCjA=", "KtNpqEtX90VboxBkABynd50rS5awtKkfFWq+w2aqt4Y=", "FXk/McrqOd4xXcW/WjZirV2OGhL6GnKA8u+q2vqXrfQ=", "BWxV31Q6jUBDoS9AnNLEvPQ6dw8+OMP8ea0hS0Lag0w=", "HuEOKMYS2dbucvEnSFDD6Cm+XAb1uykygBUqVhDrAeM=", "KfNW3Ow7eVI8BYmnBG7wdYSGgoshIUbD9c6YevP9cZ4=", "J86pxD/gvxzp5TwMAm6DnYCn2GkTZgMQLN32PN8ouXU=", "C9wHix7dnLH9LCoBqXvffUWGSEOfrB8oUJtBotyed0A=", "JWWhemvFboewtjZkMZuKR79mLB9J4uySUb5P3zPZD08=", "FbCFtetnj4zt8hv7MOLWSuHL3XRyRJ7STmA0EBxliGg=", "IryWy+f4y8qBspun34SN1lmQNf9RW21IVVCELho1ocI="], ["BZQ+NhijLPBQAYpOI3X00Ce4wUrIKg3lfLuQxRIqZLQ=", "HJtcLAf8z9ncazq/4FZ1/Jl+t7jL2Ni0y35nFhWw7M4=", "KQp65zL0dU4MuRkjySSJcZMmB74ugpFj8RYS/4qVWxA=", "FDTs4gnUkSgMWuBdfibPktmbtyiaXBysCaOM5TtuA98=", "Io5zmbDgWAKFK91dXgmWbwPEw6/1PGg+svaeD8whwLs=", "JPD6FU/MbWRZ1sVvcR8l441X6QvnuARsngAYFe20FAQ=", "GIAL2heomDL+pU8mdB2Gxrb7nhWwLnvQZVM8tWYdKpU=", "FrEfJFAqpMw7DCVioYokq4+YZDGyRANNP8KVVUArX0o=", "AgqdV1/qiRMCsQZDmrA6ipUdiy7ytWKZGUbrJUHx+60=", "D5wF9gmtFN6+r/EHuVrM1g5iZiJZkFEFq/r6no4I6uo=", "CV8dtDyCfm8LnNT+kp57jHjJP9AuyeDxCZL+t1O0ygc=", "JrwA2c0lEkRCgy2Xq9kIZtP6ekAb84vZX6etUmVI/qI=", "Fz6AWWdWzZruBL1t2dwV5Ljrv+/jdx2YGb1NREcm950=", "EqZD9KMnrNJFRRTdRpVR42qw4/JOzDsop23B84IU/jg=", "EeGwr39fyfBJh3FUrhc6GnLHvDuhkuQ4qdD6gf36SQA="], ["BgN1UYD2bpghXWHlNGsRbMAM/QWCdNfZabOvleeLszU=", "AkOTC6Ad/TlF8qoC1YiSK0fBvvL/gCOoSbTKZqG/6Ys=", "HrUg/qxi5FRfT+fNtnXjZHS4sf0Z4V18c6Kx37sj/tc=", "JV373zBVNBOh+PURPWDphYODjRPhHB7gKyWjh+oAzM8=", "GEURMlgbmt+ZbGyuFbktLkwJ/cfWwntEJvMrXmagtyM=", "ByIcrTnZtfjbcFqHIwOLkra6+HKEExc16vvs1TPdptE=", "FW9qCeaoHY7s9NvyFka7loskBnhs0d7dTMcyt1Mvf+A=", "GOoO3pAQx78PrDYbW45/l8de2ToTp61KAX2SDAPJhoY=", "C3MRnJjSXrbeFCRrFAG+9IXJ3GrM7cI0lLlSajnVMiE=", "HGaChVLKwUQzNO1wt/1/tSX5B6tkR50ReGTJLpEZhsY=", "EKZiaN2aLzaOlVB+/CCF7u7ozpd8oe/1suPZS8NC/1g=", "HxSqtaWa1FLPaSsSPGWHPdgP/BiHmKRXDsp5Kz8vJX4=", "AdNGVbV3biRwFiGstBMkystQFl4Bm/8eZfmDBPfYIqY=", "FqHu276nnFQRpjnjvw6Q9uP3QPFBWZr45qQ6IGlXL5U=", "FN5Ei+y6bKCtshsHRV0sKGTHuFOCJnAm4o8JeIItZaw="], ["GYF9tm/bghXs9wR2xARMP0HXisWlScaE41hFlH3KCxE=", "CPMo5eZsC4ebNsIz9Zi9hXjRji2p8BnwQRcxUk9C2Qs=", "JZoqHwRoRHJM+ZKu3CY19mgPVeig/axpXs0F+8LLvRk=", "Bn2SlLQHKxLDaMKBalO7Frfn4qeZeaQW8tAq+GKr7fs=", "Dh1+wqVLEbNuZddVHpqHWojMx6bARw58JuGZZwoIWbI=", "Fzs7NJ7oiNk0runBToic19eF0ePk8etypcLlbEj9VMk=", "KXdlihDebnkhq540vPB7vKYaclSa5X0MFWkb0UPU0t4=", "A5YJdzPeWh+kpUh0m3P/fEJvmNnlrRaSBhTTN4l/ax8=", "Kmbe/PSJwj7sUHmg7OHFNBAnpZ58WS52AYS4JtcNupw=", "EPQzaMBWf0Bapqr882fj5ovv+VfEsMuhfDDGKz+VSQw=", "JaKkPuYSZj29YYFPLesG7QBadBT5mCX4vmb1Qvlaey8=", "GC8ck8brKYZ7FVnFggemrq9Atm6q9XnKa9fKQKrrer0=", "BC7qYW2QUCUUekgutDajt1U1yYabdtbNrOEY4VyR+3c=", "Bc5/WS3KIUjhmFVP1k24xHnynSPx8W2vPLiTDZRW5MU=", "GESoHU+rV67btMRiji5H/LKSKIPqsLLh3hbySN5LuQI="], ["Bzll96m6jLM6lV1C2lX9fDej8CJrAp023LP76pXWQvM=", "KEovCD7jKmZjCByABxPg8jleNI3OzIn8gap1pdsroSs=", "CPeObcWc1GlMQau8oIZWmpCDyozIAL2RNOTUjtnYncM=", "KTyooGxfF52TgGXqR/gPZf8hlpqUKeQAqhd+z2tq6FM=", "Apto5lLerIGIJNoMKhG0CNeoOaLoV2xVv6XxM1/8W5M=", "Cbw+QL/l9hb71SDziUoP3Tf+spQp/TpQFZUxcd46cPk=", "KEGBCT5DQZeJJjc25USBcRH9y1WaQ3c/BRhmCKzFQuQ=", "C51aOpV+7yUa6cJuU0I/m+by78JLsYdWiTqdgOVqCCU=", "BKqOkdww+coxj+JHGP5ZWHH3iX6S1X8th9SxvPmmNeE=", "JToRxmRjptyv2Dmfyli6J/67wwfYgzxmbg2N8HLF9p8=", "Dk/UmHeMLHagLQ2R2PiYJYVucG9Zgzff6788ozOXlo8=", "Em7IwgAmLEXREzv52l8eX9YrzqHkk6CArxvSg6uG8SI=", "DPAwsQobQpHlduurs5xYP+oPpt7PqYz/epbcBst32lE=", "EQKY/n8rz9rAvNw6/+60Ntezo3dFOud4+r03qayymac=", "Du8E8kriEO4KlLxWIVdHg+SdTZM2Wis90Gn6/UMFVFI="], ["CaVQQxQwhGtmlBJbVkKwBgfzahopSFNho89Cfad+zNA=", "GXcug4FvwsSblkJ8atBXM0f6SaXfaRJSWSrrw5AFWjU=", "LY7Gra06ZGhDyIzaAShfjzLSnGsQJctUIUIr+L26f84=", "JVuWJY3I4WRPG8rs7nc2MvJabqgDzTKh4B+CVzd19vw=", "GG4TYAQRk+EvOAmbDjXnZ6/8NBD2qN/Om8dVZ+ObxAI=", "Kcsx4a/vTyUleKq9dvI6EyCqyQ1KCmbCIl49lMxI0i8=", "IA+iDtG4cTE5AMAfi2l3YNAw2MwBUP3FjgSg2KKzRLE=", "GmOlidFxCqcFE2y1IMLxxE13jkkMIS1LcunxU45VVc8=", "EzNps7zHPueT6Gk2DNUNjfYP45jtnZwNDQPmafeW6H8=", "HplRbCQNQryqrZxz8hpGGT24QzNJIDA17qMDmPnfeJM=", "E9hMp/NYqv+x7o666Bwy4BrcAekNCclFGvNuMa+CFw4=", "BaeEZKS2u8pultg5gnv926qdkkhArvZVXeZD3xZ9TKo=", "Jg7xOsfoD9LbPenrlC7e7z9eJS1MBFCLHhsTAZGtDfY=", "FIKfCdS+675vwwVFBHJD+z2rmcYqq3Nkp6W0J0V6AsA=", "EyhGfIe6cwKJIaiTM7q5f4sk/Kpy9Dg3y8/l37epRf4="], ["Bo606dbgpYi2GmrVAfOA2g8AkGdmbAhT0VbjPVnENRU=", "LcWQADnUyFI6w3mUXLm1ilTgHbrNZ/DEuu6F01PT/pc=", "G3KsQ3TpW3t9KM0pCVB/MAboNS1K8Z5HsLkJaCoDIA4=", "HyqNyv55/Q6iK7FWPDsosjxcTXWR1F4GdEs7N51CZhg=", "GSlN0i2mc0cDd9Zx+r30LOzTfsvAGDhqQ4cG1hBrBKg=", "GTK8a7SItzbg1L8wbUHmIuZsHWhapFmBUwVLQPdcCwA=", "CNHWi4Q3vJgKp8Wdgzk7FioIJ950Bw0tNLTq7cF+fmA=", "HANDgWuM7LpIUZtZsPttSputMJ7jgxHcPoz+i611378=", "BwnquWzGJV8q6ReRTyUIUCVJDEIyhJFuI7YIY4zM4pw=", "DGegazPPc4grHHFS1FhbeCI9hcd83cLH01lIJMUBZWU=", "B0DB6bjtFun64gQ2nFVM+3IAfcz9JTDy401UQAOuWZQ=", "AqhMQk61j5w4tDgK844EWEaJgJiPqh8NTG5yOEVnhSM=", "C8Nn/ZPOrLWZxhSqKAaHg6XSfuwfyPoXZQFbdt2C9c8=", "Ani1hQPguQFBBPjERr7Uxt5XXHLU3Z2z0YZoRpeaq5s=", "B5HYMul2tmvar/RQcx/zXZmFlauXSPaVu0XSwP7waTA="], ["Il4AoNpaf3SWtw0JI6fPf/Myv/BpWMwPP61DmHT2Ak0=", "DMN4tE5Y9mi0WDL9q0pJNycx7yQVw39Atd7VWUrvPMo=", "DX2Cc94je6LU1egFHFvV4xLSmLZyb/vTr35zKvkd/yc=", "IuvgoxXge+SwkoiF9SRJsBGzln5RnkOMQkzAQow1cm8=", "Au088CFPRE1DZlXgOviu4rTZaWHuoG6BM71ujT44I08=", "DLb6Cl4RuRkqUZBJOdRaBa+AVb3qPzefqsKdEwmDDoU=", "A5WYoUQ8AJZ4YCuN00dPJ22l1iQlCD7GKKFzfozKPnw=", "GvVuZXUSP5nF16t7g3cPD9YPufQDjClCZEBp48JDeT0=", "Do2cBwfcW/gKLwjDQ8acxlne+GYwrzFBoAOss9PpDAg=", "H23Y6F01l7ttN7R6HwYxIgFMiIJQs4z46C4+VHHvhKk=", "DMj5C6to5t6EhF2hiZv8UkQL3duUCyCDAa6UqVd3y3I=", "DA3PKxNVLsVclxZr40fKL5OwfioQFkCW01P6KAx5aCE=", "AB8SYRepSd/5APpdERoM4mYb2dVERXfEkamVHPtYGS0=", "E49n+9nLke9SBtSMq7JprEK9NSzzceQzEbzK2JrMUJ4=", "EUkrpAZDXzViOQb/Rd8Rw577Wf/wn1AfuJPXF+NPnWE="]]
    };
    exports2.default = _default;
  }
});

// node_modules/@selfxyz/common/node_modules/poseidon-lite/poseidon14.js
var require_poseidon14 = __commonJS({
  "node_modules/@selfxyz/common/node_modules/poseidon-lite/poseidon14.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.poseidon14 = poseidon142;
    var _poseidon = _interopRequireDefault(require_poseidon());
    var _unstringify = _interopRequireDefault(require_unstringify());
    var _ = _interopRequireDefault(require__14());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var c = (0, _unstringify.default)(_.default);
    function poseidon142(inputs) {
      return (0, _poseidon.default)(inputs, c);
    }
  }
});

// node_modules/@selfxyz/common/node_modules/poseidon-lite/constants/15.js
var require__15 = __commonJS({
  "node_modules/@selfxyz/common/node_modules/poseidon-lite/constants/15.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _default = {
      C: ["EeJ9p7fvlklIozKXTQfM7qd4vDOu280J3iIvoirQsQE=", "H2A4G4O0So/mWg9BQvqq/F+/VfeRM8V0DFPwNqMGW2U=", "D8HhrIrTUk69v6RdzFFXZUgjTQKSrf4c1wpwahttrdg=", "CkB5jq06EreLzY8QuxXLDEJrvSKCqB3NwHAITOeLjXY=", "LcCdM1cFEVWYfqlVlENrbL85OwE19R4vZ16l9GL0qcU=", "EEuSQdU0JkUy7aGB3hoVTdF17hUPNJAz5G3cVBgdoIg=", "EnpiCNmPbNOHuAL6RMqyA3s7kfBiLxcITxuNisnRJpg=", "LQdc7rq1Q0HcAvsfUNk4zh39zeZZlVqTDsGPhiX4bU0=", "BE/VwhAaIL4q2SO+vhWkd/QMYDmj3Q10Q/5ydYBCAQw=", "KzAshRH703ArgVVkxTmay4qPKo63f5bH8ISWKOCfm8g=", "B8vjOduQWZRV0e3tHoqHC9MCySp5sdD07ociLM6Z4is=", "EyZ0kxLG6L1O8kyXyAn3iuVIOUyUw98vKP+oEF3r4hE=", "BUAhQGuNH4xwgOfCRTBOS3p5fNI22tktkpsiPyaXgOA=", "BcDgM7WJ+N2yOp1Vnq7s+YaRqNAY8Seb9AbQjyeHzEI=", "JQiozdRQ+Wm2HHSdVmyUWaFurUMw411UFbEuyjhYS7E=", "Jk3MwC5XTKfnNtolByvY++mQliH9T0Fpsrro02j/EtI=", "KpOMJUDWNhV2PsO6EMGiYAG59L8UGNEJKmsC3aUZXbM=", "JU83C4X1in5KsnpiA/OhYcGwcPqjGFuvKFKnWoZaQAw=", "BIAYlvEmjlq/g3EsdBTIlT1iI+UcRMstyrCynBSVKsg=", "H3GI5NT3VJQ39I/asi6HTnHQofGMMBBuPdJyH5naVh8=", "K5JzcBrgLXsjHORDrx2AvyHWWuphY1MzYFn3Ve3raKA=", "FZciTLjpBc7YKWIKrNz6x25Qmg97wYb7cGAZbbk3QsY=", "HYxaZSiDRpB8/VenUjchloQeYyPpaznaf9F6gsXhJxY=", "G3Xc6VBzH1CCUbhqfhpROZINK+wYeY1Dn1gVcMHcZjA=", "J3OgGGm/mtNZ1a2CCbM3EZ/43t36xuTtLI/QFY7o8qs=", "Gl1HiD8kRiYQy+etDpsbiuWTC9O51MHuAZhPYiZRW3w=", "GYJ3MgWUYeIHPNkKCa1UFJscpZCbligaR7LZw5hQbP0=", "KXyL9UsDpvf/JyRl+4gckYVRu+mEdR8+nysw6jexpPY=", "AfPaNrH/UoOweLafXzp9S6sVowh8Wuim3DB+unci5A4=", "FnztbjndO9bWVe3dKr5saP8kfYb5pqa8vUHJjTe08TI=", "CF0ZsOFvCsKfMtpUFEXoqKbbmnv0XnQfnxE+dSa4II8=", "BPNl9xDprNXBZTzG/Y6TyuKg02PxaX8++Cn3Q1Ul6k0=", "Eo1PA9A9cJfToiza72sR8ynK8PrLwaZ7qR/0k76cpxU=", "KAIQ3UEmixM8n653C3ma/9PmaAXGFnQVrKNuqgLbECE=", "IE7nx9TqBvfKZfqtYx5wPg49u1nEW1Hc7nOwymTUXMI=", "MEKv8JwXZbT9c2Wm3KDxFyZm/cDlSYIrA/c4jqwz14Y=", "I7eAd+dRYCvnd5BFhhzOOtMYZwu4LzPCk59m1BVUx/w=", "DzUeFL06Qa13A8+akGuteRpieZa5NRIebNw79xKSzsc=", "DmewE19x1IWWdJ+fqFhcN4lEECLUW1tGEaUHvUAdDuQ=", "BuhGNJZtRiu9aMFM5u4WYnaeQzFODrhePVkJ9RjanfM=", "F2ERLxXzV8+WQiu0Z5b1fCx9baQBabj1eUhB6FYfwCs=", "JDh6xXMTeZx3Vpmb+sSVuP43enOFUmyKyv4U5a/gOcc=", "HzyBfL+UMCoG41Jv6nsyGKKHoxKZ8N0WK2bTWM3PI3A=", "CxPPJcJy2uM58abzDUPUD3S8C5OO1zvxapXsw8SZb8k=", "LHMeYttMxBxWzUZcSl6NVxnLUK53NwRP5OqFlmWZfwI=", "CWG/6o+fKnCPOt/BJ/2xfr60pWMqgmTxeklMDwYBFWs=", "Hu+5n+nayakZY/ES3TV+1R9Zm5JU5b4sdf0BpY73E5o=", "Av+YY/oqbK494Rax1qpWqK+9k8cEF7igWThVof9XQSM=", "KWVfwDDwoPbdKwDKulJ5OP0P30HeibQuqhbuWY/QMfE=", "LZ/nRPK+rbmJhp/CBelIdpf1ZyG+scojC1m4LqsnsFA=", "BLTD9PHCHW84mEgoDm4AbAVSRRztv1q5be+/DCy575I=", "E6jz89DofVO56VlmKgaWOPvfB3AkVkvCpWdvAkfoQo4=", "GHXC6PQ9lmDhpVY4j9gXQe2n5IbPYkPC/hdS+RmFm38=", "DbepF/fvwdIWdySvTqMrH2pswjwdtav62QINuvW6U3E=", "AcVtt6gfx4uUsmfc5FpNukikKIuZ6r1Qsa3PEy3Up8M=", "HJy1pdAnTZ3DHKB3Q9HXtNQWgB2WQDmFHwVnjkvoKFM=", "AveG2/g72+xmq2VmlNU0iYi4JStPWj9KRSoHX2Df6So=", "GLl4mnpoGDrThOzwOEKfdYFFk8D+of0l8QAcO+xEiMQ=", "KOscNPdwq5ErVUgqlGvaqinfK0yUfCnOt8ihnjiIHWE=", "JunJ2qtiqfHWpMaUuwxv7CdHh6gyI0PAP5Xf5l7njoE=", "ARGXeFiHkUVnW6fx1w8wEpT+3bCoAs+pRKdZB6TC7RU=", "Fk80t8NWuf2hp9hBX6u2g7rGHucMI1c/pyqddWulLPM=", "FjIZylMis3dOdbHm91ZX4LvrdqnjI7fHiKfdZjiys6U=", "BEFZT1nGXRqFdrj7urQFjcOQAqG8Q1cIQZTOYyuWEbI=", "BMsAW01DkxycSrxQtjmo5uILPKWvtgsGFAyyS35KaR4=", "JetQIDyqwXw5nIPGdM/OtOc/InIoZH+dIg6V00NKBNI=", "CmBff+nja7dQRSNSUWnGaJzW0v0HbX3BEnfuEGkxZ3Y=", "CrL+IJud/HyQBySMt8o2tMFNmRqzuNBKFj6w6DakbFg=", "DhRZy1wK3W+Q+UmWVgMyCzE0VOZ0evXzmVZvXSNGEyY=", "BFrh3EqG0eyA3EQu3OloKmFtJudgE2dauwTMpF/OB6o=", "GDT0fBNpjLuRYFnLzIiXX+Fd0OnDMZhl4IFH5NOXqXA=", "IDmhxzNafkx6aUtcW04bRPYglg2Ikz7VI3Qi7VMYn1w=", "KhAxbx5mrPMuKtzcKSo1CgDY1eh+xdu2aUnj8DNQuz8=", "E2C5FBVFnaWEDt8UgmrqBSgflz3BgTPO5cvidhF2gko=", "FQXiVSZ9M2oIHbbwiol78rpA2s1OwdYamQz6pA9qX2s=", "A1DjAg6jDR53nZgToLZQl3rbGEJpHoo2TBK45Fj3fTM=", "Duu9TCsMmzK4LZbWSw0iGo29BkE7YHumn0udQswSyvs=", "FbLUs2HfSeNESiQE9wA+4EMUfKw9FChxHxIms3TYf4w=", "KcgzjFz+mN9/1J+TFrSVCBTd6dZlNe9iToksNdOAsY4=", "HXomJ/Va7ODMgbd1WAzN6V/RDxEvjqcaf43OfprHmOY=", "DNY0wnq0BgWKvaFWr0Vlct4vVJIAVYeu5px+XTRdde0=", "EwP9SOJlZWXnoWyo6FIxMUkwNalyHTVPxE17xZtyetw=", "BS9aQ4bqIvX/Bv/qYXnlhhe8kIo9xrHnRigZycnpBqs=", "B347xe0cNLo3AvwKQsRbpccUprDBC6K02MKnqnWVkpM=", "CNiBYIgvyK/KYESQTnqYT4XJnvz+FHussLfxBG+VPWU=", "HOOyLf+V+DTH5bYyYCnGvLTVrksZ72nEBBnRqteWoYk=", "DU/ZlNvMFSYt9fPAya3+wmg+Pv+/UG5TCdvYwrmIq44=", "K6a+XNea/3RiUR71o4pPjHjHT9BJ5rhlfNBE6Cq9lLM=", "CXZ6LZ36OeZ8lUAEANqWoZLab+XA8CzfG5w53I6Whko=", "AQUhxyP0fcX+/DW/4M5+M9LgRbKgGOEJNmLshPEEwF4=", "FE8JuANGzPvAhl+mTSINbbt7Pou/A2PmL9jMtFe94e0=", "H8C5ky90tNtW0JMVzGqOhiBSdso+OxJJY9roPbXta6o=", "B3bS2XKgBMBKi+e18vzrsC4aOxt4cDbjUUu4+XLINh4=", "Ih1uVg5U6ydmUSjzfhwxJSi+Sa867sydfFZ1XwdnWNY=", "FkGJzf2YM7ccH4Ny6Zm6J7vSDeYvllrUBtiu5nuI4fw=", "Hj5zbs+XRbSr9xpNhj2LbQNSPq+C2SdFJjk+EDsIo8s=", "H/PTCzKGuYj1AeySCxYi0qC6LPqd/FicU/Y503nBAFE=", "ClDZgk/MlanSK8CKWSsabTls02GUCrw/hzpyUjAIOn4=", "LbUKHha+Y7tj1C3lFonZkNLkchuToH7fuijyCJZXQO0=", "EoJZT/ICEuilgaIo+0QF8u59NERVZvyd6gEdibICu5I=", "Ct4nwHeVHNM1/3ibe01j/10Lzq7MRtzO/gaAwOxu8Js=", "JzdK3xs4rGLQePpOcTaSvjJMok8u5D4k62Ktzi8+Z+M=", "Lv91+jbocWybasCst42pKXDPespqDsOzfYbpdTgkLhE=", "GigiVYKh7dRkeEsR7H7/GQ+uM6YaeDuEUydkLoL65o4=", "DhET6B3hvPIE5RqMw/IABH89jYVwTET19axu6GLJ9Dk=", "IQV10g88KBa4BwdOcqZypQc47QxPoJtvlmIjkDpHn1w=", "IeiX90nISsL6/6niZKxhuYPwO/nzN726TcSMWXGhQ1E=", "GlaH3LusYpcq7YXFDnDL61AZPYMcB5Due7zefZc4pmo=", "BBBUmdXP6vEV/gpA10KEToBrEHKWswbE1VbS8kTklXc=", "GvlJenKA4UFJVugPTwcuLya1CgaHaWfN1Xrs5yDGvkg=", "Kg4tPuxiWbfOfg6xZn6O0MFs2/oiR7i8fjCO4y4sYDE=", "LXyYbT09O+jHAQXkhJIWDvhTifHjHbyIFLDNPoSsXtE=", "JR0SMedjl5I4t99KjA9QGScd5eQ4noTAnlpZbU4eIrs=", "JjuNwDrH0lP1y3uL2SKikGdbq+1jZK4Sz6H6uMVsN+w=", "B8WcMfl526kwuUyJfOcBbJ3fxSemlnhrfl4cGTiiwo8=", "AJ9H8CH6Zd5rVOdR3VpL+Re9dXTgcce7Mb8aTmOvIVA=", "HBYAQ9z/IzDORB1J8oBIMpafJzE4PlJMjnqYE/dB3e4=", "DFtolmh/Bmucsj8hsywmkJLNbHEdvma/3gmFhzXLg3w=", "I6y9f5KLvltyp+xELmaEyPDVDPgj8CgEx4UJM7m3DPA=", "DoroodEUHcB4KUE4R8qFcQXlGJpl35rEDq1Mr8Idfd8=", "LsoJifmrkW0HqylqAiT9o2oLx6Wr1XHzNoBU2neV4wI=", "LHbOt9BAtOWP4Gt7D+g+qIt7TPN2KWdx7BXRIjfNjyQ=", "DFOv0bOBFn1z0Uq3246kG5M1zsQZSxBaq34AYO4eMEQ=", "DDZilWKn3GfljMFb/c4jkrOhZzYC6XDxdM1saxRVUyI=", "BS1mthQlOt6PdAACdduFJfiMt6cbFN+diqTs8m9Mm9E=", "Dea6FAkEYFjYMg/Q6/n8UnX4N+5d7CeWPbQUUJ9gj5w=", "EJrgUkr8KxGH6Iwvo6FvY4hWi3+L28SzmfwAole8G0o=", "CxPl8skBtFTKSb7Cn/y12j4T/iN86G7e3BfaQLkEUFM=", "DJqYavKtWEg7VT6Vxou7O0WCnvbk56SrhfFyggnsBZs=", "AJOk4fxGuGohCJDnQaFP/kEknrCwAIJk6m3DGaBzXMo=", "Ab6n5So6yik3VJkj37fjX8349cgSJ2N7MBXtG6cSZXo=", "EeiNwLWQC9KVQvvCODLnSbyaq2NH8L+XzTo2xjCP1ZY=", "E4dB9ey/OVmX8h8hLnY2ZJHw9Y7BlSAPEDOFXOukMC0=", "JEcBKpRpJ6QkC0cT240n4TDkGd9Pu01ooeDxuV3TZtE=", "AnYZOngvbeW5A5RTceU0G55dys4EuXaOZ76YMKL2dNk=", "Dfm9aMT8MsjAZPbEfVF7E4iGd8mF0+8fHEn7iA3te8o=", "KQkcGGE5Y8bLpPTA3vUPzhyrZHqJAZV+4qVTBcKw+ME=", "C3j47MZXeWb+1H7mB+JfIbQf1npUFt42QSg/L+glyVk=", "Lo8FnJt49iQRsBf4fpAP1wyANr4XacU0TupBWcYrazo=", "A+NMKHaoNBMCnLcBj2V7Uqwoe6NR8lIXOK19MJ0bZzI=", "E6H2YKh1V87PAbUFwaR/zda1LF8FoexCYtswjOhvayw=", "AQ6aWZb44zkLa3hhAsrZFFIKjpPn7VUbSPMkVofxTTU=", "C9vumEao1nzZ1U8EMyeQRNhQdgQbB8PiJLONII/0jE0=", "I4Hf3ZvDN9XW+4YeFsoo0RfVhtFtXu63QZpmHHgsH4o=", "C4Vr2P3W67fw8d7Q7xkgRpHhw3gfipxPWFEfH6SE/MY=", "FuwVlZvoNXUTyqij/vCy/BCxaWuBUZsKLPwYyRMXi3A=", "GUPXDA7BPJFCZZEhFWp3P0FG1UjN/ULkCiFbFllIbjE=", "KeUmiseW0m77wstPmOLCoB7/rLFQG4WCzK8eMRry7bI=", "D9ctKOdb5T1iaTf3WvIvdE6ht9z//5TIZvPaiol45P4=", "Gc6fmKNphp7EW/7LHxEqX3Bi/NbHXa/OkCrHDMwM43A=", "CKTRSaiieiFwvJzmcEOO6mTSEdOpfHAsGwHb071ekf8=", "GRUL44+l5f5N5+v5jVn8mvGrqhP1oGjLcWAC86aYORA=", "I8RSYRAUQN7xwMI+56r12LFe578x/3N0q4CDdNja9pc=", "IEqVQsaQ/jOP6rZT6aRqrOuvLfU+TpBeiWQUy1oMsSY=", "Eo79TGJUzQPCGyGRPOUmZfrNDpxG9GXFGkWBJHI63xA=", "MFvs0cugf7dCyVKOS5J22HGxgVr6r2IYyw51iq5ezn8=", "C7FLaWlv+0pG+5EwGvMmgv7po5GlNyrRnzpOMgv6xqA=", "L5gdjuyZUOOcb+2Aef5EovJW5+aGpgy3VL8YP8Ou3go=", "LjjG9qdImlTtmCxIOip5Ues9Cyjkjd+LV9KWn3g2kzc=", "G9cIbrcVDA3OG+ujmmfLrecri3LhwbtvDdtRwT7lg80=", "HItDfyvj5hZx5rYvtpjorxhyAxGWpD/+dtFSeyMVtGE=", "K5HHp4KJp8Q+FjXo7s1QukyWaUMfECQ6ZcyuYDFWb8E=", "C9+Ynn3d2NlFHEVhyne6cHtzj5zb/10VwRDudHE3D4M=", "CtGjIX6GZFps/xpNhsofGa/oWkXnSRLWFqTStDC71Hk=", "JW/40/Uk5OpoV4BEjy+MVbWSU0Lwj5RKx41Kzq0Hqgg=", "IJ16spf1oxJYIH087aey4SFoPSCuVhxtRgwR6/sbawE=", "Ca/OisLCzzr/YAJEG5jqUvyG0+xBEhbj1mm1XOW4v1I=", "KfgrHsAuaMJQmfAQSBWJfjPtnCbc/zssieajRxIiyTQ=", "A833+PsBX2hhMi963CIa2igAIRl723H4AM7vie0CHdI=", "J+smPb986sgk2F8qdTgEaSJwM90CFTNlY23wRNjLC2E=", "FijPCEKAvBSanjzL/FvQhyIQGuSgQ9M7L5iudqnVWYQ=", "KxaL+x5sTO1qRP3VYYYX3LjpxNrXsExKiVUgnxthq5M=", "BX3gcJTcowcjamqMyz8XIHeFSQV663p9r4pGO6GMhf8=", "D7B5ZQ1e4/eGA8YOi1RTE75ef31sGmED/XnxAKyMoQE=", "GNl27Z1E+3Q3MguR0ylcjjNue0AmWRSbLKuusnL7Br0=", "Ht+77xgBQsR8TH860eLMgb0CCr/MtDLuMnyqIuk/9F8=", "JRD72gwbglYpCirTtFGcgV8Dl7uMhVBa9nKut9ofklo=", "FHg86b1Jhg82TQ5G3vpmbTYTjcQGJVuSAJBPwGDPBCQ=", "EA4AR3NpwMZ3j+ZTaXRIFjMb/jd9sz5m9jrOMeO1aFc=", "GuqTtRcmqNcEOd37fi+HdL3plrcvnLAMw9fy7i4MRcM=", "CxTA32siItl3ITFhQBIpdjpVG4iWlN/TDoDffm92y0k=", "CmQ7pyUxoZKx75yCdLqOq3P7GmTDlRtnJynGDuysNU0=", "DDahLIOkRaaXmxOha4ehK8xjXO2MhCHvmoyyg585awI=", "Jct5Ks8UcIDTo8Lof3KcXr7BxDiY4iL9DlCpUYl9XTk=", "HhBk9lRINVSG2/osLINXn+9kMd6sNQRvsne1iFsJv5k=", "JkQO5PxMR303mYDBg0o7LzsmHX7XuRPilQZ27SD4eFQ=", "MArPPpqQG5xoG0Om6ntILL/ESV3VElJH1Mmyq4Q6r8A=", "DSeDPaitzCFdmlMGlsUmk7AE3hUsZHGUXKehcBw4Scs=", "HE6PYCS7eWMz+FNGKileDMFqYJhXLvWNFZpSjPiGquY=", "DbOOEHEhjvDuXXeseA3Oqt8c953J8k0vPJ1YQSsaWTk=", "D4pCPQQK7w7d1u/EafTdnd1/5ZGkruOuOQbaenf4vCI=", "CdpXDVXi9kyU47LnouJV8FndNi95amkUKWZ1b62FkME=", "DXzVwmXPtbAaWeREjGfHrdvCwJsl8HiyPFINeK9ABX4=", "LJxHvEwzKqwVrGi9tGSuGTp0XBNRx9EjCyYfpAuV32k=", "GrE188gfw5WnuU4LkRU1kQHsdedq36FFKXWTk6F4nIo=", "MFIdQIL1i486ErfI5B0f2WgoSs8SFD2FkH7HgtPfr5w=", "G5AQIhAnmkK3+PJse9Bo3YK3bNP6LzMBRWmKEfXtmW0=", "LprENBeQKYJs28YksyCAMNTwsmXkqOHHC4lRMQM5gJY=", "J4TD1x0SVYYYVJbj/Hw2mZbnAK2Xg7I/QftIPN+O7jc=", "AlMFQokh9uNNoqsFw7diJo7Rsbw/BqzdHdXjJpHmK6g=", "HTAG5sVyXhe1gotbWiNxb5ptCkyGf+0swlQ9wKyZ2qk=", "FodnMj5Ql7sv5mgr9qyLtbj5rwcf8mAlZHOZiKOm8Lw=", "Cl2AsgDn7gBQD1Jo3DGeALeX0K01iYmhXYr1UUIeG9c=", "Jdu1Qj7ip9eGH5mC9SKww6rm3P0OkFCMtlUPck17goI=", "JeG5cqp1dv8ACs9+4QEXXR0e8YJkQV1PyfTFwzYqsCY=", "J6nGcOaW7FKHuLYGpcIxrg/jzbdk4u+ZrSVSMbmFAP8=", "Jg1mBqHbSFS7NY+kFc4TzhFDFthxp6K5DREsout73wU=", "I5ejdPhKKaWtN5i7zlZ+tjFzDHRafTieZUII7s7LKPk=", "Ee4cYWME3M8CD4j2pI+kByEm5k4nlv+6id2Ts6kfHy4=", "BVrgEVILTsW1p307Xzd6JS7ph4GowpRNK/CuGGfvkhU=", "FwB/dKL+K4VYGvh50TbVh8vhjpqcO6GsAcUM+i+47Us=", "IUrJZLNLIQ4DKX/s/Ij00GqF/PDxXjgPlIsV+hME7Bo=", "HCFG6hU94R+kgLREKF/dHNpTzCcop5bDdcR8Li1XQEI=", "DKCvAk2YOuqP9jQN7p7IKN15h2LBjwa9qSJZs8FYB2s=", "AS+Czp2naHCmVzVUiYjm4K8YDG1LXZjFrhq4bAVcpug=", "JV9hSjM7E3XpJSbjnTdj+njxPlNffsoqKnuXyg1Ez2w=", "DQNUrTIvXh3/p6ruxEQp/8ieTfYIHASbftPT3ggue5I=", "A59Jbov3a+n6/2nPMxqEjpKA7aAybVoZExG12vwn66A=", "GwsOjdhiUj2gkDzL1RjtxaEpUX+mmJQf2wkl/wPPV5Q=", "IhtnybkjJ3OHuR/UHHZU03zrk37mkvvsOv5uqs8utrA=", "ElJJujyaxMWcHc2qbeKaua0UgPiz8CDkaGCPZb7FEVc=", "AmTpOQt7J4fErjXZ41Ng14B+NBS0B3tTO4U4GBHR5zA=", "Go36F4Oa9c2sQKyJxf8jR+cMF3BuMmiM97GOCdGbdS0=", "At2ydOIvE9HpwYbrcQwrPPe7A3jORiJsG8oFj4AuHaU=", "HtkdcKHg4inYVmu8qvY7CqoyNtxy3Hcv+1Jkw0D5Rc4=", "JY2XFHSMo7rWKx/JvtzK4C+IYWQJBlgNaD8hExxSBbo=", "KAlPsMnOP6Nwc956EmG/Dz5w9jOP1ZjtrvV4SSl68gs=", "AbJoJFlgokLY1g9IMJKP0Qsr2bJ9inMd/faUdWA+R3k=", "HM3CxIJJSWgYYYhzrOC79Ks6Py9kl/k5vnMzCtGL3Wo=", "ENe2/XxxuraIf1HsVjmkR2gtf9a6cQ6PsU+B7XLHH2s=", "FKE2oeSCfXB9rMko+L1SNMwyfIo+S6YADG217jsSV1c=", "KZEgiEL+tcmxHGGA21f0ecMonJu/K21eY5sU13zCWFg=", "CGQnbwbPUFANUcwtbu3KCS8e/R41cXyRtRgcZuqzSF4=", "AdoRFcA1kB1C1RKwO8KWLS895QTK7AjxhDfJA2OlzRg=", "DOTGFSLPEYtm7dLd32g7QH/dHQAhPy3r+ZY7WoopdhM=", "IoIr4Uc2x3DdERAYrTpIGJedoi61Irs+5LPr9PlMATg=", "AkiMLvPOzfmA6CavKYrzuBztSQANCe9szu4ZTBPzpE8=", "IrO9Q70TDA4umJ/QYz41KAXqcsIUQd2xT6Kk1/9bXr0=", "D/6hHZALXBPNjkYy6S0o5V9LArmuGC6yYtn8BUxZKs8=", "FKzcBlk1Iw7+gK27Q7pW5IFcxT4eu/05AEKU2eN2ch4=", "FfwefLgZkktvrqUfwa3sEM0eOtrA0KMkYKDUqVoDxqE=", "BUfRkSg0N28ANXkO5/Nqtzycj0HhxPvNdzm0x2diLFE=", "E1+fTBb5dUW5zbXOulrLmk5SriVeKmniKzEUVzeJgJk=", "CM5K9A195ZjFZPDDjGYg7dyf7YJsQGCqbCjw7bM0XoM=", "Idam2XElkpbtm3KHIQSzQM7bkRnEd0tbCKtLrSnBYec=", "KrxiKsNfUCQfNlKqli1LBFyM4bTTp3xRpcrpmVxu7rQ=", "JUWyjVT9zr5C+KRWLeEGHrIWJyiJU2Jg1fMt7NvEyC0=", "KFQmDmPcRdIq/SLYyf2MIuHaaPQXOkAou4hb9/u0reI=", "CV1U5WiYeufDedzkbWeFN6JtYVWKNwYJ9JHP53jo+5w=", "KsA8RAyK4PdTpPYz5wS7QfjHUcxGO5GXbcYxVwV8+NI=", "DOWXcA+k7wfM79Juo0bDBhjrQr+aS315GpV3NnmJcL4=", "AsE6QCf0FTs2gKKbcmjh6veN3u+fjRrAhmWVzZUDuDY=", "IaZDg5vjUaTzj7uxc7Ww617KxPeLd/aDDaaA71q6EcI=", "BTsHxxzYZLIROr0HBf3yQs88oBayzlRc0Yd6tEujXMo=", "GInHBQLj7fs/IMizL77arVH8atHKoUdVx+3eUuHUujk=", "FoZrZkqj9ijOnhp5iHr3H/G/INTfbnB9UeBf7HuO32E=", "CrR8IBrTFcciBBLhwwS4ElRtSj2E0P9xx6VwGOfceDQ=", "BXe/yTsatQ7GIiV87ts9L0pUhgAvdYHJ/zzSLzpd22U=", "B5AKo1K/lZ5xjlKEpEhfJBp0oLt/cwFmwpfkSHMtbMs=", "JjXflWt98/feKYzp4Y0xCQfmXByWUCxpPRvpVUurRfk=", "LnEV8da7df1a38hyYTkiqhcvrZopSDtIcuX9Icg3QwY=", "KOMwtuQTrPM02+rxlp1WaXfcpna0YYrCelMLbIWeVyg=", "J+ghwgUoaBPhMK2ZGsvixx3lUs6yzDTucnZm+Taw6C4=", "CCImhNgBVJMPli3feLLFZWilnl2dohro8GOtrMnCw4s=", "D/t8w8Be1KMITb10MRLAXyVPz5tZOr24LiXfxbTbj9o=", "DW4R2bUe+PoSsDT9hwaP3CLwpKP3k9xslmLrnrkV0nk=", "LF1t3hjSiwjZGfOYHl8nqZ8sENmvUmd9JEzPZIDGlgw=", "EFgt/F9TmcTJUlUBKO/uIRaaRyftnhwUC5oi227LwPk=", "HFj9pounS9U01RkAbK5xgEwuYHSrph2V99ishKPe8L8=", "JxBEyNVOGmQ9xG3bkJ/0B46VNOjSOowqGRbJxcKx2Mw=", "GGxeJAFfsLahQNf17OwTKxS4WWZ2jOGznCA2XNP10zU=", "HvUoEkO9I+Gh0/DqqGU+KmQlVq+BZkhZyBbF9psTZa0=", "Dpr1MhXiNkk1oCclibXDsMgK8VTPps9klpiF03z6aLM=", "DApcm/EYoHVASFoCTxz3x88GiIJ/bB1tk/YxXGKgIzc=", "AnUuo830EBaaK599lAuTAfhVy4iP9V3KjV+g8UzPtMY=", "H0hNThSvOxHNJX63n8Unhf3Nj/FS3Fbcn4IkdSiePWY=", "GKQuIaw16/MDSmt+g2r2uploa8B7Hugo/RjOJk+YrxQ=", "F7xPz+Fn7XQIABZ+TThkMe8b3yTGEoqWTAJ6r4eSL6g=", "L8O3tBCsrgFcY3dJ2f6Q2JQCtrUMnYRHdTFsIEu0o7w=", "IwULNmZ2j6kRhs7Yh28MNZmK8+5I/7FBuEGnkhUejhg=", "CRuzMrNdbkZHiZURWQA/aIL8hkqHv1KJlxHoTXppbns=", "Lue/bOrbV0lhLT8yN7GB2DmzLGa1HD4OUY1hluP7Gtk=", "DlA3s4fN3suENGy1wEuhyadgAlPHXyjRTJOJFoA8oBg=", "FVbYcNObtQbbtpzfFMwIMIC42BsUUASAkMrdkQ7HOX4=", "IZlN0BLBB6Fl+TrX4ovKtzRoZFJmzhI2QM+qgzDbN+s=", "LalCVthDCU3Zvbx1tsiGNM2qdubSuyx6S5wjJg4oFE4=", "C+CpLtxI2wmAjVCgOVaz6EfdpUgfrh39B314Idm1N7E=", "HTMsfQdcyBXdMWMHGJ2T4U8LueIBY4V5zvP6dFaLZi4=", "FajVjde0Q7HgR+MwuZ65AHtI5cGkimXwTCukDhNrqYw=", "FfC6Ji68XXItPP5nu30vwgN1+vXO54cWoyHqN5B8eUI=", "LPtBe167sAFe+pRYaHzZLKwSudeMZAM26ukZNPs28eo=", "DTMbMiiIUyc3dByMtTJyjezd1+fDxUWdgwqP9Dlbnco=", "GIpIVZGfFLeQAC2busx/wBGYDj9Rl+U8UJubBNcCPV4=", "CM7pambB7X4/l4YHwYj7kGEj00P0u/AtAJIKZtJD6p8=", "ILYcQ+Jk3syl2zer+3F1IeeOzyXQKb9LphFCbxqC1Vg=", "G3C+onOkCqp0ztg2nVYRqtNFKAQZbuh6OHBFDCLBzQI=", "JMI0vWxz4XJU76sBUFCgG3rG3IKjNU1uE2qU91oad5Y=", "KiGlWUcH7vGxBwyjnVU+x0+Pzoj2T19JTjyiuAencEc=", "Cc3P1QOVi5AbPG28FoE4a3/Q4zgxPjveTuTMaQcXXzU=", "A3IT/Wua34uYNgYSUyD3PsOLHjPe/2oOcZ6oL7XRVWM=", "K+W1XYPMb7Mux1joPsV29SHc2x2hN0zCrgIkcl1tXYU=", "H5uYUKOS9toQ/QCI/QYFTkPV4gS646s4UJ2/oYhYkwA=", "CWikenSNsjtz4aEDmyqyUzupGhLtgOMK/kdUwDyhyqM=", "GmJHherkg72O+dga/tDIYSv+RQoSTiZ92DlXq/aj3RU=", "JawkDHEmpkLusSmLwZh22WnZy17QlSzURutUiWK/FYY=", "JxUbztFLb1M4O/RVO8koLBfbu4y0fB6Efqib5D7BZ/U=", "AezivsLeeJEnL48vEfygwAyq4WLj/bBuBUih/ZBf30k=", "J+hW3yJ8/32Tzx0MBaENGEk0XpnWlWpmWeoR19c3TEM=", "G6hZGvHFikXfCQNHdKg24xWIQSfWK6ArTpkVe2K4xGc=", "LxH6lALFhTvTCBgcZZbc53yVpDGSjRa4U0CYDaEuUy8=", "GdzN82eDlhoYyOQyYY+r3QiSzBfL846/zmOiv4RiMu0=", "E1DspajLwsU7ap3xo5rH1y8Bg7/5+/0BdX8Ido3VLW0=", "IwWFr3WCtqTcZiBw6zfrHDV4Vk+AqGcC1aBG/nslEnI=", "BSpxtdrtcNEee7mrGmEwz74Bk4PcFPmf4rUxCO+DEYM=", "B4Ud3HOixvl7igigW9HePciOBJEL6g2DcWTyxXTD0zc=", "BpmVKH/u9buplsvFqDG6ABCV4ms+a141+XZf799GDo8=", "CmkgQVC9x7xzKXqkvxVrB/pYG6Le9pJOKGjH2uhMdKs=", "IP2fvRU2oz3qzfJ2eLcENsuBcF4mfNw7zWkmrSYoURQ=", "LrGi6vFdtdV4qSHY532mL55iKCu7Ap8MskG2AhNk60A=", "BR9VvAl0zLdeabef1pX9VOIQrTcDSDa0AfLyM5edXeU=", "DqE4bXfA+JbQCtor+WMDsX8bQxin3V2VnzyKscJdw7k=", "EeL84Ot+ZOSI4KY5pfHdIPHbkaHNvHn0cRHg4BSLTC8=", "ImM4dPta5HdNHwKpVadHX46SmrZ0mhfLyw4SZj653os=", "HuJhO47V+uqMO7Xzj450J1KOUrNqXNEUyNhGW+3WIT8=", "Gz7yU111mt0Fq/Qt3eKDEpJ0pxMYg0tWGwfguYlayyM=", "JKCE6sYAYS4HowxfFlG5hD++/iXmUHfxu9TtdeR4vDU=", "BJwuDn4XehZmjo1qKDHSC/UskVWGtSvjpTXDhuLiP7A=", "B2nStW0NSAU6LbrR3dEfcmL4DwS8eo9h3SxKk2FbYJw=", "GqIKJeRSZAEwX7JDLIl86DxOTa+dS2/FYJ3w3Y0Mgnk=", "ICFNU0Rp8Jaaj1ezb21rshJeLqYbISYUPPxm9zd2Mq4=", "AsJbn12w/u/HLqlNo1/DBccS4RYrkhyVlLjJs7kJU0U=", "EdBtXNhBSImyCfCCZOH2OLVr79CnrU0cuRqHmGQm86I=", "ARGMZjOtu/ofCLc9woFI71AIEo6UlG5H33jlK1OoGBM=", "EMvQqXEkPBAM/DRH1Zh3kLYEIGZNqWR3sp7VgVnTwLs=", "LX3vpWIYsdAuZLMeDYT7OdQGjn/vL45HwXNAHVoBvnw=", "A1v6Gj8WRyrQlkpmA9RMtwqTD0U4qyNdXLHZDnWoqTU=", "ChcjKXQq3kbn83YS5jf4oCYmIMzYOIkvP8vOD2NA//E=", "LFjEh+pgdpJC0Z3YIwoOEKm2AKBVQWhYFgyriZa9dH0=", "EHU7NhaO9IFMvOipIXb+DQQpKUp7v1YlmekBOJcjRdc=", "Bcq5jfsycLyfJ8YVExXdsK8LKSZCKX/XY0h5SWdas8M=", "JEur0xQDajUwaLOH548GS2w8IaHkN5xkA0hSUouMwoY=", "GJ1uoZdUIMFRCPkol17qT2Na/oD7FUP/ZRjF3ZibTvQ=", "KDSwbi8x4cLgE7WJwwZinViMlnfqO0cp2inluTFyfhE=", "LqZVc8rXBh0gi+6T1vcued+3qbDFjRw8Q7KVt+28BQs=", "Kor68yTcoowzGcZCyTn+44D7sJkr0AwNUHuyROefO2Q=", "JwDKlkRWISLG7BM5qevQYXD9g1Ds2JP0xLVMpxTozKU=", "CI0gumPVI10Wk1HlrlOCpl0KDkVCRmYlxJZITlJ8r/0=", "HjsraSdG2y4yIdMcLJ0q9suuWc3qLfjJ1h0JyrVDZRw=", "AyAUDiw2NOK7xuq9Z+MVBZNAnhfIqLoU1roQtI9Xvns=", "JfzOrnr8RJz2+pWNfQG7V8DK2Wa4nenbBJ5Nmao1xjw=", "LQisfD0e9EJS2jxAqqfclVdgZy+72rysmI+F3X9hZZ4=", "B3I7fzTDGh1YxdZ+jwCCoRf3e0A/Qjg3g97XVQEojiE=", "CPk/EaYoWII7V+vnu08sf98Kma2a5Sa8dWX3/L7VMdw=", "JQXAiWb0GMu3y/GGByzaNHi6AwzAijHU3INT8U9f6c4=", "InMMd7rO7l+mxWB+y+usD7zKCl+qSKs31PSeYD8zweA=", "KGbaj2XO95QXftmcoOXijEXjPwWab9jbi73YPze5O6c=", "LLvRafSjLWebgYY0tAGKAKITqrHfdYzA5e1paRTSeUs=", "FS1n2hbSSgCoKZGIbG4YQbtY8ZwGRhhTH2b+7nI7rfw=", "Bk69nwDTqpJQL23fj+6W56JHrwdJPt/1mmRzzyuHe1s=", "F790ML4O0KWSTsaIm4cOOlrh0AVDLpZVlyZEV746kgo=", "AtjNbE2r+rRqB5JzxLeJt5IbaJCaad7ftkl0zRIo8mo=", "Bhbn/AF4Wu8WcA3XQIYOFEVGTsBSQiF8HXeV/Pr+0L4=", "GNMJJ3szykgTAeDKPUKogDPqg/5rmr4sLn2TBhox88k=", "B1JIEco1f8Ms88VYLK1mKwQNzBXwr6PgRVBocDGYRlU=", "HsBl4OyVZA73T9M324xuD9ehQUFi0dtFu+Ujs3OUEzk=", "JHF1Y4azSWwhgOaMasa9CEL4zyAk1uUZo3ES6cKwEV0=", "FbFnluVz7oSrhnbawEGj0rCIvOWxfvQ3s9zFllMCvHA=", "IY5vCRcxhor9WspL6vlvz6yYrKqmbVc4AU8BOcAv+kI=", "EJ+6nlnPVSA/6XHc8yYIpX5FqtZKfI3KV9tIEdwXyAg=", "ElpsBRp4FsUWa6yzZHv1TxLsKUXKalG8nfGQUc75sZ4=", "Gy5mIdlFjNXc3DDj7/L/00Z3st2K909NdCBJ4VfV7ho=", "Duahhkq4XwzGChk3KxO40WcYIaaBzd9o39gqDprMcso=", "LF6ouNIs9M5V1KOBHqSs4dryEnqSx3uzvKUeY2xd1aM=", "BHaevZSfQk+SXgnS8RY6ZgLyZ4X3AaD25G7vkaebLYE=", "FMpWMfcwnN0nw1Ngbo671IuRGiOdhrRcVYm9Wp1WZPk=", "FwheCRzLVcsB1Fwv66HIwYyjgM8XYV7dENP9uRBA7MU=", "K1gGLgYJf0eEMZhFipdLx7qIqvAbu/q3I1zZkMPsgqs=", "BfGXQra5y/FLYi5Vtb9FvHJjlTPBjJiy3YEcTdZ37kk=", "KvTLo0szZdaPWwd1vc7MbsH0KXKvSNZIIO/xZuaMRYk=", "ME75Zc/AzEzeoA6aK4SH3XkWUrr22YEKXv2uOSwzTqI=", "DGtwBQ4X2V6q5n4DuCC+e88F4OmcQMft46TWlDTCzk8=", "FSBRVnse19b00oZOrx07BS7CgDfOcJrfz+wNzjZPrnY=", "GWp+UMtRfiF2nR/b6qkqu8BAx2QE1xRFVKSoiye9WlY=", "HbpNbS66hDObsqejL5zJeHJkrPaHUErkxpqLGilrmgo=", "EU+zWDndtXw6gz1AMW7rKOMiIdNP+Gq5ZQetdVxNN1s=", "FSCG0SR9qAUDllQSvKWwIPCRjgX65PQCk8XBNWsBWDI=", "JI+GWVdMJ7NJuXw0A91fCPyq/J9gallpO4nXQ66VL+8=", "ISEkzteLsM0LcI0fDdo6jk9bQssyRuemTs75NeX7zi0=", "CdaKcX2EF4ZNpxaz3Cmmqm4t/AtmHMlSa2YCanyei1I=", "EAnZAzAROH17WddYQYyjwHQt1q9+yi5eaImsNlGzKgE=", "Hc7ZBgTSnMZvWBAQhxPAlXn6+rezF1sS91QPGgPeaFE=", "EtQl2pURZXBx83AOc9OjV8HbM2iv9RSNQNOzFcPPTVA=", "AnvcBo8j+PkofIvlVGmAmSXf5SJhCJE3lLR4Kwf/Wbg=", "B9kJGW1svSCR57ZtFVDjdys2CvpPlkavh5ACvSDmdLs=", "LFQII05HPvpyaWBOc9EnM3E6R7VScmMy38WId7r7hPQ=", "CZGpp1SOPFxPCUc6rGCBXG4Ey8cTi/wC1DNG9GpbzSE=", "DmxuR5JtI4aw23SyD2d4xQe/ksP+XrwmMn7xvFqb1X4=", "Adt9f1mVODM7/cG5N2s46M26J+jEm9gZ4I0o4TL/8hE=", "FODSu7WWnB4PhoBRAMKE2Pb2wcEB6Ocjmjjjx6AGJnw=", "Jrp4TgTZLvWdV6FxE4svK7v5nOuy1brCHNhsivUQZ1U=", "B94GnrzWfdWIDQmFSa0+HLvnTyGbjFP4vUkWapcl9yw=", "MCiUmw3TPgFaprRgaR2DfY+5udXnCHe9g98DALSg2EM=", "C18sy4TbPAPuSEL2Y0edmwqMsI0/HX7UEGn+MBIAOPM=", "D1ajDcOW1sGxePaSUwlF0YfWnAgoFBki8pI9+k2T+CE=", "Fqhzw/PNgP1qReeCbspZFRwD5OqMF3eyC0+7QtcRj5g=", "InR53UpehuRN6Abf/5jQXuLFFI9bQqWs0HdHrHHHtHQ=", "JH8XcgTBORpLsCQc8NCE7Xn4H7QElJjAA7obIlUUmU0=", "GnoNPgLd/Whjm5jtzKZAm1EaTFCKrEo+4m3s86t0EY4=", "BhCQdHFfkBlhid4oCvbQyCDI44YqvWml0FCTL0QiNfU=", "ES751GTi7Qw/NIYs2VXSlijDEW/lRSDnYwm3fKkbwv4=", "BSr9NIiodbxE5zxU6uasBcrS1+GbSA9QwoWLjsWk26w=", "B/6okRt8KEH0976k87e+fLVxCmJCl752ezE0R/sqH50=", "JTuIu/RhDRWTTX6Y9KEwNmL5z1R7th+l8QNbEYNzEuc=", "EO+PKh5Uo+CNS2QqW1hCB4hRZoQ3CUaWkdM4NQKDSog=", "Lec4wB9yUitpgsdY4BVAxteSBA8+oVKFx4ZOO/ksjjU=", "GGmgXCQ19O3iyjP62ECweFfv3mX4UJMl4GoG+Jswk/U=", "BEo8WJz/GwCVo7uiGMY8RRmY1UNiQ7oek/cm2uglk+s=", "Dt8VzEerUKkuVAFLVkMWiYjiU62ubwVR4jnSZdEPH80=", "Hd5xo4jhqcsHWv1rahM1RwHgQfw0FbXWthNUHUED9Ak=", "ExAXNAgssj+b0mV+y8Md6968iG3LWhW72LEgyKlF+Cs=", "JaOnwSisb/3f/sTXoXzTBErQqzCLl0Jg8IPDn/cpN9U=", "DFqTg5MBb/oHHjufL+PFjKMIOWeilOYu2L5WVyRmG0s=", "G2OgvuBwct+zozxj/QDS2k5oKtrcZm2xIFMmAIy6bhc=", "JvmaNPwZ6n3/6carlnGbLO+dONQaIJ6+dLUbL4sPYMg=", "HxiEsc8/42zA4KroisZoY3XOZq13AIe2ay0cQB5Jg78=", "DX8OIgbWoJLFAsoltEBFXamOadf9Xk4gXFF3qKTfgSo=", "GE2gn9Rf26Nghh8SX7U5D1pHYlL+cYiVgs17c9qYBQo=", "GEB4FWKVXMGpA1+LG6ZRyDOwcZ/igzM8JJyLJjuwFXM=", "AtB30CfzmJbZ2LGmGepgYykNoUd9BtaiRLSAI7bzzcg=", "LLqPMFsAkxCjYRZ2mioX/yIwtJFeFWxDwrXZyXeBNmA=", "HhxGsGj0gH1oMqlovp95vKqZC2SThErXJPios3u3kho=", "Ia01dAS7jNnbU1XlzEedwaoeSPxsdvYvXRrnaKDhpBk=", "AOGc6LcsZFPHOjU46Rn0jU7uEfZgm2DPQw4Ut0zqxf4=", "D4nZRVZqKGt7xjuTcDbUD+WP/zsTpv0ep2dutmGU0Gw=", "FealfLtTIggDxOkeBmtIOjGLqwviEZqGQ+0c7LphE30=", "HEXIhB/V1OZ1pGyZEVRcFOnkaO+D4efGZ16RcD8OIyc=", "EOqT8CV1EmwjFFiyD0t3SAoPEPU89MW28du7v+jYigE=", "Abu3eEsfSXG4t0txTRcmbjpFAIgFrHQkdxQnZ60MX/E=", "E4lB+09mas83T88BkKQcyG+UKThq18ogT9wsoiTDQFo=", "LImR+ztilc1nFiYx7DSR71T7pxcnwilXdAVSyCWUNCM=", "DeZrJMHU4uVngbxinBs5ideN+tYocWqEOjLF20GMdQE=", "Dos3wW+2KBJVyyd5CsUj9f9cFb4oax6C2XO04BBLsqU=", "D7QQZ9/Z7m6EC4goBZfUNqDL1hUC4GiYz4tf7ZKJyF4=", "ARnBnfaT+Ap6ew5kR5qad+9LjrcNa+4H+8M+96z4V9s=", "KCbA6zrgt1yWz8GBeX9hM9hDS4EgWL0Yh+carL8JV5U=", "HROMhzNBT3AevNMZpoWBeAN6qwgrgE4hQzIqh7ZHfHY=", "IuMsihqeIA1+MdaeQnfD5nlJSx2XDgx5IXWH5JVdfAc=", "LVK2VYK4O10T8ojWes4ixcUfik8HW45tdmCmYK1c9uc=", "Li5wSMCg24kQ4IJ+rdEko1lHyyYGSiLnk7TUq2q5Ahw=", "I0+dls9IMzPBP1IkpA3UlTcNrLe2eZ4/k2Hiq4kwQcI=", "C7PgAiLNPXL1SZonSd1+Nsji1V4lX+gddYoQcHC6SBw=", "GZrlK3VHo9pfVL0rnKncDyHRFZTrUqB5B3Wbgu7nZhI=", "AaPYBI2tCVgcGNGrLhBmbT7M0HaWidYSGZwmVQ86GBs=", "Fma6lKwss6WMXMhu7HUTU6FDkbDgb74mOFE5bezA/Rs=", "FcMDTNecrnXAC3l2gXxZaVmJFu1WNEcnuBGHKvQELo0=", "CGrGky3mGpzkGLYSUChR4G1dcPTcOx4e2Oosbfdbh4k=", "D0OnDIZOeoHgV2uyd2RlYUGrQ7GZJaG006F2i8city0=", "HbOit8a1OK0HBo2XUI31/7NKCeofmO0wOZrymD+hRfQ=", "GxU5HKhSN+6OpIVw11lBbxgmqrNOqH06PMNUfRfn39k=", "AmOqqfnoPCVeZ/mgmQH+7SaN9WFR553zRUJjQeDzjzM=", "LahOw493B9XXH67q7eeT2ZDwTozdAWy7871lwSkTghM=", "E66d7UgS0fTSjTeWQrp7ebstPrgdzSI+iRDFXo93vp4=", "JbGBxyVQACwrEwSTfv3DSg1F5wlRGSnOoGA1n7Ujv2o=", "LRQfh3eOuvZH8tonq74FBNRkQoOPOuIarpB0WD9rZLo=", "Bc+1aY9oz1EwwUv9TId0Ggtl4sGX9ZSDHKQU/1PvVQU=", "D7o3fmlJs5CBVAhchFeimAzF6jRy7DDgmWzI3Z2jHZ4=", "LqW8Iv0+TuhYWsiD5XRQEhWXKyA+IdPKwztIUtm1B7U=", "DbL+hKp9E3Ry5ysP+8fnanb5Ik+sHRs9pu41pcck+Ns=", "EcgEpBnEfcc9sasmgpea/bBCwSzjSaAN/toccvCk2yM=", "FCPfmcie/kPD6Ar2mf76u4Yf4NiXRiTfwZJ9J3ba8kE=", "LgfB+Bu6n44b2JFXh8p0wEYH6Dwwj02iUxQN4OPLTuA=", "G5Rcyxe8J+EKI5JspVN7SbKLYzErMnjNFtsUSrJ/o8o=", "CumCEkPgO36pNzsDInXTLdTLq8k3gfNtUyt8ydt6V10=", "GPLmL56Rw+OZNYI0+moMkHw/NUH8DOjvG1rRNdQcTAI=", "F9eu4pLbo94ZQ8+DNCVPl1SxetelosVyMO734GxASf0=", "D/dfj/c6VdSGvu/Z9di/b2+dMbEKCQOyT0o78hGPmDY=", "L4IZ88fBSNyy84xpe//TEA40sOyNz210Nt436d/GWk4=", "Fuwe5qdPed3Z0UIhZlnZm5Ej99eJAZ7LXPOgQ/fYIOY=", "D+VhLY5f5f9OIkB4y/OQfyUHjSYE2/IKaurxiwIWtX4=", "CAIZd330fOoLw4UkLFJj6uBrKn6qymBbfd0y/gsM/I0=", "COkMBakJEECBXsCOsUIQahsslO7tUTLGN8+cDEBAPnc=", "J50s6DRnMf3uekmQO35u8TYsWZcOMarwGqxR3sf58CY=", "EX4AR6zSK2H7+B6ZzBPiufHY24+zg3hZLUQ3J3m98WU=", "ArxwU9yFKVpR0PjQURidoi8y8iJIfsnsOdWhdlLZQR8=", "B5BoS00muagyJc9y5gwCZDLKU3hnjrjHRN27bmRfwBA=", "CM6p8CUj6dy4dwmBLh94aD83OjOJV3RJHB1gcuOrB50=", "Gij1VI6+LCEPNhDOML/xzV8CM/4EXw2i0qcGH2OtNfM=", "FVFJGqDgNXhyQvW/Q1Ga1WG2YBApxW/IY8Y0dMvGcT0=", "JwXnNVb9KYs4z+az0ELk5fS0V+kOfosWo8m1S0nGRPY=", "Ge24SGKkoRPjcuAcODW3FnvVjW7csDgHjeUH3IlHJyg=", "CTixwmUwK35BSJBv4OkPmt43VRCVDUdSJKCRXb0qNCk=", "BDXWYeGNi7KLuhpGSLc69kRBYjFi5bY2uh37en6IfAg=", "LOcc4kMWYpEeoz+Z3dQiJ7FHdXOyYfnTiVf5yGKGssw=", "F8ddoVIb0/RLLtOXmbdH+0/SgDioelCm79m/OQYPHfQ=", "L6GOiVleaZk+qlf3GroVqLuD6ahsXa93B5RWf/T/GHo=", "Cpe19zB7m2tGFNvdnKBu7YD6jsY2AIYodA8EZzzM2YM=", "L7AjI6jbe6fjvqeGUqPdUP2QcFy2Xy+ZEVzlENHukNo=", "AQmEkV+8vLLH0FHAagAgCCPGQxQ1/zh3iLh4NLRqZF8=", "JfrvtUrn6KybNRbtRFNoRwRfmDUP6AIO2yT9Aoy5XnQ=", "Fj6ahYBRZjhkBq7EMJFlbfijVBBJYKxwl8hdIQfc/3c=", "LgHjn90gnt0AOT28eSc3go+B0KJXBkNsRYaKQMI/5T0=", "HubKAVbuvtQ6fwJyYzjJJZSEY0iD5ky2w0/0tFnc+mE=", "Je/7S4TCwJBuu2Vxr3oVEyXGrWlqwKtafno0NmqSP0Q=", "CQGFCG0M+9+UGvCfboXmyRmdpBwLKUwEniFD4tG/lMQ=", "GWkho3QCDy989r92t/2Nuq4Gzt7Un/lIJo03KNC6zL0=", "LjCoipwaSN62a7H+kjLXOuzS2Bl2gisu1DeqnBEIBXc=", "GPyV77hA3VL03lTNAjsLVS1X9Ums3E+GwWNWhSJTQ80=", "C9Iyawyq6m1RQbO+Rw6GXa6Z2G2+a9eGGiLvbi2VwIs=", "BN4ao/uYB7Iv48UD3LClgyU0DqC1pQcC5idnAYZVqMM=", "J50hZXs5tpQYHVCBgnlA9ubhJxoITFX0Lfxzehh+uYk=", "JZSpQhXcxsc9ZFELrDswQUq84Yzb/rUJr+bXDT3Jeos=", "CVFC485uX726mIWDPGFLv0WYlbbOoQ7fut3bJ23dKSA=", "BPfHEigezFbb+Lv5X8GvRpD0GbhBMDQmR7460bZ3MmE=", "FQwpW7BKYoClz69w3j6Zj4pCRIt6juVtH86oxRX85IM=", "BAsHOuoBtVlIRis8lpZeBwaBukLZJwW+q6fqnOWYN4M=", "KFhUquBCw+phbaewKmsu8wl1qqKpCuuHE/GJxMqjbJ4=", "CrALvuICpR5C7I+5tcth+RZc62UraVbBIF6N1TvqOwQ=", "ARUuGRMJHN5fOKa98KTrDrtQGVS3IfOFmgqiYs3hP4A=", "LfSpOOlIiCWXlELYXdpShQEXG9CbeA1D0bLiUy6KTRU=", "HRBDPmdsCNw61J1xrAJ9xLK8byGi+z031+npWBknmnc=", "CH4qwSzRJnoEkJP3MMKkYa/2pCnCMeX/7bYsxSZ23yY=", "Dzdpc3pENA5vyf7btrdghWgm98OmyouZP7AEEYcYrDg=", "KfbVSiHMAgmADuYTtEWFJS58NdPApPAM8YqCIPNs928=", "ABBt/WoF98VQBMbQeScomF45LWPG0i4YO3bBPNTuRl4=", "MCS2ZT39aKGrhe0k8wv7iGkMULmWDa7Vm0YDMfjjbj4=", "Lxea4/oWc2EQwpEaUEg31xx89dJ6TIPcRHp+pU6aif8=", "BXdA+4jtIcb0rQOtSaszhmgNPQ+13sxN/mXiwYezl70=", "FX+Fc8wfl3OzhSyWW7ALwRibyDNVx9gx8ciBAG09IoY=", "Idrp3oTIlvs+Bg/kZ8fdC3Rx526WGjsw03ZE0g6PRJw=", "LXbro3+QEIu53O0/naGsrVop0qNU7dVCMK+pt25HA8g=", "IEHqQNSR0vEGKGI3JxU4PbiXUIKAUiVbHgcfmbo2AZY=", "Jbk54sQMbgdaQsuJaLv5KOPWqK+NpMx5yb/HLWghxnM=", "LKjwoVl4LSqy/07Nbt+yh+9uWh8g1Qz3p1qLB2Bc5GE=", "COGCUuzVjehadPzypd/YZteA6LP1khU7fnwEcH0vH/s=", "DnQvomuECK2rqhfKfcor/BT0Djq6RqLW6F0+O6DFdn4=", "KHQ8rT2HKEKtI9rml4KV0mF52BJ15S3DCnr4Cjs/2n8=", "K3ikd3LfD4AF5QjMR6PCo3BZ/eNA04hsLq/nmur76Gg=", "FplLgVIp9m+Q6I+J4Ee07NP5GlfdnuXppWKUwvNQr3s=", "Dg8WzXUEEohSDtsYl69asRuFpUX01kL/sVf1dyEpQw8=", "GwHo6R13Pb1Kx1YSL455qp8BfaPhXUhlbQfpj5pz7wQ=", "DR8lJbat9QE+nXYXCv5vURdqRJfBWIyL5XXATlZ9My0=", "CtFQKUWIWdz/4Q8xb9zBNFJ+qx+XwKawmU4tFuP0UhA=", "Lu95A0+Mwu4E8PGIEVwB4itB1Cn+sqZrwjk2HupK9Fw=", "JeQqIeZemfY/BbNs/Ehel+ct46o4qFc9ND+VzlDGLa0=", "BsYsBWQEqjEGGXhhPJuioFLvhTHu3TJjvMNMTxZvfI4=", "F6aYtYOnaRReMHeVEigEAj+Cvjdhis3BINQe7e6dTP0=", "Dhy8wR1l4hQJKCF5Vjqz4nOFk2OwvunP8Ggc5aEfUgw=", "IguOwHxkkZE222v/y6zZvLwqVgv+mLAsqdKhwWIN0K0=", "H3GVs78Ympl8LU1/jRB9kcKtU1K2PREc8UJQXC6jVkU=", "CUbiKl/hJSzqdJcwqmNja3+ZaA9imagCScOZw4tWZwk=", "JHhYdb3snuLcdlYNr53CsBZHIYm3sqfX3ZnoYykxO10=", "JNbaCv+EU/ApUx6akMq2lsQyn9BdW8M84+lJ0tNRBbo=", "GV4+IQeco4CTvduxFZHNutrM7O6R1EqceXOA/StwFRI=", "G/9rQ6RT4WsrEwMjMXzPaMARbMTmmQj8T+qt68AQIJ4=", "Bz+dX1JpTYHvYohPupoxQy6MWQCHYwJmqGuJ88Dpx4o=", "K+P+TauEwYzOQ2+T1JKnPTM1whpvtvPDJccPJ6sHF+k=", "KA91g1DiziKswCIIKMN0ETwKBFRyFt7HZrJmntaHTbU=", "BqS4qqNjJhwrpj/DHnPEcEFSkIJQ6613vXkC44HV8lE=", "BhGBNcaxmX+W0wphlod+4KEDcTuRAEAnQQp23Fvf3V4=", "GomysQq6Ja00RFkXBVuVjxITBfezFIn1Du9HRJTDHAc=", "LjTDokuQ+lr8s7krQFkcOAOSHbS7FHX9lJhBJ6/h9MA=", "KfTNZLfJ2qiMHgy+NsC1OEC5JBr2vj+jUoy9hJXYm3Y=", "ETA0+JnJr4RlTuc0z1kHE0EoUo+MovxicmGt4AbcXaQ=", "DdXkHk0ALRf9MDoYLHzk2hwSwp5SRalOZ4lg95oDwiE=", "CUlSOaT+0GOjwpKKQkE/As+a4IhoFG+ABU5tX/Uxy2c=", "FUhv82tzJVKK/lMpgZhLbAamOgtuJbH7Jx9juMpujYI=", "LYquHQgqYNtrOxqgskSSnON8E5J+jWH7DpGPAaFOSDU=", "AJTrtVAdrlCz2GgxFwD7g3pcaem9CQCQNgFhb2k1ReA=", "H9r/rK2sQbYVSxbJqiyIWcQv2NqQg9KsB8zLJuaQx+I=", "C3WEzuHHjpAwF+Oi6D6BWDDbkRiltHebWU12SqWyQck=", "FBLoVNqKTJ4KEdJ/8MRgm9co8uDVZqVswpNvNwxAyHU=", "A9NNvC5vd6HRKu36XhHeJ8yZHEnt+zlu504mnvXaKYE=", "Ku3VeVBG28bJE3g4gtSkVGOVDRCKfmkQUyuhofTTF8M=", "Cl3OHsXH0ZkdJ1+R7S/qN5PtxK+n07Fx1sotXsiA4oM=", "FY5/ydFZbPBLrICkn0qTRFs3F4qeWna+JNbHCM04lZ4=", "CNcwYdmDYQ0wk+BegPBJTOxuapdS+F5/YEtOZeb6WV4=", "LrFtkjVqnOLHNyAVtfFqsYl03ynPU/F+H2QdU2DX8gk=", "Lpv7HAcv+h8USLzzyxiePI0EVIV6k/LbTB8I9mUG1tQ=", "BNo66czyPEQlDunzIJWy03WMMiOquFzU4heRKHuqTQg=", "FkSVdJzNfq4gXKFPSIK21an4TXCi6xJl5+NhkyJybl0=", "HIGzkz4wLiojBSoe3oDI7ceggw/JDU+WfBPo+hmdupg=", "Ded5AqLaRc9nJ6boeQtLOH0mu+PToQ+PGvfXG+gqzrs=", "D7yPHzn6VvUB0hjMQoPZ9PfFdYvxIa6Xl4oFRrJ1oiQ=", "GxWImN3q9XB1rFoDPQaVQ//ZIm7B/J9f6M0XQo6fnCU=", "EKm6fY/DYkm3HOOCgsVQBHwHI9QySFm48zwHIzFX99A=", "HmK3xT9RDmDBzLeCZRXADWLrIa7gCwoSu+0z8/CkEBM=", "IeKjCXPmAUab049p5r/l/GsfLFRqKY2+S3We7Bg5l+g=", "H0JWwBK9tzzGMktgWbGW9mB8ge6+DO/ON/uuNDoNuGI=", "KDgVQG6AyUWraoC0t5A1kuMyX+//8g1g3x7swBwxCTY=", "DLTODeBf/t5nCKe7FCRUDXgRliRH3qB7vWs+JP/P8/k=", "I/na34LFIt89C0HjGn9rpTIw35BGuKM407NxJ8utloM=", "IRMG4Z+2WuEChti2KdTMe/IUWrds5RPUr8tdBYpc0Fk=", "JvGLsJ7vpwJX2UBsU7FwPtMgLufuKR/2awgHV8i8q8E=", "LWm0ZCP+eaocoH3JokBvJCRXfjv6//WOpQTBBOxPfcc=", "B0ZbozAm7SPcz3bVIVwR/8jHUKMLXZ05yyrTGW0sfjI=", "DkFG3ueM66aIdzgQ5TJ5Rq4g8EesT6ssxFo5C01G1ks=", "FiTpYLHcVuWHbqiy4hFc219gpoiYY0V//67qwCBm3YU=", "H9DjrieGykHmVb+OAkenGev9843w738BLuWl+TWNesQ=", "IFLDbmuJ4YQObRdMlmSaPS57UPJVjL+GKgXDaxd2lqE=", "Ese+gL9/+J1p1i9cJdHLgp9ZgYdXjS/RFYpH89ybGH0=", "HnEiY2fPDmf57h5bubzsCYoCJAA7xyTwRK2mPw3IhII=", "Gxrv3ifUAJ2pyp3RTY2cVGp8hOZ0eosf4qVh1i1HMvk=", "KPtvvoDRYbnRnWTGi/0kZ9sDmUWeTgCGmbujsJAfW08=", "JwNMmhi1X1JZgF+W2KHZt3Fvsch1cfcfE3sCMUkUzhk=", "LmreSe6W0rmc7JTHq5CYnK/ZEdnXT2uWkTDcn2ECyK4=", "HvrKPVroel9o1PMRSQLkgKlBbWkzKRTgw8z6ol6BlmU=", "Hb+hK7HnsM85GVq5iy9P57C1I8Q/YXeLKtOOF7ZguOA=", "HSGtxZW7NGKqOV6drMZxU6WsTiqByLqD/jN+ZNmYHco=", "GDoDH2UoOixXqmG5P3H46iqn6piBsKTIp+tiqZxipOA=", "BVBdcD9//9Mj3FZ5hy2bv96BpYzlosT6AEoftXAFs/Y=", "L6lLk2NuUJpfu9N08RGlSXTq5N+oV7ySfUY/0CxmWy0=", "Lxgk7+5rkMcojbzEF00u6ykWitRoyfNDPRg9OP27YNg=", "L4sAQ8erffElKjZaZTa17kWG15v07dTOTU6hI2p30pQ=", "KgZvqBF1SkyN9ho+7ukqeoBCD5JUHQ3LBuraMSf0s0Y=", "LdSDl1vyEk+oXcpBdJGIxPdNqBJ+zvvnjdlyt+nZ4UQ=", "A4dSJNPQtAoWR0b6MPeDXtbcvOnSPcSjxB5l4KcPeow=", "KYSP7mJlCN4GbnBG2TzmeMc2y/5kg5sP53R3LGUUwcY=", "KKfYrqv8HvqlFchVAkjjRBKifn+my9eNILAGfBJWejs=", "GVB7FWhuIP4rH5jJoeSVs2/8JNwUmtKfIzlh5kFfkrc=", "CmG5aPUF4HBL4vZ2smfqRJCNkp/4Y5vcQUSUWwB1y5U=", "EJdaf3BgswKrxNXNLo0rXTMNQrMb1cikeNenaFkFn1o=", "I9HvO0LQwVPWIWNPQ7JCMr91yQ9zxbwwuF++GLTImiw=", "FbZr0+p5hsfSlkEXiU88Q/4CuCVtLJwYXct/jGO3qnQ=", "CeRqjO+onFympblh+9lF8HJVr1TFP3MtMmGUQrj9+OQ=", "DnLbSHJsMEkSHL+9HAg0WcCmM81pU4y2M7h55K9sa9k=", "FvBTCduRs504rPwd69OakcxEQzDD7URYEhQgFqZNeEY=", "Bv/97rOBy/OXlfg8nWnIs6zLLYf9bOQnD1pmBt0M38U=", "GiUrHzR9jYlK9huy91xlz1/KGiIR3h+QXPOfptOE530=", "IxVhu2h6Wqiq9+HFlb8VWtLZPgki2rMn+5wfJ4dyEO0=", "APjUAw6sk+xtp59jBM2msEvjLwNugLQq3ao1HnAHkT0=", "L0nd9WXLUyTp091Iu1cCLMt7R5vhI+AD3j8symzcgNI=", "Hf7omHaWwy3jBEBjdyWGVTH518PXb+6YEWVqQ1vwaE4=", "BYIXveswZVRokszq4hj3/fOkPCODzu8SOH/CnU3HQ4A=", "BfhCOSqaB9TH1w8cofcrnjtc9WM+GZ6/VLokI1YNT1U=", "GIsIB7eRBdy9XDbsxnbC/uYDrqByt3EvLrtpudF1Lks=", "EQP26gnK5iHsb2leB5KaNgN8Uu/LtJPxCvE82wBVVI4=", "GkD4ujGS8MkpJItK7WGcgaIvigvwN0XRU3K+Q3sPwIw=", "AIgjt2JfhKX1yaiJHL89x6NHfaIVIAukIOUYIWRfnS8=", "BSpJSvPs3vUDHYeZTyZJBdJfxsYme2995ENbxhYfPzI=", "D8jNGe4x2gGNDGxZhW5ro2mlQpIxET3/TI5T1Q8Vd74=", "C+zohwj/RH8mEDVgDZmxE4mqByW0Rsno1UoC6P8t48A=", "K8L8L3yTJF8fXtCrbEzft3FUT43+ygIlDZyhv23C75I=", "IrFvgyXyosaZB69CaAEB5Pht6A2QG7aXAxDfob+AX9Y=", "J4KCPVGIz11BTCgM/Y3sgWrn/zbA/azYcK5kSfJabLY=", "Eto8kKzEGJtFsGofdBWY37LZwk9FkSDevs5cX+I9tb8=", "LYGl+fpBc/WPdUZDSB0ICJcmuse7cHj0ERtVEGta3ws=", "KG28mQFABG4eJjeIXU0pBIdfCvpRIZqyt1j8MstgDG8=", "IOejZ0oGZ2bQQiY2LnMhm1TKakJYJgN16Dl/j8EVGX0=", "IonzIn9M7rrgwdxRTeTGQvFTFOrpN7OaPDwSR2kT/N8=", "ITJR4wp2GZDyf6GXBCb51EoJPdBFJAFnBqEYB1OqRhY=", "CRZVYSqT9b480x2ySMe2J6LfKq+h72n38nZZwT8wGe4=", "GvYPrzSwV1XxlBGVsC5kY7tC33bBKxDxT4sWJQa41ek=", "IbQdDv/SsEQMDTtwEjt3MZA7+0bbPHojrP8Bbq8Qf9g=", "FqCHbJbUW1nd6CyPHhAixcrTFjjE44zs5belbECNhLQ=", "GFMp+eSqhdSdQqYqtPZB1ixf3t4XAVp9efMWS2kPZAc=", "Ej8gjbDE71SVYzXRaucVJTTS2Lp5PWAfFVJJaWOeo+E=", "GqVlQnjeIjgNp2vniFOBwXhMgO9PS7AyrNE7CXOcJjo=", "CVW4oWd6W2MQrY4EkugtEEShTHjKh9HjDg1/MxbqbOg=", "DH/v1O3Uun2SdWtRc5KJBNGPm2/plaV18Oam6I98Dlg=", "EW0YiZfuxqHiryrsil2x68XPpYj75UkPCN7RUD7K+wY=", "JY0u7Swt51nws5S2o8zS2W4osQAY8+f0U5Osj/6UfqY=", "Ip3owpZa6sGqftt4+/tdf7Euf9f/5rmzr7XoiDSabEQ=", "Cx+w/q/pjWz2NyFw1MWVrdpxcCwOnUHGyhoD11GPg6s=", "KFoFvpst/Yry0PKPLjL1zOaxU9iA2Kz2kGeAymNsTLs=", "HYJA6ZAjlO3uK3YJnbA9dN/5GFQ086Tk/oV1lpzk8pU=", "IWC+gjPOGwszGYk0nsS9mxJIZEhRCDHmQUZ4sxLVf5M=", "KSm4OdRL0rP8W/LMgV7nkQ25ls1bXf9CbI8Ypa2rUv4=", "B9DUPD9jNwHl8N6tVRbpS5H5dyXkaYLRmd4DNFkg7Ag=", "C5nCfa/5DMBTs3EyYi/dxf1SvOusEnCxzON4p/Ajk+8=", "LpUt/MkkwIECzKfpVl7t/s54llCDuFOsH0Eox/PXhpE=", "IZC3f5YzkQZtbSbz10Yg7DXlATdrUpnNP36cI7Vcyl8=", "Bb6RnFLS8dwNCw0WH3unGVUQIIquu13OsIFfKpEWhlI=", "C05LPKiqg0Yiy//7dubzD535l9y/k98ip77Mj/mgZy8=", "FiBSKojDtTHEXVHlNj+U+TM1guX27hw8t2QI0RYUT9Q=", "D0QuomiD+OGIcV9YQaaQyys45HnYrXB06JPvGePHOQo=", "GoVb++gKeIatgd3w577dgMHg5NG7AxMOAwNdU7WbpxA=", "Bqk4aGEiM+PWCY3guBJmSQNswUsc48exkUmhfKogtm0=", "BnFCSWLpI9qSZhLpwGYWZcSmfFJCZ8Rag97lKBMNTEQ=", "CxGXmfbuZ+J3XNSnGoxdRVuCQm4Armzs6jK19Eg7bUU=", "JtRo1V3DHNXqFBbcoPfqUZBkK3fK+ndB8SMyE3lsFls=", "J2/P4X74IYGAEElL4K7SSrwaQerKUxx/XS9xKeroAyU=", "I41AyDbbchW+oUVcySttc/UQBWjXGm0egavvwYwh6Ts=", "BkxP0cUO9Yffx9yszUq3rVx82wIwzI4ONNds45n7Sbk=", "A3GGafFv4wrcOEdKdUBq8pQx7LV/PbG6e2aZeweypCU=", "GfEE+Qu8A3YtYhonSjJcSfUHP8UMR9uIXpRWZiQhCY8=", "JIbJPv+iSJC+pO+a5subj2X9dZG9hNU1t2AinAzie6c=", "Ke99PqMtljImn7Aik3x4qR17yqBjqBjFkkt7ktAey/U=", "JtkefM4dje6ryNfFScuxvv8MFSy4gZ6GhM8gUEoCUvc=", "AkjQiZO167JU7Iha8qONPkFcStFU61Nha5sJw5NK0Wc=", "IK5G6itwHTebynQx3NIx1aBTin320l396czX3QJRjbA=", "CkhNb0uGV41JGT5cAkhoC5YUlQ2OOR9SffD0eOxR2ww=", "BnF/W4adJlbCs1wB4oxWlysEv5fsp3YT5bjKkrz4Tz4=", "A3g8cTA45UiS3Sp2/M8BGaMp1jOsUz6BHlEYF8TEo1A=", "DxO7/sHH+puUEjVXGded63N2r94NoOcOLLMfdS5PnTQ=", "JRrczOUxfJiTdw8WlKN4h8/rJvH6rPm//2yuyTphgqA=", "D4JaBvxpAXyp5XLHMueqhZW+b2yqof3Jg7mvEoT2Pb8=", "Cjzy+zCtLHNYl12W/7iV3o/c1h9067JNPxzW0lHrqTM=", "AlGy4GGxLFYBnsBMVNdEbBO7199G0f2RI9b5G5v3ekI=", "KVFwLfoSb1C6bQRjvkyjThLsjeKBgHX7BDykcbzC03k=", "GCyfCICaKVPmRlzNNhtXyiilKbuVGjVWQ7cInqtxVpg=", "DeofZA4J3NaftFAIjNsGHfRjDbYpLx1ghcEdWua2+FA=", "FXQQ6+DooMgexwJTvBYCLdq8znBwxQnniqG7b0nhfG0=", "EXsJs0c4OXxhY+9kfWCWnW95fP4fS0pVtZSQqm/1WKs=", "FXN+WlsxNA9K7FeKc9huTaYcvU0aVLtfufrDZ4p2L+c=", "GWsGclE/J59dsgDRJkwDwexfC+AAJVo9JW7cPrcT8RU=", "C73OA4unkjAM2xjmidLgZ4oJXmnhCjpWu28rGMB29pg=", "COT7XhROLYZ8VcyyzALGZgYL4OvD9vqpi0CXSlPc2sY=", "JUzFOuiu3IMjtUakBRb5rSeirBr++drovafVai1rqmg=", "GixA8ZhN0jON5ygQIK14Tf2TbKN2qL80kcphywAocgQ=", "CwKhT17V++MPmLa77puiXzeUmUKAxjO33AOjqb9TIQA=", "FSKLRNuZFeVq7z/Q6WXyvQWBZj3Nx35baphpSAdEFg4=", "JO+PojIx80yYseGcDistJTLqEEjwpFw+xgXMp0F2Yxc=", "Jc0FqSZ+IeLQtX8i/AfKMyc4pulP3i7HL3Zre91FZqw=", "DO6mttht3o1jE/fW5Rme0jpmNphMi64BE62tmKz3EnI=", "ImPAcBtJMG3x139vGhRybStu9GW95LlQSS6kAvkBRlc=", "L7ZW9N8ChBJI+YpGMDaTN+RD0YFuFqPB8ITDjwBe4Q4=", "Dm+e/rQY+gtAFnV+EuZBR2C81FmOZB2JSqJFxvOpZhk=", "Aklsc5lRJK4ARBUbtpj1dl+CcvOI17US6pQ24s27gxQ=", "DfPEm8ZbcIe+yxlAmU8c3Ouxb08hEho/ZiZ542G9aV8=", "AjQ/a4AYbmyuoq1N8mw3Yoqv9xMXYaGA964oufu0sxI=", "J2uGUuYTPsFkgQ2vuqQM6Pw6MPeCZtjnxhsvsL6FRuc=", "K/CaI1yJ/r5+VvAC33sAQhS/ANoRlAGEZ5CerZXqhf0=", "HvkGTCD4Pox1gbYJrFcr3PS24fs2jKvA2/8IrZW3PnM=", "IQtBjil+7j2k6As8k34ZBvWw9V2sAj4nZGvB3LjPjoM=", "LKnm7lmYwq0GdTYkB13gdxp9AZ6Jptb3av9Zk2Zb7r0=", "F0ripdsy3KTVYiZXXx5cT7D/6n7ndksfUd3H9SVshqA=", "GGIxnO6N4+5NY4mV9pPzJFRqUjXSKVLN71IEDYu9kCU=", "EiGQbJl5jN62bFDxQLi1eeAyEozOCRebsmM5Dsr5zUk=", "CE3SWk0UGnI7Kcac3o4Lu1PQMZJvsNFNCRN+P4oSLx8=", "KTQa0E5zpuadOsZU1EUKOG7Sx5R7AXae0yTW4zE4FBE=", "GqsNyWUWH3fu+ND7TnLka/3249cY6sTlzqF2M5mT3Ag=", "GFLBJoYrdC/+PlaP4nrOC2df1d82FVpmCZmFxwDSaYQ=", "Am6r7lwaXBsPviJBd6x6Fujw17SMTvti7tlqkxIC8MQ=", "JotgenVJiqhqHrZdtfpypUtBw+jtnKWnB9dhE7zapJI=", "EKUFHwZP7cC/wOx7a+Vq3flNEHfdv0VqGA86m9UCm+s=", "LCeTjOTh4PmNXlM1m87KWpwiBmyz3Q92VHHdhf9kEhQ=", "BgOQogNFmWOO0NvCkDzs30kPHCDWBfYrf5W6+9Nno/8=", "IQnn3EqvbLKhP/Yrw8vQ680+vfAiY49eSA0BC+/+x8s=", "AQaVnhDOaBm9r0jNXBlDLTWsihZygrRMsKZwPuvj7Sw=", "J2rPi84muTIVkbxYg5JgW1Dff3Zr6QyDF6Ge6TyNy0A=", "JiXLG+Cf9jxeA0B5jRC3dMBDIdIjQOXujSzErqPckks=", "F1IjtWu8dKRv65kaT8VfAvrRrJuvx1x2yj2zpp3c/yI=", "Is1uF70UJrE+dCITYG8VWNVhm64l/sab4N9sMeprmXA=", "AzMHkX8vBYrmKVYR42A2qr25Gg+586S60+av3yg7GDY=", "DHTifVNqYnSoq5HfevudTr+UTGgVfEE1qBmTYyukEUs=", "EbIhKgjLh3zLO0pWOc54Je90h1+yE/B2E2nKXYepqAk=", "LIyNQggOLpYV1MjcDyDDwwBdzrFpfZYj687rY4um7vg=", "DWESTQbNdbqgjUY7mjo6HNH6O/bKUIOZER4gbcGfe+U=", "GKjM6eeqbfPV6zVAawzUa4fksI+P3JkekftZJKBzQMA=", "AUUyJsdXQrhA+3HxUePlNGZIuaB/wQqsMUhdfA8HGoA=", "DrBfUgZ5NdC1UXrduXrZE09muSHID75oVI4MCM+45g0=", "F4g6D6+jfQP749pkD9zfAv6oIrz2EtfoLgIX0420Ago=", "B1Fsuz9n27wFC9LsIbGLudDqmXF3BZWoXEhjYzsOGcc=", "H4bvlHFEOyalnaZ+HCoiPkV7rur/KunwCQxVDDC/4tM=", "C4TsY1XL+0OraXCdT+2QZoXwJhPZtIYS84zeM8aenwM=", "GsAWtA0w0mcjxb206dL8caG574BlzQjM72bKmM54lzA=", "ELL6id5FRWBhdqAEVozqbDOBvpYS6DgVRnzEv661hfE=", "AL9WdKXqHOb9TLdc5/JnEOUQY5s0NU5Tyi5mMbQE1eg=", "L+FDmZO9M3g7ohxewfKNq5cUej6GZIZt0EZo4EwBN7g=", "L0A759OMpzNnaKOpx/ZWaShTYo9DeKdKUt9Ilv3MQDQ=", "DhwXG6oLo+gl0kLR1wRUuDPD4j/onn4iPUjezYgX25Q=", "Fy/IYcgioEWdJ+B4P8YDQJ+DWRP3O3HVH/MaYvbk+4c=", "G7niRUozw8CMvjHddbM9nWZCzZsKl4wCUfW5HwgjUjw=", "KSk/hCLU+W49xpT02ZhGzNbNW0p4ZiYl78cgNDCNTDo=", "KbN48kRqmjHzfUdcgwaQUymU7bZLqkN5ThPx2caUnRM=", "AYqCx0utiqx7dheUdg4JCs9VqPlVVvKqz8IP2YwZYW4=", "LB/ATe2H432fHGOc7UjdjJ5GYYz0khhjfbVHVZIbFkQ=", "KeoOHgFeXK6z/xzm0nclAud3i8+j3AN3ytfV7+Z0sr4=", "KhdTxqTHxDcWzjNx8UCmWQPSKNWTneqSjsN5aGEPM0k=", "AtlKo7tUmNDXfvHvxZUFGbECk1DUdGOUqmjoUmwJ4d8=", "CPJpCE7mN2IKEXgOq9jo+WwrBLjbYCfuiKe+hQSF2/A=", "A6v1U/taS51Qk9O1+JihEaQmHCQZ8+BVBg37RdgufbI=", "G52E0YnFoivJvikmYjNh/GvnxxTQeVNkJ/x6cL+8u7A=", "I6/CAEFPI+dJa0BGKU22kKYLz1y3LEGmHsc1E2XIhcE=", "JqXObqY7/Z5uGjcxiTjU3aDc1f6dbCrPGr3SfOFFN5k=", "In/AQS9x++SQIlIjeFnwuKaUmQMWkYrWcMNFTvJV+c4=", "DGtEin3q5Ir7/PNMt1jYR1aPddcknepNoJqQ+WxnK+w=", "IYyS455i38EZxMst7ZUS3CF6mQepqLDtuWonUWn46dk=", "EGv5KgF8MI8Pcm3z0FFapv7sHBgCDDgDM892wlAWu6U=", "Hyg/6hckTwQ7fDXqHnGTFknPcABpJUasVDplsYyjrao=", "H8X1jloG4ccOvz/Sosjf/nvfLCwXm4F/wfQdGibufa4=", "ItDXfwrkzZOWz82KJ6JGMDzscP7dVL7vbdhskZOP1WA=", "HOURIS2GiFN6XgOZVydumTWz6NW9RwRcbVg1EI7sXw0=", "HIPKXfasR3rnQjbEn5MJ3fUqQpD5x8HTCSwRMBLRw/Y=", "LnLaDh0dHKzJX4qRPYehBoivCtESlLNQzubRKKl0Qu4=", "BFXujnVSvna458JZfZeHHWECtJ6yzx3bb2gbfgWw0Pw=", "EHhj2vTKwxjdBqsU8TIVl5SQLjuNoXG4hI0+2gTmxEk=", "ATKrr4DjOsSJgtqdXS/pEZHxfxkQ+9wGcxcXtrxjqdg=", "E05FZ7KQ7ZTEexY/owSsjRTwD54mN19imahGdw9KrCE=", "DmwQCKbWzzBKHdnmGUo2DB6aptdlouUyihvitSNRZPs=", "L428D4bNMwij1ZipND1jijwvVulzbpHw931Qi/04KKI=", "Hu2pqcbYoDw82e/RvqfkaEDWxw1/qC4IW65nNH5dp9E=", "Hivco1idIrwJMVYig3/riVVyBah3FM2AEfsm26GuD8Q=", "H+uVkRIXW6byq9nWBR86/zKpxNpFn8XzuqFmt+ASBKU=", "G2pL8vsyAxuYN2VLH7qKygS2RyqR0F+WMgu1vdOt1m8=", "C8IHYmDbeX8E7y+mDGz10BTYl9MgK+AJ/F2Opg3BjLw=", "A5pf8yTKqdzWW4xEvdHUI7bALkBQrYrpMa3m27InPMU=", "HlDB96W9ipZhTqJn4MIgOctHCGcGOLFuTE5rS6CI/zU=", "JDFRQNseA9NKnokNhfs3hoYa32SCEhQb5vAx7dUbjAo=", "ASy281oY2UhccqBzxPkDfdZk2Y0BHokr+gbfi+ortd0=", "FJpSjnMDEZzgZt6dpBd4A9d04/Gyxtq+nt/7OVFIFhU=", "AJkHOP/sxvjcDmtSab0d3nTG9q/Ud3mhGdjJY9W2XTM=", "FbMZ5PUayJMe3mVC/5g8su078wdy5oG63ky9ZGWfx0E=", "FVM0P5Wx/yJqbYUyrz5InTBaCOjVxTJ4fTUaXDC0JvA=", "Ek1AwVTURU0Q4lT843OYboosobQ90iG1Wo+40ZxaIxQ=", "CGMmcvpCNqykP03+oFCMttOJXb/vWMX4D2XqD0jBegM=", "GO1CAuCB7+txBwIa7LcG9290ZuXjYQH9kmdMaQvaNqk=", "IrYtY+Tap8ZnTcl/Q9fsY/qc/gR+rWAeujb9N12EAJE=", "H3a6GIRIwtxQz+KrZcqmRihmxeMbynLRLNfcG+fsFtU=", "JZtJaPnkwyiFkLtSGyvvXzuxswpyis1FYn66RdcyYN0=", "GhryQYsezU660kxaVK3M0AkHKit+26wEoIA4cPzfIdE=", "E8SI77V22YsvWMJloNdtRQx0wBBdIlprERgIz88T6Pc=", "LgJ4kz2UuENMUqNk5ao51MAuJoKVgZuwpMmZsV/ja+s=", "JvxqD1YOV4EgLpXlhm5nnqOqSnbNi9T+Z1ULtObB21k=", "LXzgNU5qRX7V02Ia+5FzLQLlyZJIeGvougxR2mj+lIg=", "LeHbbat+ALgYOFlszmbouwqiaYmmk4bOUGFWDyaTz9c=", "LjBoCQc9SgC6voNub+SO6o5PoTuZMskoZB+rrUlE9Yc=", "Ibm8W6e94Hh6IKiqnvmhfVauKvwde9eirad1BtFrZvc=", "A34SI4Ap+70O9IoyV3SApNn2Y645oOO2xq0PjDkUxxE=", "BiNA76GjBhkQ/shU/1+pA33ddJ2f+9WmKA6UmLt7npw=", "KOLsZ1LQfmRXTk6SQJtBdob3JRJ/FWTRZGxP9Evrnew=", "EIHbOe9BlhqsjP2vuMR4WoR8ozSKm26vWpXg/088RUE=", "CsA8SK3Wh26ouEdc4W0wb4CupiKdCLPJhmYvu7eiI3A=", "CZQTZsVzQ8V9+GB4LVP+itwqddotDxdDZKBVqn6gfY4=", "Dck42mCrkYLHEhyKoEwdlVwfcpt+prvYw3uli3S7Tc4=", "B0Jr0S1HaeF0hA1KOmS0BUHoXtht0h/11xvn1+upMOs=", "LKNFEVOTN88FRxyqOsZgTvBwWz0uSHTbF4d/ajotZms=", "I9scEYAi/KkN/JoqvxGGqsCcIjcrWmgUg1RY0zwYM6k=", "KCtZliYH7TwzqfmjaJmiSSB2jmecQ7MZx4GswCDGhVg=", "HOxxmk6P24OD1URiPPsuz1wIet4DoSzCAgYN3yO6oF4=", "J50UkOgc7rc7zOZuCm3ZhEO3EasTF6MeosF3GMU06kE=", "Fo2oTrswP6k15w6FMhsQtnYHOSVh5v+6M2T4iNKnFaU=", "Fkx74TZ7Ig2qM7X49jfpIAxDySI/1xxB+5gwKHyvNQI=", "HAnpl7or0WJYUsUOHWq+u27Gxhsg0cyRsBUISUIWK88=", "LsOFou9Z9ZQWcRKxSR1Yd1IGNLsw0A3GgtCJ7kWDNsU=", "DPqe/kUHljgG044kZChzaCOLL5DhOublIOxfHl2hroM=", "Ivj+4LMTKpU7sPTUrMYhtaU0QD2SL5v1oi5RLMDBA7k=", "FEc902UKe/FAdDtDxYMhk4I+JQbGDbZp1xxj/Hy7Qr4=", "FvkTlaQvaKkSFIkg5bnDC1NuhPFcp7UJ4RXjOgjfRcY=", "DZ9JTuZ1wlDL3/ScvXhgNtiZEXUTsWDAJxyLpvrzDaQ=", "C/NtTG//QQHYTdB89tCpyeWrNG1fFMkYWvPbPhPWl/o=", "I0UogKfLWdOT5ZgCZvHnUsaGtXqH8EH3XvExiTJXeQU=", "MF8qFN8VkLqk1i2kwWhCNiXj5yHyDAwhoPtFzsovV/Y=", "GUfwF1qKnzvkkPYDiEhngVM6wL/1uHMKCLQ1+KNAes0=", "LeQXqWC1ZqvPhtmr9JrUEUTDthEN609H6jYiVzRedIs=", "E7iHx3WS8V2uDSD6JTMOGSAdVXLfJEuY3CsDvAaDvqM=", "CXs13Qsm5GgF4W/QSQzgVgkW5J7x68oh2rtKvyxEU3A=", "I3oDetlqNgrtWTfTzOOO2R5YkXsUPxcjO8LXVFbdQVE=", "GM3ANlqN+rz7BJQnCvSCLCmm2RJOjBkKnAtIJndK20Y=", "FjQov5ZghZZZAWE6HN7Z8o1ip00AHmaEvD9qR6izv2s=", "Ha4NFfoYIqXlm5QNgbOvJ6W9P33VCBZ+pgZbbUnDMt8=", "Aq3Zx0zyLR5JJ/rGdUtcvMFy1K3HWsH+wF/4/KDZd90=", "HttWLltDdjJKC2R7kGkP4zZAeNwhLeCtNvX7JtFPZ98=", "MB3al+KQp6AewQDlm1nXj+QCGXOvHZ59EBIx7Y/pofc=", "FwoRXn+w52pO2wWsCA3STdtcJ8DJSzs2715uxU65jaE=", "KXY4FVd1nyTamfruLWxQWb7pOaZvsyG5+ypgnk1H6fQ=", "CFjHxvn+x3zHtsKl3y3WMSFAcT+XzHyFA7TXxsge/6Y=", "ElV8YSwPdxjsEScB2AV6HcMBzMMLLIR1pGvK01FNOaY=", "GrBj/9/6IWpbzikA832Bny115vAMZ84CS6P4Mt5k3LY=", "KEk9BGcgaMam6U95yxrx1BUrgjVGNjWJSZwKFBvSpYA=", "Aj755dRog4Dd8sFsDQioMSN+5Yd1eXxn2VxuDY2K80U=", "EJMyUQByL4g2yvML7lPA7xTrGEEL+RVXCzJ//ZRkpcE=", "FwVHnPO9u6941PED0460dBPJM1R4ADgQiT81JZ3ejVU=", "AIlsK3nP3aXrf2+e3jq0d87uKziwaBdPFaOze7izSOY=", "FJ8TvD5OKwUVs3iidH37qQ99XHcx5Z6fNr3j8E61DLI=", "LhQiJEi+UMBo7P6/cJRLWTVAxylcoOR/K7f2MZm4cS4=", "HiLAOWAkuj9tsYGskrIppRhxhwM7E4+yehz39thwUNM=", "LFoeRTQG/NpdWGFDU/CimEL7VK+I7Etz93eFY+BeB8Y=", "LQja5vH7fgJQpmDnGxzTGFPCJ7GI2HVZIWrxxGXYq+4=", "IVUzp3d2ImZkEYqAgdh+ISoSUHZhOeo4x2n5PKK017M=", "HLu7JvmRpyHHvfg17J0e4MB0CS/NvwB55N86wocpLt0=", "CPV73Dx8lWgfAFUAQnrVOZJZ9pEEwiIGrsL5kSKSTo4=", "G0WTjHuE8BdvM1IDIVANEpfPl6pmmWZP24zNde05kS4=", "KusgkESGjKhEh7eRbmtAM+5svvcm4mnQ6RasLP0/ut4=", "J2Nb0q5+DKyv8Lg2WWYHp5JAPboQrDcGyeEZd0A6PrI=", "IuWTt6Z5NQJ5OBSb8W/OB/6ecmBV/AzdB+fqoX/lcwE=", "F5WWK7UQAjahg95JFp1rg6Qn7evSNxG4lpTag8vQh8c=", "AHf8jXzZrbwoPCUyG/N1mM3yiCftNXB89Ih/zkcHxDc=", "CuW0lNFm9qMkQtHQvVm2Xst62PZXG3dIakXs2CfdEoA=", "KSQim21kgYT+Y3Ga2nBB5pJyzf6JVFXXfwFjSouJLIc=", "BR6ECQPdq9vyIQNnSTNoUUKYHAhSpspq8MjRWwaHFtU=", "D8UIt+Ygu2xHqFlxv8vijfYmGcUwloXQoKat88i/L4Q=", "GfdiG71lmyfRibsyAQuV/CvYdzkuK1avtVisX8Dw8iw=", "MD6Y7jW/ytKSaAp5VuC5MvfFcsChMa3sUAbY8pi3Ibs=", "GnglPlf4JbDLx0LYeSOyfFH0pTHRI1qKkB2ZfjGy6gc=", "FeIgk5umSzo6sp3r87CISkxDhadNhF4g40Sef6LzkyA=", "FgSGtuYh36DpASOk5D/WkiHsGw7HPRlkdrUEvM0pC5Q=", "K+60JATbirXieWJLrNthSyG1rjhvLCo0p5j+ynYxEAY=", "JLQHUAQW/7BFmx25dAZwvbi+itu0/Vr4/pxLXsAh8OE=", "B/X9rpiChcSbz//yP8ESO66xA7/8l99oOaDDUGt8BCs=", "LOm1oI3szkuFPmfSivbrTHVce+6BkNeAavBCdZo5lQM=", "HarckRw+w7jl9CyxIwF/H78W5KouMt6UsBgSiEW/0CI=", "H/gLFpYXt+5arvvuZ6pkvWTdFO2O2uFI+ZoW4/IgVlE=", "Kv9ozTjRiLirhcAI8wDFCIJJi1Bo0807grWuAjv8buk=", "EU0LP1TxTeRcxNtaH+scR1DqAkfY8k6Pb0ctkutwht8=", "ErYHV4wtNJtp4PdWhQ3MISWPha6NjKqKOgIc+NAqu5w=", "FMaS680H/O9VCSu+lQWJ9H3+x+xPOkKUSwRCaQeVoFQ=", "Iinb37kq5+uDROtW10bQcGdjfXX/pDnts9daiwgZnyA=", "FvRkisR8GX/FcvWDUeSwB3OtmivK0ErA+HOlVrbs9r4=", "EtkNVcjT7BhN0E9cautjm+pwp+PQE/yxdDfrpmISL/Y=", "BOLEl1a4tawmr52TlBHK+H8VYm7EQ23uvH3AdJBFIW8=", "IZF9cjoz2yZrB/gZSJVcRd1QeFfp5ZgYMdNcVtvQuzY=", "DRO0aqG0EWj4G00jZRImjCPnv8QQiUi16fOl9e4MJmE=", "F71zEnXWAtF8objsR8sS3xpLy7njsCom+GoIsu7x+3A=", "AkDuYBpoI+xpikvHdOba/C89HOwsXIn1vRNim9xpJ0U=", "JmP/nQ6qbpEFk9EQItPHe4d6O+2NAH9vwgeorXW/JSw=", "AsRbU/py16DXokSrOrC0H8QOnMOMu+KU6MhKcsfD++c=", "ELuKdTGrBdIocogPloNNI6MZN2I98/0pU4havd0SIrc=", "IiKVDIoczBwhIqNT0UgnRNQuYSVN1lO9Ja5p0rp5sDE=", "LD0+tyBTfS3ee/uO9iZdJsnW2Rjjfy6XAw+9awRFfbQ=", "BTmmluFRmBaTFClt5W3IdDEuGeWzUY711Qpyz5ijCJU=", "JeKl/h8VWi7ur1DQFmT5b31ncrEIrFxMv6XvWh/NWtE=", "L10+h99pBKvUVO/KnMMPFUFkIgyeP+8n4YEuCHC5D8U=", "De4g5HMcDnVC5OVD6L5sLt5x1uqoIVluT8nmjoncMA4=", "BhRCwTudH7M5YVzYr8C8nhG+dBy/y9KzqSGUA06dLlQ=", "I6VhheEtYjCg66981KAc0YQQ09LKmR95r1cW/iKZMSM=", "AzRLe5rbFaO3w9ZP4e7DU0IgLuPEo22y1J6B5RdCNbw=", "KEt1HtYdSEuitZQKGh7h7FNtOSsRPQbbSZWwirZh5nU=", "FwGtJqQt539NWKTIGR+dRzAwnF9LzQxtw6Cqs5Y0CCA=", "J8rdpRmoNwEI16pukQL2sp6PojhswCllk/L2NEn/PUs=", "JibWHLEQuwOzJxLVnw47Gy9bkFnrmUgHsmfkrSYe1pY=", "HPMzCJfFTyXxX16LjaV77Qhl8/qEHsSEQanwRXkVE44=", "AbW8zp1pnlWkkNPYboySyDpyVqf+uf2K9shNaOFI9k4=", "KhdRBdFbo/7PW8snRrPIH8jKRo0dSqmZ+7qo2BEgJu8=", "IKI4IpXsoKYciIzvgRFa4GN9fseS0w7Kag8pinf5sms=", "BRVJu5rbzibkshiynKeeIhy2kcmrWyeGI574EmutLlE=", "CBylNJ5k1gvKCAv8U0yLMLGL6kMJzwL0THEYX+aI4Hk=", "KFpADWGly9bKe6p8PJrKVQOxf9cC4AQgvOczI4LAuC0=", "BOG/jJVbw8hwgmLj/xSL6iaK22YqwkWUeeavLnNECyE=", "C74ZrE9cZ+nuwyyea33XvIBZyR9QGy8mqSswvCaLC0s=", "JySsWOHqTfGeZkS457dmXZJI00/7v0xMqJNMYI0uj2o=", "BEZ4jZVCav6oMNGmyo0tCFv7QzDLJRTf/WCpq3D/9wk=", "Dh7PJsKGyGq9kQwrN6xAv8DmXLKRQmmmpqrsXN/1dY8=", "KaJn3J89EtYBqEkUiiRJED8lcTCDsWEcOG19DAXqS6M=", "HcNKYOeDtdr0ISVYbqKltJ3Cy+udK5C6iBw0zrmdLTs=", "K5/OWFNL9KSGwyIPD/kCb1eMqcQ12DIQJNEO7IK+Tls=", "L9nJfwEFT+YcpeB+NoHB3ZqdH4umMN0kylo0TD1mbRk=", "AE5qcUbCrAFQN/CoLBvHRr+0ac7J/uN/G3CCOfQz5kc=", "D1vrogIK/ecwE7fv4ME4R2LbhhLa4FjQ+EnHODwHlDw=", "HF4ebvG+Gq9Lbg0y1ZDcWySeGxu899BdPmDGPgoYZn4=", "CVZ1xuHo9tqo3UIGCIOn6XlfG/iBCV6YSX0z/VyM+nk=", "BgCTzJ4fVPe7p0r3GOGaEPAzGYwi0h8+6AJxJYCZ3Mw=", "LESjXKjiSp9Qk84cuSyNCknFM3zDYBxE5PEuBErODcE=", "A+iWI0d8XxNlu6FuyxqKWnDj1cg9UPMHFaQHQ0Pmj2g=", "GSX9WG5ngzTRYYp1Y0mfa00AHL86+yAjKENfLUnPc0o=", "Ghh9Yt62ObggFo6Lclp2yW5Vam6QMEoayn8ZcQV3Gbs=", "FyON3kR9m8bKtmOVf/VMdLR9U7rUJdw7wRSCrUSEqg4=", "LXoFk6Vr0zfn6uiphBgad0ZYkctpnQae+7zocRNXApE=", "J4OHxO7uas4S8GUxoxK3d4ley0NJW/kKdAtf8linM68=", "GBriCXCZg72QP0G1fu6gVoSfSobT154SiSpFJQ4B9Hg=", "KGeTTr5mwzVmOwOMliK0HLa/iEAsBJ6RgB1BbXNEGmg=", "AWUYcNGg19BaIY2BHkZPxHZ+eYBhUV5DvgFsZnK021U=", "DxcJX4orIe3VASbSdRNPKc+5EaeEbVzy2nlb4MGnACQ=", "DynqQAl7NPOdAc2InmMZcx2ncwIXFxPimQ6Djty1HOg=", "A0UDQY8nzPvcDuJSkRLVdoCHNnOGMVtTCi2aBStgiQE=", "LaZYruodt7IGbMmCo6SmL8Iu6papVrjI1Pa58Wm/NPY=", "CZiR6PIgW57bc0+wvGyOFNTPLreFClSW/7RNrPvuaHc=", "IrKFJ6nifWW32dQl9LL01XvNw5AInTqyEM9GNzVlslE=", "JKxBwh4DLxIF9Ik4obqJJxaujUxyMIZLhvO3VXbSSfo=", "Dv3hfFYYm13I3T/J1Hlu78fdUjR8DdOtBlOMLLzNhgE=", "AfMhob5V5LQcXVqZhdRQ9sI6LbWAzeH9F98eoW85OZg=", "EoRjXoqhfjS6sWH8WKPoXsJpEjWTeXpEYi9rxbFKAoo=", "GEA6Xt8wy4aA9+uGJkqg78ZCLqbzTv5V+Xg7trzKr1w=", "Ka18Xnxe6TyWHUtnDCmYBHF0u/p+3P4osrTRnzyV2ZU=", "JoW43scQnACMTrVZrviyiWSHOAh3cNZaik9h2TMwnOE=", "BtGhvKdSLWl6k7RIrBHZWXLic3yfbal4lAjvSnAcA+A=", "FZ+GKURrJhsX8ruphnnNIV/xio4ioK3a3KoITKcoviw=", "IQDBYFtA4WRMUnVx0fKiaNF6icGwJ0/ePBhWdo4TQ2E=", "FM1YN2PFqqWWWmzYENOqcI6hsB6GWthJJrbdigwpfzo=", "L5r98ldfhESXzPckzcBgFVsp4vRSyVAGv+VNRAIGgnI=", "C2zj8G/CO2HmlJCGoniRyyEycw1dl2xNA2x+Wqlg7NI=", "IJakrOGcx8DZTJdYT4vR4aoPOKBbpESxWMCk8z3vZfo=", "F0KQnSD58X77XGzosj9rhffbDgERGtgOkQ2nOHkmvsM=", "EzxIbDvp05kXbIl3eHL29lzEv6QaALEaKwfbeVQaTZ0=", "BgtbyblPRUldbj+tXvfCDB0wTD0LXb/pMMiuIiM/w1g=", "FsD5KGdpUfrrsal/cN2GuyQ5xPresmAo1p8zEHlJ3Kw=", "BFf0Lb2nyzjeM2m60TtoMhdiR3FYw9my7cZXMdKwxD4=", "BbxT9L84i19HfVv4xd4efzjvD5THddc337z+QKf8ykc=", "INBX4w4lY9fbxdJkEibG9gALy1Sefc25t9+Bn/0QvNs=", "FvBXTnwTtBxezsw2+VkHGcMfKUNac2wzrZrBr7kodYM=", "G5Yp1WeLGOyl+cUkStvCh78bGolGjlSdF2WDXbX9zn4=", "J9gPFWSI/ZA9B9LGRGDdZE1H21lz0Mc22RTj+mD9ux4=", "IRl7s/2LZthzUBnN15Ec/Oq6Y7SdzQeRDkjJk/552VA=", "KPX0lyjallMqZqLTd+spnekcwdeHAdRKClpcxn3ev54=", "Flu84NYtaEESQnb1PLKIg6xefswS0SUU4v6y4Zt5E/U=", "FJN4B6LZ1y0iNGmcXzsS8bcuKCshb66RDbVvaMraS/c=", "BxQvxJAfDiFOxMdPFoXDWwSFUWt7gn116huAHnjwRF0=", "JxTWp3rArHZsTaLPRoxZ/Me+OckxKbnZJ8Kr1oQ7ulM=", "HTEQN52Xxcpw2nsEiovIWVh6+Xe1+7g+rw+VGx2yzGk=", "Ei+bSABgw15rGwuwISKRsK2+JxnGYOqxB6vV5jLiuW4=", "AoFfdvPuypS48sQpgs8YLJN69e+8gCYhxK2Qh2A+W1s=", "IorO9ndGa7zoFgvVnJOMXTQAwkoQ0aPPFFUZzhOXkEs=", "L28IAMc+C1jE4xY5wdmOV6odezjyQZjdq0072tixsdI=", "EtywC5bpcp4+RA7qtW0jtJWSyNMGgm7hjvyPf7EfzT0=", "FMk0/duek8G1Of88cmkjF9DDZf16cn8rDUDgRC7mzYI=", "H1tI+7EM6g71mtmxJIPte+XGAVE7DMzhzaOoDEWoDGI=", "B2iriqXNBA5e5d5SYRENIru9MMC12co9KwdasLDejzg=", "K4T+AsME8k+twe3AaR9b/7BQH3voo4HQmaZ6m3qHA0c=", "GCfRGRsV3PUaIAvZaPXKnNH5bD/Xnt1kVAbKDK0YJRw=", "AWlQoGuStUhe91nQpDlFxIIxsP/eWyKB74fsoBgL+t0=", "IRKX2k1wz31D88zXCojBUiTPBD9vrqaKdNb+KCqDFgc=", "ChgSF9ExX8P+z16AGBS0Bgp0L4GGiT25Xzn/IXIeTYU=", "KGBY7WME8Syde2BT5tInnTSgwYfwKYEIVMgJSG2DREQ=", "LNClYhMmePX4QM2iTaTTBgY5hB9TxgOxp61Fn4Hd+ak=", "Ic4m6OfIMEXZ55QozZBa1InfvnXKwf5YVAhnyG7zATU=", "AUrdxnqekj/4kO0nm2opZWsRRe4qIT48BnV4wXdYxRc=", "Cvq033kR0RVPm1ufnUTQjCzpSNDpKgbjpGbBKTYY24A=", "B1bdxGhmuiiuICmerFjD1Y0HwMaPhP7Zy+MGoLmgAig=", "FeoXfYvB8lTD0pDnLY6+b55fZy7E+lu1O/6vvTDEEic=", "EtQZkqzMclhnHh6mFn67Pcmf5idcOPEvt/zJlOMmMCU=", "BXCgcCHn8Ml5rkfUL54+NxJJ6ypYO3Bggi2DTmic+O4=", "IbbpxNbcd5gpLkkArIn1um3dw9J7u1DEX372P2Pm1wo=", "C9c4Pa6P0/GvFpaklzusWjSgHFStxz8a7/1fMfAfwfM=", "Eahm/Vnluh2Qw5xaSkFeyDA2EfNFDVLwSHqnrMgt7p0=", "LjMOD7KVXYRzrZ4bpiM/2vRP3S+hiNSkrtFcgpebM9A=", "LsYUFHZSRPa0Z8XyTkQsk5wEw4Ebmd72TVKxpPF9nas=", "E3p3CDjYUjcE53aCfcNy5VqQ8gui3VEyDArHg7Ajlns=", "HWrlI3u6a24yqJ8wIAIAr13K8pQBmGjk4VKzMnZeDIY=", "H5A3+RiaU61Xc8kT6IrnkQ/QICmaw5TuLk1wO2L6ad4=", "LGASJZwzKBx30CxhvytLPbOzMUZVd0d0bJ2x6ru3z30=", "Ehffgw7FZEV1IJp1q9w1+mBrJxd19G7be3dCtXPSies=", "HTm3IdSNO+nT1RVcWMVFSF5x0APxmp/AxmP/9X+Py9M=", "FE72tSmhnFXAfkHShZ099ysPdWAm158y7rHa5XInwjc=", "LSZpB9mG1+BzA+LrRbZiDQFkTLjDgeo9FzjXZ0co79Q=", "GzG2O5yXNjZS5kzgS4RO/GpjsSLxZP09L4fUnU+w/mY=", "GoxFKjGv3GKiU4DXOMbPTlhBxWINqxlBAigJRTfs9Tc=", "DZ2BD8faWTHHpJB5dre3f7aM5/qGBDWRDKNGqqiyrKY=", "FecwiEHoLLRK0AukrvmkJBAE+K30loGQMjdaEP7NyKU=", "Lhf3GK6feJfnK0gfDHeahMQb+s7bE+CVMKfRb+NV92U=", "En5//G/4uhlMlCLtVPYbY+WMeuZykoDRtuHogdTQL6M=", "DHMJmevawVC21ef6adR/CQhj+rENGUmRGgAVbTKFk/I=", "ERQYJUudFu+NZJxaL8QTasV2IZHvYfHvRtNe8Zn5Kic=", "ANDjIy976KlWmbm9EVCP5JXgJtqrue/JNe58S3VLyEY=", "JRMOl37E9r60rk2/ZPGW9I1g+Av4DI1fIoEYODeQySc=", "DL0iynAwAHIWPsG2GslaRelZ9qaEPR96j+9rWykNtMo=", "DE5ccbRuJmO8iTkutXdcd2nAgFUdIijYED5UVUi1gSw=", "B2O1VzHRBSIL277T4PPY3JIbSrotW/LVmVMXo51Do9E=", "LleLnDUnUCws8kj50l5ySyUrH+pdMLloQLFCsGas8UU=", "LXJivYnnP2T3hQ5Wq5NFN/Ysr69RFhS8iGmHXjOmk4E=", "Iz5e85dmHHNDP6xJC3KjdfMcb2d03WkzADOHPFmo24U=", "IEeIHVQrv5dLnp6SAUU8grV0RzDueNL8Imv3Pcckv7g=", "E5LgnY49aUN3j1AjrFd+1YVzZA36jPsiYd7lbwIMrgI=", "ETzlZB6MCEAe2/jkClj38ZhIbJQ9mItXEmXaO4AJiyk=", "Bv40ruljMsDbqnVnBPCsym/UiLehpCS8UHWa1m3z7PY=", "IQ7tqQ3waI837n9NsBL6cFHar9PU5iqKdarXPKDEWAg=", "KPVTEcpSbjnibjjiBlhh887B5ijeRvQ1ZEHI7NtxYXg=", "D7OoCktSiolVFC5kIZSsSmT1s0XIbgzPcCUAFgUtlTI=", "H2eKV6dXdbuzypX13sB2G7casUffEH+nX0Oq+TCuo6U=", "Bz7lGpiupOnOXd75lhtZl3DlgN7lyykWG/gcCqdLpsM=", "EjbBqSWazsUKBPGTUGkYmQ2hvMnyO6/HdIA63qQX6bY=", "Fpq5pYNVV/UYoXdW21V16agnMRL1Sx9jR50mGq1deAo=", "Ij3JefKDNWnCQTD1mTagXaqkm2EMevHfNzyBrUGHbwc=", "Kn4HxCsmT4hHUI93Z/rSC36FM4p8x7jbnPBhWmFLKnw=", "LTdMnsFIL017DPRbX2rlsJ+bTF4NPkKGRoIv/FgzILI=", "F3IqbJevNhHDHi6cinwb4s8bHmeSDMYZJSKLtrFxn8w=", "G+whvSt5vwqrgk0sc0Ob8waXmVB4nHYtPyRu8XJmXGw=", "Hk9cTBUWaysNDy4SQ85eTX3w5AhvG2wTwkdgwjs9K5Q=", "GyZtagP+amZ+W7uu0kB6ygQvxl/1h6N0WSQuNH2pCKs=", "D4LrtKOi2cBhIx0HKXTaeGdGTUWgksNpM31vfzjxnU8=", "A18PUQ3wU62Y2VfNY/LFEay41j+O5zTZuc2dPNpxfFU=", "I54iRkEPkKuq3CVtCtZJRY2KLzqYtoC9yGSDKHBuWdA=", "Iwpk4OOVMbq2noN4vsXs1F3QT3uRomTUuFKxcFCi/n0=", "IB2TWS5j3Y7ZftoMHvj1SuM1VugLpR7Gx9TvU3baJmk=", "G/54xQ0LhVqmmIXmNTfuy5hMGOLJ/99vdqDTjNiqJKA=", "MClwjH87W6/FwN3Nhl0XThuexxJq1zDBJCdMVie4v74=", "FaBpLid4DMFU3Pt7zKfYxp1hPtcaxznojMrVMR1Bk5M=", "FYWAiFtFIfqx9ZJVvHSsRty8b2fkxbvjwEB/bnn5lmM=", "IuVCcJ4Taxj9qNHFnl34qe/PImKWzmuZ8MWkxtjFv1M=", "AAmE0YTCCQmxibVtieH+MQdLcRsQaBPjGkMPkjSEX8g=", "JguywvVhr3tLujwjrxRGDmP++RkTd51quHgAk68udsg=", "ACbi6jcrSYIa5Wu+GXhuvyHEMmwYjEe3D0ey0SB2XK4=", "C2xNnTb6wwM52Wh2owQCJLrzi1n5b9CqAq6jCuGi9NU=", "LPX8PXXvQrWzdDv6vCFJC6uai9nTgob41uxls8E3U/M=", "CEaqaqIfGMdAAPBEFD+iZv8ee+e99gC+Fs5P3ED/HmI=", "AC+NDsjPBr2z5MY4cziU1dCpUgTWSPvOraBTrNnTukA=", "HOj/m3S3nEzqC83VgGP3RNuWMPO/WWPxy92Vn2ESb4c=", "AX15ER44VFLmFcRCxu8IMzOoqeCGKLvh6E9N7nldwc0=", "J9Bk37CcUTSMlpKr5059t9iZsG1jrxA2q3SVPAizxVw=", "FGh0po3zNGFpJUa4i8B52Flh6kYvDEgX5RIddOK/L1M=", "BStjUsJ9CA3PXR5QuHcMG/bP3lWbJOff3RfTc+mpSFI=", "HnQ4lG15zRkb7w95q0+WBGaTZ1ciUuuCyw87GdRpEVk=", "BHCdoXNvrvQ9YW1Z/hAQyS6R4UEOXdmsN278c4ZwJCY=", "KDgdSgKopV+wa7aWxefsILNjYviFt1Ox3cUX24E/Yvw=", "Fg7PkLTieknT9Assvp8Katf7qCVrmlL7TL//FQekcRM=", "Aw5SHZGh4fiDbzmydzN0X9+W0IZ7v9bMqrzJRzWkcEs=", "K2avMxg6pOU8+2ZSFvhrRY/T6QnZo7A3WLrZ5EZXxDo=", "HoUWsKInbcupLYuI1v2PmwTWGrNnohBYylvIp1Kqu1M=", "KyFytzMR/07r32uJr1FtKuC4q3W4rfgETrfiDVEYJrg=", "BkwuBjaEWjsikSyLqpTDnhTn32u21Sy4kUUhurFDceY=", "G9T4ln5EPo7+WhhgG/7X0r1Hs0xg3/Cslk1qTrBZtBc=", "BO/CNKFzY1S+EGIOrbD6+/AwCS4PFvU57alYJ01UNDA=", "L0L8HwXZDbzkE3d/dKNTxX6OZjLTDiiq696IuHjfRts=", "Cj/cay1GsAR3MfWZTxk7Nf0j5tTUkG0GIr6W8p2bU2k=", "Cpo4Gm8r5bcUUDFPNW/M7v8DGqRqJ8ks7O0s67VH2WA=", "K/Kg06wAvp5bwGCjkFPYX0UV0+zG7m2ZJcVX6z/6SHo=", "FJzqSsydNFr5uqCwqp27OidTQUh7SAmpctTKSf0Cz6A=", "Lq00OkKw6lcOGzWvGck7DCX1DxUDz0pjfbuby1igvyE=", "HBJ1nGwzycv2rYka2xzC70Mt40JRhlH4sVdzlNdSft8=", "FhkjD+r8gQH2vHmyxyBOuKiwg6OMDUuudLMfzTU9h5s=", "K9xLuH/s7KYazgmwq+i23XXPr3ulkfAu61Y1gI7NtG4=", "HYM8cTXSdhDmly/fAFeArkHw+Y42tiUZeLa/ldffaj0=", "H/ekWVJueWOW/MoZbdBPgbo0Af7Ge2ttg0IumHeCAJ0=", "JED7tIds82p3GuE1lPMbBvO6F0jMsG86Fql/lNjWayg=", "EOXYSxGrhkh5/tBn2igE91yadSc5Ec3ti7VRz/Prs+Y=", "LlbBgw/mY3AwZND3dIC8eLTx0Xk5Yp/qLp45KE8/YmI=", "CgmQJ8pvXBAIei9LOMrds2a5jMTdDqdPCIGedQKfRvU=", "GpdGjY2bhBpX3sJt1PF6+GAt5pX8U50oTueP+FKUmQQ=", "A5SmRYNJpST0mVx3trf5zmRVohYvE3Q4MYenUakINY0=", "EhbPjweaCYhSY1KWQy9XakjG3N76rHC9Y8D4bXnelZE=", "IcU6nuHY9xCZ/RhavpdyYjNDuLpl4/lpq2ZcxYwKYAM=", "DQDh7JkOvVIlxwmQYzLsIYRZ1FKjRWDAAKQUH+kqEnU=", "B5A232swo2tPalLMh2sz7IzBO+7T5J2Za8MRMOmUL9k=", "BzFskNVwl8IUB+ZHwSkKQtV2bUOo8yRzNCDKvazBZYA=", "LKqF87gTIAG7D89BFNhNuo1qxhyWoh8xlddIA4VwhbM=", "GlsyoSJpbfBDD84jOr/iH80R3Qcx+Wn5Xy6SQ/3ZjfU=", "HUanYzQXDPC1i6DN11sx+Ds60rx598jJMKXqywugLho=", "DZm/BIQ3o8xx6mmY+JClMqs6EgJOIw6FNtiovvCE6VY=", "GvwvTIuhJuMExhcm/sIjQfRHMCoka5IuM5zYe/Le9WA=", "HJ8R6GMc1GZNqbz0W97B2SuoFAfnEyHHJ7FMTFP/SRw=", "GZJo46wUtgwqKe/hjqh+wQhyHriB9qSenWuhod2U0+A=", "IsM11Hv2cYAx6D3kLUergFvc4D4+rLLuil3YjK9dVlc=", "EWC/mfD07Ae47y0Vvlo6jRz6GS5Aa7717Y3V+3XbQbk=", "IlTNMv1Ah7cTh9rDVUz8neABlPdHL6Qd5nTYygHL8Iw=", "GRl1HDeKglBv4wlYo2vW517Gc78l1pPZgDNgLnPWR+U=", "J5FrPkoMiZIjgayUzfiLOk6CpTn89ciZpRIKY8tPdo4=", "Jo0/+eGNycNzYWpqWhuByT7CCNwENBRVcxDHSbd5hcg=", "IShtUdNQR297Oirj7ARsE9XJERc95BrB3J5Zu7pmnyw=", "IPv41oQ7rIRLbLYyT3BUNEEl21TVYAoG/JtyDyIplB0=", "Gi+1dEOjo9cDCquBslbIuahNpyQDagA9Q168rMx3T0Q=", "IbE7mky46XErvOMvF49ZB0o1qM8HcQYcoHZLaxkPoTk=", "LHoRgVpCADj3H9IBuqZBKsKSpj3Z99MJC6FVc7ujxdY=", "GMljgJRibbfli//XF7EofIrOcGgjJTv2+Rygajf3+zU=", "E2+0q8TglPtLW/8j3g1Bu0dkSB3nk/govz2fnfGqHMc=", "A+wPeb93ML2hiKARCJuS0mr6pbrWdyTY4ZMlcsZXlqg=", "BinzBtixoGgsd5TDLala2uoL5IP+T2McK53CUFQSV9A=", "HwhU7mhhSRchaEJwh532h6EsKKCnk1wLrAly6jmEENY=", "BYko98e4UDolhaxDmuTtqTENh/lQQkAv+v6Y70jqcTw=", "L+Wk+siIz436ms/O4kn3iOhsBDRBzTYj+5cu5Rms4XI=", "KelUBFzMq5YS/4QCrSIsId1c07NNQVZUHVAk3IhbjZg=", "JRo5YroPPp+N6IHRBGQ8nDknIJIxKip3HxF5HmOVeyA=", "DrBPiVmcuhAO5bvEcE7GONECxnAQg8av7o0mzcZLEB0=", "LSBX67SHjEcxMwD4oWHG1rMAjCY+c47Rt39uLSNosII=", "D1N8doHqrXUgYfWUahDySPiv4C76pyTZfnY8yMCXFVY=", "HkC5qgANcNbuaA8j00ugfqBDVht56LbDBvp4eCMvHPs=", "GqOPShGfqcPj/5nQrlSqbLEYDEHXWF704DNnj6yEsvc=", "BWYcAjzI/63EJa+O28WkWl2vZJZ7qwO5HG8jg6YZSak=", "AjxNnYCbDTr8HCfLax3sZj6WJf1E8fE4nNGyni2xUOA=", "CfrA65IxhQ3nllOTqL/RXdy78mWWJ43HibPkBwPbQrY=", "BAuEqwBzcQPtWsMS9dROJ9R0nNGRBRv4piMbtHgONU0=", "Li60uDVFcsJnzoRsnrIj44GWKLJkVtckSJnlfXDf+Ts=", "GYco7Jlq0JU8+Hv+uIEL5cWIrBC3OMytex+LrVDJfjU=", "L4qO5B2QqsKpHBzHB3Ltb5g0AFJRazpUvY3ziIcMWyQ="],
      M: [["K2/XvDo7WVwgbEParHUrdloSJVw3q1GuGDkzc3qLgJk=", "BpsXed7D6t7T8H0MPmzs1s/+eNdH+u2tnJBmWqLZLLM=", "H6Tv/INJjRmqpZi3dx+IoFVN3dqJ0y3Pim9M93bRO5k=", "AWdvXAdBerVMN+yK4agxS97rCZZHaYgVkgQ9/8smv0E=", "H057vI1Cd55Yqge/VP8yS4FP5oe0yOuBubfnREjuJ/8=", "D2sYyY/In7+pmgTIyWrl2zXClkefSEtoDfkF1MvR36k=", "AObNEIg+HhHGwZHTYynzDrAEWvBsLYbQxDn1wfT+9Us=", "BCWpZB+wFVi8cXCi/8JOtqUUGYspahYpzChNmDvKh1c=", "ADl6fXQ0sKqUE0jeRa7EQs1crSw5iISVDoIzxY3VAzU=", "HWbyCPwEQRoThcIuID3AjwusL3zZ36zN7CDTuTJSrQQ=", "DsHtOuO+rE3dH9sXucfGSOfsgYhaB6W8vZZ+ajZ281Y=", "Cz5gHjal2C4CFDYshBlHTcHMLA7YEmU01po/eQsnxgM=", "Fjy046XskuV7JbCVo6qoz9xM5ZJncYzGCQoH4UrxCw0=", "LcqQ8+WhWymJX0jXoSkNejNka4liDdCozN46o6UdQcs=", "LHjuXqFtOPC+udwHM8S7GJPLM/9nG3N6ESLWT3Kc/yI=", "KvMk7E+ed4bc8AQ5x1opS/91PjKSu/YuZkcfpzDxnHk="], ["ER0EwIP1Gm/fh0EqU39mAQdtYfQ1CU6haUbvv6SJPpc=", "GHquJh7z7iGzcCNRigcWdcbQC96CvX9UQUSKu2Mqdks=", "DaKO3n9j91WWolaLLdelhFduWygvKEeVsaeqIWY4IrE=", "IEO/5S0pZOSjstpeMBB3Fsx2T5sci6Rj8hWrH38DSYs=", "J7SKY2o5tRqTiuo+tVIJFVn7++ceCW1RjEDZCN0lcO4=", "F/51o9EbS50qz3hW1t6ju6xireDFATR7FoZPPHPrt/k=", "IybD3KeqtrGFJlT7E//0KhUsqWMhJCFsx8xvbTdSKlk=", "CAxEKQkif0qdqS4zI3+agssMb30MQVW96lxlF7BG654=", "KxwA6gCJP5+RMxvJBzl9uGXDfTvGxLObgc2TFpb9eDc=", "CS8Dx+mOYcKoWUP/r5wE27AUX8IFXk1b6Qu2i5AQl0Y=", "Kg93uzYk/EgmyaKma+TsddvCFkKhb8xBgtLWXA/Y1/8=", "EIO3QtNTMqi3m4Dn3ASnL36GaS5Sm2oexWhzNLYH2nw=", "BT6V+UVbxkmdRHts7dC2qtnLztl8zxAGDzye9R4o520=", "BZBNrjRw1AzhJ0myfWRuYg6FGeKxfPoBbK64nZ407m4=", "LlY7ncWj1NWpP0drRm43EBnHf9bupQYSak95J08va5s=", "FFYAg9mA0XLdQMlCbP9BRnrOpB1/SP8RrF/MCHui1bg="], ["ATPFkT8l/16qhg0DGPaktDSf0i8tU1MOXHhbcJiKOog=", "FpU4CU1PdSUpRx4/3cnvmUz61PltzH1jbw/VCbjrnDE=", "GZg12pX26yLFkevlFMfyg/Z0/Poet4ff7leBpk8IJDk=", "Db2GYlEd1wAJkbOdoSn50DtWWgzS8hjW6ru0miXxBeU=", "DdDBGPFa4H5dtVB336RuCBCZVNmeGNcs0sr2E5IOOQs=", "B8khv0XjVISKYLDl8pK7A8JGlJi5weTTIvSv0YZ0CMk=", "H2lNGsuqsOpbwCahhk1Wi+VVuJwPSbYTTpuJWuFB2oY=", "FgTeai2xIr3V2DlUChAF7UAkJbrDuF46ciJNM3QCvew=", "JZcM4xt7EM7yISZ7sb4WVuwpFG3wb9tbT2/mYHUjqgg=", "FJVvgKZbAfnul+LrBw6d8nEcuLy1ON2Y5TJjbMYHgug=", "AdeZroPvZVLzDtxHuegq3AUD3Et02kC6C70syesbClM=", "EkF8ABvoYZcBOytIccTpsNzrg5kZGanK+s/lRmb1kK8=", "IXH9EflEhUZqgZ4k0KzvCLDIfXi0bZO7lGK0Q/pAzcU=", "Ium/KqAv5l48x0+z2D1OM1GGm9MFKMN4lYr0Yu/WRf8=", "By6i9c3Io3ifvOpBSpHnsnu/sxUd9RDQgP9O98xz8Nk=", "Jg91HHgjq65huPN0jIR5HAvYSs9+toVIcCUBeOmlLPU="], ["CIdfR9b1GMjC31Gnhr8iB6reKEBnIo9EDn0DB1IKVs8=", "CmiDDxnApymy+Jvic3PTl64RV79QfneZ1CIBZuoJgtc=", "KvVgYAs+JavMf3ik1uLNP9mby6B1q4K1XphBvve5IQ0=", "EbM6nxgY7X9YHKwCAFHeJv4o3AvYyxpEV9WoRHvb1vw=", "BFxhf2BMGsn7jXbo04AyLlo7afp7fCriyOxZZtakx4g=", "DmGX/lAjKNDvf5uTA1UxKzRyBLh35/hdm1adw08GTBo=", "DN/gmeehVCeN+2wDiLnaoej/Mjogvmpqp6hDgzP4ecs=", "Fd7YWdUBwnM/6t3eIv82+oroWAOux6IE9CsfZVO8xlU=", "LUAmv6ezehmjAKuvLh1cMtvNQiQO2GD2gfYd1tYhTO8=", "C8y2acsBbUmEZJRPcZLs/2cW5stfiV0nFby7tlsSiMA=", "Bd4QmcZfCKmQrA8fRewvuHLHceECddzPpPzhFGY50NU=", "LEZdm164UteTOLQnsxhNlB80BGFyqCzOROK45cQ3lHg=", "I5GAdcj6CSm+/CsXH5nr6d3WaDWU75qD+E1Kz9lZLVk=", "Fdf7piusV75dl0UqPAbZ+nV/FE3xZkee5zBpZ0gKKH0=", "Arbxb4ErqQOQE1WVXMTduZ8k8cbiZDCUflGBGmgxG78=", "D2Zzt/tL6M3qdKqngCycc/8NU6mOlKK8YGhdiQok/es="], ["C6n0ShB6gcsj+6ZvK8NBUnKPX1ymhAZkmn7+R8lHPyE=", "AYrjkIbuu5jR/F8F+g+H3csUmwr+ONG7uFplaXiV5j8=", "EBVE0TFFTyC1SbJKZeyE8bMiH9m0NGHdxtFWgzs0xSo=", "Am8vWNY8pu9Zu5UgbOPtMSSIXsIXYrux2x1qd3HsZlA=", "Jbl0/FEp2CrkxiRuNfgC4DRA6tCZlYZTE8jKkcggwtE=", "LUCb94vW9qTspzl9BlAj8LtnMiB5JdPOS+759iHaK6I=", "F/cyzBNUsftHbnBWjS3LC2aD0wsCQV39OFUEc2qobeY=", "BA2w3v5rpHl7dKQxJc802GorM+eiLicQsPt6VWiJOqw=", "KeiQNJQkFKH/aDPW4idC1BBuD1830fKrgOVETlpSycc=", "Eh0rpb2PIy7PRKrPEETNarb5Px5TfX0VQXVP1J9RsiU=", "DwkT607n08AtjOc9HOwrbLsXapISmzSilK3wZiQ/9r0=", "Cg/mbA1N4AzHdhAIcyoAl/sU1kZfnR34NeBCP7IH2Xk=", "CJjtHsGkNof/aroy3l+BlDRSigdSs5KDMYmbBkay8GE=", "EeCyND7zcdLW0igFl08lObblENdh4NoXDQ2pAJWhMmI=", "HVnVwQsMndNHiZN32jW35nfH057xtJFmuXSn8ryZyUY=", "GhW34t4nEl8uanT07HzSRV8bv66xFV8a+Bm9tf5UJB0="], ["BUKDKrI7bHpLVHoQZgNxUqJELpmMU4G6l2mEExU7pvE=", "BMXrx3E0TMBhJ2VxC/yxwuYJerw9NG8ElJX317fwbLE=", "GlF0DNpeRepNS9e/XOVGamahGvtbyTzxDVMJ4H1BDk4=", "LrbtVoN3tpatPLI3Bk7GjjkMJIhuHxItIdfPMpDcbQg=", "GBWJsUDJEJ5JL8PsfYyo48JafOWN8G8T70NWHVjFkm4=", "IFptWqstIktmjHD8tBWC7p6+H/CZKStLxQr4spLA6kI=", "KCOaiC3HsvP/e5qo3p49ga9zbU7m7ZkdXGtPpUAUj0M=", "GrFfL95vU1535hXIwmAhk9RYYMwBWEnfV4+f75pbsoM=", "AytiZvJAF/3hsoHQ/iBt/zC1OdXFuhO1MS5IjY1vGUs=", "BONY8lmjMkT0BYoFYRCiaBa77Dx2q2pfe+k8ngyS8+s=", "JamsLR74Sr2YkntSwk84eW6mDmOFjsW1AZbX4WnJO4Q=", "L1IfJLwCKGriv4SE+7w5hDiGdV9Sv+x9PdXfeNNAch0=", "HcP3pllTChOsytGBtuJlR0EI2LFGkmZVLfvDjLZ50G0=", "K6OYRTk/zHdv04PlNdVnYhx/ZABag6b39IIivJAgkqg=", "BHMP4E4BCMmlFFpcSOYMVFfkcIUiFXv+D4KvXGZNbqI=", "B1oJ5B503ooqx/7ydZHnanfIUeGlEYXzHpm14I8BzHQ="], ["C6H3ZDZzYJUpQsy27fBRyPk3kGqBZkHg0eni7SaQb6g=", "Kfqn2tyLfpWI1KYB53vYCq3ycqG/7DxEPKPMrIHZ4eE=", "EyRVi4pdS6YbF3kBKL6fJEDACF3V1gZbiPCjslN72t0=", "GPqvHJHgAvfbvRL0CL1cW5LzjgLONjWCSCHgNH+vU+w=", "DuEoiymFXi443SYpKzniYFKYQTRFONZJmZajLnzFI/M=", "I4CrBR0KxYCn0Rb0qTN+sxCQpMfsvU5jjncXt6Ur8QY=", "FYkmuelLEPyzIbKTu4qGR2J6W9MTFYCNOXwclPZQ8s0=", "Jk+tzHkaoY52dRqJUkLDDNu9EZepCkVtwnjhC/C/9eU=", "LqAUth7VdTkiOb2UEcCmxCArczTPLg3YwwQFKOSj39o=", "LaJgOibU/ew1MYIEulBgZj4VoLHk2TlSWNXm7srqj7E=", "IKDj9OEknExq8QDf32P4vcaex4hbzQ0sLpjZj5u50QQ=", "AvHT7tNgGPlnlxHgML265RIkte+4sesc3KiriGIS8Ps=", "DjiLsQUkJAbjcggOmXoxOSz0/72caUFj/DZurncOQ10=", "JRQ2ScE+CNSwC/NNKqGo5FD4l4jid2aJYhcEcVXFvx4=", "EuwkI5uhsPyflSVQoiOlLSCdjSK4shrCSIGicZJ2vg4=", "B5wElE1QtHd90L6+lTYAZFzsqdZfugIPlzZRRr75xs4="], ["LgYR+kyjmF17+vUS8hpAgRQfTtDcSwIoNNPLbP2Lf/w=", "Ks80kwErvYGHJOfO2iQx6XyJM7+utddGO1Eubo6Pf8w=", "E0cwJLpBn8KndD59+PyDdaqxUNN1OlQlCoCNZvLQa5E=", "KUN68bFPY3ofDjmVXyYEvyBDn8sqCQ40aqZanr5peI4=", "IG5NRFMVt2QoDMZDuUefSZRuqG1zBLaixpKsNNfJjTQ=", "E4LDwkvySJ/p79gKFj5lARH12YheWKntcp3KH5p05Z8=", "F80Rhk/Sxz0IZ9NyZLTKFN+TWoLypvQyxJmBNfpfSqA=", "LeJ5/Pd6JwgjqRps0ar7WOnjqzL9/ws7BcmNVU22+tM=", "Es7VJU4mCp23q+DL6iY5ZoD25X3AdzKnVdQJ73USALk=", "DvX57muhrh0SZM8aNuD+S4BDqwvd+bnDIA+2h6jqXIM=", "BrfhjQG0f/jk7wgHjoEooGaTvmV0iUkqxBlahUcivf0=", "I6p8zDdRt0DuyfNaKZhryVik28fEsS6rK+g3Zwbesg4=", "InPDcOtYEMA5A2BdfMlNWpKvaqqnuETzUYnndAan6Gs=", "KnMQ51+v6QLiAoepGr44iq6EILHqRmDdfBWcJrljLNE=", "IAmDmXJe4V2T/9PkgeSnuVyMUIP51pv/FxTup8fYLUk=", "AsorrHwaoMZOaEEj8P/iIXOSMFK2oB88Kb6AE3/Ylyw="], ["Dm8jwO9vFZ3saDQah4MPuGS2wIy5VKFKJQCHZpeJf7c=", "I7NGEufQUvazEsoODPcANK0jLZv2PIiCEIU4O29uxKM=", "E/FbxkU99vk4NEZVBTTcV67bEBOeMFPoO6/dmTVhdfA=", "Dt+GvxsVmf4nxm80lIYtdd93ZAcKgmPPiHePcoeTjY4=", "FkFkjCa1otwpfaqm1N22ovJYunOPkJTnxc2m76jJk7E=", "KAxFIq0P/ZLDkelMcPhxILg0GJDDMprwUGJfK+UvOkE=", "HXcgmLYVSSHbjnUG5vA3LKRPIK8zhuE7z3H/XcDWGxs=", "BT7YrVUNiZL0uYFJIBg92Dm/NV6sqMx7BwIKImFKgIo=", "HU+bpP2M5O8ZO5+HD0SVYHlTjWO840T5AWrF7WOpml4=", "DVPWHIpSFODEcVJ0rWel1qLPufw8HnkdQd4iyLqEaKQ=", "Es+HJTkT1F0ofpdfK09bkJ0WqH2JyIkFf2Zva6YTibA=", "KwiM0woQiZurwyW7oyqjQ9Mp+ah4JGnE0l8PI3/2B/0=", "GZcv/d54mOyL5Pso5LGe+qQ8fuIMiOKQluvocuHBlHU=", "H6aURwP+ABKhbuYEJSn/AryAQxPvjG2LD5EKdeb0dzk=", "GCN69zO8REGKyE5iP0g6a+KLjyHQM/vwmdZFuiDx/CY=", "E9kDWg3HmLBNzvDwjt0kFST9yg6VupysBdIHvTF+Gc8="], ["AaeipKCNh+dfcgMCvq18ohyPfC7S3rrO2bixstpGHLw=", "EWgMxugLDkMKTNNgcBf6gzHYbE0DqW38GHZ8l8vgoZc=", "ExS1T4eGCWJEUyyfBUs3ljbitYv9zrPUjfsiELUptOU=", "EzayCOANjrrIMkapbr3eNRBj+j9jWIfnU6DOPinH7t0=", "GIe+h/ejUkEEgu873PfvF5duCH64mQx21+lxxEwEgjk=", "H0BalIMxHhSXVo8b3NbVjNa8gTmCoOcVYbYgADuIggQ=", "IJV2vnLbewyf4rgykSXn3/BImo6QCl8UwebkhgQTQmQ=", "ACeXArE10UTt6UMZUmnAC/Yg8Fi/AYbOn/88s4siJFo=", "AsnDE1z2S4nrW3FNey682B/H7a5jfMYRZZHfIItrJYM=", "JS54tIOK1QB/UYu5xqTOUBhx9xEo7uPwyXhM1ksYP78=", "KafVVOn/vuY5hnhC/Q59QeqbG8liG2VPyzmPcclbZo4=", "MFoMLCxNNZmOmROCn1YCUENj8hvXIDRzULYEGT55vD8=", "Bh144ZU9GUPi2WgzW3PhX+zviQdelslD05cCshTdxfo=", "Jh+XW6vXaSgiRzuOOflIuc+YcwqXhd45MXnUu5nazcg=", "Hj1s7zf5vawj0bOBpsWNDs8Gpuv1jfp6mVpEPtffaOk=", "HWZX15GDEWnFa26aIB+LeyQCRqLQ+FRDBIm5g0VAMtQ="], ["HYAF30jIVlmH27RCtILK5b/BDuSG7MW2cM6GE0WXnR0=", "H6dy695vNzJERiPWf+mREWKY+PMKLRAQyK5hMqPWkH8=", "BWqOzSMqZ0xj17YD74zQYyHFYN8v0/bCZJr1dkZ/15g=", "JkY0HrRLSADVYITLSFAPrEj8UziR9VfpZ4TMYATYkos=", "Ix8smL2o1Iu0ptnJi7vBYCcjWiKh7U+IvI06blgiCfI=", "HK/Ptikm+8BIV7C9fXOSuNit0WtcvvtUtNUxKCbomUI=", "C3qx7xf/YjX3c38EQWGQLwPVlM9KDMZ7T/tHEa3h6w8=", "F5qCt38sy5SzjrWCrEq7sW30KezCJHG+c8x3ZvltmUg=", "GLY2hfb+0qoZBIVjeEQhUd0foBx85hIdI+Hp7iC0JVg=", "Cieo0a9qBGCuFyTzLyGgawNmaNCoY75Q/MR/7FdjzpM=", "GGdWd1BY0JxjnNq7rNAb88J0QVIVb79+jz6Zn7YQ7Tg=", "CL2d3RkteXoZ3R2gSb6zn6ZZZZiicDHqHCsolm2WGAw=", "GUGEqCXenptj7Xp70HElPvWQPh51pQU225PCYxGnIBc=", "Lgiyi9zEF9lkOzAICFon9KmHZ5LTkVyLnaNWem3WzoI=", "KOVbC+1ZGRIW1dvh3QWyLACbB53od/1UqvVAHSyGfgI=", "HInY+XXwMEKCrY971BwSw7GKxrgOQGX8zaQju7P/p4Y="], ["KBIiVII/iSast+mPVX55YoLl4ScWGIWOdtSdCIbaFvM=", "LmPxdAMy9X6DF/JZLr2NsIEnFNZgQTLVJeM+GbPJhJQ=", "AJi3QJdsKhAx51Ey4FC/ODi3OdBhWCVDwcf5XBUu4mI=", "BvU8ef7Z4JhI4RKgdC2K6EoEvZulqidlseXt+xYCFA8=", "H86okobcHbYf4REWBq85bpjLU9q1GZdQql5dEVYfsUU=", "ChLhYmIOcb7rIDvlZZRBawg+fpTuwj4PRKX/6eFZUIs=", "Gxu/Tp9wYFFxag4omQyvF1cwhqXYGMA4g2aWgIsS2OU=", "CJ7+0A6dmT9fwdWvLytdR6m3Dm1aYD+6qo9lECEj79c=", "KyAuHSYmxnk9aKrPnDqP/7J831oLg/+PNQT5qyakPRU=", "AwSKJl0O60DlpTFjOsIruCX3XO6QNuZqBhvj1NJIyGI=", "JTLddIf8rg3Dp6xQuA7DMMb7bUz4hfETWYi/bfwBCm8=", "Es7o49HKwcqEUXqz3vSHxGCuwFg0j/IgyAG3iXmvnmE=", "IcDRh03sr5BhMYPqgnuRwbKVGDn3HzKcucmwdT/67+4=", "AX6e0ZHFZB12iw5V7A1KhfblQZ0y9WaNOX1bbLgFOH8=", "DGyewxyeO+B0SRn8VVx3wMElknvRbeKAdxKzXKJt0EU=", "IIKe89+cGD+JZeScjzFcKZWmRGp2BTVD63UBRfGndAA="], ["JBTUrvx7SFffaBMo5opYLSOy3P/Veajmru1sYQUOBc0=", "EgLjSdHXuAWEbpCDTvyRHraxDCoJ6uqintKIvXebFPE=", "AkuW2+v6ttI/oywsjndYyyQLrNgUMyPFPNtI3Itl+OQ=", "KjyfVa+s7nNaG1FVJkJjhK0EQpH3aRl02cBcY0tDlH4=", "D3v8+rF9s0wUTO5EY2verfq0Smv0/I7zhOyJpK6e0gk=", "FyA8TS4aQooXviwn0cTFlg38aqNvIr3ei+VqDNROcas=", "IqjudDZ0E+zPeqA/3UIMa7YlWm3YIIHWsU7ampdSMps=", "IeJfCn+O3DjeJbpgWobMCOCMywPnfF4Lntq+dHaLYMA=", "BqeN/eFFjuNBoInBX5U6IZNSff+0P1Us2tWV2nxv7MY=", "A/2U5Ru9poQ9MaKCUw1UJAqklhZdZE1ddzex5afWDVI=", "Au/lKdsd48Adb+f7inHx6qtq8WQfsfeq1PK4jNE8n+U=", "DKtQSyKjVz0JUJ+F0/vZTpRBesslOSNCus1oQAbDcYU=", "HLM60rp90MIGNENDKoR7zM53Wo2vho4MR0kFpPo21w4=", "Cq830fU90FVuNH7HBZYjeQd81UMZjhwnWT9EVFISYfc=", "KmB/rNOTb90OhOm8PktLrIboECwrWtFcrlUNKLNlTnM=", "FKK9Wlb4cAnbmBVGUzIC86+BLS701rA38oMIU7n5A5w="], ["L3EMctbaGcfYfL/9VWZbRysCZdE+IyapozuW6V03RrY=", "Fo/cMtSqjckDStSk+v7onw7VyYDT20JNOPjOXNBMI3w=", "FbvVYZ8NWXkIBPK5s34Gn8kJonltH3fQxiYJ3totAng=", "HhbpyiUC1pYCO840JyRK1lU86Gu8TDSaNLphBnxrbWo=", "Ad0KVQJ0OqqfWDvQrTXeE62NX8mPGWHyYSrUwo/Z+fo=", "DtLPrns29HCn0faUD5FOjs0yK/1rUPmtn2oiJuepXbQ=", "LHhfnYg09c9dCPEG1fmRg0D9QUq+JPCp/yuOBJK0TYM=", "DY28P8hUwGZcMMSIRte7DrGNPXik9w/vB/JC5FuGXqo=", "IvYuReUAhGlqwlEqJduZJSRM8CFLa1Q9Op+DuOjlj/o=", "Lya8E65IUgpDnJ9Uars1oSIqMH44+vw+f/yEP2x3160=", "Cvgl98oktKKF9UR2LZ3v3JnyuFwbifxf8gedPVDm1Oo=", "FgWQloQp9ID1VhHGRIkS/fQj03v0g8NqzMwayaKdKlM=", "K7Ms9g+NRp7bG2xWST1Mkzi0BRriUU1LYILvGLHVIoo=", "Kkpy6d/lvyX2/edQoYR+W0Qpi6WPtQS+V6WV5/zNxAQ=", "DFCaS/SK126QQQvqNKiRl0Fgi7u2tVA8k+cyA28HnRI=", "GZcz2kru2NbNFIRhYX6ORt4i03IEMfwWBWGbEqf9Tio="], ["LihUQdC+2Qu0HWSAg2hQ5NdtqCEbBKI228fDwwMgwA4=", "C5rp9e5q1wplG0tm409SGxMNGMSUZNhv5dSxggSJAo8=", "BHYAVL1dBxMlSL7XZX8XxhwDjrzf3UAlx7gC4IlI4Qg=", "AqTG0yWXecOW74Fzrl/oe9YR2+JdHASK2pYwbbHjpA0=", "GVnbAfXIuwz0g0kDc+dbBFG4e0PlkYG+C2AWZ08/Xvs=", "GEnNCRDXLqzDLYkbcfr1ALy5PhzvJQSvRDuU+LHOchI=", "BLXcIFe4gXCnGKEC4MqRd6/HV+4mdzoCkMa6sVnKT7k=", "F73zOAcohLUizjxQ70cRCRudr0ikM3S9wKgww35dzcg=", "LZN55psXggi4SWuKCgqQ1XiyHwkMUwQr5HZ+PBDTtA4=", "AUBX0C5evPM8Fm4Y/pBN76njQqGeiNQjNjd/HF5n7DA=", "F4GN0CVLKR0Nj08aRYxqIdiEEVNmGBK76YaxQDzycN8=", "HJXCkXNTxTtM2391Cg/obOEPjVvbAYAy0/eTeX18CjU=", "AklbPBv+xgdBgIFJMz/EPwTXnexWWCwpKCn/37PBo8Q=", "Kt7IVJ3/3nI4sr2m53MpkKkRcAyNNSiLqjnmcBWVMjE=", "F4B0MDuQ2JheN2WEuLjft/lS+PTPhNgV+Quqo7ZExMY=", "H1/AYAKLoH0R/JR39Pr/55qBBA6poExWgmdkSJXmc38="], ["KWSQGitC6a6hplk2Yq654SB3oodDS9pOwgEuNqGdyVw=", "BsIZSvcvrFjKE6Kl4yIxBO9JpUD9Lq6g1nqSDYVnBAo=", "ClSUybz6Bqpyw2/SLZj+ctwU3A5OdOA9F1XzisNAUK0=", "JlyiERgLASw3jgGY8LX3dYwVXjZ1+t+SynkVa9Vv4zk=", "IfZZ/tr2wmF/F9Y3zW9UoneC9OhDH4evXIWRkyzn2rc=", "HkY64/TDvQR6oQSfTwkaLx1dNVDj1YAfz/aPml5oKPQ=", "J0EhkforLlMnoR0pDktDmkEk9IFFxh/07OhEikNz6t8=", "Czp2nIs3FWImA5XuTzSPiLsFai8OwPmOTmM799lDYV8=", "GttMh0M9hm6P5a4m0BR345YoecIMjDoXDAcnFnwG0Lg=", "H8Ju0Cfbe55yQcLHYBdmYvY0ugWpynqFDhhK5YjL4hU=", "EBdftvgbFkNq8waC82+6s5bt23gppQ6UbHXyfiYJh8c=", "I9MANzu46/fbzzFKPAsf3s1criP357uRW822pngrV/s=", "DwQX+mI3Fn50FSUmEwbBdmTcPvqSR6oNS8//OOid7e4=", "Ho/SCoAw/dlOLENT2PgrSyEr+Ie8WWFYFIkLD5KkfZA=", "GFcoJjhd/G7spNPHHRELBKuuATxUUNnklHo9AZu0G28=", "IIt8jB/4Qi1KG9E6AqlGgc4hfZJfQNKHX3Pe8U3noiA="]]
    };
    exports2.default = _default;
  }
});

// node_modules/@selfxyz/common/node_modules/poseidon-lite/poseidon15.js
var require_poseidon15 = __commonJS({
  "node_modules/@selfxyz/common/node_modules/poseidon-lite/poseidon15.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.poseidon15 = poseidon152;
    var _poseidon = _interopRequireDefault(require_poseidon());
    var _unstringify = _interopRequireDefault(require_unstringify());
    var _ = _interopRequireDefault(require__15());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var c = (0, _unstringify.default)(_.default);
    function poseidon152(inputs) {
      return (0, _poseidon.default)(inputs, c);
    }
  }
});

// node_modules/@selfxyz/common/node_modules/poseidon-lite/constants/16.js
var require__16 = __commonJS({
  "node_modules/@selfxyz/common/node_modules/poseidon-lite/constants/16.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _default = {
      C: ["L7WDdis3WSxsWpXrHQZpS2xvncTxrUhi3Y9eZ8t6P1w=", "Eun0bNgjG7A9QCi/ehHXwOMx3AXAiObcPR0AHaWLhaU=", "EnXNcDJvUvgWp8U/5i4yPv5hpbjTdH9t7Fg3qCWHOvw=", "BufRZbV7ApnSPnUKdeouEsnHoWlUxApNEJBKYeh3NUE=", "L2fyOpPvHiFaSt0uy0G+9LnYXvkTUGXZkoAONPqYEIs=", "Fp65lS4qhiPvON5X4V4kLfOIAZSJ4Bt8hPqDnYZNzRo=", "D0zUBLQCTKE6UTujFW1N6cs6okDGg7Pg63JTvJjItfY=", "HEhr+uOrAy/1GejcptxB6gYLDvkIMSe9fCxOCJ/UWso=", "EC50WGQlHOlAxnseL0vE0n/ThRVxzmgTuqxmXozAx50=", "HmptYgQz0iKTBE/+NqXypynBKczj7rC9r9zQ1SvDurU=", "CPOr+XrY0Bz9hlH/LVduPWjsxHqtgrQYjZITi65gO20=", "KD2j8c+Ed9mCHuYDeLHDnHJChRGhudZoPAMCk4wkjOY=", "LZnNjYjknguryEy9WK28FDp1omuhb5ZGai5BYpc0Q30=", "Fx7danRWpMJf74qm2LdI6thpNp9ypOUChh/QN92o93k=", "L6tkaUNp46K9VzwMw4NpXAKjgeeFeSo/q9bhyo3y06E=", "DGFVlE9k92lPyOzSormiNwVow8iY25Ux3BjHJHT5r+c=", "HuDlz64DBiIkkhDNzacUN/KPCxcwZTwJFe+/wIYHw8c=", "J0Hhp7xrossWKFjE6EVNug0OEtzZVtEnvtBxc5ul74Y=", "MBGUpmMwmrjYCkNIIqb2VSWF6IjUmFgYRfVL5jTryTo=", "GIrSU0fsJeaoobWZGz6W34H1XL4sUrpIdBwE79Rx8pY=", "LRoKAyVUxQsiaZSW3sSHsBQB8lKC9YfhtXX8mMn71kg=", "LEf+ZTO9NKdgCE6NTEiMTKKzvRHCJJMXmsgamfikSp0=", "L9tBTrgGm1Vz21wR7eBFpgCfJnqNkI29fZDWoPAo8o4=", "AJzr+ettBvsnj+c21roJ+T4N8qBA392l/n2a0PuUv2I=", "AdVaOACmTugnA6sVkdGK2wAlnRaCduGw+tRxjL/gWWY=", "Ci9rBZJV7e1truR0PAj6hNw8UbrjF5BABWs6jfOJgq0=", "F89JwFaDhOk3+BtBxixHbburh7vW9NkiiwRCkpnMgbU=", "Kyj2Cz7hKEAdrdPZTclvABuUMvcOobOzIZ2A02mSGqI=", "JfDP0zJX3izDJBXmXr/sQkbZChgegUX5OH3vPExeDYw=", "EXw8K3AuzA0SzfJk/Cb7i07GCrN1LSDx0tfEQM1GEnM=", "CshgPugZJ0p7rGE7bSZCC8ppodFHBy3pCqOdSvgDds4=", "EsOx3DfWZRI/p0ouaO4ymkL3XbQtKxwFWnHBbwTURVs=", "EHsPVQb9wud0Zo5BkrlZQQpKjgyegtBcXLuovpPXPzc=", "G9ufXiz3rvabJvC+yLvVALo6Vq3cslUFyHfGYqgQiZs=", "AIIkp0ao9yy6YZWCvXIEuOIdPO1zcLt/x37lEkHBz3I=", "DS+1yHl6KKFb0nZl3FEP96+66Vq9MteIbSI9GuhuwvU=", "ITl7RcAk9szuu7nRsOQ2RPbKdtLenrBQXIYvBdczBYY=", "DiBzBebTAotcRZ32CQOW/j7tuuDPiIThX6W0/Zxe600=", "HNpkbJTDJPhNzMAvd6cW2qhudnfFcEfKoAJnJMEnid4=", "AzktHBKe7PiA373X0wtKjTXFc21x5uGHn64jYiEaeu8=", "KkZ3VYXMnlvOpIIWTmaIGOxU/XbZ0sfZM74JD3poeLc=", "B1bXkce2cN+9GOu6/sVvwUg2Xx35lRi2NKSRoiA8njo=", "FoLSgf3d9vNLQqS60LJg1ZfoI4h4wdegIYCmmdtPqn8=", "C6Bp3sABImKcLuu+b5hCBApA2KEjJ7wITvNP0ULLoss=", "JdGQo8HiNNF07BTajbkDqN8KdukSF/kZPciR8ZZdGrM=", "IgYnDNf2yw9GklYK4t4O/x+tn4YQAFOj6lLbMvbekt4=", "ExNbQXGtdS85BvegInQG2MUNyuWHtaZxxj6uwLQu/Yk=", "D/mjNDKH/120lfZC0ypx8ZPOJWUO6aPws81wzN8R9M8=", "LF+/hrLfdcnxTuILMU/ks9f9NRlZOtjHOs5pz/ZAapQ=", "GtbfqrLL2zUK8PK7qDwhQ4oHjwnW9Qp2UJZGkHUwfIE=", "Jt7zq1T/4E0hbXK98+NDRcIfKccV28lkpw0VZSJKYv0=", "GtgCs3yWxq02CjFssIg6FcPW6VHz+Bsp8tpRepMpfDA=", "FpYxd7U7UWK/L5gpUUyhrGAZa0KKd3CoC+ASpC65hOM=", "AyBlKbcj2ASrWCxEY+HTnsV59kFeDDwQDE3fy4ehtus=", "G3CA5bNrimeCMHiC7da6nENxSjGVRDYHJfEMvkA21Wo=", "H1Ad9mfOQPICMnKzLsEjhU/eyoz6jSH6X4+R9LPG4VE=", "Kdz9IEisC16y2yAxamy4BUkM+qp/fFLP4yXQ7j88gTI=", "K1wKTzrElHHe/0dmLPQMIFPhq5vYyQJZ/TmViBnxzCY=", "K9FS56cEWrZKlC1q+QLMKZXOyj1fpSmPEL3kZ9IOs4M=", "GSQYD8YIww1xymvBlva2tlkV2Cq7aqpm30FUCI2+8rY=", "COeoSj7J/qLFaWkENuG4n46Xh0J8wur4lfhr7zemprw=", "G7k2zYqS46yx1Ahhrnq117Cw5NFUjhNuJ1HiYWMs1dY=", "L2/bBKbdug2gPvcKNsiRLOQHuB6WP0xOxKBeHBr9u6o=", "Az3TdRfE4GVXozS8TCcqvBmIU+OBWZpfCw8kjV6U15o=", "JXvZNqpW1xsNZLqYAG04uoX9B+LFVkQ8EQHeuTDWJ1Q=", "HBiZckZp7+Gx2bF9Vib6fqUtYri8k6Uvpp60paDWaas=", "E25AB712nQWQltzhuNFujV69kmLWRjg7gMzsw/Zwji0=", "HN77BWYYtShiZffRzYXNrZRdycbSA7l3VnAKaKfjBeg=", "E772QK871o7duZ5lMuBfp4cXGrIQYfLVEoJQVViw93g=", "IixDtExYH6+SRDD+WxZ04V5fYrF06TYpno+kGu4ADBc=", "DLdIkUnXh4S1Xe7xaFPj+vEpjnjaXD0Znk9iVu7DvJQ=", "GYjPiwmCt+uzxd8b5KoJfKWTEYFqwcUt+H9gR3nl2Bo=", "KoYkPVU34OG7lGuoevwEFBpPRoO3OopkL0MBE7WDTXk=", "CBDkdnwPg7CO7kXHQ6KPaqD2xHgXnckjpzDACnd8CA4=", "ERBRtvbmRbER7hb41yd8VzZUQle5k99Rmh7CxWvNz9A=", "E45jcYahrqEM0ZKfR4vnXq47qQiDdaXxAy65A4n70W4=", "HEjofDpfZYXH/rkAn5WRJ1E5ZYafZzErXcSuEJHZexM=", "G8keOSNznYVXpJ33PWsY6s0/HYQ9L5oZ1aVE0s9hux0=", "H1XLhtROiXW8FIPlb9uNp8SuU+HsMbhLstoCcAXUUn0=", "J99CgNwP6eQLPGn4HuNbnRDDp37hqlaMuZ3jwlozxEU=", "L1yfhyYGTZ7yrnC5yLm9jGe9C04B4z2hTusIyehJALE=", "GAOfya3Wnhw4+qMgu2ob8P3vRP6wk1iC3wGZIMh6+C0=", "AyeQN4jDJF2mqwCx3QVO8KiQnHRjgdNr4yxjVA9q7dg=", "H56dGukMGPGLMzhuGQKDzXlbAKXnANm0UL8wWXv94yI=", "EzXyolHZfB9P6Yyd8vXgtJqZFbY65qyGBxWkUM4EXGk=", "IW/ePEfUTbEsqbOJC3RlUeFN5h1h6tqoKHK4sC0IwP0=", "IK6l6id9XBeZvwVlA9FunBgGfM5SNlVSBQCkUJVY1t0=", "LJhz/uTzanZORjPK5Y1ZdXkOiHjQL2aH/Vrs8P6kXHI=", "DFnQapgngRiqMUwKLh/xOHgqEBZZJkMUH8EerEWO+gY=", "IO0ooOXdbTUo9t20cp+tQhrQeIAvKDUiizjASs21yz0=", "JCqEygEoZH27PvPaJcs4fUIvVxFx21CEXVjqa+q5Dd4=", "KawUoLErWB2LdrceIZet/1aHkJDYTlw5lS+R8r+MOXs=", "A33N2yUw7VzambOJDJ5+oLCRoA9QaHvaC2Iz2gu5tCI=", "JaiYf7b0wYqgHS5UKWl9Ye7EgwowGmDDVithrjKQypI=", "HJv3HxE7Yce/cZ2Zu1rr8Mq+hxKzBPHh7y0XoJjHms8=", "BKDJ9Zr0M/Ry8d6SzDnWBNTOg2npHE35/rbXZwbRDiE=", "DTAONScK3J5F9DFfPD2dk5rp5t3RBe1PftOAXSn7DXw=", "A7PV/pjNPUHWVgONhPP2PVA2zoOasQyshtkxvG9Jxx8=", "DU/x6OX0ccDLYMS2TiXUYFimS6MNn9Umtt9SjzalxYU=", "DmmDM3WYX2yZ8yz5BH7XIxmnjRzEUldLFgrlAfkQa3A=", "IYotoacb8tlJVDXBOCboG8T7xS9+nnaAHXbvptFQbV4=", "Igt8XH3yWdKO9ch4GNN7Gu3TMcXtZOK+NpY7qm8OLt4=", "Beb/O7LDw9Nv7jCXQ4HH6eQlfPyxdSJpdfgMeCZgHX0=", "BuohMEdQOEgtQ7QNcB8uVxn4tSkeMucOfstnyElSwV0=", "Do6j4yo5zS8FJBYJE0JO8BqZtJDs+36shE6b+Fi5sBQ=", "KU5cuG5N667g1Q250hgo1U0plqbSycGEFyxuWPq2bxY=", "G3am3GGPcCOy6SAYFrVuBGAKH2AHcEdXog3npFMTfuY=", "FYuH4ftO4DoM82TXc3/qW1BcjyZdheU82LbtIbj34Mw=", "DWhF+P+oOukFyQuTm8Ahe5ahFOrhkRQreznMz2oF+Rg=", "AecLh6pe7DH8/KVvAd5vDhar1o6UAWpoYvH9hKx1Prk=", "Fa/QjZzY8Rn2uEwbzxvYMhv8Jp98pLoxL3jBjO4GMyo=", "DooYr1CIjA5nihjbA16V8+UU0SrdJbMSn8sKEXW/INY=", "BaQjt2oGb/2Gv6ziSmnuoBnXQqwlZzz7zi1sjY+pWfk=", "HNZjP8eBdp3km7BgIi9w52TApZnPpj3KVGzHcKjJbgE=", "C97GiPtlGkGoRUurcrzre0uaTmThWndZr5bDkQ8a8e0=", "Fv4vZ8uB30ChOu4Gy8o5GqnzY8i2ETlw2ld/AOy2hjI=", "DZ4wMWza307nhhu/BY+YZLpBlJqX2A9XL08yHFyBwmY=", "K3JQ3itnAUPSeVdnvmK0AbM8qHMX1Rd0My79wNVh4uw=", "IRkRB82Xzm2C2PJFgNPzEjhP+PfDcqam+EvqRhlDISY=", "LT0U0BmQO767OESVH0kq5kA07/MR9vrS5+4iTfEiq/g=", "CxdhU3q/5SMT0phHlODwy1pn+rbH3mBkqbI6nBaC5I8=", "JkjAIeoiNA2cFb87TeEBnKW7KxVPUorL7IebowYMXnE=", "IQODuSlaz7Cv4KJ3mQT/aFEJecuDCM1L4bp01Q+OvS4=", "I2a+ufsK77KyeRmpNqkOUXi2ySCnza6ywk2v347sT2I=", "CsC6u/6wWsoLr8hqE3NFAIpHhYKK7K5udXJuUrGUc/U=", "FPTj+Sn6MJ/3a3cCL5g1WIHTpGGYJvj0bz8zB7ftfL8=", "JsF6cFwfsW/JO0mRKjsCYjmqNxRxFlSK8ixQsXxj0vM=", "HAQbVgUnV6qLJRyc+TrITxY7UClEa2udX3NzjHFWnBs=", "HbhHr1X03uSwSwfYx1be0EsQw4Qjq9qIz5VWhuGbTZg=", "FKn2tSdspkxx64VCEyTqItqeWUGMPz0Wii4lYUqrslA=", "Gell2AFPqiFSCoefpwYvjNg+g9I9NOuW9hVctpj8xa4=", "JymDtHuYfJSqcEoByIaYwof2bNajWwxTsK4kglcyhJE=", "F5CCRF9+kAUPJ1FhOhi+fGFUQ6WqvZ7jDdWuGu0UHQ8=", "KkXZkXZdaBDnxt6Vt1EHf/Os0ani7YQdTjUWQbUxr3c=", "DOgGAK53e3V33LDDjjAX3bvLzoa+2qePPugP6PjtnEY=", "GDbv0ynt6ZntoCmsdpM+UdN5wuyfgRBgkdTdgRhLSpA=", "I8L59cMrn8nYoPBqH7lDQvjg9yhxUyrmIuac0mmDy9Y=", "Ippg3p6nuaMa8FN6FfwMyPThh0sFsCmheqYGm63HBwk=", "J8HKzYR2NQS7namV+5wR3+HeT5tN4AcMYkWNwG5vcYw=", "Imkl47KOnTWDMGERQSx/sxJaYinVZJnUrUzidfuUWm0=", "LUw+9rhkn9UhwxfUQPDeIXDH3AzirP5VR8liZSNyKaA=", "LhYzUtPGwgSk85xjR+0qFUbaHBYsF7N/5RItvgyjjYE=", "HVCUSrUmFOz3lKmeydk2Ssl6yxc/AaV5PVX5rb6kw6A=", "K0vXC18fQ09w8flS0CsDFyP3aa4YIHeBs376fYYLajM=", "AdqEGUvq5ZnqvN0NnKKc7gXI1wEYryLXlJZmS6Y9lT0=", "CxRpwUhq2DemSkiJwkrNYMeXX1mnAYG+vemVD8BLlNo=", "GR4tz026QQrFD36apJelx4O/+9zC24Rxy89wtW5QEEA=", "AWaGB/34ZNVPS8YqemS8yE58mSilv4IV/fvyKHdnMxc=", "L5lnIo1wVCbVASx2ThdU4fQ+HLnb3imo2kuoYq5GSRY=", "AXTBUUjNZMapx+Jb9+ksDu2Tup2dINydmRJ7mDf4Qq4=", "D+rgvM2QYfAVeKegAzlN8CDQmLG11NmU6cewHVwqbj4=", "Ds0UaPulsxQta2o2mL0n6ylh8iMtpWFIkerm+y9QH4M=", "I7i7K2bM5xsIBVhsnQH4LB96zWYIuhQ3cFKrUii50qg=", "KWwpQsBBc1qAaH55sDFZ6gvMnIKIv2HpMrFtmndBhwM=", "Df5/nJQXyJKhqkJeNuq9GoMHvxQXjMG/8w3icIBKxrQ=", "D5yAwe2dv6UmTsDKfykHtFWCqhqtyPIkTrgm82MCB14=", "E8dqng72oq/hJFPVLFreB5yUXeZwCt6ZnSZU8A4OHbA=", "CNFJNsUcnVv6iTTqaXUlYOf3LTPG22gsbuqo03r+crM=", "K7/SnnEDK9bfNibK541dfZULglGqmtOHuv8M7MVa54o=", "IK3Z2uKMC2xWrPjdj7+Lgq7oueRkcEJDB3GFRoxseiU=", "H+yWuqhth0FG/stJUwi5J8vGPvCs8kgSUs/ul313oFE=", "EH+ULNH32wKoT/QQkTsHyhQGfAjjzuaIPIKfg4PbVq8=", "IERqVIgCRjLByloD8+DZkn23kRtI0K2jRc9ELVdPcI0=", "FsRcbuLgm9hgIEoSVQz+3xwVz1rnkhD/VsOgZ76YIjI=", "CVr6yenA5786N1ev4aWbHNLIqd0KQBanaN5OOUxa/0o=", "F4m41QxPRwogQKjJdUBTDrSkuhiOBYxc+Y7v8phjY8s=", "GuSgk/H/BW1D6x8XbvrFnmTbsLMKF7+c6+c5ztAtfuo=", "IHhmSFKSOvjuBaw5O7G3F3Gu4jesS8E/7vXt24JLUhI=", "BFwmO/0sgM9WP9HdCTkZ5hcCxBgGZ87UcQnyIpPW9jU=", "Bb1orf6SKepfkbm5t8ZIkwJ4/5zUI1p03aopibjtG2g=", "K6YUe/YfrG/p+J9dA0JLvT3SWr0bqAmUmM3eh6g1CKY=", "BsKcGpZDFuX/RoIB7NpcXqso5csMvsH4P79V+RHb9uY=", "CzpC4QxbMqTbSuV0KRe9KitkhNWNBpmI1A9LLF2SNRE=", "HvBcRB5cRJ3N4rAQTMDPCTOMh/we8knkchm+AfiQDUw=", "E0a5dNNVkj+IErG4HNac6sArou1CB+B4sbzdZbmcHEs=", "BkG+hD3FurraKJOgAIVgOLDEgMc7sSIiQvXBgrA2ZWY=", "Dgq5dU+lVBhXYznHSlGNoj2kUS70TZGPPOetwDh3wOg=", "BSTtqajPdMiu1A8n6AShGPR52jYzECnY41+jBnqKLmA=", "LZzCaWi5VtKC2IKtJgYmkq1XVBriB86Qo260CP/MHC4=", "IIvoFELw7qIAFNfFDP4/hJfD7vWdI6x1Z22G5t9nIXc=", "ChA8eRgp5fkekUOqrzc8Ewvov8NXnzYIsu7yPdonJ3U=", "JMJQ6163stAMKQ9UjyWLQgbaBQ/P7EOTIGmBRqaHtNE=", "BK9hHcdWIovIfHkeq8lBK03FOeSCsRNg3eLosVxc6yY=", "Lt2kwMjNtqwfdmrzDylsMLrSmn+jRcSSxf1GHIOnStQ=", "JKV8yXrHE9Ei0goPRa8yoZLVfuLfAQoqv5MtP+3FMaA=", "K3hpJW74RJ7xYyaGwuTuv2x9wBkl4XG2owU8AMf9k4w=", "H8LK3B1CWY+or5oIffl9EVZPlhJEhvnTYnSlKQdxY38=", "FyGDB0DqtdPoJMpQHZ27J5wzzKRtlXz03/2GxGQ4Uvc=", "Blusw4Renh2xZmZ5upGYllqWBPnQ4XpQnTQ1Rhvdqss=", "FLRpAly+OuaVSABKdauMynPmaPP9vlsEEhSdohK4YpU=", "FpFVYZXK7m258+kqdAuOPfl7pluUAdZAcXIPw/W5PRE=", "IEN2DAhG7xqDB7iJZAw0lbzRe4VfrSOGbNyUCp6b8gI=", "JUw5qTN9rgd+NO/8sr9hSdqx/0xHB39WWhFkzBYGXfI=", "Fv/4G4Tctu6BlfyaK0MYPvLJPrpp7QH9ZiFa/UEYvHs=", "HdP99JPld5HicM8eRZMqA4ca50nYsHGyEMETx0bO0+g=", "GfNMMNKeKy5x0Oe1iXW1LliVEApkLlJQn3NJlHBmTm4=", "DlM3irUk/eNbr79bBz9gM303zHuwJOTXcLR4yrce/e0=", "AmV6Qvt/5w9p+900z3fizB2b5dq1w99URoQC6YI7cww=", "JweX4YETGuRU++A1t0yBhXTbSwsUYXFFYUv80X2Gb10=", "H+hQxu6r6MwyQQX4eA14ArNSY2OcwJ18J+LD0zn+xTA=", "ETsP2E+Jaxcm7X4yTwN9Sbz8YRBzQbpQ5s5Ge9T7A5M=", "BFUwHJw6lXaGTlNJuduqJLtacxlJKeICL5+UYtxg/Fg=", "Hniv6ec/T6w8BgPxqZRPrJU+hkmmOrnKOG4U92zJgD0=", "Ki34BizU5AGev60yavdfB1rZkQESyeVtz1wUAq8utac=", "IxmdLj0hPFk+oFDFta2fafGwywo7x4WSdQlIHZNlp5s=", "ERLz9SBsrW6gb4Hn6T9tomBdEhEffYLa2rchqGKCBFQ=", "KnhQl1ND3S2XNqQfrZYXOr347JVaXb8P71mKNCewbNc=", "Do8My1VHOG+zd/jrA84xov2ZY3yCiKzIJLs8fhGXYkc=", "Lf+gy3mCohX6o65Yfz0Kj9s4vWf+SX1uxqmvOFp95f0=", "A4EE2HWGHBb4aWYw//D1ZKtjZ+67VK7ABESr98oBCX0=", "LhwUYFBST80FnlVElsc2XcokmDH4884ZFUo6TyXAoV4=", "HxsAcROyVxY6Izj33NMQGYmLyd6M1DPG9NKg1htKiVs=", "AkXUFMAhPSs0GRg47OUkg7m4I61fxgsNG1+qGdxJlCg=", "J7ibKusgSYz8TqELcFe4U80GDZ9Dq9oLYuwKy1DvsLQ=", "HHfMxlF4netarI08Yzrg1hAh+ST9Feo/ZLIZBpLwuEo=", "E0SrlgMQg2SnHNCPKROPF7gTouUHxaNxJlCUw/8JFzM=", "CW9H2kCb4rh9cqW03/52jkZLnzQxSFYcyPf2WZZHMzg=", "KpY6LX2/G2ZIMkylyiAQBXB8aPGQM4YCEG/3ocgYAHQ=", "CiSh+/jp6l4O2bL29FGQuvmOsTDyPjpZuYgAR0zObX0=", "Hvw5MmWT2zVx0fgfbiOe+7tiWEjiBAQ6Pq42G3hNqMs=", "AoePGZQ3+AzrYRWkzGmtQwbLkMr30zpX7ix3L8sOfEM=", "FOcUEWrwLqxoyi8tf9xWAtFLDjFWv2id2K8CIl9n1qU=", "HMT4laSURCpMa9C5vkTqjVwWTqCuvc4Ra/biLqnJ3/c=", "H3LZ9XzOaaepU6nR6taOD+5ihHjVmzf8zx5xByn58rU=", "FQQSJFLtH9ACHCdLL5DoYNYhxTA5fUmZYlcyhBwkF1w=", "D4TCGF3yV0JsxxYL4AFm+r8nk/F7Tc+VVTeELMOevsY=", "JiEYdc/rHwhAKQa24QCD6r80GIwPHJ5u5mZvx0mRYbM=", "H9r5pbfctIfrQ06uOjobYyBFxPNnJ6FgDaXGfXFivsY=", "GoLHxA4LM7w76Pg2xLWMEWe53TuJpkpA8lD7peeZJgM=", "Jqgw1Vkydf0Jg4ozfc66nXO2sLzeV5TzeVosfZoAW+s=", "HKG1EDG1TWwgnGAJXrpGPPJ6/B2H22C4UnM2WGv1rDc=", "Au0LLA/ATpndNz8Ro/zlKAApFyKk9g9p3kSwvjabQwE=", "E4v5Jsn32Z87NWeG7KBtA2lsNKKz5wRcz001A2uo9eM=", "FMkATTqkeTLsxDtk9IASKW7sYXWZiyfUrp5nrDfiUt0=", "Lo/OHavgzfP8Xuv62Pp63G+K/al+QpFy2bdT3eS5j9U=", "CG2Gw8cx/kVya6/FF2tYQ/0E3WT1gIBnfbGsmf0nnDQ=", "B8UiqpWCMTwQejYpQD9Uafd36GuD6nLVBghxh6jnK9M=", "D4rhHY9vQm+vhRbjUAE7539IklElgO0052DaHCmLaOk=", "C6WqDms9x8Z4BP24S8G7zB+ETpBGpmJKkQFzzaQVS80=", "EloFfBCeRshtSgedOqQ5aviz4BNlVWobVPOdjt5m/SE=", "KMpsEBAnCtxJYaqDNc6DaWskvttLtHPfwV6C0wW5XXU=", "HWNpN4YdqhIhXwMd0x713bXSmP6KaH8VQcET3GpvmC4=", "LnVTNeQCLXusCE3M4UmFIPgK6T2pfS9lcVAn3I8G8N0=", "Bx8nE7GnkzoKIPUHuRIFZK9+OZvss8Nk3E1P8A6CyEs=", "L/1dqCgOMpmeGaFxfhDImvzgxvgfXTKJ49X85izg8yg=", "HdFP5jZelBUX3bj7MI46k/VAA6tL9fKsx6e8KLUTPXc=", "JxARKfx/zmIoDKLFiOwVfZblruXCsNvyBJ7SSywTBdc=", "IZGf4lN4Tw2zltT55MdzUjhrm3JIkEN1S6iisfSsEmo=", "BwJ5WKj1MYd9HOus+CjdiwF6ElydKHWVNzpaOeWM+NQ=", "D0wSt2gUrcHN2zr00c5pAJNO0hQgPP9Nqjwyf57OVFY=", "CNmIaD6vSRWKfJrocUYGj24c91RVqdgiMWRfcpDRCzY=", "AnLnRCbQdNllj9lSa4YWkH1Wc6707jNnhQf4K87vWGg=", "GkcJ3640z13fcAbXwpC7WMdCl8jEgY/fXzlQtUySRSU=", "IgAri0F1dQR6DtXTWRQ67aGeiBDFNJnqS1fehtRBraw=", "JFdIaOyKSnAuoM+lW94uo7+yKCH22IpmGDUnscf48Ok=", "ENlm3n5oCIdBLu/YfYEdxGsCQIhtaFSTQzjSESGBl5g=", "LufH4+ipeQh97e0C5yVewGexxGR8xxS5bhooJY1waWY=", "BwKfBnlF7R9pRolNZuKo8XUTt8rr1Aya3K857O7+uoY=", "I4+W3OIsEMmsqaGYLubuqHt86/rlo4d4K0mmL+paq/w=", "C0aGbFJIL9SSuqM5XgoskEcLQC5Tiz2NDFByLlYh3R0=", "DXZt8qEQ7+JaPZwAcJz1MJpxw+2nmUGfw8uw9pzOKuY=", "BwFDt0DFTHEI9fYYPOhDcfdwdQ3aBLp2Xvg72j+y1e4=", "FwC1efFeUMKtGM933d1UnaAApsg5Del+ftDY5o3XfVw=", "CWakx2cB0JZ2oIbpXZC+z6B7uANGQiRM9q7wClQNI0g=", "Db7+i+8K8lWY9UEvhOAKPdTofeZTB1ugxdp+14OXC/Q=", "Fm2GN0w512YAlshyeOJwJMqDkZfmXNLzQeeliMU4f6A=", "JRWDve0VTrI5YlF1RYhxLQ4beMKc/US0Xymp/VLOrsQ=", "EE+i82HPaWCCxfztR+eKdfOTYxQuh3s9gsVcaG5SYno=", "LpN7+Ekwl2WjUO2HkalthZogNyKbtqZSvGre0mTHxbk=", "Kx2f9/twiDUIxWAh9X4/nqHbrGynQRaxfukmwewxkKs=", "BfY4TBm+migG6JLIEJF8ECJBiL9D8EGk6WM/Nw+rzZ4=", "Ls0yEeBe8npQ6M68Qv8LGDz+Id+rI46p73Yimz8QkwM=", "E0zEJKJt8n0G3+zc4mQaAb0QLn/xoHmi9+AstcBND74=", "Bkkb9t8DhQmZJrMiGX8DZrJ1fX3WLuPCoE+bTJU0BRw=", "GV/CWg8OUYk2r3Ouvf2W2bOKQ1NQSw/4wUGJhlUpIMw=", "IdkFLM4oz25OlAc/hjzo7fEvAuwyhiN/nSI7YjlmYoY=", "C6qPcwyjHwP+7PrDSpbDrHrxSAeRB70dFyQZF5FzIb8=", "JVgTiSEPbfx3TTcW4ZeEmE2Tg39G5RncdT026yrH7Ts=", "JOAOL8sZ9kJNcjoC3uUDlrd5okbaU6GiQPG9iJqJcKY=", "CD1IVLMO4GedLbQQsgfg46Z1eIYxxaNWzIdzKWATTHo=", "AK9UQW1zQzyi7S8WE1knJ3C24wCTgdcSmPgiPerPrxE=", "DYYRLgtcqTj6ftvsqewW6enrRYnHdwb/OGtPEh//EC8=", "Ii7rCxapt+0xCIkX6+HNPeKlHxXh45IpoIv3NPss9U8=", "JqsYh5evxzMiywL455V44OKW+ZG7K8/rtjXRISEW9Do=", "AYmjMJViSp/oQ+42frIyJNuQyNeWFJQfQwCSAr8/dpI=", "DLEW8FxbGI1mChUQDk5TIT+ckaLHzEhJdGjuAJIEFV0=", "BncWe6Zc4xztgSxXIRYCER/Domu+kiaRingZyUKBGWs=", "IDhwnnz8w6H9UOyER2yQhwdI67MPZDG9E2/emc/eJS8=", "ETBLRx8HhGS8IATCJNwFpMTsXbCg0V8yQTDhJ5Onruk=", "Jdjiq3+HqtN52j4+t/XTXyl+uAxDDHZa3sf2N8T1kuw=", "AlJwX1TVW/KbMCN/jRKq0rIbSl06eqrpgvfN49pjCGc=", "Hbnt54rw6/JtwYj2+nVmPuyPZbbJpe04+7NCHex9fkQ=", "KJFb36tyNThKAFLtc4OfO2YAp61jKCIqW1z26DOiN3g=", "Ckj9mw4AJ59R8kC0cpwTYHQPAD6ASglXnijAM8R9WyU=", "AEqolejBJOpiZD4dR7KBYsQEqjkP1Fwy+coAwID+wAc=", "L2/yw9uXFHrQRZTRhYmUtBb5iqEkO/ud7qZcEJ3ydxw=", "JPT0+vfOT0BambmXrL6U9PdWRv59Zpd5c35q6npZMYs=", "LG3og2GPYb9/P32NJ6YH1qfER3SRtKUFlVMSoerTvBA=", "CE5tTjgh4TP7kd3xfFKjw+BW3FIR2ZxQel+OsBDyBR4=", "GCaVd4rCUDvVqyMvega/ZwqVD6sPUmkeZthdZ49+xLA=", "FgMzRh76oqua8MgxCE1U52adijnFzbZ7Lc9B08T8XgU=", "LNFBQmrvg7YLrySpGWT6A6ShWpVtuWuf+LGALPeIaQc=", "Hvz0beQNAx+EM1A/NbV+fgXnMzKS/E6H6M9pAWcXYCM=", "E1ZlNMYh2AbtFi7+ht4T6Z9boLh7dmK7x7VYq9R/ty0=", "E90PPnrXCRhA8PpG3ygEKXpgoAr7XLTK3mLvkwELkH0=", "BjB01kcpgHJ0uVgvVFn6XxOlcKoMjBzflw4KZ2z8a+0=", "LPC5RjJAGJ+RsNAIHx/fEXAT47v2ay7CB2i2GWynikA=", "JBS8CGmJ2cWktDiSMWcuEGcPqg+kY5PtOsuPdZLVPP0=", "A1w3UhDEA3jedjo6HKgLb1nucuYLzNyrmYdWdgenpmE=", "JGSbIkhdQWSlhJ5v4J5JGAC7l1xMGNvgduxMhDCUQQU=", "KP8wFUGR5zS7+INQhtAmlYdw9YwFrfKrh0UbD1tqW5A=", "EzPgaO7CRJ7J8+wlCQM6le7n2Ts+IbrL8THzUwIers8=", "Gq8B/vA2jabsJdQg32K/f8I47raPnAHv4ICr2SGWmZI=", "GoFY6dbv/7P3cEMBNnScE6w7V7CsZ7fnkLh+TJUzFk0=", "JnpLzkZEjSUPvEdiQL3ygIK7ez/U/fa0lZ0gLKXCLMA=", "GQks4XnGgs5lSFjzPX23U7mmhkJo7qw+AbnHSZ1mk4I=", "LLyEM0UFFByFRGo2i9zm9DxMcwArnH+idVuv08kTzeU=", "DyKQ16zcJu8g4Ov2x5CyJuwnYYeA1ps0I124BsLPf60=", "CJl9j+mKOweyRauxov+STmnJTsUS3YcX0m2ROXb3AJo=", "KBJXppMEQqBLYrcu2F4GwmUQ7zVyuddqWkfTnMjs/Rk=", "G+0+9Z1ST9OOsoNRrNiSj+aDfO5ELNQSjhfkzqv1xeE=", "JFDEIi+SE5HC2IDQVJpmh5sfA25hlrDtBLb2XXUBrog=", "E8vIFkUvGnhZxaFah96nxwdLBvUGI7jVNa0x84CGIBQ=", "KkR9q2Dpo1beBOCSN7Cl6COZcHLFV8KDmNw0NJzmsQM=", "BAOvsp1YvXqZhcR/j8XiMGGcMGvDueUAHlZBeB4qJ2c=", "AfGzTXTHuksknp7RpAPt667bfN1omX12lwLGFnXPn+0=", "Dl48VO2t812YSSxGl128ji/wjBOFir6PzeX/dAGCtkI=", "DWO6ZgA3sJrYkfKnPuaHzZP+JqzRAvkK1ax/zm48wk4=", "Cvty7Pj9AuFpmAzY9NaSzu7O1/VEBqZJ2gtUITgXdQY=", "ChjRgpO1OwQwV8SMrudS93fry77Wysh4rm3X+CPa+Ic=", "A0GHWGAUm4AjiZ2lSZEvbKYz0M1kMIF4ta8wWDECXJs=", "HnT0f0MOHZ/k7a/PZIQpPUddu9MuTbevsQk0TWshfKE=", "E5POMDxSwtcny0AERGuOKtIsGPPGuq9/C5gHtNyrYO0=", "KZaphoiziWsSv4RGMASx5s/UH+v6gqdsOYKcAKWQlWM=", "EQEniES7HtFTKojJRe6j8XccC3F32ekKifwU4Vc1wPI=", "D/lE5YSVw/rPnovOPqfmO0XgCURT1t46R2808Ly38HY=", "CWhYkrFkeTai0G7CkEI1oqRzI2+64AB4E4MrOyh0ehE=", "LflZVmp/dPB6bY2w7kjM4z2D122Dzfty+OYBy9qKYZ8=", "E3HDDfhPb6F3F9yr8hJAsfYrag962I6pdLdEJFdr2y0=", "Bj33il0q5lk32GX7ZlM1jxEKFiC0YiIfxTci4+WRS/Y=", "BpQ8OzuTpR91ue8Cfn5InEAx/5LfyebMjBRHZe1FWWM=", "JYpjAeHU7Yb0MMEhuKegKsQaRTENbsz7HiXFDhRNVSo=", "FpRsFgUJvaDmoosxDR49RlSW9Q8zHroSo9M16A0Czv8=", "Ioo3fcBj7pXqk4MgPgnNxE7orUzko71qzPru682zr+Q=", "KdViyDM1WhMkbq/tnLgWtwDkMmiPnQFh6zRfk8htHDA=", "Brwy6FGfumNkr0jGPUaHlOQ+rwRKEi9d91BttzKBFXQ=", "BbX17k4d4BZUhe0uiJ3mUkRZfOl5W9EwKZXWRItwmcw=", "Io4PaudZArjG81Hjr+kRhS+3JZTaxthLslAfbB+2K3s=", "Gt7ho1f5vQe5ql1d5sHPE6uF48Y3VyxEBRgCVaayYss=", "D+jiMPemU+cNfma2jN3jsJHJC74zku1wxlfMGFKcSNA=", "F/Ljt+Kl6VnKxLLiq9WyBO0dHaeI7LYB4gnpE1tCd24=", "Dl67jZq3suz9dPXH2FL7cu6h0pQ45YSdYMO+EQ3M138=", "EXb/YLCakw/DeL+lv64TfX6RSywuXUFxi75Zh+pCBKY=", "HCieKo9O/FvwJyv0UBLnxTsuolk1PKX6wTRSVw8Owwo=", "CJcIXKgGLfQ0pPlSb2Xe9rkN9CJESFpy4jti28OtSy8=", "CHAtd8brSFSrmg3CAKlJYCI4Hh/DNgb4onbK4KAIbt8=", "LVV94ESwupk0tOhMFMJ5C3ff1zxglk+sQ8EoNK4WAjY=", "G3xxtUcpVIUlGmAeeVpb4pHskxDQmvTL9sbx2dl/B1k=", "DC/6nQjQH3hjrPMnQeb0D1phTVtbyWgNRFC8w93P5+A=", "FrTfdglIDcSWycgMIFyxMNx1o2vIbtOXU3+4Yhu1Wqs=", "J4hwKFAiqOYsAH6hqA37mDEIkzkWR01wWX6yI9s40SA=", "EtCG8kJwmVUy9eml/g9FQhHfbg1wpPVkjewVMrztCCI=", "FAUbWyRscGFYGORgBypjNTU+0Lqv7nyifdHtMjoaRgs=", "ErZPP7NJF0AjTEsqnCKw02FeZAk3Tb1RxoSA/+2DxXg=", "Hbp3w3FVz8OkDmCjyrIqZe09CzueFKCI2g94I183jEY=", "LTze58IOmB33hBSvvBGsC6VTiwXYs+5k6T3fedFq92E=", "HnLsZFkESoVFzwT8l1zqQ5aTJBGYX2P2nPWr/Qeeozk=", "Az3kKq3zQr9juN+ojxg0MW7AoaIDH+a5kLiTnq2QI2c=", "AQM6+kIPwxHfhzz6Zisap0wyk7Mvr7bdi1CVe0DkU4w=", "AyRgifxzWioQ7/gZiN3fa/bLNspMlOX4EdNKE4r3aV8=", "GEN4h33CnqyW1w8sPCPQOxW7XMM+9Gqk19i8dDbi4TM=", "JKRXCcvP+4Zl4Abm2hOHGLlhoR5fgzr8FN43JzoU+rI=", "Fe35xWurzM+1l3I8Ti7MTp8npmIsFh6Q9qoYnMwoxHk=", "JKWzc6QbYoS1jf/IU+V8HpTdgBi/YVXc959TmtOPBYg=", "ISZngWrfs+quI39LxQA4NyR/8WbPjLof3UMkTzSqVA8=", "HviT9jcVg2jpqWt4k7E2k9GgjaxPRSMQiwqZzWDWJ+c=", "Al0U0dnQOarCrNTS3aP3OoCIRq7XFZgXKJ24/wGlEsI=", "CdGHCdXNHmajClrypAICoG4sS2RW++KMVQn8+PUBAJc=", "EOSeRRWrI/EbqZsKjrK5wMAP/THil8wOv/S3ChkISgM=", "Eg2PPeU00550poZqCVqjA4zVqKbaLIw68RxqV4ePvSc=", "EIahxnDAs4pGFeK1ydpFJDWyjLYYp1XLjk1sxKGF4Ng=", "FD2k8eVsKZU5DebVwgOoGg+FNK5v4bVIvAbtZu63G4I=", "A/Z/DGgudBhvqKQxha0QWJhteCkDfJvE79EzA98lZbk=", "LMyCARXxc9bfGQY3+GD3VZg41i2khHaKqRR+OHGP5PU=", "FseMAD2xet5JZAJtnIBfmPa8wY9asIS/bbR4MktMu/E=", "LO1z/vwsyvZbKJ6dvFZetxGPlKHlW0McF2ZZpOIDALs=", "CANV0mdEbmV/T6SERda765K9ByIiS2I1QQL6+ZXIzw4=", "HXsDXi40RxELVpoKKF/MdYSOntsF8mB5CxhCgnyqacg=", "De99aTIZZXTfqju5PkVeswc688b1sjUQrzBORK+dRes=", "HXvul7g6UIqvq8/CFelL5sMZyRoGpEbv7qXS62Qz0B8=", "KX3yDxFo3zUqwvby66N8AfLh3OjGyatv30vU9zqKphs=", "JwTaahciNWNVUD0saP4bTMgcfsjseeYCk8br4s0Pu+Y=", "LuHJNiFWkEL8tXh5hrFix3E8P0a6mA+Ew1YF85xr0Jw=", "FD2tsnApQ/DBq19NvFRHQScbX+rMQQd4ORu9Md8n1Xo=", "CStIgNYpdRyIDFKlg+fIl7lvjkAX0DYVJAtYsJlxA0c=", "Lfu54w391qYQn/YJb6eIC73KYwr1hamN3cJsPAugax8=", "GD9e+rzQuztbzcMHowAECP+iJ9fqCdHkZyi4pB3BCxs=", "GI7BG45Cef5daIXK5otHsOLzsbFJGCPVbUW37guBm+8=", "A7ky9C8FdFLPfmO+HXkd8TWxIDoFoe6HGBt5Vp3Zyvk=", "DwBOQRhmvzgn7od/8muQMOgjSvkc7Bq/Sx5j7DdstPs=", "B7KaK/JsMlNVmskYZuGL0kIxhzxijGxUCFAg6dlOTgY=", "DdSTMkR32rP7guv5u17LJhsWBT/94HgMehA/UiTtDZs=", "FaJIHZoC8PZg8m9zGABnLU8BOGqIs5pIEwBST/fW138=", "Ag/Kjemx7BsTBgaUWRNDhexzbOPUf8/jHJA23kZlmdU=", "E/EwBswhxEE9EmuQNDDH0PkYQ/zIyp1vKeCI1T5tVtA=", "FWInAyHzUdGf8DDNsQYZBuyvHVRahCYR39L2K1F/rcw=", "KhusDRN2J3FKZNJc/4A7Vjl+t8SfkW8hLDJeNuCZohs=", "CmJrhBPENxb7OUdareWl+mAyvmWHChTHU225aazNn08=", "AdhhSnUBuFCLlyuzqYZdfr4Q2h9++aS3yq4ujb6v3jg=", "LEzVQhO8nBGFhJIlc+3Ql5aH/+YBlO5heomXEJX/FxI=", "Jztn5Eu+DzbgP+G7fQJtOuGNdCgOpmD362revxNiQ3A=", "I0Xtw6SU/QhicN+OwzNwIbv+2zE+Zm7RM1jYCNf7lr4=", "FOMkDUALLzfEYnMeqxq/oxIf/0RSrfi48eotff7+W5Y=", "Jv7RAML+GK/UVY21aQ8fXBrkhI5F95hLl1oSeyw+Q/w=", "CU8MBDLj3WHdWfePPK57LOrMfqUuHkKWGBMtKZNWGz8=", "AbaVKNHLBl6hu4y0/81vcnpDwYSZioxSKJcT5S8aTxo=", "J/QeVT+dWHqEes7am8N0raI/1aMQaGQM6IUfKslBa50=", "HnjcV5njGuAEfsQzjM+LU2Nc6/7sfeBQmKyaSfUbThE=", "FAjbI6AZUWP1f/VzObxpV3uWqnyfWyNHz/7nxsrNOJU=", "CkXtKHS6oeVYU8qGnYjs4LGPknUqamIpkvLECoD6G9o=", "AIxp4RYo718lz1qpqGxYGSKT7ae4A4sPzb6exDo4ezg=", "BEGL3dG2N7Vm6YOvcXSEDzEW/u5j7PgRujwYMgi3NFc=", "IVzaZHhzXrFD/7kGdPz3W6TWD4Hy4TujoUiuMvctS0Q=", "A1V3pU5RZpYzSUTTVfj18ZzcAAaj2PGcv1KjFfypJlc=", "FAB+CPIFCmcmetyJma+r8t9AjFJLYtZiQuB7yoRrc08=", "HTTcFvebbjDtWmYc03wZF44bm172gUEEsPAbMEL7wfE=", "IQKHOD+OqdAiMwWDA3yXx4vGVZsG2pmNNIbHhFGOKPQ=", "JPFOhSkNadUBojR1cHIP+4Be36PEJXTxDBc2MdwVqTM=", "MBFiAkuye7y+dgb1D+f/Yfnvb+xscPrySF0RhZ9ZJJo=", "ARLsfPGrd7qI3wvyucmtzVu9OQR5hVex+xfJ8JrrwK0=", "AEBeWIiFRoQ5jKoKRH8Qd/IpTSPE/hiL0dkCS1x4bJ4=", "JkgTfW9I6S4bzKysvjCERzmfY1g3CDRuLr+Yfzl8jxk=", "KCjtcDkwPNKrGsB+JOLKjfE1YvGXSyyfKz+udC6twjo=", "AV5txYPk4fRibYaZkQFw+qMjXVTU/awkgAEMvEODc28=", "Dg2QHxJhNtuK5AgDU4puY4pnvklaiw2mUj3RUr4kUU4=", "FfHWuIcX83YDH0yduTiZIsgyda8+Zb0G8WOUV9iuptI=", "LUotS+9CCUUS2iXx/ERRl9pBFsvxpfGd7acTKbP9PMI=", "K3VRa5DIMYdaUu/sZjs6wkQwCkrqM5DLt5yrBKQcnDc=", "It/nuhqLg7T/nlmOT4U1aOSSEu7AvrVmy9g6WAyRNRA=", "FzVtIw+dpNJF6V0xk5xUaP1rT+HUOl5qI8MlvreBjoU=", "AHcapaActVHWdOzHekVm0wQT88bz+YiD8il7sq+QFwA=", "IDjCvcV9kv0igm/Hbm0Iwrnw38UoT/+SBnyncRhp8fc=", "G7steDEp1WR9zYaNQGi0yykXVTQvTRiWZ8q3P1iRPFQ=", "DPo81ioiVpvZ+D2sdZgvXZrnP20R6UXbTxaR5H1pDN0=", "ILi8r7IZwOjMdMVkw2Xn8arc6+nR3jB6fYv+vZpZRIo=", "Ez+PSTJM5Vq+E8UgZbn9VSXRmuH9lcloQA78LTKj5Vk=", "Hjk+KBbRhLtv0GJPD6fQvix2fODNqHqiI1hjVktvDsU=", "Dqn5ltp3eSlpf9nAtweBKOcKzkTg+cW9K0CAlrpqyrI=", "H5mCObsTWZ2yXFYhQ+En2H9/epTTIXesRszrh8uZArs=", "JzGVT/P6k/5hE0ll0/LboL+sz8kep2ylljjS+pxKego=", "GNB6mTn6+lEuLbP1I9HK1d5e5hONwtaMjKBtWrtK5lU=", "IcUSLwDw21/YTOHXwjcOAZ+oJp/nYxVg8wpMeR8ijg8=", "D5TL3knXu3R/G3qDvbw/u6zJXGg1V2e+7QLWj0RFBMs=", "B3hlhVd9gWOMjfbG++lP1jL3rX41zv++Nn6co8ozwWU=", "E4mfobQfEvm6nYW3K6MQ4Chzb1IAKTvBXfVCwfP986I=", "Gj4rSjQQuBDQ2NjpG8CrvFhDyQ4fGWkCkkkB5KQj3ME=", "JGk81SmIhlA0OL5oUnflgMqgxhCQzn3g59QOSdErkZA=", "HLiHB9OFBIgo7kpP9GUdJrDGzkQDgBtw5l0DZChb0l8=", "LV2ONshy9boImQXnSLAMFzitUQPlYzQlDbjDT4n0y1g=", "HfSP0EGw53Yv/3hAhwZP27uvKSQqNb3Gokx2TxIB450=", "Ia6hjWUmT0hsmGs9zeery8DOH4JBi2/p3EIO9yj5pa4=", "KVqXjWsRQ9403tb4Hir1C7r56To8T5jwe2mpEpeCGNo=", "BPDwtU4vmt1RfFPxHehlps403zUtDIt7Dqj8oFIaO18=", "DE2qa9iigGlc63c8I+qTbq4wua7LfSlzLz0AXo9r6HU=", "AnW1+VDla+0BMgnjTJiVn61Rsr3rrPsVHimTyGkeHxk=", "FC5iK46wlNFWR/1pEW9ZpSfYmEcQq4Q3N5IGvJW6sGQ=", "CazJD7pSV0I1t+vpSzr7EHpou37W1gshcUIZ/BcNVbA=", "JlErTlNZHxhxCbK0829BMfwLzRzGBraFOqIFJrlZHd4=", "MEy00lizCmeYz14/yG5JGAnKculEBmFgon7GDGaH+u0=", "CfJNhGlxeiu9s0dAlCy2aATtZ9kyt2jIe7a07PNU7M8=", "MCpgTRSlzqSdBBHW1ml5dXjePt7dS+5ZUQmlCfIAX3g=", "FwV6kv2C8ndjuYwBN6Papq68gtHuhNwoZSHEszrRas0=", "F8mMPmsU5cOL/T0ZGOezLYXUMk8W5DRImS/xK9AGOnk=", "LYW6ppK74B7o7Pq44guAuMASyW1p9pS67vwlO7mOSec=", "IqcTrtFgfTbKrrRv/0EeZMG7MWDbPzQx+swHlp2rTU4=", "L3rk1Kz8hJf9pKwNCCytOBlvJlyGCJI1CT4arFPGfoo=", "Gv1SlEYoye72pNXPIanc9vpJsdofvZyXaXqlDc1s9xI=", "GY6HTrMYdbV5bDCBQk2nOpJwjs106A7e1cisSSqAEf0=", "AU6ht47GJHEU1GFc4NEeKAwzsKH7rGNvVfBDpevwTKc=", "I7R5ezv/sh20J35OsTl55ndKzwRS3qs9BX7WwOtfFxI=", "J8hcHBRwds13f0G5nS5VUw1NQ7NBEhGH0BBjfLtmroY=", "H4RoNwl2OfrUPA9AakApo6ttgJwaJ8YeSLFcG3E2Xx0=", "JrM4v98VAxE1f4BkSe6Bsv0p4/L0O638eEiUjdd4GvE=", "LMxueXM3Rfm3WcHrX6NnHcPZkGXoQT1lPrJIN6m9xUQ=", "G3+6a9KFte514ZXeK7sYnoIt7RmihnxTI8f2xXXBmNo=", "GEpchYWGmW8IrFz1tfZzZ9kc/NcbNeujd4fkTnz8YbE=", "I5FXa6kRjbEodOUWnpPHKfiq73HS3tyB0oPdlT1Z4Kw=", "Bv1hO+9kavpPHVf3EoUY+DNQ5e/A5B+BSNLru9kZQFg=", "Hs8UR5SHrY+OXkZ39z2+gfPON37Hvtn78MCg8WuRJxg=", "Bv6YcPA6j4NJjnPs8uIUUyuLEUoUzzs0LXYj6dUZK2c=", "BLjac5elGRU/B1b3LJtiZw7V6YPAKkEJEx5yddfy0bM=", "KxxA/L332duF+Biq1/szO3JJ23kdH2X0P1Kad+MRiZg=", "J4+yHkytEQCRcC5cjNyEQlvKCIKGdy8YFzCPMQl4cFc=", "F37wPDQzKN79UijffU5E1M0jlW37E0RIpIWxllcpJbQ=", "DSAWVL/N1Ay6UuUb1BnA+VwSEB/BBj67jYFVTHHBYVM=", "A7IcSjcCasXZYhGVcti7q7RTND91wNVcdAqtE5aNbgk=", "BypSFk4xdfY1BPvnoOAlCdBQ5VUkkOI9fJyCQvqHDOU=", "Aw0MGEt0PjQBEUsfOVsS+2qWIZHHfFvf7xZZd836y+g=", "JLo797kTSAOrPch/2enCfxKXZPkcNOtTtVfvP+qHo5o=", "E+BdXE4dutRohd/yevvwIffhu9Qy0Knxo9/88zAKekg=", "ETov5ukBnoPg6JhBDDUybBDN0BQprLsfq1+qnPR03i0=", "B4rryP8poC6JUU6aW+tWkLdeWY0q8vkBa7+9rAL0fRc=", "Ld073wTX0UScEuYAMLlxtExld6tWD57+joZygu8RY+k=", "Ig+vNqAX/v2d9CgqlGUTWFpPbPpbxfl2aGH7+kPKGKw=", "Drai6p9oJwZf5mb/PRMYKAkjpjT5HvqeQ6IjBgJXiB4=", "C+lFjpz9bMZInX8g0XOPPlGbXCKtFTUstEQQXvS4moo=", "GSXSRjW/rAlDGxc4Njb2nyJLrtNXdijeM9Gigs0Y79o=", "CkCYiUcp1Eu5aksmXPmAkAOe/2z4sXDOPdb45CVm3Zc=", "GcnUgO84qhMQW1dKQZUgqn0JKmjtbnYXEGWAPaUEgr0=", "HApsB8vA1quJSGTfzp30BrBLsMP319TwCzQDVRQRwHs=", "HUC9QM2uZHz/OLSSia0szP/Gab2UpqpyT6L+Iy1OawI=", "KO8tS7NPtP9nMWmqHN/L/XqGmXSVf/fse+9Mcx29tmY=", "Gy1daxcbAUiUfVX2GwaYKChWcPS4Q9Kap/RJO8xaiSM=", "DqCmflBKVeB/yGjthfPLJEMYNUCdteZlPMMfwwfSnr8=", "FKmbvLj/8GdyFJ377QED3ueLViKvwNmcyyvN4GcywEI=", "KPcRZ26K6MJEPD+CqLdl7cF8/G7SVLfSM4+SK2hDqOY=", "FF7voBSgLZzvO9swUgbfsdzU5Li7kVE+rdE3TDjpQZU=", "I3nSnV6cadb7qMomFlbJ0DcCNaN493zKKFDPs9X8IXA=", "LRLOT7Ae1e5sRExZWDzRom2OdFRDpnIatIc517JoXh0=", "La2l/KznTXTb6+iNr9dUuFmYmwkkC0OkbgPcb7psj0U=", "LiM4ZXXi8PH5fk+whDihNyjf1QMNOYGS/6qh/G2l0Vk=", "Jw1YkB+Iig0zMTkddLctNf50mEmt1kGc10fWzWfbLVI=", "KeSLFXy0B/nOBp0PgKRTfNnocXnZ7sqzUMeNaZCk4OY=", "HRXVBjG+cj4s6L+LVZ2XWvNwVXq+4ztlFM7RvH2/v3A=", "GalUqlVWlpcILZcBfLZsxnbQO+1lQqWKIjfnSDro49I=", "EUbYzULm4eR7UdXYBmDX4Xq0NGeipbXIwNJxv5KDcVE=", "AoGjvCh3uC6al5a+++jbNTaq/xK7zr2R3miHQy83u0Q=", "JxkE1vmN594ccCddPjYsOYWy5+vAc65ZBYrCtOcTlOs=", "Gwfw+IHWC3zt3+Tf+Hj8cWLJLYwje1JBAX/Aoq70OIE=", "K80nAaY3Nec7Ale3PWOsfNd5LPlu0KD6POO/YiCDWus=", "Ex8l6KqWY8/4/NxPMlQ0/hRAVvrauwHU7/wCAUjwdWY=", "HgPGJFHLv7gqakyFE2i5qc95Nmvkx5N+8W6JC8ps1sY=", "Ko0wF/KyGoGNPIyTJWa9G6qqfEVgC6oJkKpnpJMJyzI=", "AXTCDhENEG6wOM2TGNRmkaaF13e3HYhS1FYCRi7F46Q=", "JjnfBz+jJ4nQ6a+rDzRCJIjq4G/XXvVZleNp4bFdvd8=", "DBcNaPEzEldjuncUYksAdHX7Z4ehsXBDkmlj2tFq/R0=", "L7KZNASDoXObAQjmMaxuiRc2clOna555k7Gq2faU7Ck=", "JYjP5CGmBwIhb6C9VnyyZq8QQpI7xstX7Wi7kEiPNfM=", "Isj9RjhWS53pDKNeZhll6m8B83/2Fe8wgEb+E27l8Bo=", "AXzvCcmAqAxOU9coS1sqEN0c0KtBJg0zzBnfraiOVEc=", "HZ8KMCLEdk+eXmQEOXu/RL4EnlGFysSLxymslIqwEzE=", "G79rFK0+dma9WMfpdQ97ufbW9wxMKr6R4g/FHMXsKMU=", "FMjSPnsVeHAkeU3DPFjauMEXtRtFiPXsXNjFn5zDDcs=", "G5H8jmKnnpj1Rc2iYI8ppBaWQaP3FerXi/SUgiVV9WU=", "CukEFHYgvPBKS0qWebJxP92M1QKW1CyjGFSOMrgeOzg=", "Fm8+MyV3zhDIc4kbXMdC58NLtNYrV3MxZojlEPTYK4s=", "AUHgiL/G4Aei2Cz3F5VHIMspuXswyMgSXV+bRsLiZiE=", "EY4O5CAtEnoFd6buopu2FNmcEDT+Di50Zekel8g3qik=", "KXC48x2bmvs9O5EtkFlKhHugSD3aSwk03xJ4uhS8Lsg=", "L0peqkt6/z/NBsnWj6LjLktOYprrk+zLVSyflvvaPd0=", "ApHWzH6OUVKQL1sFwTACu6lctUZX7zk+krzCO5u/f/w=", "LiIar0BwwsDXNbWwpSCZxllNOJNpFMk5PY7NIycIjEI=", "ED1mn8RrB6r2zESJ6FckGBUDAAgX+MH7XUcbKzYXnyI=", "ENvjc+1wZ0ATqTm0agfuT4wZHj+2OfjQp4HR/7qC/pA=", "EWIpuhz1gP+G7QBrkgcDbmnMDxtV1AiKs04Bo/JfpTE=", "F5uzk7m+6O+RiiuiI5/x5r1j1tSMrUq28tMZ8pmb5PA=", "JXqN0BULElS1hRIph+O/zd5/kU03TSvsBZXEavvAmXo=", "EBX3+IcdurDRIVcLC6ZBeYCi0RspL7KjesdMim4Zjfw=", "FgrPPcmNnR/7FersIofVzHQ+89FvuL1AlGokYz0jgl8=", "BjxzVSsZ/m9o6d+UOKWBgn7ObDFSARfCNTxnzwcU1bE=", "A+jIDa+IeTjNNV7HEKnjL0TEdSCqul3P+cYsS8BBKoI=", "GsP3gc2WdsQeoh/St80/OMx5Xra6RaUlspHGa4znumg=", "GJ1xIUkybXGwMn+bcQLKD5MEP9vPQAwY479wEGSTNUo=", "JakSdh+Ni938+8CZvJlKNVF2xUoYMfjupVcsR2WSwco=", "EVjJdY/bvWVR/SzNYV274L7elpps0PKAQOk7UjntouY=", "KOe1bNKbFhM+Zjg6IO2qanebavuCdyNEzSwll5qaXu4=", "AsNZf+rxA67wzw2pbHgXv+VxOCjGE+MmyXXKEwmSdwA=", "HEy2AxVUovQPzRtxIjqXl13en09cJsoIZ4hwoTntk8k=", "Lsco/ntpzEIfGNlr96gmyhsEJh8kqY/pweigpBtktYo=", "B54zH2XIqCuHWSLIRJu96joRGmgXnl0t//9gXhykfco=", "AmzYE/JIBwM9fAJEyfB5D7gNow5ePB5F18cDLyqqGDE=", "Bb0RwrZN4ac2+TrI/34MFm+MVwpvBo3tr3IifoXBFFE=", "JeFuxb5ojhN7LMzug1Qo2rk5NRsyJ+i+v66F86H5wnA=", "CzgHOYGwr0GP5p6lXtob5dKJsvDeO93kfuZIPwM7Fs8=", "G0C+Ux7froGjPkBjj+hfiAZ5GaFN0d55Po6xUg2zor8=", "GzQ30PQFqyfBhWVpmcU4pnZUQ48oVis6AOrDlecTODU=", "JavpbdwhssF7a/s6ipCirAUbOHHIf7njU4PPbXIjiIo=", "JeP8k7zf/rQovfjBJJGWPkrKGEdYRLZ/xWdsc/0Os1g=", "A6+WtLlywzcbB2ghNZz6rq+WOKByxPk+CKsRnmx0Kac=", "IypIcy3yWZsJ8fFjHWgSkwP/bUAJj4smAJg+VTRDXBE=", "DN1RipGzj+2kaB07yZIYLuER4EQOmGDNxxzbNq6Aweg=", "G4IYmMQ7TzriAH6ZTqg6hNP6Y+dZXbL0ExLN+tHPJJk=", "E4YgOuQTwZQqM2svoIA49OkuWVLlI7vffPM3gRPvDP4=", "BCVlflepQQ66A2Zc8c6O/z4N6UabAy1Gi6Fdkgj8ILU=", "J4hK3ky07sDJHIF34Jcb1am4RK8YjSisGYDMtCX+aYY=", "DsgXMN4IeJQq9LOCe4vZrEy7Hzq3rpfNG7E1sLfHj0w=", "CpPxyWKeyQceJoFIxlA84YAPTMPFOJw26e3j7rq7cCU=", "B+nFjdfEdn/KXMvNe92KT0vqeFhUKymHQ2YGVAAexS8=", "CXXgdhTM/jzzn9AgjpfK1JxlowrzWQsk3xAW5qetmzk=", "AoPzAsmJdaQYojLTJj2A3XQwARPYUd5te17zx/kplFA=", "K5mZP4EnLABVPHGCfp4ksycFSecDUVpnBDk7OJSn03g=", "A8zmPO8LzuS51cdToZDCSRJ6YotO/11Vfy7AW10DPJ0=", "K/TOE0Ch5xf9jfUl1GQ5N16zZCIoranbrKWATmmYUHo=", "GulFPcuIkM5XiyIdhGYSozlqskrIBX7Uggnv2/MRZc0=", "J2TT43yCx2OCwsR/SpPdjnP9x8rb7Gi9OwO03XXAmHE=", "FQ+UGaO21G2v4FKULhXtSW5bFiZIt93Tz1W/HlL3Y28=", "CHbcJCyNKqGD0YTLvENA1amjpHTqhKmQRpmdlceIS88=", "Ia6GrQtprmnkub4M6uAWZ4lanZOBocDebThk0ijo7FU=", "C6CudfPHYunvoReUyBIdK3vG6+448QX+wANZWZJBlYA=", "EKFqv9azg2DU8yV/PFHJ+5TsX4Rd2D4MSsT3eY8tkHc=", "CdzZsAfQRQfAvHcsDr+WTUluaXRhdTvRu4G7w5WD3jw=", "CxuyoQlmGO47riJWP2P89+hagX9jRVAUJsJxos8ZdeQ=", "BEx2UgaPuwmRrtaURUAyG9awmh8NbpGlS4r026GEccs=", "IU6pVcSypRB9iFo3c03lya/O90TEgVWT+XC72sUdtV8=", "FoTTbc2GQItoIwyp+Y54SVe/t1UqklPq7odoIL7jEKo=", "AWZs652c+ky+0VmuaslFUWsJPOWJxZ39Wr7/bGwu4Gs=", "IVGpnve8B3B+9+IjhkyejFCDYwLymarQXeNa10xAna8=", "L1bhUyYpW9cBpAMU5CzP1cpOCBT6VNMS53F+SI2gWVU=", "EWrgCabEu0wowBZxY2T7fnvjshcjdV4WB7GiYrkaFq4=", "L9vnH1PVTls7y4UM5hdD1nW+YB10Qw2euAc/aBQgUYk=", "ARqR875CS5VbIkHXU+PW1bDEj/nGi6ho+KYRIyukQvU=", "HHyc93USVQcOvdDj23+X5dlVZNM9KzKTyv+gQ05teI8=", "Hrl5Ihwx9peNQ+dWinzudwnWi4blbXfsiVh9+qeCYbU=", "JjtI5G7f+J8t5dzSWIUNIAVD7l3eMUWbb7UkGmvO/XY=", "B4W5VZxdoL1XqAFQwim7LXX1EJTI4aEb/qU44hfS7PU=", "I88a1axXZYXsz5cJG+V88Oo7uy06+RdPgEJYJCQyHZo=", "J9TbS9sw6k4HVQ2eB3uoqdXKodQYwadqEtxx7FWIEYA=", "EV9iQv1UErEgjNQCPYz4f7YtM6gpKyMcr42CVwGraBo=", "CJu8gwlPZOKTyRrnmot+AJ0PZ5xn3BnGJZewThQVxCQ=", "HUobPnptJqjIHX6fS/CK8L8TcNzQ0hAUae2H1GnSRq4=", "KGhYPpvesQU4Ni1/7YmX6c60tDq421sKSy8UCUOuUqg=", "C3lFnqgOcVOegHnPs+quA85tDjyFZVfD9x/JgwlbQ08=", "EZEZ1O0W641HZsY40MNKzBWaK44k44kow7qHWJDqGYU=", "C/2+S0N3IFN39pw81ek+zSqcs7SuLBVB2OdLZOllp80=", "DUEXTNa1xMDTSy9NhB8/naTxAOIM9hQIZO/m7uVMCKE=", "IcWRW4bSIRBn0Z/poxgjQEO4C1MxJ0mJi1N3g8vk4cc=", "EDikqc+iDKui0j7wZOdBl5LoOjHwyr3k7qsuSZcv144=", "AXzAB5+YYxdxR4WMidPX8xra6/vkyeB07KvSC30iQ6Q=", "KU/35eNvdpDWD602uATjVlnoIRfs1E3u63nli7jIdNg=", "HwP12BDfpi7dMlIavR0oPCQWoo/KokTTZ4ju6xlakEE=", "ACET4nFeqJPQDRAbsw5uFwIVfRD6/+hQlUJ9ydnK7sU=", "LpLCm3okOimdkueBlfMKmWo/U01XkaMqC+KLt+iWDH4=", "ALswCsdFZESfhyZ039nhehhUMvH0YzF8351JnIfPhZU=", "JQ6DXM2g5Gbb1ZpUHh0DxPvtY3rGtxXILDKvWI4bsCA=", "Brd2xQJKtjdMhPVSjKeTBDnaAS1BL5Np7jbbM/xDWCY=", "Id+LMYpEzF+dVLvvyXqRt4eRK91c3KlfR+ucyJq80eI=", "Hk4er10XKdVSMLr7F0PeRzKhjWapaShJcB+aJedMqbk=", "JozrN0lxk3mxTqBixjs1lEnnCtWBbfAUy9ECrGR/Iig=", "DiUrIxwfDvGMjWr72Hnqp/nmHepzJHyjr2Kzweh5T78=", "B5nBTuwgQ4oOU7aYgskMbZI5tzZ75Q9kzpLZl0wr2v8=", "D8BQAAyCGkz07mv02RukbSysIwURjrwZRoSi3LfXOD4=", "JhqM7DHBKJ8jWMc1MO1+AcLu+Iy61AEOwJ0DblfSqcQ=", "D+U2ycfdpQcKN/0xE193pn+fOphrHCPeuD6FeTzzz4k=", "Gf/drv21ADK1jgi083exwOs38GN1/3jnq3tgV4Hd6Nc=", "LiBEE8U0RTUQBDFhEPU5hJrnlx+Hf7CEGxnudT7iCD0=", "Kq2YaC3+CK0smxX0RVogHUqWOsfbsYmkLSs+HD4DERo=", "LIn4VVRFlLCMpDp8MsMcDZCurzABMsi0pMxmhDoYGuk=", "F6ofI24OidbIITN+yQvXp4sy65uv3Z6D/4x7G5eEgos=", "KQ/qrv8pjYh9WluqR/4uhAcOt40gedeRrLkGepeawaA=", "JhA7hziWhnGJdBL7QkbahurGkjXEoacap6koA0kV9n0=", "Aopw/OoPJ3l4Eg20vUeKawnVTqqKl9Np2seXFpibQ8c=", "JJnR5FRMbblOne2bqT/ZIWJobkEgmd5brxIyEbQTjKA=", "ChqqaqqX4Mcij/rlF7WTkiEa8476ZwqgYgetfwW/Cvc=", "JbYYnM9qs6dZZBrnk4Xz594ON1phwmDYTZGzMPg2Fto=", "F0awuYL+/Z2Q585yzbX5LODGmQ60OifNU++hvOiB62A=", "KJ6V2FjSur4lJlF9hQWHw2Can0rTKmRt5R6Ga7oLQr4=", "MEhBGuIc7Rsx1D00lskuZqJtU6JPJQ4X8yjDWNl8Igw=", "A37HEXkLW5gZ7S8g2gkqa++pvETL5sHCHzPT77F2iPs=", "LUAp3nK/AeWTe/o0/01eu+rLAQ6oFtn81uevkdmmcUo=", "BGb9iyODbY5FoXUaHQ0o2wA80gVFqI5BMYxXHDj9OxI=", "Ay7fXfbYM7VJCEDgFAJHIY1iVMNpfQBw/c+/bxFo6EE=", "JAmOcz4wem7knjj/0BBYmlHB3yEoLYJ4j1vQz4ko0eE=", "LV4vpeYwBCoHMeyE9KVIQg3VZ0thSz3oPlynB+yzJwY=", "DnchDcnyjwqguTML2mmCWOQpraPhDwhPUGaq3IbX3gE=", "AuvaoJk/anAucQ+PxHOS16DlGGKUunjMveKRNRCHtPs=", "BWZ2VcL1SyQThbhvz+J00fJFaZzWqmC2/lFRAubtnA4=", "DPl666gk5Fhcyec8YvAzS47UzOEna5OVAfwvv2ss8t0=", "Gw2B1YuFqA1f0QtMOZ4LqWA+DWDHpjyJyDOd+ss92Iw=", "FlJhgG1XTgYS2TXv8wZHVK7w+fyGmEseMdqZaWG1Ze4=", "JUPBIup+CEBrfFqJ84VXnFhc5kfZjsRAC2247L5tr8g=", "GKrB6TMywGlWkYUogLMI8GnYdJ+UySNywTZ7ztFx7gE=", "G/Y8/7Ra5vCDWN8BUqzhcFi7OmOwsfJWfmnUK0QEi6s=", "ICg9BEPIQ9+izMsoURn7ShIJTJDOatoPbe8R7Gyqa5Y=", "HZVP3WOz7hOmyhPf/pgyqp2eXy4ezT5AcnLYfCgSULI=", "AxuA7zDrD2OcM/1OfVt3jWB85iSrfAu82bKSG23QsWQ=", "G65vI0YfaCpjicYHZwyiyXW3aLpJIlQ9/gx43N4+2FQ=", "DBXTS07w1t0yTx+o7wWL8ktXQZweSTlq7MaylFVieA8=", "DJXZH0brWHUGxXu8LM+HoPxTSKwNrTdetAmqZM+S2pY=", "LR2hXKUiqhhodAuegBoAjdt4hGV66JUH+5lFcyZ4bds=", "BXLM1/xv4Gvpvyv6i0iRo35yiAXGCfHigqAhRIDmKJQ=", "IBa6dm3BTr6yack5+YjAsOXXoW8mSeOId/L/ilJaiKY=", "HVcLX/hXMOmtjDJhtq6FdJmSIVdP2oqX8ZutUNwuxyQ=", "FDIj0CfLIvQrIKJYYDM2V8JDoF4W+KD7B3hKP4s/g7I=", "D2ftUw8xUEv+O4cyVoKl6bkW11yqe1s9XiIsf4ZBfc8=", "EBOFFkaUeClP7wUIFR6oFk8UbI43fpBjfEYw0LRd5Tw=", "KG3L25yF5dbGgGa2lyC1UPRhWDdLiOdrpICRZhtZHhk=", "GJAXrQ7GWZZV+l9cBBsYnUpQVag5FOXrFWUgnUQ2bx0=", "EjvOn9QMfxli0AZoVgzDGSQovCKWyS/ROkLXW0G0QaQ=", "H5ql4lOHmFBzyiINp98qbO+LYKCJ5K/ZPhTus9XcteY=", "ED843bbhpmmqQuoce5qwV2HxgEoV/iLya9NDZ2VDJqA=", "EjieAQk3eq1Ca+RxY3WEHC/Uq1mLYLaytOei74pIrno=", "IE7wpP5o2/ISNxQxJlRg061jaRJFxWzNT2mQuYlTfZo=", "FCXH4fX1pCcIYzQ3Zy+Mz/HBe/dNvvoemc0EDNGT+5E=", "HRsl08q/9YQo4mluzqmXWpSEMC0X+hLPM9hBa0/h0pk=", "I5CBhnZ/B/E9CtrRFihPLxeRRHULDx/9zmLrR5fsIOY=", "DXVEc9fIdX6CKolxjLfXxazRElyl4NEnGEhlUqN0GXQ=", "LVneccZbhnjdedns05FRl9FhslORMpkjjvjT0ozBLWc=", "Ky9jjc5sXcBL/L+0DW1UflJzDN+8p08MC75f4l4KbkQ=", "IIMfMxiNqt93xILB8667/MubwnVZQGhEQSdvgAaTx1g=", "G96gOocRKsX3HSewaQ61eL4gp+qwLM976UqbUEMGv+8=", "B/GQYmxc5ANnCrsj9zkRL/uR3CNIGRgNg94jTedDox0=", "IdA6isxQAsdWXf2E/jAB2dcCWSnHF0neJTgr+Tg8cM4=", "A3+OH58xC5CQhc7ZOLYA1N0GoUfVGDmS2XkqxEWPeTY=", "AmgMtCDqSuScIobkl608u1U2CHWitp4X4f0JbrrFMcU=", "E6OgbR+4J/8UBhkhYusjs+J+lM/aaqBahqteMl5d81g=", "BwYJJ7PGQRF0ZkjWqEM/+PNzpFNIQeXL/+W8QbnmiPA=", "HUFDUmBFxsQYyn7fv5hQ/SYNIxtSsgl/0iQRBBy+744=", "BPbbJTC3GaN2xufUic1/vGUufS0JBk4+lESXjJvhl6M=", "BULvw99bzvaZ8Pp75ccc0y0lPyBIi/cNc0JB5DTb8J0=", "J2lCS7lqbCHGSlBhB9SIX+U2A8Cf+7AYYGWDMKsbV/w=", "EjvNsM9uevtHuGaCfbcjMuk8VxUG4HPEmK0akr766vA=", "FaHSWrZNsDU7M60QCahnJ2CX1aYLSxjdAr/oVaSVKyE=", "C5y2/X5v+uyCRqzUHkPgcS/XbVyuVqlAds2BY1TbMb4=", "HzjB/+VHDINnZ3yMZbP4MZTNnH0ugIChwxUTosI5Esc=", "DzIjfS1u0AscqVTfN8MMmI+JQV7tgpEz9ac2NNBfDGA=", "GQX3boJeFnH4Z/tYWPJeU6RfjzBqmhtt7nAzZH/IrRU=", "CRx9VOAgZ63AeUSU79CtkG6MM4pSTDf4JfkAOsMS0Cw=", "LbpaIZQ1mAQfkIYMjpIiPXURx0vrRkjKquS43jhw8/g=", "KTo1C8PHidv3wuWgFUgGeKdV681o4csp5B0dKULFedQ=", "BJ0BmbbA8rMSLX10sxrqj8twGiT0C6X+aY3mMdIvYkg=", "K5MlKRyhSMhuq8LrMsrkd93oMPAo9Ui1tcbhQ/uKto4=", "CWpu6YxWhr89WGoOVJYbCjr9bVLaN3Ei6Fo1UAn0pWA=", "E/zHfMtKCR6kUqP0oQ/K3bqnqxjrP4hQi9EorS6lqBg=", "CRmfBhVu2nyBAzQ7NEurEfQ1UbuVB7zNR6KSrz1Pumg=", "L8QXxXbj+ptrOKguAyhCLC0tq5CHnkL+pzAzp1YhZrA=", "J6gaDJ5dDJj8/mea/eDK7c4sX9ZnQkkugNzpX8rHn/E=", "BGe/jVN9voI9an1kyix6JBei13WPwaif+TME/etNB5o=", "Bx2CvKkq7+djbxDJzhb35bQTFBKK5ZB+GIS6oYNEJGk=", "FHPkQ07uMLLn2zTa7vsN9H0fXpOayiU5SqEaaG687LA=", "IwNAMBTt2DM7h9XMTLCP+inudS9qNnxcmRj447gKzUk=", "IT8vNBdJ3McC++uOuRauZXVEXNnU5f1b8Eerp+wl3II=", "BkNpvqTGdtN+/jpl29Qxbg4ba1GsSL+cAbUsFbJOihk=", "JhiTQVCZUeY647AiOXCY5fqTU2JSgBMbMdrDocGDeWc=", "KMUatGMBLYup8Lf47skczXaR7wVwIXiS1XSUxvqmq9M=", "Kj5aZgdTwPczgnYgzz0jUeTxcRM/dJ6uDKslrFqk8Ms=", "C/MU2ddeNUhs+fYvZTlYTQ+W/P3+oWF7dqRkCZnz0Qk=", "LZY2hFbF/ibRGaV0LQFNuehv6w4jFcKje/v34CygFJQ=", "Htjy90Pkr57dYtmt1jRHTVQRNxLl6UjwW4LQbntZkT0=", "AI1aBHojOWq2scAtEIl0slrhNeTw3mgFYnygdPPFiok=", "BH2KtsUjUNZU+GuJQvENLAAhv+nf+h2yVNzFAorvcQA=", "GZHIV7MPPtilj+Ip2lwT/gfXUZmZjfEJIQaK/tCaajY=", "Ai5IZrivFs63/UVzesNSgFscV1RW4VNanp2fenngpbU=", "CghAzDcg5lnzEdrM/mNI8ofOHdRzkSw0l5pI5psGqlQ=", "Dk/5EO45IMWH0GENsfvgi/3C21OBkmJjsXdpiBDdpX0=", "FV0nsESFaSC721Zn02GlNsP4xaXYWZ4qeVXf/ud8Jm8=", "DNwAXVX1dcYaQ9iij9u+8+7DXlakOKuZaAxNHvrmTns=", "Ix6Hupimf4bVAWUfW3S9U8/ia57gnAep2Dcba/fEK+Y=", "BrTYeAW/t1+cN6YeEOVXkSLTaTJ8NE1RbizmyJOYs3k=", "FuZtFtP1cK1do9weyz4Ys4642OBbLo54hEkaLhsuViw=", "DGamNAycIM9m3j1u651J6Kc3wjM0PfjYR+WnGO1RGKs=", "FUpLGVdRR7ZnK7CnIc5AlX+uPjNsgsf8oZmrMOdRInQ=", "FeS2pwzavyxN6YQZ2oEdBiyo6d/L45vHVC9m97YL9j8=", "EWGtj7ogdgoTv9e36h04JX7f+oxSvo9BAIfJFvUEr74=", "J7g7x50q1NpLXvSYLpG4EHSYXPIzEaZY29DtMB6Q/Fo=", "GkEVcw11FeiujQAA5I9s78yJMZBWbZTTnbFVF/QB2d0=", "GpwrO5ekEIgovXa8QZaNMUArQEGq3EFtZcIJlu5qxq4=", "FWrrUOEcOa+UbFMS+w4U226RlJBXHg7WtVVVbDH5fZA=", "FNJVB9uGnigtB1nN8W6BAG+vnxDmY4gwMJl6uJQUnio=", "AzaXe6VRD7O4Er85+hlGWUp4qZwAEB7xAXJ8Lo581oc=", "B/i7dx5Y5XYQF6lWLGsoW5PWtwmu2hhtlmFhl1efG2g=", "FUxHiiVmKU0vltg0MjAJrw2+8V2mLe+BccMJoF7R3Wo=", "G5OL8wbef0gyXeWYd6vL/i7qCJ6rCQOALHvz+5UyYn0=", "GqRGiQz2W+bOf31gO9QuA7f+wNIBZo92DdYJ0xtYfiA=", "F+t+5Bw4dHN0p7HxRXh6x1uNVC0zSU1l8O0Ayk7Rft0=", "HRuV6eTc89+QGq/hvaLMgjcDL9Nu1QjGHItBCfggu2E=", "CZ19+XyrUibMfjo1zqpjXCKrARDpOmJRbwNwopZ0KfA=", "Fh5TsvEO6aryJZbGIUgOHeIJBQP8xVqClcI9Rbr2j5Q=", "C5u1PWYDZM4aUiK9zyqAoWGTTj6S3lBX1mjc9J3qmfU=", "HIRXomXBdW3nVxswKQ3LSPoL6yt9HkQRQmJRWFSAgyY=", "J/nG/QuQmDAQ1go32ApYq7DzUA1tFsm7TWpSrJHEpJE=", "JogM+gTsre39o6JKlWc01KvIri+SZENpyEYN9fIWR6s=", "LztY6by+N+lc3ZmQrrJkgsVesqlAnijlbK4k38643eg=", "ERcQTezGeaZq8udYjZcYBbUYrCGfrIB4zVIqyJgMaYA=", "AcdFQY5M3YDqGKM571kOWDYrOCOx/tLWqO2UIZB3HPw=", "DK2KlU7GZ2tC5DyGkCQyoeF+LPSvWjJ0vBvmcm4dvj0=", "GzC7mJ2wM30EMg/M3H1m8LsVtDd/zhp1tCeL+qYdX1c=", "GaVXoXIAX4QkLUDFa+fDeVXPdNoiNVew6t3rW1XGGB8=", "Kh+IPF6ttpZNSEdHn1LIJQtMzKD9spIji5N13MIY9Mc=", "FioORNuPqgLb4apSsWgHEKjcpgkTh2lcsiwf+ESSg0E=", "DtmUS/5IVC76EMnyC33UxrFVhOEmvywByOBFaLyK4h4=", "HVPAdsEF2mf1z9gi/MnCkd+ikjxMbSdd20XZJslxHC8=", "Byugos2uV7WDuh1y8Jx0XlD04Wre3WSIyti3k+PSrc4=", "JuctxgnCkBhz1Ap+c59wr3IqpDmg/kF9dWjDjjj0fOE=", "HzyrZaq10MxkWFGaFNKw3930wAWmMwPRc49W1MQWAr0=", "Hfs0WrVllw6VyJuil7Y1XesvIwK2YXnh3FSJg6rgLXY=", "C2Dml1NSFb8Q8csSCODmmb2IWYGZxtjWUuabkK2A5sA=", "CBWTeG4wJlA5awpF/49iNmMQofU4adBVcoRIGsS+4lg=", "JgJ2pG5sYkeB86d3qbRbSDWnUcawFuWE2jWjwwmEQ1E=", "IBILQEUWcxN4TQwstO3gev5/sGBVGPb1DOwbiktorHM=", "AfweIpJnivjcXcHy8fVzw6xOGVxamFfkD66SMJvHaKk=", "FMAEetALfXNqjYF+Vh5YLpAbRIHjgxZWixviZ+d1uTs=", "JQtOatHH74ymwlHCev8QHXvh/CX7xIRHfLvk6Q1FbS8=", "Ea77wMSh24Hlt0WB+B96g857/u/Oq3SrS2raDYrKKsw=", "EAkX4IhnJIHIPOnj/LPbMvtyqDMy5bJ69VpIxzpvmok=", "A3te7b9NqXYX9TuJg3CTM2diA4jTjhagvaandZcUu88=", "CvmLGoVsUTh3Z7wmFGiIsoBuZmQ7RG/MP5GFn7Oc3bM=", "AP3QCLysaX6BE+ccHA5JBPUln2CqQ+1Eh5bA7ZSPutQ=", "F4Hh/PUEbibxm9rzQW6mBEVOJU/rCkk5BfVmtRUQtZY=", "DoDu8U1c4GhHpRsOnkVBs6uUyufKKlNtqaJkyDkYWUw=", "A33KA6a14VC1BWQSgILmmApncD/LeD4OPhIDMAT9drs=", "EJwo3LhzsyctQL6wo/6PT9seei7Fp5s8Q3wZ3E5WH2c=", "GUk8D1w3LHrQxPCWv0wgZgLq0j0Zdz9nZvE1px4Be+o=", "GxC+lly35G8VTjwIo2ZWwuiVS11QfJSfdZe5ccA94yU=", "LeJucAMg7UzJhlUNnk1qFlYRVnDzQR9fUDQERFtK238=", "Edhqxx3nRgeFner/PPCT+AdtKGIKiGIcCaeqsSCakaY=", "LDw80T8jE4loFwEkGlT1jJ9q8ev9bO9Pow6fovpOAqI=", "B4hkvnpfNsB/qSSOmBgQQPxakRgVmEuHUPlEv6U2UDI=", "D9cYfLYJauDhLk4nZBmgPtwNMkYgM2LVg80GSmx5//A=", "FeYmWWgp2ALwrb8kdulWbhw2NIsCJe6ufji9Dj6y3aY=", "DUbe1VIdFlxPsHJWovf15IGfbYit6RC5rT+mxdffqxA=", "B5U5e95Gtal6I/cqi5JqMp880rtiAFBufoMqu2RTuKc=", "EwCOFRm+MCk09CADKduVG3AOMi2xqH3VeYwrnhJZ6aE=", "Gj9AP2RHN6RmFeBHpCrK3t+z2E/MtzmZyrYn+2BQEj4=", "DJIbwyqfyerGBl9dxjRhWe+fbc7ZZJiWsU7b86qCZPg=", "AHj5ejfVX1D71juH1ZXcZl/SBu1siHUJrafxrw0eZJM=", "G8Y5MhQWKlICbQf+dw5TB2PHJbdTnZshnMV0lDl3xtY=", "EhiYwBLsiFFPFViAw2wXVcFYk5CJ+KiVtWVAHeB7xg0=", "DxvKRmuyTdzGDOkrmu/nv/Qn0eV+VvZU+9zDYuseDWs=", "CvN57E2NZTMiGPUTjcEo1BsbNaM6XQ78XbtsiBREiQ0=", "BPIQhjkt2+Iika+QBwm+h/5OnVKx3WWexWO9hI1C3Xc=", "A1iU9YDIJsZp2RKmlmR47PoZqxu+gOWnDGoYZ8AsjZU=", "LOuRXS5Hh83I6Uik6jWuBLtqAsByDFHs+ZialLiXlII=", "BjPXfaXtiPnBJ8RZow1fjMC9hTd6Y8TnVB/3NSceZvc=", "IvcTdZVFF180PQAmXDrZFWrpmjXzBFoDRG/NiP8zFo8=", "E+MDRTfiuCB6ItF1NHTyxLv7ED8kc+xQg0jdxQ1gKXo=", "EiNoZ6e94hq9KXp3AY7q/kuEDfZ/eE0baYHX6R1wQks=", "Fa0Q1oCTRP12o4uZ9F/D0Q6Y8LTRr07t9GHEPpKmwOY=", "Bec1LZXcHHogMTpT5m5pUlkCoX4e1DhZRTFC/ElSm4Q=", "KfbibY1hQeGVXZ+zImp0rHHzk7Fqr6tB48eH5x+/4ZY=", "HKPAtAVtureXxUaIg4oHTP+N5r1qdce2CB8ROx/jc4A=", "FB0xvXHca8jErVlYL1m5Y8BWI95GGZQ4un7b5L4qRmA=", "EGNTj6RGVzmeEll60MkiD9YIF43jmeWpj+ir86xBDIM=", "ChrvcGTMmqMZNd2lfNxO4PEQTUNFvPLkKsSKyj+5FY0=", "CFKAeTEo4VVsu/s1yaqXqgdMSmDYFpQn39o2bkJoaqw=", "BqPI2ruaAECvVnHLHdv3JbSExoNg71EW6bfsBf4KaWY=", "CaX2WW4IkdzF4no7mMz1N6zJqLt0+FAiCbQ23AcbtMk=", "EWIEEpQ8V7kCrzYm7P9gj3Hj+VjIfNABSiH5TJ/zVek=", "BSFE17lOrjPeDWzOsuJsgpt/ci7S+bYBBgb8bzi3zGM=", "B60co0bW9MwXv+WCdMGzVWWQksWCleTA54ERo4euqx4=", "KWMFLdNtM4PzWMgCQwja4hJyE2QMeF8gKo2DJRJE1L4=", "BIlpCl1WNytFdjLXfMyLgKokh0c36aBd4mnhFhjtaf4=", "HAH/8Gs3pRfTnsev2mbudo/TnsVomx7N6/MSmcN2zGY=", "BrMMFYMY2bXIHt7oBSKvr3LogPoyfMsH+Nh922bxXt8=", "FtVx/HHl5KljA3PRK4WkEiaDIs2UcH7uDWeNK2Jm6ew=", "Bn3ZgdpgUgh7vkTtNXiYvowQj7ftahNIGmUJATAM1YQ=", "ARRPM78b26kD6wtDRJskaHvZlfDbvLZU44rrlKbZOhs=", "FhQDZ4W6Fsw+FYv3DCFPwFhOQz/RQAnVdqZ4eXDsC/0=", "JXdVIoMAljWBZi+g52f0LVvG/WQvBANyxT06H+6Wkt8=", "DehiiitR1w4w//0lHbTcYY33MIHQHfFhIYKy87wHuhw=", "L7PIuW/hfMFDJ+hIphAHrH8EMtO0DwgC92TOfBaGZCg=", "G2gDdhfqZfhj2Cjyu+RBIouddtlGPYPXeeXuoN3JIpc=", "KILBZUfLaPiAa3etgT7jY3I1PpvRwAb9GWECBQh3RBE=", "C78J74OTmJ0opo0eC/m0m5M10MNhETZJThKOX3tk2LU=", "AscK9tNsB/TktlSz+K2Ysska8Jt7+3QHmXeqh/mbE5Q=", "A+ft69GMw/+CuDWtCLxMM3G31VKG98SMdH2TASf2K1o=", "LQJN8EGVS6I0Qd2SezCh7RAo6S1MNRZDKWdCqXQTm28=", "KYwNH8Lzbo//M0JWvFzX6eQ7iSyhdikrOmTXYifMSak=", "GOZBaViJjsiYhTU2MElsLF9XLsUNwtBO8XhpeY+a7+o=", "LVOifCwH+5YFi4jJeJ/D+OHTYaQSvxZLKqDmbnALNng=", "BVJ3BBy3oSKxYYsF/7k/cjQW6o7raBMIXdVKmds+sT0=", "JkPm1d7QajtUCjoX52y87Qbqzkx/jpXpnbCaHPZ0+yU=", "BMfQDNd2fhwKgzdaexHUO8L8LZrT/2NmiQomHFPDELI=", "D4nR5TENBnZ7LwsSZtVr5lPYNkiHjqJdecS6BdcZLiY=", "LmqQRKX0j6m7de46dZnacX3MiZbOwAPSbeh+SU7U6Xo=", "LJnB/2padXKVQMQJs5+u2Th3WbVzHwQB6Gyd+arQjKw=", "E+rXJn3GzWFikxg2sHdFvxQuvzj7sWwDCkEAVar0Hmw=", "F6hxBclsICbHd6ozpTKS7iAMu5+FXZkJSaNtVdV2980=", "Lq07bdr0lmG9S/P2zR8SEnuOJte6+TZgBYYdCKur1M4=", "GUf4wNssWCYEeSIqcbaS5O6/M8yiz/gvLtYvkPUfF6o=", "K7gRDSEJxqHy7Fa/cuBaFh6UkZu7DYVdW7NRYlpAnoY=", "AX3XbLDbpJVvi/tTEagyIuYL9d8uIDFrM2aT0ocadF4=", "G2of2ljAhKkJMuJpuOVvtRy3dB3jJigOA12diZJaRTw=", "F9lVEURpczerLcKULLd0vEJECN/D/hgZs7sw/K9AS2o=", "Eqtou3uio2+mRfkPxyINT4LoOE4jGwnOmTk4o0ng1bU=", "Dajf/Hvzyj0q3L02IDWuySlrx06mfR6Uovb332oNkhk=", "FJbLPsfNpR2F93bYYTsEMOl018OnpqhD5m+iUx2idXg=", "LoGVfS9zqrRKWQMK/8lFsmFy/OCbTUNRrlPs2sgt2Z4=", "L76Na6UCcpa5jwJ3sn4ofkxZ6bH4RiTgCX2zkPplwJA=", "KATUXJbS2EIsjB3a2MERXZKuwrFpMM1wB5vUTPQf2Y0=", "K3uotkocsv5ndFvlI/9GpMjAQICS+qIzPEXRg0ghFBU=", "D1BrHbsbXt8rLZO/vCl8EX3yEtYSfLKcbuYKL1e54hU=", "LptSx/BQsueb03fUe9wdgkb63z23mYJjZMS37iEzIH4=", "CBUfrychALRZ6jG3LDq8KqDM1xrdouwBlolcmy+abDU=", "B33YpUYUG+CNrKFkYA410Q1NTp9TYWPUHCcMev7bWOc=", "MGHlVZBBHp+BFHbW7ni9r9iPT8PUvmC1Yet54OF4MeA=", "D1AAwm5zgkpFMA0EIOgdjP8+hYA4fpMQ1PRpCM3pqS8=", "CR2DHPFerUdRG5OvdcgwW1VhCzEW0HoWT+62rush96M=", "HTo+c11JmRAwWQebWViNtfoHa5TqjHCsfqbNun96lVM=", "HonSs+MOxmTukpw4hCchwHRFCgy7QqSpKWVLN1bQu7o=", "HEu9X3Lzun0UhOUX2lwK9yI2NBtqjpkf6eAqGcskv3E=", "KnyB94E7guOyY/xXOcqyPF6zXYTH2CEj8IYl23tPuWM=", "ANSOQGLPJe1gfRebw9hOH0nTDiH3g4OGrDsgNwGumIQ=", "F/QzBZQvNWYmWXK6VUPUqIRdrAyA4svLVqqxedKFQVc=", "CNh3F9Xqzz5bs/tHN3alzEfS74Bb2h53BZAmx8Zil0E=", "GebidVAL0OgCA6ogwP9l95hUVcsAlgiKW5uN4xSQCkc=", "CW0PO238XpIz26qs9pvHCgqqob9sDgTgLew7XPiIn4Y=", "ALmlZDSbrk/82wRTy3IwrsWhXxjszfGRDBDdetOu+wg=", "I31EnBVI24mHkXV0zlQLHM0k7v2Q4oEHhmoXXHwWrwA=", "Eu0I97nRK8MEVr9CTywFxryRKZDecxjiJX2YpBPkfes=", "KWEWAavhjSb1wZgmivXzKbJfQrjwemWEn9vfkAOECOA=", "Dhcofut30IX+egsQ/hZUA2jksbRXQlv8qGOO0Q9isgE=", "KdFYE9tmZQ1ftjPP4PxW4kKsPQOdHeIFsKJheMRkNOM=", "B/5/e+H8s2quFaMxcenQ1/Lg4ZPnieV7y48BbggRYYI=", "H6h74Zb5ONoinOrETuND2o8sP5VsjlAJXTa3MSO36w0=", "JP/bUvT0Q+38BrjzGpNXJTxqFXqg7TURlDcZbCMI/S0=", "LUvKd0VxIyCP5FCOpOtJxhcDK2vHNfxTmbDC/W4Lb3c=", "AjEdfwzldj8EvhIOgE1+iU94nbnr4vhaYmWalKJ9O/c=", "G2vvjVHpRR8A1frwmng5O6g+WO0iSi4hwAOWWL/3mZU=", "CQjWBF2W0RE8T8MDNt8wEbzFa6ZuyofsjSB1oXana94=", "DZTz7oCDMB+OOIEAjGZlHDL3QyTUFCOuCFnrwJb3a1A=", "AeqJ4RuH5v0AYjSJ1t3am/Z+/XSnA9O99YvAn2igES8=", "DQdFfcPuz8bud8etqsofWjaeCW3vNp5mUZqIcBuqt4Y=", "JgRho/drsGYJTXZAZYerY3chf+1SgiLaKb4sx7kPHS0=", "GiKeOT4tMMeXglC/7zFl8mdkPrPCLdnxyxreV+wb3B0=", "FK4jSWlFSE4ViCJFC+4dWd8opVKvydvc50jjZVPSF4Y=", "AKKHIAq32SWpRVPmk60w1ReWHXtbopPZ1rpnlTQ4unI=", "F4uBh0hjNhTpIt4xWD8nxBfDZYGJU9QM1E8YBC7h0dc=", "AISuiu71+3ksNs1XOgsS8N0MkdbUR2d54dmbKSWgVDI=", "KKaqYNVw8Jmbdy18g89Vg8myPf859jOI3aQPbqStzvI=", "Gv4qSDkTKwyuSU929vuwn8l6Lc/8PPRV9kTfoeieAZ0=", "H10AwMOiS8EVeYcgsfm6a1L+qkRSKtH+wsGsnMLPqa0=", "KAwgMl0Qxcn5UmV21gGdwCSPEFigr9XaWgzGWm3rzpM=", "CqNOA687Aoy2fR9N7H14lHijy3OifwHHX4S9Rm7Zsyw=", "LeUe/rNt1/W+6bZ6/hkq1+9Kv2O0YhJHvog69wiCgHQ=", "FDy6YVsGIj9VYr0KKKYaM8+N2hNMK0GVThpWbdMLvwE=", "FDUanSfWcLeuormZuxh9fssFKfkgOqA2FC5Sd+aBX24=", "BGkikEKUkn5rWAKAUBOQAYQwMvaWetigWiBEJXEeGOw=", "LgVuHONp6pA8Rzq/eYiiTYL+n+DIe3yaYFxlbazTxao=", "ByRTk5EvhTAu17XTYB/Lv7qm81kgFF7wxZzojBpqkhk=", "Iwn+bDBu9zb2Hcr2W/bZs50Q0un89o7eN9UR+ku97hE=", "Fw5DMtohfLNWLiX14gChnPNvhMmGKW5x3h+yYSW254o=", "Hj6svBHpyBkCdNcLvV3QrGSjdFlct33AjjPuXg2Cxgk=", "CZgya4+T5tp6RguvbL/R0p2zdzBwvsqwAcW0r3bMJOk=", "JX2UDtDNdmR+LT9io4kZs8YjJqSUrJ4Dn4KiLvHmiJE=", "D0M10Qv8Bal58DjekNr3AnK73CQm5JiGRmUOFkxWJ7E=", "HeKnKunSpWMsPmI55h3ng7e4TIv76X35Zcc53KdgkoQ=", "EvRLDoxpTnu9Vpnk/QynNKjJzD9Zui6rSjKc9csikok=", "D+JpJnT6wv4Bf+59kiko3L0xWOognXlIo9dppwnZDUU=", "EHWrsOWiCM7hiEETGrTIcwXxRBqvy4CM//aEd8xPssQ=", "GmTPjAIOcSszTcgWTyR975CYVT3K16RAw0n+kCQ56Tw=", "KWpRpKuZDFk0kiufVT4FMpPK9GMW4Fi8ea0To398gtM=", "E471yoSYDhHcm1TOAr1RZiG2XqeK4JdMHbmmcgwAIjw=", "KKdc2tU53DAKLpUYu/tHz+zOXaAc8ekCEHgmBRgTALg=", "JtK5IznY1Es2h3CaupXDgEODYP34i/x6AROCvSp4WeE=", "HfEfvLd/Dt5QZQS/tAiOMnmnn+a4TDpRr1EqX6nirjY=", "HCR4+nYqvGB/sKFiokc7nkyYOFngzPUdq95fp8jWd4k=", "Ld/gLN61dZMy6uTite3VOBIFUVZTt6dmlnuCnKuA4Y8=", "Bn+dCCxK5S5T6wKsEIDTGpNTfqJNdKUQyJt9p5vDFY4=", "AQ9WNJFpqYwB9+jaYuUV5Vrr1NRMRQN4MBL1iKN8coA=", "ArA1h5scVwSVQ20lCipFvYVRC4prlRYppKW/76pxF/w=", "EFnk4zILjC1mpraxUR+gnmGcSydCAe6HQb53/Fs5prM=", "B5lLkTaBRGnLCihgZ/Yys0m1riTa54sFbORdcidS65A=", "Jp5HDojL2Tb0w17F8AQrnW/BOPPcpd46g6mTIcjB5Kc=", "Ep8/CXsqpXRv/ISuF6/5qJKmvEvJZatL0cZa3e/BYOA=", "GfObQnz5SmWqe/dqQFtDwNC0qCTI5g3dZF1m8Kkeu8k=", "HLgvfOSHG0qwT3dGnQEAhX6Y1tlQ2+jvZONWgc+IjDI=", "L86ga7PE+ckVhBiSG4xKsTgNFVoTmJRkiuzuiRJBQTs=", "DIjS7R1v/FhEVQJ1IkffU0wld7GPyD+EGf6jNyflb24=", "Ch2lgaOdtOjb5PX2hjJ+fK+84HjKfN/inKXTrnSrHSY=", "DVbxHRkwCyFKYwl2nCOBbZEJtBX+ax+7F95vrX1+Ess=", "LldFvY5l3y6MSQRl2Ok1fpr69Vqhgrikak2LR8o+a+I=", "HagDw9CGBkQjGpWLF9LCLqStoTR8V0j4q2ikAud/6Oo=", "FGptH8hCjKZ5++jGlhb/Z5j1moJ9R9r8Fa80/lGC8I0=", "EuoHMe/z5TyIGqzA6nfBY+MAAc50oPV3N3kFn5Y2D7A=", "IcRVkQmWGH7Gd8CDc+IMQaMKLUwGzq8huR8LFKE8kEY=", "GJiQxo5g2XWsbkTTQ7Kc2h3LoJ4KZ+YeLOyLL7n22Mg=", "IRLflsv1uR5PGSaej8dPJP82Y+1WMqJsnDtyUrUCz9s=", "BcS4Kr+wwVKSPVbw//BBGjtdEb8AU5RF/xg9azFw+80=", "J9iP4o8SxR6Ur5srPxQJmvznOjc2qf4cyJsR/UuERHo=", "F0ULM7A1qX62E9KJ7Pd19AAwRNhh60GWOl14ME672QU=", "DumIqevI5gjWMf5DJP14+nfgDkAvW0sEdHI+5H3cJv4=", "FKiVZtwvD/C2Tfr12HA9yfdKD57jlZYYMsGU4yV+Dt8=", "DOZn2TF349rJkB7DI4+w9AO33rNwvAaVE0KL5wATRkw=", "AWqsQMpF+Bir/vnBWHBKl5syogixVXZHxgbehoWCGEw=", "B0Xyzr5MfrOhcLOqtYJdXCvLqMBNZt4QB/WHsqHlNbU=", "MGHxiOtU3HGhnGmPGTHuJh7Gkpf3nEIIBa4HUUlnA9k=", "G3GkF9Es5zo7enAloU+PtRqQ/eya+bHc2AZ/WDD8F/4=", "Krqtl74ou/Qzm1pL4uJLV+jZzBR3X1txeujLInyMWB8=", "FXl8WgcssAzao6l86pabzVP7KYTCO3rbI3tgZcZQ3HM=", "Kd9+2ss0okscUtgULFM4uY3DQMDPJ7zaloiR5juKems=", "JAI6xCCyf4OBS9GCqEP26+Vzm7G5xob1nOihqUeNcEQ=", "C6tAXtEcqlQ/nNbYhjpl3YAN0I6MlJnl1qWEdIADOfU=", "EnDROaDdima9nTYKngERzEQLOa17OrRpSzzlB7pkqSI=", "BNciUDpzQaaQ8ziXe4CtZtBxCqZcbye9SYI9fBLH+PA=", "B6CDAM9VxgGR656etjtASXmAiDeWhWrOthR+OQ31cUM=", "FDbqOgM5mpWHENSnb6kUCzLVGA0W3YN9ozXff74Y3EI=", "A+WXKp7lRz0r7nBoOkBUCY1B+vikTAPqnQnMpGCxhq8=", "ISmJ1JVA/AvGsaLRUOO9dqYhuizbRHWrG3KwtjkdiKM=", "Drf0ALDpoqRjVRClN5tKA9+NVsVDNPyMcT25a/s6XZk=", "IzjDSP2VavbhkZCaIqmQCazFO/2BgJJvWRyn94+PmGo=", "Amr8x3YBHIvsXjL1bxSaUR0GTfCc2yjwlltwFVjmODg=", "IdpIa6CqRXcEFXiycWIh8VtbsFTvJ2zZpDg+ZGo6I/w=", "BKzNu2ylAy+nOWwlb92PUr90EtEfMYwvgpOqHJgyuEk=", "Leio1JYMEO6d/oqwGP6jyHVTmS9ZvLrjbNQq9LRVvFs=", "IVrh9X4kIbszwrTC6FQITOoLErz2GlOWMFep6q+hmn8=", "GoHfPHkbsIdolIrmP9u6G9Qu/LAJ/7B6rYgLMbuKpoo=", "FBmDRxyXwN69zU8PCFFFNkkA+6hCnh5Vg6TlYd2tW8k=", "AXbLembFhuwfSAzu7fMyzWzVUI1LVaGjKGKJoXiGTB0=", "A6J6E3jmARh7gd/dduP/gZDRcNHM1/fPMzy2H15qavs=", "F+HYkZtq2njJ0YI6/oJHFP0JSEBjEbIaK5TToNHAip0=", "Fh1kI99k4asenbYEgJ06xf7HZ21X1C7zE40/DSIRb6I=", "KloYPALsR8AisvZWQqSTcw64bZd+WZwNV7HVfiHLq7Y=", "JzTMM2cCZFpXaeF2tiYnsK2Jno0+8k6ENXIU3qBnXho=", "GaC8Wk7WW1GJDGCZRib4bXytNxmHngD9F7Tbby7wmqs=", "HbYIfqn0JoUmWEfeE93xjcRGsVj4S/ogpSfWLsmEE5g=", "HVRL3zwvELSu7rhUOvVDCXBfeidfCT7cdpAZe6Oly6E=", "KxqHYSeSG3Xb9Nfadaa+23QUvF1VyZjb7kn0fOIA87g=", "J2qzNQYuNhl/5EJET52UUMt24XHADD6/t2F78K+67qg=", "Av7VjVkgsFvHQstlodflDdjmobrtwntt461qT7vCWbU=", "H2AKUp361v9i7xcZdK1w5283M/DJjg6xsQyV8TZ2CVo=", "K6NersLDj0+qrOUrvMBo0wshFJpgiNBGeVJULp3YMds=", "FmMOQqqrwCAWPofBv3RjwQB9/c4+HOnFwo/mTBt98JM=", "FYXjxpKyfn40K/u0vUIY5+0B7+E8ldqqymLS9UVfZQY=", "GNfPnAmPc02ioE+Town3dIIOFB+aqS6M/KQtjiLGHZ8=", "BkanMqfVLoq8BEHsmwTSr2/36qCFoiwM/YKtAkO25k0=", "BP+pV4ReHgHykW8iQ4Ffjl48djYfNoDiWSGMDSjznxQ=", "I9PIkP1lJbeBT9PDJd7i/6EfZ+FMuL894ispBYJ20dA=", "IAAxVyOlbL1naSFGz0Kc7kCVLrxgezEA8hNUvgYFwt8=", "Dwkr2zmVMF6/5ydRLr7sHqSNKazJd8/RFpWIMm9Q+Zk=", "G4BZ5hYie5qDYJnp7jcyn7WiQX47W6/tcx2q7hK5saY=", "HY5gsl8fsdC5faDxfglCWK6qQLFCyXqGOyRfeHx12uM=", "HNc41lGdPoIqZ2en2/0jQo42HjclqVv2LTByOkFO0dw=", "IyyF1JJZbTJDzXIInFDzppH9efvWC2y7rOFmGibHpek=", "DeYL21ik58fvvZW1UBfTIBt0bnippvS+vrUcHW7k5ko=", "AvwQGgIwYFQDXvWbYOHj76ssP2UCf5PaIHVuir7xIFc=", "A/U+us3vVytzvqmVUAZHgtKRlDag8rXZIjstqXTjygk=", "DieDTMj76jiBzkPZiW5gebjoydtNdxktqria3TJq7sg=", "JNQGFscTuQmffI86q7xzHvUuDpZpOnRqOH2M5nbW9w4=", "FJ0n0MsBTlzpxBp4p2qP96N1Ad72A7Vr8Dl+3RduDGg=", "ALzJeO9pqAUXOnvx0dVlGIEwMlAuSh13Ktkammp+cAw=", "BpZKCvuryGovSR6GJw6tRPSfmGIriPTET/hoMPzOFkA=", "GTQhInE7ZiMbCny6GZPF2QTUJ56XhzX6B85oMtpNbmE=", "JvU1wgQkJnqRAF/SJCMKSu69OsB5pYp4pjUg1YcW9x4=", "K8Q+kwkFIWdkiBRFTL13lW9zqmmyAclPtReEWoxxmLY=", "DZkio2Q7TJ4XW1ffWX8QtwpG6e2kGVZMM2dbavt/6/E=", "EbQ4+x3wpFV/5rFAW2cgrUoVN/4bQviEuEEAf1XGGv8=", "FJXer6G9Hye3VBE46uIHc7oB0NnsELdxcHlV54/a6jM=", "Jqc9ShBahmEaAb0i2Q4OtS3QNAunR293EZDP5YerfZM=", "Ft2rzm5t3TKp+KOmdIUe2JduD1PB9/bG9aKMywDZcxc=", "BYHrplWgON5JbHhdMdZakZQEvCXwkip3S8OZpn/hIvc=", "BldippdOt87YD/QrU0vFRe1s3ghD0lg+5wIrnOQP5vk=", "F7/xpw42toSi7Z29lVMMvps4uH126utjNZ/9JQt4xeI=", "GOaCie01IZSRcvBuilndmwdNw8nbyCA9j884GMcKGp0=", "AqjY7gPV8DppwLDSsfNXknR7NCnwC24BH0oUE0Xlcks=", "AwAkOr7UsY4GH7ERCrrGMo/1XcUxYjiPnbx1N0mUa48=", "DyrOIYdxJc8ueKvpavt5/bXVcqNp8dpPLde1d29mUq8=", "JrfpK59Ph3ayua8x7YUPyB3/GPcLFlyERydfbqXBuoc=", "GHizpPrh05glOG+uXxmaGztfj1BFWrUAJRfL0ut7X6c=", "AGLQ2J6We7b6TJh8CoP2W8x5XA6pd7bdY9Yl4G/7ClU=", "CgOyeLJa4ufTGzEIKg0MxXyOekMvJM6f28zZNHXz0TU=", "EA2hIOwq53KSHHwEuD7Y7naC0gd89HdACGyYDgTjj2s=", "I0IiOyBaKwJ52eXwzn8Pm813KDmjTFLFfQdQvh5ROF8=", "Lff0OXv8QtysWEgPVzFod/mqIbqQj3AVPfoZt+UvNu4=", "I2IlhMhqirWfuvJWlIHZZNHhX4BzuvqMbpL8LAsYf7Y=", "Br+AjM5lH1gaGrJSYdZrdPYEtwSAr2BUzEX4HaMpCsQ=", "D1PJcnAs3uD5/KCnBQXLqvbJYFkJ3eA8/kwzczH9/XI=", "KYixp5+NIml8DVG1N6mzCPl5eSscpHzECLi9i6b2eQ4=", "DEG+AQxBiWCS90CTeR2QyFwEBPkoYfdLoXdt5toPPoM=", "L4jBkqgioqCy8SyzSeFeorPzscg+or9UYauwEPgL8+8=", "A6RDpLBwnr1AiRxZPtUoy56fZe7MQK8fIxV0t8lzgYk=", "KPghHsGaTcGR91c3Ht+3iGlu/CsLWS1l2Al/OOcj8TE=", "CruqfvI6XZhxDkKmab+kIwWt/B+OSeBbs6vclsjKc+w=", "HwT7VKCe4t8oa2xeCJVguPph4GK8kPtymNUhNJEhGrA=", "BnnBu7/X9NDywsGNgpSNBg81Y/KKGmMsmfLGSkYegmc=", "K0TXDr6Web92gbLhoySeKbXYABCTZ6ekj//1PpaaE9Q=", "I/P54AkTjwmYtT+EEJMwekGsOANI72YuNI3ignykmeM=", "JIEacM66Un6mx/r1di9YE1kchlFw0oeaCLytSWsjIBw=", "AapTWBH7sT/jFfQRzuA+IKSjxI7G2vp1/tDhI1LDS7s=", "CuPfPk5ZyZmxZgb/OJAsdhY04rSdY+pxaSmmHotXMGs=", "DsGsyquKduQ8SYTzgNL9Sh+Lu/SaFriJRn90JMsGlF4=", "GxbvxXKcgVZZvLG+z9HhlIZW/63/B5eNE4tUNJ+Xt28=", "EfsVFK4bA425dQgV2rXX7pKc+4BnSsxUG9BnmxH/B10=", "A+igi88J7sHcLq2XhKkZgQzsZJk+tAzUk5nC6jHvJ/0=", "Iy3AYXtgNcmPZv/EqJRdH4eN9eMljptUIXjWuhtoTkI=", "ErLF1RoULX+KBUAiji/zzsd46R5P9wHe6iNexxQgR/I=", "CdbyIorNudSgZXesn4928shY/1MblX+JuCKo0o33Dws=", "JuYQGP5LPvbZZpVMdMY+HhWHeE4nbsGYIytl49HzttE=", "C+6WNbmsUQCZucgt1iIgXGfxNhlyJlk5wMGX98SKDoA=", "Lvx0VngrkCY/V4U+soB+Z6iM8V8sx1a39KlXC8w443k=", "KD+y6NaxjsP0EV0EMXU+tvrP6Z8JnsZ5q9hWkX3CL44=", "KIm4cO6YaI+u6IY6VISvy2eHSzOp8MF5S0apJj4YGrQ=", "Bde9vz3w8B+6+cH72H8NjcNUh15FFnhHaupLDuDAFrw=", "GyMSSjZ4Adk7j7/SIusn0UmuLumMa53DC7Kc47UB96c=", "E/Vzuq7TKqY+8u5RydJamWzJzbMzv73SuV4qOjI7n00=", "AP2GxjEq5TjFgMb75n4HU5ZDln8HXIHPxQTUoLUdTVI=", "EdB+GQdI0V0ARHtMZTsFWIdnfR0MuJmkpwkOoHqgs5M=", "G4++s8cVB3sKCU1241cC/+vEdA/syj+u6WCNRgwc3q8=", "ApdCPiEYB4RSe9kL5j0CH76MS9uLIEOY7h3m89QfzDk=", "Bp+tSy6vmp/UiRvl9PEo70zBHkWXysfFXjsr7e2MBaQ=", "GzUfMOIEwhKl6oa33imbHfdE0HyP9/f0lEUUmFFgxJ0=", "A8gUu3Bvc/kzuwPTv/g/tbeT2DjC3gAInV1YIYPJVKA=", "JjwUgq+SZy8o5kyj1NxTdIYuLmCwLJ4vqV3sqdlbn8g=", "INU2Mti9UkLZ3JrY+rxIxsYMb3GiNYB7GzvQ1C4YfAI=", "ExKDOEbU0CHmuFRHjajZ1j8eH+NqCMapWVLuTRuCRX4=", "I6vlmMvJcf8LZiXkQQGOH/hOoH7Fo32zrX/y4Y0e/fQ=", "GJsTShqnLIBrqQ1wWA7nWNlowaCsvB1f06qYgedCt4Q=", "IXOTlvgZPU7AFUy7MC1yJudWO4A9m2Y5p8oGVynYem0=", "DRe9pbDysI8spHYPvI/sGclhwOuCGVZaIBfBm4/q3c8=", "IpT9ILYqGFSBlUDlVgMCtFQDFI226YkL3gsKiD/hkJs=", "K8qhIW1XN0dcAT28PYxU42vgGW3HHqCYGwFgk2nSBLw=", "D/xi1Zy473HwPVt8/73z8eios5Bsj9Jbm6hbdW93TlI=", "KCsplkSICQaMJfs0MNu1vbA46cOBDVVNerPKH7JbCOU=", "Ixt3Z6TLsAiPzxVv/4xxy98Csn4x37z3WXr0n8yZ1hA=", "DVLpcD1P0LQkY51LgXO8jucwvD2zyVncHx42c3ur6GU=", "Do0SBfdokOlL60RglVrpe1vylWccsdCcWBuA0Mlyl1U=", "CbXivIKKvvqTpQG/dcCmdob9igzxBv3PrWWo8guos2M=", "CO5iC7c0IsazyVBqlz7Q91T52BBhSP1ibNWgTUOGgA4=", "FN62iYOvK9s3a4czA+B/RnLXd5j4+opIGiLCI+s1fRk=", "De2yMNlVy5sCuopYYBAETkxuyoNzGStf/9ElKSfOCbE=", "FqbpAIDqGqTg0ZKqE/cBp4EUI3PA2amFpMpacObKIPo=", "F8/kbtZEHu4ems+/z2ae+zhvJw0UJCmz0cao89mEz5M=", "CdQ8vVQ0hrMWlLsfhW2HbPPxNbhqoOL0WImWaRIoDzE=", "GBRXZC5pFlfVskFLeoG+tYQyqxyau1iMfhstofHoqpY=", "FAUEYUg5/Rb5DxpaKknxnIsuCjoKxn0foqMc7UPzons=", "EgSHBhyn0fo0DxGy1scRXq+5cVaVKUJBcbsdPxD7Kv0=", "FnjqHJqfY/H/DR62X/fH1ccEsqDaw7FVBftFIkzM44c=", "KYlkwoKNUqF2S0G1+0YHUq4birEI+8BwvRvhW7b67XM=", "DOl7byd3w6Xrhv7GoOplqCPLm+5lJTFXoLlzOsakTAE=", "Ao6BkjG1VB57UkPP9vBEti5uxfuK3t0rar+Hmt1fj9I=", "HQSikXB3MHPDaAoNc7oHWegGMLuyeY9KbnfAA6FFttc=", "KsMuXZB7ySF3lSW8ua1K4ajHgv8Kvu3tMnh+slJ1rdo=", "H3YA5zbfg3QE8MMnIFz7kxzqSLsUcsoLRal0trWZi5U=", "KSHcpcDcO9MX4MoVV+LnLG38SFb/9NcF94p+H1X1o+k=", "FPgL/FIfULjXlFekwunXVT8/M8N2Se4YpDpICrLNW78=", "La4FmsFwebFfa20N5kemzpr5zJtd9WWfFpvoJuCudFo=", "J60fxtpUZbi5AT8MzpbbSvHdDRjieZtzzFQWNlCEptk=", "E+qyP9At4BTjBVtKtCiBUJxrYl4ESI6O6ThVfGaIJh8=", "GM+17HdesWg9t6cyeUXfRFAuRBoAgrv3YIJf3AUFTcM=", "Jsu/vHGc8GV9mKb8p40lcq2yMBk4oewZv3NBeMIghlY=", "DM/i+XbOK6QI5DHKMZ6Vv77tWSdB4Lsz2mOgP8hALT8=", "Fzh81mghT3Nq9YLcv4bACoDct3JQvgMcLgIHE5HVN9U=", "LZrPjqptFebaf/qxThY1PPc39+VYXvni5DrKxsyHl0I=", "A5Okwe6DevrrEBFM7RL5a7kITdSkwnUNcA6Ha2yu+/k=", "DwQHpxGLaRDdkJ6JSWa0JEDWFtpAPgoHs/hvS6gBHfg=", "L3c1dl4nif1NBceDUMNca4SmmnTH9p4K+pk0Lxxs3Dk=", "DbqReNLvavHgHNwt5+hVeEGMJq2/N20GPLa1sRgfQbQ=", "IUT/1Wk5XIMHP4guz8oNjJQosyyUadt3YNN3hkn+J10=", "KYQTfF4gEti9ebHVkIeRW5l6iq9WjfNVvPUx9AFDd6U=", "CTTzshkSkc8+YxgiCHwZ+DWijMSbmHQngyJM5s7oWI8=", "DgulkYqky8OMR2SKWyjYPHrC/2ikEn7OmINrVCmsMHg=", "BJo3NKjiov8voKAeWmw8z+N9Cf7WyPXbp+9MRrXTO5w=", "Kf/4GSEo+uvG+oQywVYrwBtyibP7UoXinRKjVWzArEk=", "IgGCDePPpKohY3vHQq+qOcNhGVEzBZjmGtPc2BkIGOE=", "CUghUnZX5xfcF3EnobEFMaKp0Y+RQaEujJ8C0ffsGh4=", "ELWNqjbFbvLypN3hhpjichEvzAHmh2mGjp7xte27T8Y=", "KdrWjOWIJLpdibez5+wf3ZXCU6a2qytsQY1TpX4+6PU=", "HvddDfL+JJ5vzsbPVWmbvWFrux29s4TWqiH1xrV5Om8=", "F1SRQmewsJqUhoX9fWBpLabGvJkNO9hsBdFAkTKSCjc=", "D1k8mXrgqUJrT+MFS2BjU3SgSbxVr40Tc1oKkDkZpm4=", "CqkYVMq2enoeKYKo5RWEWnGRNTD/Wu6YyR7r9542GCU=", "EvLmU6c6kHc2e2q9416mjLoUEGKt59NYOwXaLI8Lqtg=", "FpLDf5Zmf6YsYZ/hoOeavfhtm91yQXKCKNtgCf/b9Dc=", "BOgzYgsTnVDgM9/tOzk5RXT2MTceMcK7DpxEq4oWhJA=", "FPE9/T5Ygagg7OH+SERiixTaq5wPvv6IrNGJXENXZhk=", "BFi3gzDXkCtOhPcMJQv6CBySuh3ili4ZyrYosYYI09k=", "LFIHflutps71OXAZORcXJkFAuKmbfS/eUg7InTEZIxI=", "Ad4vV8KBMyJkUAGVMa6G0WCg5ygJ8BWTwXceTsynojw=", "CnYfzSNMK71mG814j1sUpe5CVRkLgf0xU8AD1ooxmac=", "DryXThf3E/PqDYsS5GP9WvBFAUkGbW5yMi2NDh4baDE=", "G5bgJBtyIakxJSFSVqtggTWyIU4vBMEno+RR1/j3eH4=", "HfNiOoGs0XsOtFzuZjjR3R6Elm44zerYjKX5+QlvvM8=", "II8Rk7dPSPUAIdHAzZd9vGpV4vaO8O8AAM0ho4zlvwg=", "JGNSuzbrUS/082/Y33IEL2nPZ/F0RSGJihF7bvrseJU=", "Aw6U/0AYpalyUwDydKYZ3kkBd9FATa2agpnvKeCwTxo=", "H1I1QDXkSsBQ7obKYxwORetfdbRNbn8BsIBeKAZqzMo=", "JlklDk8uzD08xaHHQ1WqAfK0w66sYH9983LBW4Xsvj4=", "G+IxG3i1wSRvrYqMNG6D5sCCLfWVV1iLVRG06CHivyw=", "BQm13k3/cy2kNDcpcrRm0RVNGU4QkVtDR9/QZlpyv58=", "AyR2gIUKWGLAj7yw/vbHOd8eiAQ8Ol5zUx9oL5P46XU=", "LREFQO/2h6lFAQ4EDcQEl6PRNguZBzur1pEVQdML5fM=", "B7ohs61PEz9pYnshHBLzJE0atVOubWodqoiNAECwd3k=", "IAd9tlFWqN+3wxYKgdYuEZsqhhEYvj3VCc3M7/2ojRA=", "HP6iuJhLYrKPvWuNvhNCQOK8ENa7vTwvc6MIhxCwmXM=", "FUm6l/xTiGdQbzSZKafRuGITiG6NKr+2D84DaHmP0pQ=", "JGJSq3zzRemCcXIl+VTnTnMDzgybGySx3Ab+EP3O5KI=", "K3UNd9qVd08r7hKbMU0cPdXjArZmwr6kbPiGWF1atts=", "I2/UlHd0OV1/lCNSfFujTKvW96lQHM0zNTI0ki6JbhY=", "GKSRev+7d1Fmf3Yp7Aha8akC6bVHGgLIngVnjWILsNA=", "Asz7d/ndl9fmqLqe3kI2QhTFKgLIoKQgzNB2jfyhcaE=", "GNtJtPmfaFkG93KTiYBoJXKDehNw8CPQ+jefzxweyFQ=", "IEDcCeh3y6AE1AYbNwHGqSsD/KQcHcbr/1JcdqH59+s=", "C+xcRJTAtd2728vG+oj0ODBVJbTAivWYYAVcH4tz7Nk=", "KHnuxH5ylznR956D96ceYx7M7CyDtD2t1u5WhB+DofM=", "AaUMOgGAWQQuXOlaeJkU5cKAC09O/hczbFsqIWQQAY0=", "GVC5jCK488yFXBZ8fZu9/U6jeqyYsSsfsBclfD5/KT8=", "E7dxDZIYwLFp7koSdnFSdM6aZGhzDS3ncxNJrRrp33w=", "HvgNkIBe0oL6T14ShD7Uq8jyL1tZ8E7hM0kgmou1ge4=", "E6vEgtQe8ituPQ25J2t1WZBEQ4r4lAtcjVjn3+gMRMU=", "Jn1hZw5T3QNOeVuyDCCRIWOlgkhwnVq6ipXA369QsCw=", "JEQc0c2BReQrRx+C5Pf5wo1FrCxV5OYNPmbXTotWORo=", "A1X+iD91waQ1PBwNrO7y06camnTGIFMZnkMbj6gcuNI=", "BVG1P8kq5jwrLsvfQM6TeiCV/OBkdILmSg/fUVz0Lqg=", "KLaqpK7iVgcdmYi/8bzChO1op2FGIjkuU0ZabqkSWLw=", "LfMdhH2//LBEQljmmHbtO3RjpJRUvmq2JQqERsagFwM=", "G9IkU9NpUP8bobSbzEP5ydS6OIt4DEP0rTIWudqNoSY=", "ITq+J5y4l/p0m26YGAocgiVVis2IZnvfoUBwuqZdyBI=", "BIU6jq55DDTldRiT40upMgJNnFScendR1Ta+nMmva5Q=", "FSQvvjFHfZ3gxDHSXQyONdSJ3NTJn933LE8K1MSS3U8=", "EvYyPzHhRXYyiVep85NFHdyGiqV2ksoye8Whaek6ujk=", "HdogNbdYDmO6soU13DkvJAhdWdC7+7VJkbo+6VY6GJk=", "EyUbtzoo2ua9SYUB255sWMT51FjoaVWWZpss6QAHYp8=", "AjHs7dKCgTag923c3cWPnLOnfKBcTA+5XdtpYEA5Eyg=", "IAKnGpJvziah537kn2iEbDcbdMp63dZtp+xShrt8VKs=", "LKtvD5i/EH80XiLb7xaxXq2UQHCYqTOtBZGzxFACOKU=", "BAGnShe1FPBTLhubSqRCGt3+xyafk0h1s01Pc8+eh2w=", "J8eL+j0kbahPzHZcqLAOzfa6yiyWd5ao6MjhxQG/W0M=", "GO2YrNLI8UCtPVZifZ8Oi0HoTjDdHBZeQEPBxD4y9mM=", "GI1R995w4hiFPESkDlBbOPRcrKjJLVCQ1HTy0BUw2xg=", "GTC4mzMDE08fkAiA/Xw5x7oAqWqXL8T0Oxfhnj8fPUo=", "H8yEJqSTZzYZnuaCnF872UfPYt0KkuetSvTLr7SQsKg=", "LThHlx4zaETWJrbDntJT1plAAr0H7JRrUh4G6Zk6LUg=", "JCF9aDuYydYwpwTDvEVQy/cOoU3U3XcKukW0H/OsAwE=", "KK7yaeCj3uZaHfQ00bKtTcr46ECxodBns1OimG2U01o=", "I4s9InoBKuE9/LbwsGURuaHX3d8AkymfBACoh6kOBw4=", "GX16Y0k/Ies+mREZRMwTAmlGH3vYjTAvizV7t9aGgX0=", "G9ysmI7bAKNQVWfe1vlEClQt8J4grrATxDlyu/s8p7Y=", "EWkXEWO9zCwMi9nlax/KZuRL9h+SQzQ82x4THMA0sLU=", "CrZqvLeGlDeyT6zs7hyJsY/40tAkBGv5eLhEoaXdEjs=", "ILmlVaiznwz7xgMafM3mwRhavNBuP2+ixmhQOLh02rI=", "Ay4HAo0f73a3zLncVP9PQdoQMf+olSxkpUN5g+g4zOg=", "FXNpQ3MJW8MQbpK2tieuTH0P+OSZyy6kJtBE7tgYzwg=", "AaYC39NS5D7LL2n8vVaLYKFAq1L6n2W1OvExI9URywQ=", "Hiv0+ldOqQfv6yhfZ2a0oX2zW8thhshKBGAtQ4puMhY=", "JQXI1BdznyHSFiEQ22Z3AXvdRunhBb1KPVYUfDcyegw=", "DmVFSc19oVooCNBthhF5bAAChvp30C9qAjDevvyIwhU=", "BvunMsYWx4KM7FV//s1uOuIq61LHKiEOAH/NxcN0AHk=", "FlgyGtnD0KNjnvu54jr/MJUSWZ8N8lGZi7OwO3ylaSo=", "KzMFLGGDh7i2Z3mby4Vmprb8Xizj+UQNAl/akVDUqCs=", "FBCxrp2yGODKZU3nDwXOzHlTznEK76SIXwhjuOA0cMM=", "GEjoDtFEk24xIt48cGz7cH6j/OMQR+Yyx5Y4qwHe4ek=", "J6J//V58+h3FVB28lACFvT3FkLIUc9BThPjEY/srqTY=", "KblBJvVTaojHY9AwGuNmq/JIa9MA2zEjdi3zy5PR2YY=", "LVuWzdAsYQFKIo+rraWXpl4cV1d3IkgAmAK7pFC2BJw=", "AgLFNQpqN8bxWREu+lFr6XDC+I4WwBqoRi1i7k5SBD4=", "LKxxjYa7aLgM/D4Xy3QGCdQlqlR67hT5EFtNqUkNqN0=", "KD4aOeisCxkTlD6GGKGcicXHS1jVkpmxH9En8Cz8mJE=", "Eaa88O5rC59vYtwMSBaMrdV26NhjkPhcR0S9cOPB6Wc=", "EmghdxQRGGrbVe1+WeWEgyu4w1RN7XIn6NcHpbNNYTc=", "EwHSgKEr78AvmhPzqSUB2nIIJ5vAPZnnctpJDnrgack=", "KOcpzZyicWz16CsMFUf/PEiVjMxJ+Ab5381vjZCy5CI=", "EP+SZ8OxkfL7N0UNTgFaoTeyXxIpRDDpNujRJKH5jV0=", "LBm0mdPcT4VF0xzKalimJAyyzVzgIEI5387dsrd9FCM=", "L5JyeBLIYvWrJUOuiLtVOfymqXzTMfpOXgLvcjEBfuI=", "K5vM6hjQP13k3Lmk8QrID7RL50b6W/MHJP4EwNV2gUs=", "HIW7F2HZfkpXb69cU7m9tHmg+8N4GN2osqvLNl4Kc/k=", "B9rp6H3zekAU0Rh4tJ4FcWKKIP8+ahAikdIRuPux6o8=", "K5s73+NCmHk1ydeA3xPwYfbOmk5rRwzBvHx6qlMHUzI=", "Eq2r4odJi+nd+rJO95m8Sb59WPBpy0m/AcnEsVBdBYY=", "KyBqEaku21R0rnq2W4/oXUUD3jtvQzB2f5OOfGcGD8Y=", "H1QMSDfEpKddj4MJNcbS5Ncx8jDdp7pQUqUNVyQ5wBk=", "BU24cmBQr9oOigxrXq9fln2A/g5LhRecFj82lwcA0qc=", "LOqa1Lr+E2zONJ/G6q4tsFBxEYtLgvJZignNyNsAWvY=", "JS9pnqc51VZC74oitFtY7qjVWQD47X85H7Hwd9E/lPc=", "HwYbBLX5J7IQjHtr55XDyTFJZRBwALE7tjKD9BklrYk=", "CEWe6nOpSvNh08ZW51+X0n9vHkJQP86Oy7rxmikYaDU=", "Gz1wD+f1GVPiJ1YE05HxNsH9qYaj0wIB7Q+hQCCKyBI=", "KOVgKHmBlu1esNiO2QXVsMR+nWEQx1YypaLuioakhh0=", "Cb2Q8jM8TCy9S/ft2t0f56keW5iQivpVl4HZiiV5RMg=", "Fbwabmuq1fawwq4zeKJSsUKZ4K9m7MtrJmgUJ47RJ40=", "GcUvDcyqRBmaf0/DO7R9Qdaggc82MX5/4Vno/msfCok=", "JUe7X/INteDFkpg+VPyWLw9l9HhZiyzF/s1y8WlImpo=", "HvC8pwA2878dfT8pTIsKEFdpEXJ5PFvmWLjVX45TN6U=", "BBmNWOzc+vC5wtas7e9SU30QQxNrYkpaH1iKQM3spSs=", "LF7fVl7SBl19BP731PfhsXIqLQZMAFSXJeBxWUfCb0s=", "K7oz+9SosZ1sxShZJZN5o7Rqn6F8xcRXCVZQPvNOuLc=", "Lpj62COrqap0Cq4ISGDwQIGljeObuxAe76EZzWpHH7A=", "LSDCzQkKvQUzqgXksl7ZR56exLIetZx2VjcIO4epWSE=", "EJZ77unaJQXNxTvlyYN2cujzcpxqeEsBOXnYq4o8Cok=", "Eh+3rGhe8T90/4Kc0YrxQLvtJQ21iW8P/OukLV2AOj8=", "AULghYdohOZXLIaJmKDqMXdvOKsw5sb/dMu+8UHckG4=", "I8oEH/4SMfzKEtYwyNtZe9hEGRiVcU3RYj6vwgVsG8s=", "GjB2e19PAdAMKwGkTwG18TalJY96UT1vfQYn93iXDVE=", "G6D/ZTrmvYFXP615AVM8x5SAaqYW8aJjwG/N8HA510E=", "CUpZRaiBhC2AZ7p36eaZzPx07oUXYg5rCQ9WJ7/XKT8=", "IchPIyiDwEGgeOHPYI7B8woHuIWfbrju9yKfxryobwM=", "EPg/5Ss4oJG/rQfey/KV6GEMYxEoc7sFt+8I9wQ/e84=", "A3IzQB4D9ZBxkuR+cz95LBVSDH9Jdagod9tt6mOP1Ns=", "ExdD9lvtot5+S8+qekvco50Gb5ydVxUp5i5/XOR1EqI=", "LD5vtwBwI2bdRtN/llpFSGnWo/G479kM6pC+DcFd7sE=", "C8oujdVxnySQaZ6sa/wrPnxlkTF8dv+xUW0SbOPsFiw=", "CerS6+oSmlYCOvpy/xt3xuhnpy34GDn7dsJSP5RSIFo=", "GaIQ1742Buv5rs2bDI86sLsECZWEvOWnrio1oPgIzmo=", "G0TfBepG7BIxgYAI7M+DjmJ6+yzkt3mKqob2CcJCNjQ=", "Dk2Xj6LtBQffpH3RVLUQBtJVeOGNbJ2D+HNeagy38cQ=", "FU5NGlBvwMEAGfL4nRhvSvii0basOtqDHssA86klymo=", "I/J/JGTBFvVaW3SCoc9ebHvJnxLij7rcb9SCYHLrduQ=", "LfGWyS1TVYF4BcbMPKEClEDifbg7F/rkDDX+NRiVR1M=", "K3qJrRQZ6F9NQU8aNy/spqq91p9yH2hPNP6CmyBIyNA=", "IsKddIJIF6BCOrHXDVydUkmxahgQNFUGaef6NX2dwz0=", "LURVm/ZTwRKRj7AzyBU73ORJsPHnaeRruR5frJfvfPE=", "IdcPGBsyL3SrUMQy3flzah43OMTog2JYiUNNpQ2ITI8=", "KkN7lw/zJkW9UwP5R0tXQ0JzM8ZmPRf0TZGOnyygBdQ="],
      M: [["GWt2zv3Mf2pUxx1AEUoLuCaUyTbxVzrHrB6j/M4f6Tg=", "FEDcJXj0RpTRjCX4ktmMI8/bh6dyIAAg6JeCPUvITTs=", "I67rDGSZuEv8Mq48Qt+XKHmP0u93TxUYuHC8V9E4WQA=", "HtnT6Sdqy3tNrlProUiAb9m7B7LdBhhyEvq33L5j1yw=", "L/V/P36VsDQR23kKhmR0Z1gRlxJNIXUg7y5jMqWzUYU=", "Ffrvv4WEo4lptKcZ/+XwLCGRqMztoLd1FiID0wuAIIs=", "Hm6qsRkVk94NicuyOZq4qpVdgprZWUKM1Tm+MLcv3pw=", "KjuwIMilDTEO9bXHfMQIsHf+JIFFR1TEVo/2aP5fCXQ=", "BR+BXEVLYBXH6/kMKXuQ6WBM02rMavB/mbXlH96zIjQ=", "KLdcKsFn/fGEclMXx7u4CD5axbupN7z6bO/LaeQEi/A=", "AjrzJFmWg9m3G2HQk9Y9y72X5ElXMz0ml/3QYMHktYU=", "BaB4aKfJX1CgFYef583x62wxfk1InUUVII3fQKMjKeo=", "LFtKZbxVrF++695Tzl+miIL67SqSp7P1cygyxy9/LDA=", "Fz+JXkcsTrFqKv87jgQX+zK4PrHjIzRxx2oFUFBdBgc=", "IGywOMwyhSbQw9xa8ZQ32DIZdRxe6PYbDp4vWIE2a+M=", "AkDFeJcWFmbyjQALiNM1OSHZZ0IPQBzoa77kK+KHpPg=", "Gq78Lpkl/NRTmW/agEBj/asnazfF9R39/vklW07BDMA="], ["Ew/FRHf9lTN3/COrvXpBvmdkiSqHh8dZwUQP4BM8hS0=", "Bl4TTLjYREfW6h4XkyvUo0Hr7yVoMTwkWU+vnX7KIRA=", "DnbEA5K9X0WLwYe+VAmTEqD+//RLRBY3Ag65JnCm/PM=", "C5gXZeyuad1687EP+kJLiusgbMT0klcmXGdTscxU688=", "Dk+wRKn8tAh+NRNB8l2YsTmbV24tZlRTTzSCGaCs34Y=", "MD45yojo2m5cljVkcS34p/hQGnr0qZDkzOwZ5fj8gF0=", "Abd5ldvzDMVfnUzUhJztlJNJ2oEjmgFUQP2zi4dqvuU=", "I2Q63TC+IEc00CnPA0yVgURVEGDBkBxCCijJaI7DaoA=", "GUaiariVP5vlWBBfpRefF152okQp2tXVMsLOs8/qBck=", "JItTP4deXujnUc76Sx0HMvzTAVHDpcxKu7sek7RlXUU=", "LnocUdph3SFKF4nW8e4pV/adIbHxbR+UWOslpAZQC9M=", "IGXjdO2x88u9KRncBNFK2wcGLdAewVAbhVIufg+vkl4=", "LzZTWoOgnPCfw4ogpyVHeuxWZo8DSjZKn0pWBf/9M8w=", "ESPTyX/45rWJ0Ri8QMoLmsEq6QlVjyWCVR96QjRbRiE=", "FgswyHTZwGcEySwmbHpbf9lmpipdsAjxv/30Q7EJmoI=", "E2HSfEKntL1urrmKM5WSYWwNTY/Orf2xZGgWK9+ojUY=", "APHo+Ghgw7XHi8FN+2fSLGvriZISNliELyP3WuOpLpk="], ["LJyR9IZhdxuu72d0V4p49pw1XI6QcVb98m2znSRGQT8=", "LGsTPoCr74SQT6SnX5aPuqvviQKG1f0RuHoeUrfrbQ0=", "LOhUbLWfQg7eYWkudk4On2cVsWosgEfNgTHJdkb1DSQ=", "Ctrq8od2uBPVGPZFx5Ple/FgZ/2A65Id1aZ+iVZGycQ=", "IIagG4FkOKKkHFnkPXP6mqzwwk5Pa6winWX7pZkiVUo=", "I0hYDeSarAHOj8taorRn9nh92Klszs1vtH331aQwc5g=", "H7a9bfZQ0n6MrAWsC0Xu8HAOMIsptL1B7s/1gCftxFw=", "A+lxgjfBcA190hPgJvMH6AALOFFGf+2eb1H6UCDCNpw=", "AJJa81ozZoAayAox1j90X6gHvaEFYDRa1XK+9M8s4NY=", "D4aS1kpbaalWxOIAa/7DREd/318MmquGZgmEK511Jp0=", "K9/n60+oA7wdwAUqRthQ7j4JHrqKfxJXloL29v1QRNQ=", "E72swTe7z1HYvJ0oGTHW5xEi3G6T5//ouDXjOTd1w9Q=", "B9eM4MHIc5GgagbIPTANUlJLKfGDiE4wDg6t2s0F8Gg=", "CYTBMrKaBfK1BsoHwG/pplhPNruHUG0tMWpPNTysXx8=", "GwD6qFE2sb/EluDqmmKEyuUlqpZhL/7rUUgIlVaTh54=", "GeHkZTZwTOzqw+q5kb2AbjR75AoLeVbc1wNzUv28Q0c=", "GcJUC7sc1OCPEFQ3BjyUXP7yiundULl+C3lfjcWuNOI="], ["HewLr6PoGQYh5eCV73UeoDyDbbuARbKnP405fPuBUZI=", "J8cjMvWaABNbqpS94pSRHRNdHZX1PFLrizuVWUN0kG0=", "FuZGYRRNgWiFsy8/eAlwNHd4gmjVfBSx2TmiaynLfvM=", "IBjbOGo+Tlfq2o2RQIsVUGHfBQFA+yL5pPNPtOLQJCg=", "EiY7fj895giZosIv7pGZcs153Ciah/MfG0S68kOdyHw=", "EOQg7cttp2Fwsk13fOnTFhLtsVk+ptMOjP2s+2l0+ZE=", "DryzWPlfhLcZxjHUBFzvA6xvwjj2g0Uizr0C5HQRu28=", "DEji8wT3MNSOg9rlx4pGGIUAvIBApJVC7qXvGiG50iI=", "AOdm8Dr7t69jDqqK/0/mDzgQ8w8/RDhJjv4BhjM9rcA=", "G4p5CdfnvU8LzIADlo44SsLotAWtBc9hA2TT7LmC234=", "HZLkIT2ECjMOy9sIaT2/mpcbvWIpBH64igPzNMre8ic=", "DTs/uGpEt0IkKaJJiEyFZErxl1ZBIG5hAHDALvWp9M0=", "Jcfo+vbEihVsuR2BqZfGZz0yaUo/3WT16VlOn1BLrYM=", "LXr4NMnN8bOMjP7SGPHvDOC5kI3p56p6VRDE+5F6AoE=", "F1r15Q5Whewtuxz3os0l1FaA9s3faNfAeV3smLh/anE=", "Eh9KGNe32WUKq2JevoaVqAeUOfKrAMCQJ53nRyYjTm4=", "IfCPmzwj86AlGBFKlpKbbRBW600dsUfODIiC4bD3vRs="], ["Cl9SrW7EqKo3fY3SrjqvbuoMaMY6HQNPvaZxM8oLhcs=", "CHSI9zWx/i+jxscUjElo5/NHmxQYoaVmdDwcohXc/Pw=", "Bs8NuS+GsnMu5fuIHvAXYBLcSt/YSbm+TeF4RqbOXZk=", "BnxEEXRdtsaqZZ7HN6WGqPShzeA1LjCqAGN5SGX8HAQ=", "GZCSQcrFAojA0SND4MEs+bl5C0Be8KkAGqa+AokGOqk=", "AdJblLt8ScAXDuH7Klgktw5FVLzFS2yPjMDMnXTxml4=", "AydOc12y+vGGeHUoJUJy7gGWfmrp2CUUE3i4NU2EOWU=", "DKwyA2LiNbRY1tNkzQ//kU88BWrbsDjcKoYaSff3DiQ=", "ERHtema6LM1L6g1D7shuo1q0AlOhIJ42N/ED3LhPxCk=", "E+c2zHC3yCijjdY5Ts52ucza4spPQ5Y0MlAv6MKtGf8=", "HygFCEl2sUL3x0pBb/Q5/xvNi457BXATAEB1SmG3GRI=", "J6pQoOXVWIwUhujn/I3aZUif/7hmdWwhj4fnKAzd+mQ=", "HzzG9l2dNDcIJaOP0fSPUJ98VhcbnnpiTZsOzfasTqs=", "GxFxN5HqTLLhfIxYZ1AgQ9Coz5VThMHHk8UGt1/A2yk=", "EEVg6VxJ/rt6Awhi7bOjPCsqPUFLBTay5U4lqzbo8oE=", "CMRfPExIb2tTeMd5xge1FyALtwtVM72s7xhRn2Jbkls=", "LSGTxne7zVanT8KuUKtPLMaap3zPwzx3B0UtWtrHfts="], ["IKtzlL/as0TLtvISOACg4jUI4hJb/nlatKdnzstNkwY=", "GfDi4UGJbq5tVtGCtoe4psZMu1ngMbdJ81gi/H7jU/4=", "GPdUqVsK8ORwb/kCS7E1Fkq9b8Fu5AzC1oUtiKL/yfc=", "GT/g6bSAEPoxnDO4a2sY9CjzI/ojfKkYo4+qqRuklWc=", "AR/wkd1VG21YYgPuDK+uL3ZS6SOrqCV0pTtjKgZvSIQ=", "HaPgBgHKP8DZCxl70qR0tG7+Ov87LPrx6+Ffoa+t8ts=", "AE70GUVVnB+wshFssr4fBDv86NvJb+7MzaR8v2i+WbU=", "LwU/3xpy1q2Mnfl6BNY3kW8l40JbbcM+mcp8rFzH5Mc=", "Ha90hCx+eRBDSa05lZLFxMzhb3nhqG9Q2UFZh3LMqVM=", "KujajQsSmiL4NNDSNMiRfC+Hf/ANwWIVSY1LdI+0DfE=", "CZsKYzCSakoVZN/pT5oRBLuDdLtRioneCMWRwX36oFk=", "C5rr8EEUbBGRmXV+qM7uWrzqnsQs2yi5IcryHoSEeFE=", "BV7yceOIJ4sayjTTywARa9b3y1hLPGnw3ip6/I2Y3rg=", "Jvvxo1GWP7vatZDb12DOYoQnNSWhtGxB8pImxlM59LM=", "Ev1nhjsuA7b7RSJPsEH/KA6TZ0K1TI5U04I+CQ4UQWk=", "AGAM8mY1stVGQxUHWJc5AQ0bdXzqrmF7+VuOHvqYZD0=", "D1KPWRK+SUVdQyOyWeMM4phNgXBgHutL1wlrRzU6t/w="], ["EQ6jIrDCZHbGe/osG50XE/k7O5z4Mgzg3NS2Qoi9oHo=", "KZxH8ePsxVerHJq+NvDSug7OAQUeB/CFjpepzhb1Zk4=", "HMBTpqTW+W2nfl5zrbnUm8TQ7yzC9p+t5IBAt/jXE4Y=", "CVWOzFi+5PPFePYkid2QCECpiJCWwKYhFKotsEWh0DM=", "CT19VWPjzNC18VqbCT/muGOqzM+a8R/+qbKVt91CsfY=", "BF3AV5ymbn4JbU3Ya4guaK8tNdcM9eOxeDyqoOxCQlM=", "DaAvZBDiQFih6QQSzVMCxXGX97GvKplJb5z/P/1YgI8=", "Lftt1ZitpX6nGo1o5pJGCPDseDiAhojuSz/NUh975tI=", "EFcGK0C9zx/iqu9FiYyHEUZ5mpLIfQ/OZDAta8gxct8=", "JubRiup1qUhhoCMztTZM7Oqnit+7dCgXIYyjr2B7kQ4=", "BWW5ZlkCWTXZwCXHqyCxYR2wC2fsxRQms0L4x6F/7YM=", "J3a95SoSWUcsHMAg5xn4IZHew6t2mbfQ/Xad0/45KZc=", "DBoyTEnRX4eTGCGYm4yEN+qetG7Tqs+Ilf0cwxEFPmA=", "J+aFaOnP/Qf5JT7528NWJR3GstapA9bHBGtekOG83Jo=", "HbDn4BciqtIQ5SlsNukQPoLRV2XDGBNNF3FGodn9U1g=", "Cu+KTkfV7HYOBWWues2r5+jpiXLeht0vRHqvIWq0zBc=", "CMAMTls0Z/AZAfZPn4nBW7C5CRjUiLcwyswylmkekgA="], ["BU6r5hMWgfoB+8bb8+fVNZXQ+ICZhxghQriQrIr4nL4=", "Gkvv4RwCMMYt5E/6/qDekDujKMbWevc2gDEraPms/9o=", "AeQGZfW7jFwNycEfOdR+nTPnF6+jG6dPkvhzelXv4TQ=", "I8Sr/rgxkjYqriGy6e5c/HZb8QAPeYw65wEzVWq8eL0=", "FmnkS/AiOnf0j/+8n08gtYFPYYWuEaIQ+P38tfcdYD0=", "LVs/UjqWaMvkiHiBv3tAGE+XhxPjWN4nDYemAOXFyS8=", "EMGFbygvVW189tSik2IVBnJLptPFguTCYYQvKkvbDsY=", "IsxDSfa6o6jgth/ECrlyEOS9Oz3sfwW7jvg5yEaSr7w=", "EtAZ43zRvXb+4GW7c4CpvYMxpNvNHJx3Z5K8GQRcI7Y=", "J6o4+gUcQ0GJ31e6/YByPuKb3M1Z+8GqmvEYkdNyLmE=", "DwuTNttcFtRy/aP7msE7EzlMCaufSE7PatIGAhe1iWo=", "J1pvWWIzVNcdOLTiAM4ulnaqt06ouDZvzjO9vEfQWG0=", "Auu2cw17r+rCP8C0V+qCTu6jxV7KY0vySyrCqaIUg+E=", "D/IV6x443GdDLiYt8n7afDqpQZ1bbimb2UjpcPw1pi8=", "JH+cf6YQMiU1/rBnbP9UnxwXfQ050/Hu5kLpJTqvuC0=", "KtC9n3HieFCEqguEYWt9raBTIHxBjmX0A1vmagzcjBI=", "D8PM7wDWpkCAq77U/tkLacXlgDE0witCzcoKYPA+wzw="], ["Ik2BH73vjsCgBtN2oBnlfJO9WWIToHgjt9Srzh/Y5iE=", "FAdi0wxcOgsHULFACoap4vXPwlMbcpNw862f4dzUP5Y=", "CXbXw4RLyN7qDwM3+JsqExMC/9LQqHAYHKX9X7bU+2M=", "AVJgQgHKffBZlOnV8FjztnSc6mOqDLW04cOgC2ZnlY4=", "GrbY/jn4e7DuW4g+6iclyqUsV1dA1awwsFj3cRPQUjk=", "G2K6gDeoPxJhVEwwfwGdvqHMaoTUgeqJYLD8ZwdF6K4=", "I5q8fJ+GauwoaFwm9OBGqS1DYNNstQiQ9CLhjtb4p7I=", "Av7VoDIAQXZkU334+jAna4XZG9LtId4z2QH7TYJDmFc=", "CZbK502WJ8o8VsZGCV85cwJ00l6CxCziHPeJJT1Io/A=", "ME28CTaGI1bgAksqMt+jCFq+29M38iuJBivmFNg8sIM=", "Kn3o9f9HbYHTk/HSdGNsqVbwW9QivJ88wPrABUtYywI=", "Esb2yDo1MPrO1gyI8ZqC/RK32TinmGTtIKVFpS/c4R0=", "IB4D8f9nJilHOiTzLS1QKs3I/dKIMBTedMmPQKGVs+Q=", "EYw+/pIMnD+QfIZ3Q9NdLMv/fInpwxu2oXxVLvkrbAE=", "D3Bf66XwHLJ7J8EEvJPwyXT1Yfom1WFPap2eR9A7xlU=", "KNMnocLWAS2eaemjtMEa0zbTwNzf9MXITd3fkR62RfU=", "G85n9NyZVH8sr/G1xtY+PuJWWkBBkGZFM8HGXdnY1TI="], ["DmkfykIxKKfUr8qlgrGpR5m6H10qXVO8K7pWu+yyJ6E=", "GAqkur+nU5dT2cIi5eM1mspZ4Gu+/Hzzo/+k+WH6HVs=", "LFQofu42jV1S37BoKC1o5rCbdr0bXJMzs2hIrCd3RPU=", "L2U2GkrtMg/NA6RcRN2nQCE1cfOXXOILlr/9lgy8biU=", "I1vxeLW1YmLZiL/GJwiw+F1XOFzeK02s+ebVkt6yr+Q=", "F5TsKw7rIvvXU7IfzZSee+2zBfFaWer3SpYcMEZjX4U=", "CD4c1ZQ0YatQWyADEb3kAD+09+0WqljIvCjy4I6faSI=", "IqZ6iHdpgtahX1d9z3gKxIXrqub99vvlC5XqJmp7YFk=", "LRGI2efmrCTEssncPfz7D+R4LWifMblLH7Fe8p0R8Z4=", "JlxDyIbwfQJSANVs0kawFnCz6Cq0gvWHmxBgjMBaN/w=", "DybQXpOPgxe9YI7/CJXTUtynErZTsUkvjC6payb5OB4=", "JXaJpOIvaodoqv5UIY0x3k5An9v0IxlYJTa7WDMTo5U=", "HtxX8XThMitifG+dvieuJwPD8Rw2SzgYi/QdjKDBcJo=", "F7OfOGNtXv9eBu/wietWBRpgK8j0vxuwrSss0QzwcTg=", "MGCU7P5jMAsvlbyYoEBseJjYaFIzCntp+bBLVASz7vM=", "Ea/syFWQVDvS34q5Ur4WRnCj8yWT6WLUvUk7zTyE+E0=", "Gouk830jFTichWDXTaxXKkRHoCFFUWKHBT5rnt77yi0="], ["GJ4nnJLeC6tmcH5ubjEFJOYVzUxqrMZlNyo7jjctjOY=", "FyCOqc1Nwabe6+ao0noxgatfhsanBub9AH/B62eOneY=", "Ioo0iMq7+fKe/AvOIRoJAxlys38l6jWsqEDcIzGgzzU=", "IhIsYxP8mkxtD5RNPOI4JyvzUUext4iqsrjbzrYCTHY=", "BmSaE+ZQI6cTqu5Th9OI42Ca6bFLpNoQZC7gt7ShZjQ=", "HtTJXGKDtF7AzYj1EZdvBj6ivrBpW4r3zBBYlZOnl4w=", "Ff5ippsEOClDldob/JMnLYh5fO7vZmuiRD8MFG+Kt+4=", "KweaHQm51KdtTlDEXAH7dQixxEOo+yHr0oUz4F3viGQ=", "DDRJan21q7MwsvbOmtrvWubjCMj8LFY0CXrjUqp0V9Q=", "BP/iepLLQwDndDiO3DFHq53MSrNUw4D1HKei5/4EY8Q=", "KLc7M1xy8HdIcaIDDUROX7lUl5wcVo4RL7kRpGxmZ2g=", "GVghuZrywhdATuWC4piJByujzZlLdJVcJhta02Tlqcc=", "IKVvzjcSK3QAq2GmXqyBXdGA9S+tKDX3/ZZJBjUjiB4=", "I1EykS2y2gekdQxe1d8lkOcYQErvxIvmlTQy9kQkBC4=", "EFnbXpfyWCawu+/Wv6pulJbFXvWoj+/pcSaR9vvfQpg=", "CwUMiCBzpYHnZyI3Bc2VEMBMMBaMUP/gyYdaKLaTgpk=", "EV5gxOKTfrU8bkpUiPgBJm6E0HVHoLHNkbGPSe/vmSA="], ["HZvLvRe5OxkT0vec3xKEREEjcgbwKUdG2T+OW9zrRyU=", "IAB6D103eYeJ4KjvaDU22c9IMaZWbrcntBGR2fKXRxA=", "Frrkn167H/6Ia2NNIV3mHr9PRNHNxPhGcN+O1pMQv+I=", "IpqltUemN4DY0SniCf25L4VmJhbVnakIB15mj9gXgi0=", "KaWx5OLyVEVJat7CMO1To1mTs3YwrstdduVmCNG3jMY=", "C/znsSAGi5owAp29s2vgHQcegWP6FyTxPGyom+Kbcp4=", "IAVVaLMzZ7wSv0rtegkJwXNYildjxqGnWYunxsfjwqU=", "LfH/hmRPzEKhkyzxXTFO7UB2CCRvFKgJhyX/e+gJyH4=", "HU+w8Y8xyCcLRjbmtdejPkVbEFDeEWQYLPy3OczpZdo=", "Gdbx0RDZ+HPbAC/y7YKJBb1sxdeSHCONdWnaqbJAHTI=", "KCoB6PLOCcvdhi+Y/auj+a8CRD7cliyzSALQRHfeHiA=", "MEtnkAjoofCUSEI6BYieDfZjorZQVcqe5amd/hP7mhY=", "GZgUftrzqSqxecYawsNq9crz54vL+2hM/qFdsXuDWQc=", "AopFcstlQmHPk1hDWSPmWv+PQDk3UnSLdqz9Lj9XVck=", "Fb2ZjCcp2+rMwptdbk8P2WrQpgN8hKGhp4UWn7M2+24=", "B83zMJ4TD5zt3WiK84hTafus9tikTeTUUGZ8DXZBIT8=", "FS1HrLmwbJ0SwhOKMUFru7uZGmXcTU+O+Ro91yjmO2o="], ["EXkYRjWpeA7hMS3MPRXH7wQrGK6UCWcOKMTH8PubYI4=", "Ip2kQaMCkpsLrpN0G3x14RM3x5flch+dfuWSNc2ppAw=", "Liadx49w+RA7K87T7b1B4VbmSRCIe03d+KPu6WD2Abc=", "Iakf7YvtFJFMT9SRtvpNy657O4s9RWMDr4hsMoq/Rpk=", "KfB8Hv/GW1WJ4cpSy+AL1l716WLQEgAwJnC23Oee6wA=", "BQanpd5rVuvsXnCKcKPOyzos/SXnog7UleKVqTAjxag=", "DAKxSPShVZtZfNMg8AwCuWp/x8g4Eb2GoeecwxBrIgE=", "JKRm906ZpgKJT0IQEPQ6gccIsbStB2QlGQuFNH9oWxo=", "H+4YiIQlcklwvSiXtUx/qOnDZ93byEhNo3hk+v+fkFY=", "GXEcQddvZKNxq6YvP0ZxDe4MOq0he3ywC9EmE7JO9Ss=", "J3DRSiIBUvpwgwQL6bPNOMis6eIHBzSGvPr8rXBnSLE=", "CN/+aEqjP5EdNemmRLS9v80VpNpJtlMYFrYOjOT2teA=", "HL+rfLBeLyglSyML/OAX8AX7Ty3Yk1rRF2WzR9IANmc=", "IdcmmlPTcSsgVDsAOa7MlGZSATPSmehEIACzMYSjnoQ=", "If3lgKGYhrEzWPGKMtWv9oW0vXfZTwZ/RPbnqTNQ/So=", "BSMr+VgH5IrYKh60vEgemwcg6VGW3+Nh9VxNHPx5Jtc=", "E2AmRriLoxwNVEx1e9kYFyeDXb5pDDBYOiPzf1L+Xj0="], ["DkhGYYKugzOvGJGmqhlzZ0HtBoDVfJMe3hP8B66C6Is=", "ETe1xhuWhL7EHk36p2Q4JWYipDeOpOZGooRLvIW/gcw=", "H0uFVSuWDRwYt7j2avcwWmdz2bBfr1Hg7RpfLvL5Xn0=", "C6ilSRSIb64WcAwC7993Z0E6C+xaGe0M8KfYrGDB8cM=", "MCiclnjAMw+Fz442JoOmFE8iuEGqCPWG8hndntrveLw=", "BIkASPzb3mNmdhzVj8xqwKM2DZpkIz0+pNjWvooj7EU=", "GkFi6KdwREe+DB1NXPL3d2cPSEHqJ6wnCc1r/+7Szr0=", "LpRLRJwTac6XZvpvT5modjC1wfLWNnekN6U31htsdHA=", "Itbnh/RNqmtlk9/eVXbS/fXcBEfmWh1edxLk5iw73O4=", "Dgjdtp1e/ZScPWceTnjk/HYoxl7Bz7wYumoQGqGdv2Y=", "J6VzA2UJqKKakOqjTSra7V7R7GsgcnTzxcoj2tOIDlc=", "ByNyCD9iGVvMK1r6sQOBmKPwVGti0XHqIcN8jzFVEXY=", "FR4LwhEOQwDdgqTJJELEdRxlspRCbIwyDGnmGDGVjOs=", "E/Gsw4nE+OdSzH5LgcN64hMMYN+ci36H3F+3RZyvSRY=", "BoI6m6pVYjcysC+icLL4h/04BKhcGn8qNV3z++/GncE=", "HkGTbmvAw+1mXC4kZquSFrmXP+E22fmq2Vh4wbVgfG4=", "Bldm0pgDMaVcCjnYO+eL0Se67nfVOiQmjgZMcdqvK2o="], ["HJ1W9xwvIsRNOowXv1tARS4FRx8Lbf6f/kcl6yn3NGQ=", "ETADwdx7rzXkU2+V9Oqy87rdosehxrWvyVYjSt4+cSk=", "DV+5sOFQPyuSaXxHO2nPdtOPwSkS4sPLM5ltuwzfqjg=", "LhZKUk7iLrWokD+uHzWjp4+ILz46mJK2/0dTuqyTSUk=", "AfncvefQWBNKUQpxHQNtHxgA5HOmOzOn4PsE3C4J468=", "KFsgeZlwtYxjrJ9K9WTODyggm2GAIhTaW/r9DPJMZxI=", "DOPdcn/dEai8cxUA7/ojdjCJzjMyy3MPn+VxRu4gSBA=", "AQeXRspR2VGKDDCSlspIIGKSeYkQSUJ3viu2WmsTSzo=", "I6hdT5Htpp8xDEUdfUgML0DA1TOC3dP8qq5ie5YXFw4=", "JAZX1n+SteQmGs5DT9KGIGwxVWU3jOi4FmFSPw5t3FQ=", "I4SjhLzCxKF/98nj59Ex05FzxDEzOpx8HW/XEQ4lkCs=", "JVR7UbLGh05FOMqbNAk7cUrTao81bkx44NZrHxkAOPs=", "DlnhqZDsAPcu3Dckg0nXpab3vK7xWBEEUPHlmF8KXZk=", "BmxgkJNvawVPF96pFoKVQzKz4y2PIKCuFx1BcxbTYi8=", "GyVmKEOwmGqxpOmnZhk+/KR8cNSTZPA9UMXttbVRfr4=", "JkdjVHfuX6nnrFmD+S2zTXM2ZGxjxj4t1T1guHFL11k=", "JtsuhakAbvXBHNZ1omfULv759a+QRmsqr3XuqAJLALs="], ["IjRUb16FQej3KteUiRlQsysc2JHMZndcW2NZYWQunBU=", "G2FGj6tZySXxmGGGvLl5ZahYUjolgtQ0MZqVJa5xFY8=", "ARKR71FKENbwZR5K0NpdSkieMBiSeHnalC3v299wHd0=", "LfL7LC4yHjzOE9FgkXBaQMXHlfi0G2Hf1q59l9Y1eLQ=", "Abqvj/lrsiJLw0z4DDi/EwhvHkKbzuwSCQ2KfDdqmoI=", "B7DXDM/xtw2tm7SwFC4/bcW8ldN2av+tN4zFBCSE3sk=", "EfKO5dqA0Z4xWBtWakOVN0ZtnKf98UtwhoML2KwTxMs=", "ABPXsD6Pyfpkf8ps3KlxRpAd98Z1oWSRPCvSo7buPLQ=", "JEDnhheaf7z+jSmrGND8bPo4PPt0f3otFbd9gtmw2dM=", "BWFJIhcSuI7CkfwhgyQULQKHPN1TGZZ5/OTfy13akRY=", "FixbvIG0RCe+ToLF5SU71mwwVPXFtzsospI4SHhJp5Q=", "F48qqN+aEe8zVY3Mk0lx92l+Ymz+8A/83rbzycGn0Qo=", "JK/ZL4Dld4j0D7srefKUVNxIX7r7WnJj9GK3yEtOUAs=", "BJKuX1rCpRAuqW5grIN1VTaHFRrkQELb9YmSMsjyEAo=", "ENyxH4FcfinGa+HdPF92AsmOn7FofC2CW0h4nFIfvQs=", "ChHVh8t11IVE7sZirSfKas/smPeot5Y6KU5LsymxcN8=", "HdawlctoRZ3Pa9rdQ0qoH4ClWgjmeCxlOpOv2KZfMmc="], ["FMCdFVxdQoGYwjS1U9ozjyJ8vBKw5C8rnOcVY+4UlcA=", "EX/VKHcPsX9xjimi2Rpj7Hw57x3TA58JQ/cX0YBCU9U=", "Eg50FtdDCOJAR/aCjGiuKLwoiyFuiiXosOvPc4SA45A=", "BpleUQ/XZpN0w50nkD80KsW/ihRkgH8wi+9hC3bLaT4=", "HYFLPBdlbCMn+UzAJHJ4C4hriDlPGly+NNxPRP8TT84=", "A7kNo0sZjLyhfjSqyYsWmHXs9zrrXG/x8Ayf5TWqmQI=", "J/p3oGWHkeZ1V4HDZ2g/nJMzpBNk94cO3/GTWjR0hdg=", "BtbuUxuj/c7QXiTPkQPQli3SJ/HeaSwBmUg+kqskulk=", "HlB5Ib58dhJIef/OW2LdDpYlnpjMZMJyCNYrQL/j5II=", "BoGtrqec9FfbVwGTHw7i8V7LsVntUM90ahW4XG+KU3A=", "HmGWFHUIvy7chyxOiXqWd3ixGfaftDGn9kbSAY6rQBA=", "Bo76NbxiASSrfYiZAXG65BAq0h3937OH3w3gyKOhiek=", "GwEiJKTwUN+EESLRfF6k7e18jsIDR0OkMqLO6JOXbyk=", "II2BQVG83N38+DWpWMJZpkd7/kszknEO352AeHolxdA=", "KPkB/KqGCw3EGSre+OpK5Vr2zkMsheDOTQc+UUqyQlI=", "G9Y5h5cxgjyHH5zUcU48xWpusZiEtzZk7tJLEZKRGaA=", "HT7oXwePvuzaJHPvwr7dG6fsb0eV+q6uOw3kjTCAxiU="]]
    };
    exports2.default = _default;
  }
});

// node_modules/@selfxyz/common/node_modules/poseidon-lite/poseidon16.js
var require_poseidon16 = __commonJS({
  "node_modules/@selfxyz/common/node_modules/poseidon-lite/poseidon16.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.poseidon16 = poseidon162;
    var _poseidon = _interopRequireDefault(require_poseidon());
    var _unstringify = _interopRequireDefault(require_unstringify());
    var _ = _interopRequireDefault(require__16());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var c = (0, _unstringify.default)(_.default);
    function poseidon162(inputs) {
      return (0, _poseidon.default)(inputs, c);
    }
  }
});

// node_modules/@selfxyz/common/node_modules/poseidon-lite/index.js
var require_poseidon_lite = __commonJS({
  "node_modules/@selfxyz/common/node_modules/poseidon-lite/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    Object.defineProperty(exports2, "poseidon1", {
      enumerable: true,
      get: function() {
        return _poseidon.poseidon1;
      }
    });
    Object.defineProperty(exports2, "poseidon10", {
      enumerable: true,
      get: function() {
        return _poseidon10.poseidon10;
      }
    });
    Object.defineProperty(exports2, "poseidon11", {
      enumerable: true,
      get: function() {
        return _poseidon11.poseidon11;
      }
    });
    Object.defineProperty(exports2, "poseidon12", {
      enumerable: true,
      get: function() {
        return _poseidon12.poseidon12;
      }
    });
    Object.defineProperty(exports2, "poseidon13", {
      enumerable: true,
      get: function() {
        return _poseidon13.poseidon13;
      }
    });
    Object.defineProperty(exports2, "poseidon14", {
      enumerable: true,
      get: function() {
        return _poseidon14.poseidon14;
      }
    });
    Object.defineProperty(exports2, "poseidon15", {
      enumerable: true,
      get: function() {
        return _poseidon15.poseidon15;
      }
    });
    Object.defineProperty(exports2, "poseidon16", {
      enumerable: true,
      get: function() {
        return _poseidon16.poseidon16;
      }
    });
    Object.defineProperty(exports2, "poseidon2", {
      enumerable: true,
      get: function() {
        return _poseidon2.poseidon2;
      }
    });
    Object.defineProperty(exports2, "poseidon3", {
      enumerable: true,
      get: function() {
        return _poseidon3.poseidon3;
      }
    });
    Object.defineProperty(exports2, "poseidon4", {
      enumerable: true,
      get: function() {
        return _poseidon4.poseidon4;
      }
    });
    Object.defineProperty(exports2, "poseidon5", {
      enumerable: true,
      get: function() {
        return _poseidon5.poseidon5;
      }
    });
    Object.defineProperty(exports2, "poseidon6", {
      enumerable: true,
      get: function() {
        return _poseidon6.poseidon6;
      }
    });
    Object.defineProperty(exports2, "poseidon7", {
      enumerable: true,
      get: function() {
        return _poseidon7.poseidon7;
      }
    });
    Object.defineProperty(exports2, "poseidon8", {
      enumerable: true,
      get: function() {
        return _poseidon8.poseidon8;
      }
    });
    Object.defineProperty(exports2, "poseidon9", {
      enumerable: true,
      get: function() {
        return _poseidon9.poseidon9;
      }
    });
    var _poseidon = require_poseidon1();
    var _poseidon2 = require_poseidon2();
    var _poseidon3 = require_poseidon3();
    var _poseidon4 = require_poseidon4();
    var _poseidon5 = require_poseidon5();
    var _poseidon6 = require_poseidon6();
    var _poseidon7 = require_poseidon7();
    var _poseidon8 = require_poseidon8();
    var _poseidon9 = require_poseidon9();
    var _poseidon10 = require_poseidon10();
    var _poseidon11 = require_poseidon11();
    var _poseidon12 = require_poseidon12();
    var _poseidon13 = require_poseidon13();
    var _poseidon14 = require_poseidon14();
    var _poseidon15 = require_poseidon15();
    var _poseidon16 = require_poseidon16();
  }
});

// node_modules/js-sha256/src/sha256.js
var require_sha256 = __commonJS({
  "node_modules/js-sha256/src/sha256.js"(exports2, module2) {
    (function() {
      "use strict";
      var ERROR = "input is invalid type";
      var WINDOW = typeof window === "object";
      var root = WINDOW ? window : {};
      if (root.JS_SHA256_NO_WINDOW) {
        WINDOW = false;
      }
      var WEB_WORKER = !WINDOW && typeof self === "object";
      var NODE_JS = !root.JS_SHA256_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node && process.type != "renderer";
      if (NODE_JS) {
        root = globalThis;
      } else if (WEB_WORKER) {
        root = self;
      }
      var COMMON_JS = !root.JS_SHA256_NO_COMMON_JS && typeof module2 === "object" && module2.exports;
      var AMD = typeof define === "function" && define.amd;
      var ARRAY_BUFFER = !root.JS_SHA256_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
      var HEX_CHARS = "0123456789abcdef".split("");
      var EXTRA = [-2147483648, 8388608, 32768, 128];
      var SHIFT = [24, 16, 8, 0];
      var K = [
        1116352408,
        1899447441,
        3049323471,
        3921009573,
        961987163,
        1508970993,
        2453635748,
        2870763221,
        3624381080,
        310598401,
        607225278,
        1426881987,
        1925078388,
        2162078206,
        2614888103,
        3248222580,
        3835390401,
        4022224774,
        264347078,
        604807628,
        770255983,
        1249150122,
        1555081692,
        1996064986,
        2554220882,
        2821834349,
        2952996808,
        3210313671,
        3336571891,
        3584528711,
        113926993,
        338241895,
        666307205,
        773529912,
        1294757372,
        1396182291,
        1695183700,
        1986661051,
        2177026350,
        2456956037,
        2730485921,
        2820302411,
        3259730800,
        3345764771,
        3516065817,
        3600352804,
        4094571909,
        275423344,
        430227734,
        506948616,
        659060556,
        883997877,
        958139571,
        1322822218,
        1537002063,
        1747873779,
        1955562222,
        2024104815,
        2227730452,
        2361852424,
        2428436474,
        2756734187,
        3204031479,
        3329325298
      ];
      var OUTPUT_TYPES = ["hex", "array", "digest", "arrayBuffer"];
      var blocks = [];
      if (root.JS_SHA256_NO_NODE_JS || !Array.isArray) {
        Array.isArray = function(obj) {
          return Object.prototype.toString.call(obj) === "[object Array]";
        };
      }
      if (ARRAY_BUFFER && (root.JS_SHA256_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
        ArrayBuffer.isView = function(obj) {
          return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
        };
      }
      var createOutputMethod = function(outputType, is224) {
        return function(message) {
          return new Sha256(is224, true).update(message)[outputType]();
        };
      };
      var createMethod = function(is224) {
        var method = createOutputMethod("hex", is224);
        if (NODE_JS) {
          method = nodeWrap(method, is224);
        }
        method.create = function() {
          return new Sha256(is224);
        };
        method.update = function(message) {
          return method.create().update(message);
        };
        for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
          var type = OUTPUT_TYPES[i];
          method[type] = createOutputMethod(type, is224);
        }
        return method;
      };
      var nodeWrap = function(method, is224) {
        var crypto2 = require_crypto_browserify();
        var Buffer2 = require_buffer().Buffer;
        var algorithm = is224 ? "sha224" : "sha256";
        var bufferFrom;
        if (Buffer2.from && !root.JS_SHA256_NO_BUFFER_FROM) {
          bufferFrom = Buffer2.from;
        } else {
          bufferFrom = function(message) {
            return new Buffer2(message);
          };
        }
        var nodeMethod = function(message) {
          if (typeof message === "string") {
            return crypto2.createHash(algorithm).update(message, "utf8").digest("hex");
          } else {
            if (message === null || message === void 0) {
              throw new Error(ERROR);
            } else if (message.constructor === ArrayBuffer) {
              message = new Uint8Array(message);
            }
          }
          if (Array.isArray(message) || ArrayBuffer.isView(message) || message.constructor === Buffer2) {
            return crypto2.createHash(algorithm).update(bufferFrom(message)).digest("hex");
          } else {
            return method(message);
          }
        };
        return nodeMethod;
      };
      var createHmacOutputMethod = function(outputType, is224) {
        return function(key2, message) {
          return new HmacSha256(key2, is224, true).update(message)[outputType]();
        };
      };
      var createHmacMethod = function(is224) {
        var method = createHmacOutputMethod("hex", is224);
        method.create = function(key2) {
          return new HmacSha256(key2, is224);
        };
        method.update = function(key2, message) {
          return method.create(key2).update(message);
        };
        for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
          var type = OUTPUT_TYPES[i];
          method[type] = createHmacOutputMethod(type, is224);
        }
        return method;
      };
      function Sha256(is224, sharedMemory) {
        if (sharedMemory) {
          blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
          this.blocks = blocks;
        } else {
          this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        }
        if (is224) {
          this.h0 = 3238371032;
          this.h1 = 914150663;
          this.h2 = 812702999;
          this.h3 = 4144912697;
          this.h4 = 4290775857;
          this.h5 = 1750603025;
          this.h6 = 1694076839;
          this.h7 = 3204075428;
        } else {
          this.h0 = 1779033703;
          this.h1 = 3144134277;
          this.h2 = 1013904242;
          this.h3 = 2773480762;
          this.h4 = 1359893119;
          this.h5 = 2600822924;
          this.h6 = 528734635;
          this.h7 = 1541459225;
        }
        this.block = this.start = this.bytes = this.hBytes = 0;
        this.finalized = this.hashed = false;
        this.first = true;
        this.is224 = is224;
      }
      Sha256.prototype.update = function(message) {
        if (this.finalized) {
          return;
        }
        var notString, type = typeof message;
        if (type !== "string") {
          if (type === "object") {
            if (message === null) {
              throw new Error(ERROR);
            } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
              message = new Uint8Array(message);
            } else if (!Array.isArray(message)) {
              if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
                throw new Error(ERROR);
              }
            }
          } else {
            throw new Error(ERROR);
          }
          notString = true;
        }
        var code, index2 = 0, i, length2 = message.length, blocks2 = this.blocks;
        while (index2 < length2) {
          if (this.hashed) {
            this.hashed = false;
            blocks2[0] = this.block;
            this.block = blocks2[16] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = 0;
          }
          if (notString) {
            for (i = this.start; index2 < length2 && i < 64; ++index2) {
              blocks2[i >>> 2] |= message[index2] << SHIFT[i++ & 3];
            }
          } else {
            for (i = this.start; index2 < length2 && i < 64; ++index2) {
              code = message.charCodeAt(index2);
              if (code < 128) {
                blocks2[i >>> 2] |= code << SHIFT[i++ & 3];
              } else if (code < 2048) {
                blocks2[i >>> 2] |= (192 | code >>> 6) << SHIFT[i++ & 3];
                blocks2[i >>> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
              } else if (code < 55296 || code >= 57344) {
                blocks2[i >>> 2] |= (224 | code >>> 12) << SHIFT[i++ & 3];
                blocks2[i >>> 2] |= (128 | code >>> 6 & 63) << SHIFT[i++ & 3];
                blocks2[i >>> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
              } else {
                code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index2) & 1023);
                blocks2[i >>> 2] |= (240 | code >>> 18) << SHIFT[i++ & 3];
                blocks2[i >>> 2] |= (128 | code >>> 12 & 63) << SHIFT[i++ & 3];
                blocks2[i >>> 2] |= (128 | code >>> 6 & 63) << SHIFT[i++ & 3];
                blocks2[i >>> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
              }
            }
          }
          this.lastByteIndex = i;
          this.bytes += i - this.start;
          if (i >= 64) {
            this.block = blocks2[16];
            this.start = i - 64;
            this.hash();
            this.hashed = true;
          } else {
            this.start = i;
          }
        }
        if (this.bytes > 4294967295) {
          this.hBytes += this.bytes / 4294967296 << 0;
          this.bytes = this.bytes % 4294967296;
        }
        return this;
      };
      Sha256.prototype.finalize = function() {
        if (this.finalized) {
          return;
        }
        this.finalized = true;
        var blocks2 = this.blocks, i = this.lastByteIndex;
        blocks2[16] = this.block;
        blocks2[i >>> 2] |= EXTRA[i & 3];
        this.block = blocks2[16];
        if (i >= 56) {
          if (!this.hashed) {
            this.hash();
          }
          blocks2[0] = this.block;
          blocks2[16] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = 0;
        }
        blocks2[14] = this.hBytes << 3 | this.bytes >>> 29;
        blocks2[15] = this.bytes << 3;
        this.hash();
      };
      Sha256.prototype.hash = function() {
        var a = this.h0, b = this.h1, c = this.h2, d = this.h3, e = this.h4, f3 = this.h5, g = this.h6, h = this.h7, blocks2 = this.blocks, j, s0, s1, maj, t1, t2, ch, ab, da, cd, bc;
        for (j = 16; j < 64; ++j) {
          t1 = blocks2[j - 15];
          s0 = (t1 >>> 7 | t1 << 25) ^ (t1 >>> 18 | t1 << 14) ^ t1 >>> 3;
          t1 = blocks2[j - 2];
          s1 = (t1 >>> 17 | t1 << 15) ^ (t1 >>> 19 | t1 << 13) ^ t1 >>> 10;
          blocks2[j] = blocks2[j - 16] + s0 + blocks2[j - 7] + s1 << 0;
        }
        bc = b & c;
        for (j = 0; j < 64; j += 4) {
          if (this.first) {
            if (this.is224) {
              ab = 300032;
              t1 = blocks2[0] - 1413257819;
              h = t1 - 150054599 << 0;
              d = t1 + 24177077 << 0;
            } else {
              ab = 704751109;
              t1 = blocks2[0] - 210244248;
              h = t1 - 1521486534 << 0;
              d = t1 + 143694565 << 0;
            }
            this.first = false;
          } else {
            s0 = (a >>> 2 | a << 30) ^ (a >>> 13 | a << 19) ^ (a >>> 22 | a << 10);
            s1 = (e >>> 6 | e << 26) ^ (e >>> 11 | e << 21) ^ (e >>> 25 | e << 7);
            ab = a & b;
            maj = ab ^ a & c ^ bc;
            ch = e & f3 ^ ~e & g;
            t1 = h + s1 + ch + K[j] + blocks2[j];
            t2 = s0 + maj;
            h = d + t1 << 0;
            d = t1 + t2 << 0;
          }
          s0 = (d >>> 2 | d << 30) ^ (d >>> 13 | d << 19) ^ (d >>> 22 | d << 10);
          s1 = (h >>> 6 | h << 26) ^ (h >>> 11 | h << 21) ^ (h >>> 25 | h << 7);
          da = d & a;
          maj = da ^ d & b ^ ab;
          ch = h & e ^ ~h & f3;
          t1 = g + s1 + ch + K[j + 1] + blocks2[j + 1];
          t2 = s0 + maj;
          g = c + t1 << 0;
          c = t1 + t2 << 0;
          s0 = (c >>> 2 | c << 30) ^ (c >>> 13 | c << 19) ^ (c >>> 22 | c << 10);
          s1 = (g >>> 6 | g << 26) ^ (g >>> 11 | g << 21) ^ (g >>> 25 | g << 7);
          cd = c & d;
          maj = cd ^ c & a ^ da;
          ch = g & h ^ ~g & e;
          t1 = f3 + s1 + ch + K[j + 2] + blocks2[j + 2];
          t2 = s0 + maj;
          f3 = b + t1 << 0;
          b = t1 + t2 << 0;
          s0 = (b >>> 2 | b << 30) ^ (b >>> 13 | b << 19) ^ (b >>> 22 | b << 10);
          s1 = (f3 >>> 6 | f3 << 26) ^ (f3 >>> 11 | f3 << 21) ^ (f3 >>> 25 | f3 << 7);
          bc = b & c;
          maj = bc ^ b & d ^ cd;
          ch = f3 & g ^ ~f3 & h;
          t1 = e + s1 + ch + K[j + 3] + blocks2[j + 3];
          t2 = s0 + maj;
          e = a + t1 << 0;
          a = t1 + t2 << 0;
          this.chromeBugWorkAround = true;
        }
        this.h0 = this.h0 + a << 0;
        this.h1 = this.h1 + b << 0;
        this.h2 = this.h2 + c << 0;
        this.h3 = this.h3 + d << 0;
        this.h4 = this.h4 + e << 0;
        this.h5 = this.h5 + f3 << 0;
        this.h6 = this.h6 + g << 0;
        this.h7 = this.h7 + h << 0;
      };
      Sha256.prototype.hex = function() {
        this.finalize();
        var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4, h5 = this.h5, h6 = this.h6, h7 = this.h7;
        var hex = HEX_CHARS[h0 >>> 28 & 15] + HEX_CHARS[h0 >>> 24 & 15] + HEX_CHARS[h0 >>> 20 & 15] + HEX_CHARS[h0 >>> 16 & 15] + HEX_CHARS[h0 >>> 12 & 15] + HEX_CHARS[h0 >>> 8 & 15] + HEX_CHARS[h0 >>> 4 & 15] + HEX_CHARS[h0 & 15] + HEX_CHARS[h1 >>> 28 & 15] + HEX_CHARS[h1 >>> 24 & 15] + HEX_CHARS[h1 >>> 20 & 15] + HEX_CHARS[h1 >>> 16 & 15] + HEX_CHARS[h1 >>> 12 & 15] + HEX_CHARS[h1 >>> 8 & 15] + HEX_CHARS[h1 >>> 4 & 15] + HEX_CHARS[h1 & 15] + HEX_CHARS[h2 >>> 28 & 15] + HEX_CHARS[h2 >>> 24 & 15] + HEX_CHARS[h2 >>> 20 & 15] + HEX_CHARS[h2 >>> 16 & 15] + HEX_CHARS[h2 >>> 12 & 15] + HEX_CHARS[h2 >>> 8 & 15] + HEX_CHARS[h2 >>> 4 & 15] + HEX_CHARS[h2 & 15] + HEX_CHARS[h3 >>> 28 & 15] + HEX_CHARS[h3 >>> 24 & 15] + HEX_CHARS[h3 >>> 20 & 15] + HEX_CHARS[h3 >>> 16 & 15] + HEX_CHARS[h3 >>> 12 & 15] + HEX_CHARS[h3 >>> 8 & 15] + HEX_CHARS[h3 >>> 4 & 15] + HEX_CHARS[h3 & 15] + HEX_CHARS[h4 >>> 28 & 15] + HEX_CHARS[h4 >>> 24 & 15] + HEX_CHARS[h4 >>> 20 & 15] + HEX_CHARS[h4 >>> 16 & 15] + HEX_CHARS[h4 >>> 12 & 15] + HEX_CHARS[h4 >>> 8 & 15] + HEX_CHARS[h4 >>> 4 & 15] + HEX_CHARS[h4 & 15] + HEX_CHARS[h5 >>> 28 & 15] + HEX_CHARS[h5 >>> 24 & 15] + HEX_CHARS[h5 >>> 20 & 15] + HEX_CHARS[h5 >>> 16 & 15] + HEX_CHARS[h5 >>> 12 & 15] + HEX_CHARS[h5 >>> 8 & 15] + HEX_CHARS[h5 >>> 4 & 15] + HEX_CHARS[h5 & 15] + HEX_CHARS[h6 >>> 28 & 15] + HEX_CHARS[h6 >>> 24 & 15] + HEX_CHARS[h6 >>> 20 & 15] + HEX_CHARS[h6 >>> 16 & 15] + HEX_CHARS[h6 >>> 12 & 15] + HEX_CHARS[h6 >>> 8 & 15] + HEX_CHARS[h6 >>> 4 & 15] + HEX_CHARS[h6 & 15];
        if (!this.is224) {
          hex += HEX_CHARS[h7 >>> 28 & 15] + HEX_CHARS[h7 >>> 24 & 15] + HEX_CHARS[h7 >>> 20 & 15] + HEX_CHARS[h7 >>> 16 & 15] + HEX_CHARS[h7 >>> 12 & 15] + HEX_CHARS[h7 >>> 8 & 15] + HEX_CHARS[h7 >>> 4 & 15] + HEX_CHARS[h7 & 15];
        }
        return hex;
      };
      Sha256.prototype.toString = Sha256.prototype.hex;
      Sha256.prototype.digest = function() {
        this.finalize();
        var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4, h5 = this.h5, h6 = this.h6, h7 = this.h7;
        var arr = [
          h0 >>> 24 & 255,
          h0 >>> 16 & 255,
          h0 >>> 8 & 255,
          h0 & 255,
          h1 >>> 24 & 255,
          h1 >>> 16 & 255,
          h1 >>> 8 & 255,
          h1 & 255,
          h2 >>> 24 & 255,
          h2 >>> 16 & 255,
          h2 >>> 8 & 255,
          h2 & 255,
          h3 >>> 24 & 255,
          h3 >>> 16 & 255,
          h3 >>> 8 & 255,
          h3 & 255,
          h4 >>> 24 & 255,
          h4 >>> 16 & 255,
          h4 >>> 8 & 255,
          h4 & 255,
          h5 >>> 24 & 255,
          h5 >>> 16 & 255,
          h5 >>> 8 & 255,
          h5 & 255,
          h6 >>> 24 & 255,
          h6 >>> 16 & 255,
          h6 >>> 8 & 255,
          h6 & 255
        ];
        if (!this.is224) {
          arr.push(h7 >>> 24 & 255, h7 >>> 16 & 255, h7 >>> 8 & 255, h7 & 255);
        }
        return arr;
      };
      Sha256.prototype.array = Sha256.prototype.digest;
      Sha256.prototype.arrayBuffer = function() {
        this.finalize();
        var buffer = new ArrayBuffer(this.is224 ? 28 : 32);
        var dataView = new DataView(buffer);
        dataView.setUint32(0, this.h0);
        dataView.setUint32(4, this.h1);
        dataView.setUint32(8, this.h2);
        dataView.setUint32(12, this.h3);
        dataView.setUint32(16, this.h4);
        dataView.setUint32(20, this.h5);
        dataView.setUint32(24, this.h6);
        if (!this.is224) {
          dataView.setUint32(28, this.h7);
        }
        return buffer;
      };
      function HmacSha256(key2, is224, sharedMemory) {
        var i, type = typeof key2;
        if (type === "string") {
          var bytes = [], length2 = key2.length, index2 = 0, code;
          for (i = 0; i < length2; ++i) {
            code = key2.charCodeAt(i);
            if (code < 128) {
              bytes[index2++] = code;
            } else if (code < 2048) {
              bytes[index2++] = 192 | code >>> 6;
              bytes[index2++] = 128 | code & 63;
            } else if (code < 55296 || code >= 57344) {
              bytes[index2++] = 224 | code >>> 12;
              bytes[index2++] = 128 | code >>> 6 & 63;
              bytes[index2++] = 128 | code & 63;
            } else {
              code = 65536 + ((code & 1023) << 10 | key2.charCodeAt(++i) & 1023);
              bytes[index2++] = 240 | code >>> 18;
              bytes[index2++] = 128 | code >>> 12 & 63;
              bytes[index2++] = 128 | code >>> 6 & 63;
              bytes[index2++] = 128 | code & 63;
            }
          }
          key2 = bytes;
        } else {
          if (type === "object") {
            if (key2 === null) {
              throw new Error(ERROR);
            } else if (ARRAY_BUFFER && key2.constructor === ArrayBuffer) {
              key2 = new Uint8Array(key2);
            } else if (!Array.isArray(key2)) {
              if (!ARRAY_BUFFER || !ArrayBuffer.isView(key2)) {
                throw new Error(ERROR);
              }
            }
          } else {
            throw new Error(ERROR);
          }
        }
        if (key2.length > 64) {
          key2 = new Sha256(is224, true).update(key2).array();
        }
        var oKeyPad = [], iKeyPad = [];
        for (i = 0; i < 64; ++i) {
          var b = key2[i] || 0;
          oKeyPad[i] = 92 ^ b;
          iKeyPad[i] = 54 ^ b;
        }
        Sha256.call(this, is224, sharedMemory);
        this.update(iKeyPad);
        this.oKeyPad = oKeyPad;
        this.inner = true;
        this.sharedMemory = sharedMemory;
      }
      HmacSha256.prototype = new Sha256();
      HmacSha256.prototype.finalize = function() {
        Sha256.prototype.finalize.call(this);
        if (this.inner) {
          this.inner = false;
          var innerHash = this.array();
          Sha256.call(this, this.is224, this.sharedMemory);
          this.update(this.oKeyPad);
          this.update(innerHash);
          Sha256.prototype.finalize.call(this);
        }
      };
      var exports3 = createMethod();
      exports3.sha256 = exports3;
      exports3.sha224 = createMethod(true);
      exports3.sha256.hmac = createHmacMethod();
      exports3.sha224.hmac = createHmacMethod(true);
      if (COMMON_JS) {
        module2.exports = exports3;
      } else {
        root.sha256 = exports3.sha256;
        root.sha224 = exports3.sha224;
        if (AMD) {
          define(function() {
            return exports3;
          });
        }
      }
    })();
  }
});

// node_modules/js-sha1/src/sha1.js
var require_sha1 = __commonJS({
  "node_modules/js-sha1/src/sha1.js"(exports2, module2) {
    (function() {
      "use strict";
      var INPUT_ERROR = "input is invalid type";
      var FINALIZE_ERROR = "finalize already called";
      var WINDOW = typeof window === "object";
      var root = WINDOW ? window : {};
      if (root.JS_SHA1_NO_WINDOW) {
        WINDOW = false;
      }
      var WEB_WORKER = !WINDOW && typeof self === "object";
      var NODE_JS = !root.JS_SHA1_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
      if (NODE_JS) {
        root = globalThis;
      } else if (WEB_WORKER) {
        root = self;
      }
      var COMMON_JS = !root.JS_SHA1_NO_COMMON_JS && typeof module2 === "object" && module2.exports;
      var AMD = typeof define === "function" && define.amd;
      var ARRAY_BUFFER = !root.JS_SHA1_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
      var HEX_CHARS = "0123456789abcdef".split("");
      var EXTRA = [-2147483648, 8388608, 32768, 128];
      var SHIFT = [24, 16, 8, 0];
      var OUTPUT_TYPES = ["hex", "array", "digest", "arrayBuffer"];
      var blocks = [];
      var isArray = Array.isArray;
      if (root.JS_SHA1_NO_NODE_JS || !isArray) {
        isArray = function(obj) {
          return Object.prototype.toString.call(obj) === "[object Array]";
        };
      }
      var isView3 = ArrayBuffer.isView;
      if (ARRAY_BUFFER && (root.JS_SHA1_NO_ARRAY_BUFFER_IS_VIEW || !isView3)) {
        isView3 = function(obj) {
          return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
        };
      }
      var formatMessage = function(message) {
        var type = typeof message;
        if (type === "string") {
          return [message, true];
        }
        if (type !== "object" || message === null) {
          throw new Error(INPUT_ERROR);
        }
        if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
          return [new Uint8Array(message), false];
        }
        if (!isArray(message) && !isView3(message)) {
          throw new Error(INPUT_ERROR);
        }
        return [message, false];
      };
      var createOutputMethod = function(outputType) {
        return function(message) {
          return new Sha1(true).update(message)[outputType]();
        };
      };
      var createMethod = function() {
        var method = createOutputMethod("hex");
        if (NODE_JS) {
          method = nodeWrap(method);
        }
        method.create = function() {
          return new Sha1();
        };
        method.update = function(message) {
          return method.create().update(message);
        };
        for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
          var type = OUTPUT_TYPES[i];
          method[type] = createOutputMethod(type);
        }
        return method;
      };
      var nodeWrap = function(method) {
        var crypto2 = require_crypto_browserify();
        var Buffer2 = require_buffer().Buffer;
        var bufferFrom;
        if (Buffer2.from && !root.JS_SHA1_NO_BUFFER_FROM) {
          bufferFrom = Buffer2.from;
        } else {
          bufferFrom = function(message) {
            return new Buffer2(message);
          };
        }
        var nodeMethod = function(message) {
          if (typeof message === "string") {
            return crypto2.createHash("sha1").update(message, "utf8").digest("hex");
          } else {
            if (message === null || message === void 0) {
              throw new Error(INPUT_ERROR);
            } else if (message.constructor === ArrayBuffer) {
              message = new Uint8Array(message);
            }
          }
          if (isArray(message) || isView3(message) || message.constructor === Buffer2) {
            return crypto2.createHash("sha1").update(bufferFrom(message)).digest("hex");
          } else {
            return method(message);
          }
        };
        return nodeMethod;
      };
      var createHmacOutputMethod = function(outputType) {
        return function(key2, message) {
          return new HmacSha1(key2, true).update(message)[outputType]();
        };
      };
      var createHmacMethod = function() {
        var method = createHmacOutputMethod("hex");
        method.create = function(key2) {
          return new HmacSha1(key2);
        };
        method.update = function(key2, message) {
          return method.create(key2).update(message);
        };
        for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
          var type = OUTPUT_TYPES[i];
          method[type] = createHmacOutputMethod(type);
        }
        return method;
      };
      function Sha1(sharedMemory) {
        if (sharedMemory) {
          blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
          this.blocks = blocks;
        } else {
          this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        }
        this.h0 = 1732584193;
        this.h1 = 4023233417;
        this.h2 = 2562383102;
        this.h3 = 271733878;
        this.h4 = 3285377520;
        this.block = this.start = this.bytes = this.hBytes = 0;
        this.finalized = this.hashed = false;
        this.first = true;
      }
      Sha1.prototype.update = function(message) {
        if (this.finalized) {
          throw new Error(FINALIZE_ERROR);
        }
        var result = formatMessage(message);
        message = result[0];
        var isString = result[1];
        var code, index2 = 0, i, length2 = message.length || 0, blocks2 = this.blocks;
        while (index2 < length2) {
          if (this.hashed) {
            this.hashed = false;
            blocks2[0] = this.block;
            this.block = blocks2[16] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = 0;
          }
          if (isString) {
            for (i = this.start; index2 < length2 && i < 64; ++index2) {
              code = message.charCodeAt(index2);
              if (code < 128) {
                blocks2[i >>> 2] |= code << SHIFT[i++ & 3];
              } else if (code < 2048) {
                blocks2[i >>> 2] |= (192 | code >>> 6) << SHIFT[i++ & 3];
                blocks2[i >>> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
              } else if (code < 55296 || code >= 57344) {
                blocks2[i >>> 2] |= (224 | code >>> 12) << SHIFT[i++ & 3];
                blocks2[i >>> 2] |= (128 | code >>> 6 & 63) << SHIFT[i++ & 3];
                blocks2[i >>> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
              } else {
                code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index2) & 1023);
                blocks2[i >>> 2] |= (240 | code >>> 18) << SHIFT[i++ & 3];
                blocks2[i >>> 2] |= (128 | code >>> 12 & 63) << SHIFT[i++ & 3];
                blocks2[i >>> 2] |= (128 | code >>> 6 & 63) << SHIFT[i++ & 3];
                blocks2[i >>> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
              }
            }
          } else {
            for (i = this.start; index2 < length2 && i < 64; ++index2) {
              blocks2[i >>> 2] |= message[index2] << SHIFT[i++ & 3];
            }
          }
          this.lastByteIndex = i;
          this.bytes += i - this.start;
          if (i >= 64) {
            this.block = blocks2[16];
            this.start = i - 64;
            this.hash();
            this.hashed = true;
          } else {
            this.start = i;
          }
        }
        if (this.bytes > 4294967295) {
          this.hBytes += this.bytes / 4294967296 << 0;
          this.bytes = this.bytes % 4294967296;
        }
        return this;
      };
      Sha1.prototype.finalize = function() {
        if (this.finalized) {
          return;
        }
        this.finalized = true;
        var blocks2 = this.blocks, i = this.lastByteIndex;
        blocks2[16] = this.block;
        blocks2[i >>> 2] |= EXTRA[i & 3];
        this.block = blocks2[16];
        if (i >= 56) {
          if (!this.hashed) {
            this.hash();
          }
          blocks2[0] = this.block;
          blocks2[16] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = 0;
        }
        blocks2[14] = this.hBytes << 3 | this.bytes >>> 29;
        blocks2[15] = this.bytes << 3;
        this.hash();
      };
      Sha1.prototype.hash = function() {
        var a = this.h0, b = this.h1, c = this.h2, d = this.h3, e = this.h4;
        var f3, j, t, blocks2 = this.blocks;
        for (j = 16; j < 80; ++j) {
          t = blocks2[j - 3] ^ blocks2[j - 8] ^ blocks2[j - 14] ^ blocks2[j - 16];
          blocks2[j] = t << 1 | t >>> 31;
        }
        for (j = 0; j < 20; j += 5) {
          f3 = b & c | ~b & d;
          t = a << 5 | a >>> 27;
          e = t + f3 + e + 1518500249 + blocks2[j] << 0;
          b = b << 30 | b >>> 2;
          f3 = a & b | ~a & c;
          t = e << 5 | e >>> 27;
          d = t + f3 + d + 1518500249 + blocks2[j + 1] << 0;
          a = a << 30 | a >>> 2;
          f3 = e & a | ~e & b;
          t = d << 5 | d >>> 27;
          c = t + f3 + c + 1518500249 + blocks2[j + 2] << 0;
          e = e << 30 | e >>> 2;
          f3 = d & e | ~d & a;
          t = c << 5 | c >>> 27;
          b = t + f3 + b + 1518500249 + blocks2[j + 3] << 0;
          d = d << 30 | d >>> 2;
          f3 = c & d | ~c & e;
          t = b << 5 | b >>> 27;
          a = t + f3 + a + 1518500249 + blocks2[j + 4] << 0;
          c = c << 30 | c >>> 2;
        }
        for (; j < 40; j += 5) {
          f3 = b ^ c ^ d;
          t = a << 5 | a >>> 27;
          e = t + f3 + e + 1859775393 + blocks2[j] << 0;
          b = b << 30 | b >>> 2;
          f3 = a ^ b ^ c;
          t = e << 5 | e >>> 27;
          d = t + f3 + d + 1859775393 + blocks2[j + 1] << 0;
          a = a << 30 | a >>> 2;
          f3 = e ^ a ^ b;
          t = d << 5 | d >>> 27;
          c = t + f3 + c + 1859775393 + blocks2[j + 2] << 0;
          e = e << 30 | e >>> 2;
          f3 = d ^ e ^ a;
          t = c << 5 | c >>> 27;
          b = t + f3 + b + 1859775393 + blocks2[j + 3] << 0;
          d = d << 30 | d >>> 2;
          f3 = c ^ d ^ e;
          t = b << 5 | b >>> 27;
          a = t + f3 + a + 1859775393 + blocks2[j + 4] << 0;
          c = c << 30 | c >>> 2;
        }
        for (; j < 60; j += 5) {
          f3 = b & c | b & d | c & d;
          t = a << 5 | a >>> 27;
          e = t + f3 + e - 1894007588 + blocks2[j] << 0;
          b = b << 30 | b >>> 2;
          f3 = a & b | a & c | b & c;
          t = e << 5 | e >>> 27;
          d = t + f3 + d - 1894007588 + blocks2[j + 1] << 0;
          a = a << 30 | a >>> 2;
          f3 = e & a | e & b | a & b;
          t = d << 5 | d >>> 27;
          c = t + f3 + c - 1894007588 + blocks2[j + 2] << 0;
          e = e << 30 | e >>> 2;
          f3 = d & e | d & a | e & a;
          t = c << 5 | c >>> 27;
          b = t + f3 + b - 1894007588 + blocks2[j + 3] << 0;
          d = d << 30 | d >>> 2;
          f3 = c & d | c & e | d & e;
          t = b << 5 | b >>> 27;
          a = t + f3 + a - 1894007588 + blocks2[j + 4] << 0;
          c = c << 30 | c >>> 2;
        }
        for (; j < 80; j += 5) {
          f3 = b ^ c ^ d;
          t = a << 5 | a >>> 27;
          e = t + f3 + e - 899497514 + blocks2[j] << 0;
          b = b << 30 | b >>> 2;
          f3 = a ^ b ^ c;
          t = e << 5 | e >>> 27;
          d = t + f3 + d - 899497514 + blocks2[j + 1] << 0;
          a = a << 30 | a >>> 2;
          f3 = e ^ a ^ b;
          t = d << 5 | d >>> 27;
          c = t + f3 + c - 899497514 + blocks2[j + 2] << 0;
          e = e << 30 | e >>> 2;
          f3 = d ^ e ^ a;
          t = c << 5 | c >>> 27;
          b = t + f3 + b - 899497514 + blocks2[j + 3] << 0;
          d = d << 30 | d >>> 2;
          f3 = c ^ d ^ e;
          t = b << 5 | b >>> 27;
          a = t + f3 + a - 899497514 + blocks2[j + 4] << 0;
          c = c << 30 | c >>> 2;
        }
        this.h0 = this.h0 + a << 0;
        this.h1 = this.h1 + b << 0;
        this.h2 = this.h2 + c << 0;
        this.h3 = this.h3 + d << 0;
        this.h4 = this.h4 + e << 0;
      };
      Sha1.prototype.hex = function() {
        this.finalize();
        var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4;
        return HEX_CHARS[h0 >>> 28 & 15] + HEX_CHARS[h0 >>> 24 & 15] + HEX_CHARS[h0 >>> 20 & 15] + HEX_CHARS[h0 >>> 16 & 15] + HEX_CHARS[h0 >>> 12 & 15] + HEX_CHARS[h0 >>> 8 & 15] + HEX_CHARS[h0 >>> 4 & 15] + HEX_CHARS[h0 & 15] + HEX_CHARS[h1 >>> 28 & 15] + HEX_CHARS[h1 >>> 24 & 15] + HEX_CHARS[h1 >>> 20 & 15] + HEX_CHARS[h1 >>> 16 & 15] + HEX_CHARS[h1 >>> 12 & 15] + HEX_CHARS[h1 >>> 8 & 15] + HEX_CHARS[h1 >>> 4 & 15] + HEX_CHARS[h1 & 15] + HEX_CHARS[h2 >>> 28 & 15] + HEX_CHARS[h2 >>> 24 & 15] + HEX_CHARS[h2 >>> 20 & 15] + HEX_CHARS[h2 >>> 16 & 15] + HEX_CHARS[h2 >>> 12 & 15] + HEX_CHARS[h2 >>> 8 & 15] + HEX_CHARS[h2 >>> 4 & 15] + HEX_CHARS[h2 & 15] + HEX_CHARS[h3 >>> 28 & 15] + HEX_CHARS[h3 >>> 24 & 15] + HEX_CHARS[h3 >>> 20 & 15] + HEX_CHARS[h3 >>> 16 & 15] + HEX_CHARS[h3 >>> 12 & 15] + HEX_CHARS[h3 >>> 8 & 15] + HEX_CHARS[h3 >>> 4 & 15] + HEX_CHARS[h3 & 15] + HEX_CHARS[h4 >>> 28 & 15] + HEX_CHARS[h4 >>> 24 & 15] + HEX_CHARS[h4 >>> 20 & 15] + HEX_CHARS[h4 >>> 16 & 15] + HEX_CHARS[h4 >>> 12 & 15] + HEX_CHARS[h4 >>> 8 & 15] + HEX_CHARS[h4 >>> 4 & 15] + HEX_CHARS[h4 & 15];
      };
      Sha1.prototype.toString = Sha1.prototype.hex;
      Sha1.prototype.digest = function() {
        this.finalize();
        var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4;
        return [
          h0 >>> 24 & 255,
          h0 >>> 16 & 255,
          h0 >>> 8 & 255,
          h0 & 255,
          h1 >>> 24 & 255,
          h1 >>> 16 & 255,
          h1 >>> 8 & 255,
          h1 & 255,
          h2 >>> 24 & 255,
          h2 >>> 16 & 255,
          h2 >>> 8 & 255,
          h2 & 255,
          h3 >>> 24 & 255,
          h3 >>> 16 & 255,
          h3 >>> 8 & 255,
          h3 & 255,
          h4 >>> 24 & 255,
          h4 >>> 16 & 255,
          h4 >>> 8 & 255,
          h4 & 255
        ];
      };
      Sha1.prototype.array = Sha1.prototype.digest;
      Sha1.prototype.arrayBuffer = function() {
        this.finalize();
        var buffer = new ArrayBuffer(20);
        var dataView = new DataView(buffer);
        dataView.setUint32(0, this.h0);
        dataView.setUint32(4, this.h1);
        dataView.setUint32(8, this.h2);
        dataView.setUint32(12, this.h3);
        dataView.setUint32(16, this.h4);
        return buffer;
      };
      function HmacSha1(key2, sharedMemory) {
        var i, result = formatMessage(key2);
        key2 = result[0];
        if (result[1]) {
          var bytes = [], length2 = key2.length, index2 = 0, code;
          for (i = 0; i < length2; ++i) {
            code = key2.charCodeAt(i);
            if (code < 128) {
              bytes[index2++] = code;
            } else if (code < 2048) {
              bytes[index2++] = 192 | code >>> 6;
              bytes[index2++] = 128 | code & 63;
            } else if (code < 55296 || code >= 57344) {
              bytes[index2++] = 224 | code >>> 12;
              bytes[index2++] = 128 | code >>> 6 & 63;
              bytes[index2++] = 128 | code & 63;
            } else {
              code = 65536 + ((code & 1023) << 10 | key2.charCodeAt(++i) & 1023);
              bytes[index2++] = 240 | code >>> 18;
              bytes[index2++] = 128 | code >>> 12 & 63;
              bytes[index2++] = 128 | code >>> 6 & 63;
              bytes[index2++] = 128 | code & 63;
            }
          }
          key2 = bytes;
        }
        if (key2.length > 64) {
          key2 = new Sha1(true).update(key2).array();
        }
        var oKeyPad = [], iKeyPad = [];
        for (i = 0; i < 64; ++i) {
          var b = key2[i] || 0;
          oKeyPad[i] = 92 ^ b;
          iKeyPad[i] = 54 ^ b;
        }
        Sha1.call(this, sharedMemory);
        this.update(iKeyPad);
        this.oKeyPad = oKeyPad;
        this.inner = true;
        this.sharedMemory = sharedMemory;
      }
      HmacSha1.prototype = new Sha1();
      HmacSha1.prototype.finalize = function() {
        Sha1.prototype.finalize.call(this);
        if (this.inner) {
          this.inner = false;
          var innerHash = this.array();
          Sha1.call(this, this.sharedMemory);
          this.update(this.oKeyPad);
          this.update(innerHash);
          Sha1.prototype.finalize.call(this);
        }
      };
      var exports3 = createMethod();
      exports3.sha1 = exports3;
      exports3.sha1.hmac = createHmacMethod();
      if (COMMON_JS) {
        module2.exports = exports3;
      } else {
        root.sha1 = exports3;
        if (AMD) {
          define(function() {
            return exports3;
          });
        }
      }
    })();
  }
});

// node_modules/js-sha512/src/sha512.js
var require_sha512 = __commonJS({
  "node_modules/js-sha512/src/sha512.js"(exports2, module2) {
    (function() {
      "use strict";
      var INPUT_ERROR = "input is invalid type";
      var FINALIZE_ERROR = "finalize already called";
      var WINDOW = typeof window === "object";
      var root = WINDOW ? window : {};
      if (root.JS_SHA512_NO_WINDOW) {
        WINDOW = false;
      }
      var WEB_WORKER = !WINDOW && typeof self === "object";
      var NODE_JS = !root.JS_SHA512_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
      if (NODE_JS) {
        root = globalThis;
      } else if (WEB_WORKER) {
        root = self;
      }
      var COMMON_JS = !root.JS_SHA512_NO_COMMON_JS && typeof module2 === "object" && module2.exports;
      var AMD = typeof define === "function" && define.amd;
      var ARRAY_BUFFER = !root.JS_SHA512_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
      var HEX_CHARS = "0123456789abcdef".split("");
      var EXTRA = [-2147483648, 8388608, 32768, 128];
      var SHIFT = [24, 16, 8, 0];
      var K = [
        1116352408,
        3609767458,
        1899447441,
        602891725,
        3049323471,
        3964484399,
        3921009573,
        2173295548,
        961987163,
        4081628472,
        1508970993,
        3053834265,
        2453635748,
        2937671579,
        2870763221,
        3664609560,
        3624381080,
        2734883394,
        310598401,
        1164996542,
        607225278,
        1323610764,
        1426881987,
        3590304994,
        1925078388,
        4068182383,
        2162078206,
        991336113,
        2614888103,
        633803317,
        3248222580,
        3479774868,
        3835390401,
        2666613458,
        4022224774,
        944711139,
        264347078,
        2341262773,
        604807628,
        2007800933,
        770255983,
        1495990901,
        1249150122,
        1856431235,
        1555081692,
        3175218132,
        1996064986,
        2198950837,
        2554220882,
        3999719339,
        2821834349,
        766784016,
        2952996808,
        2566594879,
        3210313671,
        3203337956,
        3336571891,
        1034457026,
        3584528711,
        2466948901,
        113926993,
        3758326383,
        338241895,
        168717936,
        666307205,
        1188179964,
        773529912,
        1546045734,
        1294757372,
        1522805485,
        1396182291,
        2643833823,
        1695183700,
        2343527390,
        1986661051,
        1014477480,
        2177026350,
        1206759142,
        2456956037,
        344077627,
        2730485921,
        1290863460,
        2820302411,
        3158454273,
        3259730800,
        3505952657,
        3345764771,
        106217008,
        3516065817,
        3606008344,
        3600352804,
        1432725776,
        4094571909,
        1467031594,
        275423344,
        851169720,
        430227734,
        3100823752,
        506948616,
        1363258195,
        659060556,
        3750685593,
        883997877,
        3785050280,
        958139571,
        3318307427,
        1322822218,
        3812723403,
        1537002063,
        2003034995,
        1747873779,
        3602036899,
        1955562222,
        1575990012,
        2024104815,
        1125592928,
        2227730452,
        2716904306,
        2361852424,
        442776044,
        2428436474,
        593698344,
        2756734187,
        3733110249,
        3204031479,
        2999351573,
        3329325298,
        3815920427,
        3391569614,
        3928383900,
        3515267271,
        566280711,
        3940187606,
        3454069534,
        4118630271,
        4000239992,
        116418474,
        1914138554,
        174292421,
        2731055270,
        289380356,
        3203993006,
        460393269,
        320620315,
        685471733,
        587496836,
        852142971,
        1086792851,
        1017036298,
        365543100,
        1126000580,
        2618297676,
        1288033470,
        3409855158,
        1501505948,
        4234509866,
        1607167915,
        987167468,
        1816402316,
        1246189591
      ];
      var OUTPUT_TYPES = ["hex", "array", "digest", "arrayBuffer"];
      var blocks = [];
      var isArray = Array.isArray;
      if (root.JS_SHA512_NO_NODE_JS || !isArray) {
        isArray = function(obj) {
          return Object.prototype.toString.call(obj) === "[object Array]";
        };
      }
      var isView3 = ArrayBuffer.isView;
      if (ARRAY_BUFFER && (root.JS_SHA512_NO_ARRAY_BUFFER_IS_VIEW || !isView3)) {
        isView3 = function(obj) {
          return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
        };
      }
      var formatMessage = function(message) {
        var type = typeof message;
        if (type === "string") {
          return [message, true];
        }
        if (type !== "object" || message === null) {
          throw new Error(INPUT_ERROR);
        }
        if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
          return [new Uint8Array(message), false];
        }
        if (!isArray(message) && !isView3(message)) {
          throw new Error(INPUT_ERROR);
        }
        return [message, false];
      };
      var createOutputMethod = function(outputType, bits) {
        return function(message) {
          return new Sha512(bits, true).update(message)[outputType]();
        };
      };
      var createMethod = function(bits) {
        var method = createOutputMethod("hex", bits);
        method.create = function() {
          return new Sha512(bits);
        };
        method.update = function(message) {
          return method.create().update(message);
        };
        for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
          var type = OUTPUT_TYPES[i];
          method[type] = createOutputMethod(type, bits);
        }
        return method;
      };
      var createHmacOutputMethod = function(outputType, bits) {
        return function(key2, message) {
          return new HmacSha512(key2, bits, true).update(message)[outputType]();
        };
      };
      var createHmacMethod = function(bits) {
        var method = createHmacOutputMethod("hex", bits);
        method.create = function(key2) {
          return new HmacSha512(key2, bits);
        };
        method.update = function(key2, message) {
          return method.create(key2).update(message);
        };
        for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
          var type = OUTPUT_TYPES[i];
          method[type] = createHmacOutputMethod(type, bits);
        }
        return method;
      };
      function Sha512(bits, sharedMemory) {
        if (sharedMemory) {
          blocks[0] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = blocks[16] = blocks[17] = blocks[18] = blocks[19] = blocks[20] = blocks[21] = blocks[22] = blocks[23] = blocks[24] = blocks[25] = blocks[26] = blocks[27] = blocks[28] = blocks[29] = blocks[30] = blocks[31] = blocks[32] = 0;
          this.blocks = blocks;
        } else {
          this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        }
        if (bits == 384) {
          this.h0h = 3418070365;
          this.h0l = 3238371032;
          this.h1h = 1654270250;
          this.h1l = 914150663;
          this.h2h = 2438529370;
          this.h2l = 812702999;
          this.h3h = 355462360;
          this.h3l = 4144912697;
          this.h4h = 1731405415;
          this.h4l = 4290775857;
          this.h5h = 2394180231;
          this.h5l = 1750603025;
          this.h6h = 3675008525;
          this.h6l = 1694076839;
          this.h7h = 1203062813;
          this.h7l = 3204075428;
        } else if (bits == 256) {
          this.h0h = 573645204;
          this.h0l = 4230739756;
          this.h1h = 2673172387;
          this.h1l = 3360449730;
          this.h2h = 596883563;
          this.h2l = 1867755857;
          this.h3h = 2520282905;
          this.h3l = 1497426621;
          this.h4h = 2519219938;
          this.h4l = 2827943907;
          this.h5h = 3193839141;
          this.h5l = 1401305490;
          this.h6h = 721525244;
          this.h6l = 746961066;
          this.h7h = 246885852;
          this.h7l = 2177182882;
        } else if (bits == 224) {
          this.h0h = 2352822216;
          this.h0l = 424955298;
          this.h1h = 1944164710;
          this.h1l = 2312950998;
          this.h2h = 502970286;
          this.h2l = 855612546;
          this.h3h = 1738396948;
          this.h3l = 1479516111;
          this.h4h = 258812777;
          this.h4l = 2077511080;
          this.h5h = 2011393907;
          this.h5l = 79989058;
          this.h6h = 1067287976;
          this.h6l = 1780299464;
          this.h7h = 286451373;
          this.h7l = 2446758561;
        } else {
          this.h0h = 1779033703;
          this.h0l = 4089235720;
          this.h1h = 3144134277;
          this.h1l = 2227873595;
          this.h2h = 1013904242;
          this.h2l = 4271175723;
          this.h3h = 2773480762;
          this.h3l = 1595750129;
          this.h4h = 1359893119;
          this.h4l = 2917565137;
          this.h5h = 2600822924;
          this.h5l = 725511199;
          this.h6h = 528734635;
          this.h6l = 4215389547;
          this.h7h = 1541459225;
          this.h7l = 327033209;
        }
        this.bits = bits;
        this.block = this.start = this.bytes = this.hBytes = 0;
        this.finalized = this.hashed = false;
      }
      Sha512.prototype.update = function(message) {
        if (this.finalized) {
          throw new Error(FINALIZE_ERROR);
        }
        var result = formatMessage(message);
        message = result[0];
        var isString = result[1];
        var code, index2 = 0, i, length2 = message.length, blocks2 = this.blocks;
        while (index2 < length2) {
          if (this.hashed) {
            this.hashed = false;
            blocks2[0] = this.block;
            this.block = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = blocks2[16] = blocks2[17] = blocks2[18] = blocks2[19] = blocks2[20] = blocks2[21] = blocks2[22] = blocks2[23] = blocks2[24] = blocks2[25] = blocks2[26] = blocks2[27] = blocks2[28] = blocks2[29] = blocks2[30] = blocks2[31] = blocks2[32] = 0;
          }
          if (isString) {
            for (i = this.start; index2 < length2 && i < 128; ++index2) {
              code = message.charCodeAt(index2);
              if (code < 128) {
                blocks2[i >>> 2] |= code << SHIFT[i++ & 3];
              } else if (code < 2048) {
                blocks2[i >>> 2] |= (192 | code >>> 6) << SHIFT[i++ & 3];
                blocks2[i >>> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
              } else if (code < 55296 || code >= 57344) {
                blocks2[i >>> 2] |= (224 | code >>> 12) << SHIFT[i++ & 3];
                blocks2[i >>> 2] |= (128 | code >>> 6 & 63) << SHIFT[i++ & 3];
                blocks2[i >>> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
              } else {
                code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index2) & 1023);
                blocks2[i >>> 2] |= (240 | code >>> 18) << SHIFT[i++ & 3];
                blocks2[i >>> 2] |= (128 | code >>> 12 & 63) << SHIFT[i++ & 3];
                blocks2[i >>> 2] |= (128 | code >>> 6 & 63) << SHIFT[i++ & 3];
                blocks2[i >>> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
              }
            }
          } else {
            for (i = this.start; index2 < length2 && i < 128; ++index2) {
              blocks2[i >>> 2] |= message[index2] << SHIFT[i++ & 3];
            }
          }
          this.lastByteIndex = i;
          this.bytes += i - this.start;
          if (i >= 128) {
            this.block = blocks2[32];
            this.start = i - 128;
            this.hash();
            this.hashed = true;
          } else {
            this.start = i;
          }
        }
        if (this.bytes > 4294967295) {
          this.hBytes += this.bytes / 4294967296 << 0;
          this.bytes = this.bytes % 4294967296;
        }
        return this;
      };
      Sha512.prototype.finalize = function() {
        if (this.finalized) {
          return;
        }
        this.finalized = true;
        var blocks2 = this.blocks, i = this.lastByteIndex;
        blocks2[32] = this.block;
        blocks2[i >>> 2] |= EXTRA[i & 3];
        this.block = blocks2[32];
        if (i >= 112) {
          if (!this.hashed) {
            this.hash();
          }
          blocks2[0] = this.block;
          blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = blocks2[16] = blocks2[17] = blocks2[18] = blocks2[19] = blocks2[20] = blocks2[21] = blocks2[22] = blocks2[23] = blocks2[24] = blocks2[25] = blocks2[26] = blocks2[27] = blocks2[28] = blocks2[29] = blocks2[30] = blocks2[31] = blocks2[32] = 0;
        }
        blocks2[30] = this.hBytes << 3 | this.bytes >>> 29;
        blocks2[31] = this.bytes << 3;
        this.hash();
      };
      Sha512.prototype.hash = function() {
        var h0h = this.h0h, h0l = this.h0l, h1h = this.h1h, h1l = this.h1l, h2h = this.h2h, h2l = this.h2l, h3h = this.h3h, h3l = this.h3l, h4h = this.h4h, h4l = this.h4l, h5h = this.h5h, h5l = this.h5l, h6h = this.h6h, h6l = this.h6l, h7h = this.h7h, h7l = this.h7l, blocks2 = this.blocks, j, s0h, s0l, s1h, s1l, c1, c2, c3, c4, abh, abl, dah, dal, cdh, cdl, bch, bcl, majh, majl, t1h, t1l, t2h, t2l, chh, chl;
        for (j = 32; j < 160; j += 2) {
          t1h = blocks2[j - 30];
          t1l = blocks2[j - 29];
          s0h = (t1h >>> 1 | t1l << 31) ^ (t1h >>> 8 | t1l << 24) ^ t1h >>> 7;
          s0l = (t1l >>> 1 | t1h << 31) ^ (t1l >>> 8 | t1h << 24) ^ (t1l >>> 7 | t1h << 25);
          t1h = blocks2[j - 4];
          t1l = blocks2[j - 3];
          s1h = (t1h >>> 19 | t1l << 13) ^ (t1l >>> 29 | t1h << 3) ^ t1h >>> 6;
          s1l = (t1l >>> 19 | t1h << 13) ^ (t1h >>> 29 | t1l << 3) ^ (t1l >>> 6 | t1h << 26);
          t1h = blocks2[j - 32];
          t1l = blocks2[j - 31];
          t2h = blocks2[j - 14];
          t2l = blocks2[j - 13];
          c1 = (t2l & 65535) + (t1l & 65535) + (s0l & 65535) + (s1l & 65535);
          c2 = (t2l >>> 16) + (t1l >>> 16) + (s0l >>> 16) + (s1l >>> 16) + (c1 >>> 16);
          c3 = (t2h & 65535) + (t1h & 65535) + (s0h & 65535) + (s1h & 65535) + (c2 >>> 16);
          c4 = (t2h >>> 16) + (t1h >>> 16) + (s0h >>> 16) + (s1h >>> 16) + (c3 >>> 16);
          blocks2[j] = c4 << 16 | c3 & 65535;
          blocks2[j + 1] = c2 << 16 | c1 & 65535;
        }
        var ah = h0h, al = h0l, bh = h1h, bl = h1l, ch = h2h, cl = h2l, dh = h3h, dl = h3l, eh = h4h, el = h4l, fh = h5h, fl = h5l, gh = h6h, gl = h6l, hh = h7h, hl = h7l;
        bch = bh & ch;
        bcl = bl & cl;
        for (j = 0; j < 160; j += 8) {
          s0h = (ah >>> 28 | al << 4) ^ (al >>> 2 | ah << 30) ^ (al >>> 7 | ah << 25);
          s0l = (al >>> 28 | ah << 4) ^ (ah >>> 2 | al << 30) ^ (ah >>> 7 | al << 25);
          s1h = (eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (el >>> 9 | eh << 23);
          s1l = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (eh >>> 9 | el << 23);
          abh = ah & bh;
          abl = al & bl;
          majh = abh ^ ah & ch ^ bch;
          majl = abl ^ al & cl ^ bcl;
          chh = eh & fh ^ ~eh & gh;
          chl = el & fl ^ ~el & gl;
          t1h = blocks2[j];
          t1l = blocks2[j + 1];
          t2h = K[j];
          t2l = K[j + 1];
          c1 = (t2l & 65535) + (t1l & 65535) + (chl & 65535) + (s1l & 65535) + (hl & 65535);
          c2 = (t2l >>> 16) + (t1l >>> 16) + (chl >>> 16) + (s1l >>> 16) + (hl >>> 16) + (c1 >>> 16);
          c3 = (t2h & 65535) + (t1h & 65535) + (chh & 65535) + (s1h & 65535) + (hh & 65535) + (c2 >>> 16);
          c4 = (t2h >>> 16) + (t1h >>> 16) + (chh >>> 16) + (s1h >>> 16) + (hh >>> 16) + (c3 >>> 16);
          t1h = c4 << 16 | c3 & 65535;
          t1l = c2 << 16 | c1 & 65535;
          c1 = (majl & 65535) + (s0l & 65535);
          c2 = (majl >>> 16) + (s0l >>> 16) + (c1 >>> 16);
          c3 = (majh & 65535) + (s0h & 65535) + (c2 >>> 16);
          c4 = (majh >>> 16) + (s0h >>> 16) + (c3 >>> 16);
          t2h = c4 << 16 | c3 & 65535;
          t2l = c2 << 16 | c1 & 65535;
          c1 = (dl & 65535) + (t1l & 65535);
          c2 = (dl >>> 16) + (t1l >>> 16) + (c1 >>> 16);
          c3 = (dh & 65535) + (t1h & 65535) + (c2 >>> 16);
          c4 = (dh >>> 16) + (t1h >>> 16) + (c3 >>> 16);
          hh = c4 << 16 | c3 & 65535;
          hl = c2 << 16 | c1 & 65535;
          c1 = (t2l & 65535) + (t1l & 65535);
          c2 = (t2l >>> 16) + (t1l >>> 16) + (c1 >>> 16);
          c3 = (t2h & 65535) + (t1h & 65535) + (c2 >>> 16);
          c4 = (t2h >>> 16) + (t1h >>> 16) + (c3 >>> 16);
          dh = c4 << 16 | c3 & 65535;
          dl = c2 << 16 | c1 & 65535;
          s0h = (dh >>> 28 | dl << 4) ^ (dl >>> 2 | dh << 30) ^ (dl >>> 7 | dh << 25);
          s0l = (dl >>> 28 | dh << 4) ^ (dh >>> 2 | dl << 30) ^ (dh >>> 7 | dl << 25);
          s1h = (hh >>> 14 | hl << 18) ^ (hh >>> 18 | hl << 14) ^ (hl >>> 9 | hh << 23);
          s1l = (hl >>> 14 | hh << 18) ^ (hl >>> 18 | hh << 14) ^ (hh >>> 9 | hl << 23);
          dah = dh & ah;
          dal = dl & al;
          majh = dah ^ dh & bh ^ abh;
          majl = dal ^ dl & bl ^ abl;
          chh = hh & eh ^ ~hh & fh;
          chl = hl & el ^ ~hl & fl;
          t1h = blocks2[j + 2];
          t1l = blocks2[j + 3];
          t2h = K[j + 2];
          t2l = K[j + 3];
          c1 = (t2l & 65535) + (t1l & 65535) + (chl & 65535) + (s1l & 65535) + (gl & 65535);
          c2 = (t2l >>> 16) + (t1l >>> 16) + (chl >>> 16) + (s1l >>> 16) + (gl >>> 16) + (c1 >>> 16);
          c3 = (t2h & 65535) + (t1h & 65535) + (chh & 65535) + (s1h & 65535) + (gh & 65535) + (c2 >>> 16);
          c4 = (t2h >>> 16) + (t1h >>> 16) + (chh >>> 16) + (s1h >>> 16) + (gh >>> 16) + (c3 >>> 16);
          t1h = c4 << 16 | c3 & 65535;
          t1l = c2 << 16 | c1 & 65535;
          c1 = (majl & 65535) + (s0l & 65535);
          c2 = (majl >>> 16) + (s0l >>> 16) + (c1 >>> 16);
          c3 = (majh & 65535) + (s0h & 65535) + (c2 >>> 16);
          c4 = (majh >>> 16) + (s0h >>> 16) + (c3 >>> 16);
          t2h = c4 << 16 | c3 & 65535;
          t2l = c2 << 16 | c1 & 65535;
          c1 = (cl & 65535) + (t1l & 65535);
          c2 = (cl >>> 16) + (t1l >>> 16) + (c1 >>> 16);
          c3 = (ch & 65535) + (t1h & 65535) + (c2 >>> 16);
          c4 = (ch >>> 16) + (t1h >>> 16) + (c3 >>> 16);
          gh = c4 << 16 | c3 & 65535;
          gl = c2 << 16 | c1 & 65535;
          c1 = (t2l & 65535) + (t1l & 65535);
          c2 = (t2l >>> 16) + (t1l >>> 16) + (c1 >>> 16);
          c3 = (t2h & 65535) + (t1h & 65535) + (c2 >>> 16);
          c4 = (t2h >>> 16) + (t1h >>> 16) + (c3 >>> 16);
          ch = c4 << 16 | c3 & 65535;
          cl = c2 << 16 | c1 & 65535;
          s0h = (ch >>> 28 | cl << 4) ^ (cl >>> 2 | ch << 30) ^ (cl >>> 7 | ch << 25);
          s0l = (cl >>> 28 | ch << 4) ^ (ch >>> 2 | cl << 30) ^ (ch >>> 7 | cl << 25);
          s1h = (gh >>> 14 | gl << 18) ^ (gh >>> 18 | gl << 14) ^ (gl >>> 9 | gh << 23);
          s1l = (gl >>> 14 | gh << 18) ^ (gl >>> 18 | gh << 14) ^ (gh >>> 9 | gl << 23);
          cdh = ch & dh;
          cdl = cl & dl;
          majh = cdh ^ ch & ah ^ dah;
          majl = cdl ^ cl & al ^ dal;
          chh = gh & hh ^ ~gh & eh;
          chl = gl & hl ^ ~gl & el;
          t1h = blocks2[j + 4];
          t1l = blocks2[j + 5];
          t2h = K[j + 4];
          t2l = K[j + 5];
          c1 = (t2l & 65535) + (t1l & 65535) + (chl & 65535) + (s1l & 65535) + (fl & 65535);
          c2 = (t2l >>> 16) + (t1l >>> 16) + (chl >>> 16) + (s1l >>> 16) + (fl >>> 16) + (c1 >>> 16);
          c3 = (t2h & 65535) + (t1h & 65535) + (chh & 65535) + (s1h & 65535) + (fh & 65535) + (c2 >>> 16);
          c4 = (t2h >>> 16) + (t1h >>> 16) + (chh >>> 16) + (s1h >>> 16) + (fh >>> 16) + (c3 >>> 16);
          t1h = c4 << 16 | c3 & 65535;
          t1l = c2 << 16 | c1 & 65535;
          c1 = (majl & 65535) + (s0l & 65535);
          c2 = (majl >>> 16) + (s0l >>> 16) + (c1 >>> 16);
          c3 = (majh & 65535) + (s0h & 65535) + (c2 >>> 16);
          c4 = (majh >>> 16) + (s0h >>> 16) + (c3 >>> 16);
          t2h = c4 << 16 | c3 & 65535;
          t2l = c2 << 16 | c1 & 65535;
          c1 = (bl & 65535) + (t1l & 65535);
          c2 = (bl >>> 16) + (t1l >>> 16) + (c1 >>> 16);
          c3 = (bh & 65535) + (t1h & 65535) + (c2 >>> 16);
          c4 = (bh >>> 16) + (t1h >>> 16) + (c3 >>> 16);
          fh = c4 << 16 | c3 & 65535;
          fl = c2 << 16 | c1 & 65535;
          c1 = (t2l & 65535) + (t1l & 65535);
          c2 = (t2l >>> 16) + (t1l >>> 16) + (c1 >>> 16);
          c3 = (t2h & 65535) + (t1h & 65535) + (c2 >>> 16);
          c4 = (t2h >>> 16) + (t1h >>> 16) + (c3 >>> 16);
          bh = c4 << 16 | c3 & 65535;
          bl = c2 << 16 | c1 & 65535;
          s0h = (bh >>> 28 | bl << 4) ^ (bl >>> 2 | bh << 30) ^ (bl >>> 7 | bh << 25);
          s0l = (bl >>> 28 | bh << 4) ^ (bh >>> 2 | bl << 30) ^ (bh >>> 7 | bl << 25);
          s1h = (fh >>> 14 | fl << 18) ^ (fh >>> 18 | fl << 14) ^ (fl >>> 9 | fh << 23);
          s1l = (fl >>> 14 | fh << 18) ^ (fl >>> 18 | fh << 14) ^ (fh >>> 9 | fl << 23);
          bch = bh & ch;
          bcl = bl & cl;
          majh = bch ^ bh & dh ^ cdh;
          majl = bcl ^ bl & dl ^ cdl;
          chh = fh & gh ^ ~fh & hh;
          chl = fl & gl ^ ~fl & hl;
          t1h = blocks2[j + 6];
          t1l = blocks2[j + 7];
          t2h = K[j + 6];
          t2l = K[j + 7];
          c1 = (t2l & 65535) + (t1l & 65535) + (chl & 65535) + (s1l & 65535) + (el & 65535);
          c2 = (t2l >>> 16) + (t1l >>> 16) + (chl >>> 16) + (s1l >>> 16) + (el >>> 16) + (c1 >>> 16);
          c3 = (t2h & 65535) + (t1h & 65535) + (chh & 65535) + (s1h & 65535) + (eh & 65535) + (c2 >>> 16);
          c4 = (t2h >>> 16) + (t1h >>> 16) + (chh >>> 16) + (s1h >>> 16) + (eh >>> 16) + (c3 >>> 16);
          t1h = c4 << 16 | c3 & 65535;
          t1l = c2 << 16 | c1 & 65535;
          c1 = (majl & 65535) + (s0l & 65535);
          c2 = (majl >>> 16) + (s0l >>> 16) + (c1 >>> 16);
          c3 = (majh & 65535) + (s0h & 65535) + (c2 >>> 16);
          c4 = (majh >>> 16) + (s0h >>> 16) + (c3 >>> 16);
          t2h = c4 << 16 | c3 & 65535;
          t2l = c2 << 16 | c1 & 65535;
          c1 = (al & 65535) + (t1l & 65535);
          c2 = (al >>> 16) + (t1l >>> 16) + (c1 >>> 16);
          c3 = (ah & 65535) + (t1h & 65535) + (c2 >>> 16);
          c4 = (ah >>> 16) + (t1h >>> 16) + (c3 >>> 16);
          eh = c4 << 16 | c3 & 65535;
          el = c2 << 16 | c1 & 65535;
          c1 = (t2l & 65535) + (t1l & 65535);
          c2 = (t2l >>> 16) + (t1l >>> 16) + (c1 >>> 16);
          c3 = (t2h & 65535) + (t1h & 65535) + (c2 >>> 16);
          c4 = (t2h >>> 16) + (t1h >>> 16) + (c3 >>> 16);
          ah = c4 << 16 | c3 & 65535;
          al = c2 << 16 | c1 & 65535;
        }
        c1 = (h0l & 65535) + (al & 65535);
        c2 = (h0l >>> 16) + (al >>> 16) + (c1 >>> 16);
        c3 = (h0h & 65535) + (ah & 65535) + (c2 >>> 16);
        c4 = (h0h >>> 16) + (ah >>> 16) + (c3 >>> 16);
        this.h0h = c4 << 16 | c3 & 65535;
        this.h0l = c2 << 16 | c1 & 65535;
        c1 = (h1l & 65535) + (bl & 65535);
        c2 = (h1l >>> 16) + (bl >>> 16) + (c1 >>> 16);
        c3 = (h1h & 65535) + (bh & 65535) + (c2 >>> 16);
        c4 = (h1h >>> 16) + (bh >>> 16) + (c3 >>> 16);
        this.h1h = c4 << 16 | c3 & 65535;
        this.h1l = c2 << 16 | c1 & 65535;
        c1 = (h2l & 65535) + (cl & 65535);
        c2 = (h2l >>> 16) + (cl >>> 16) + (c1 >>> 16);
        c3 = (h2h & 65535) + (ch & 65535) + (c2 >>> 16);
        c4 = (h2h >>> 16) + (ch >>> 16) + (c3 >>> 16);
        this.h2h = c4 << 16 | c3 & 65535;
        this.h2l = c2 << 16 | c1 & 65535;
        c1 = (h3l & 65535) + (dl & 65535);
        c2 = (h3l >>> 16) + (dl >>> 16) + (c1 >>> 16);
        c3 = (h3h & 65535) + (dh & 65535) + (c2 >>> 16);
        c4 = (h3h >>> 16) + (dh >>> 16) + (c3 >>> 16);
        this.h3h = c4 << 16 | c3 & 65535;
        this.h3l = c2 << 16 | c1 & 65535;
        c1 = (h4l & 65535) + (el & 65535);
        c2 = (h4l >>> 16) + (el >>> 16) + (c1 >>> 16);
        c3 = (h4h & 65535) + (eh & 65535) + (c2 >>> 16);
        c4 = (h4h >>> 16) + (eh >>> 16) + (c3 >>> 16);
        this.h4h = c4 << 16 | c3 & 65535;
        this.h4l = c2 << 16 | c1 & 65535;
        c1 = (h5l & 65535) + (fl & 65535);
        c2 = (h5l >>> 16) + (fl >>> 16) + (c1 >>> 16);
        c3 = (h5h & 65535) + (fh & 65535) + (c2 >>> 16);
        c4 = (h5h >>> 16) + (fh >>> 16) + (c3 >>> 16);
        this.h5h = c4 << 16 | c3 & 65535;
        this.h5l = c2 << 16 | c1 & 65535;
        c1 = (h6l & 65535) + (gl & 65535);
        c2 = (h6l >>> 16) + (gl >>> 16) + (c1 >>> 16);
        c3 = (h6h & 65535) + (gh & 65535) + (c2 >>> 16);
        c4 = (h6h >>> 16) + (gh >>> 16) + (c3 >>> 16);
        this.h6h = c4 << 16 | c3 & 65535;
        this.h6l = c2 << 16 | c1 & 65535;
        c1 = (h7l & 65535) + (hl & 65535);
        c2 = (h7l >>> 16) + (hl >>> 16) + (c1 >>> 16);
        c3 = (h7h & 65535) + (hh & 65535) + (c2 >>> 16);
        c4 = (h7h >>> 16) + (hh >>> 16) + (c3 >>> 16);
        this.h7h = c4 << 16 | c3 & 65535;
        this.h7l = c2 << 16 | c1 & 65535;
      };
      Sha512.prototype.hex = function() {
        this.finalize();
        var h0h = this.h0h, h0l = this.h0l, h1h = this.h1h, h1l = this.h1l, h2h = this.h2h, h2l = this.h2l, h3h = this.h3h, h3l = this.h3l, h4h = this.h4h, h4l = this.h4l, h5h = this.h5h, h5l = this.h5l, h6h = this.h6h, h6l = this.h6l, h7h = this.h7h, h7l = this.h7l, bits = this.bits;
        var hex = HEX_CHARS[h0h >>> 28 & 15] + HEX_CHARS[h0h >>> 24 & 15] + HEX_CHARS[h0h >>> 20 & 15] + HEX_CHARS[h0h >>> 16 & 15] + HEX_CHARS[h0h >>> 12 & 15] + HEX_CHARS[h0h >>> 8 & 15] + HEX_CHARS[h0h >>> 4 & 15] + HEX_CHARS[h0h & 15] + HEX_CHARS[h0l >>> 28 & 15] + HEX_CHARS[h0l >>> 24 & 15] + HEX_CHARS[h0l >>> 20 & 15] + HEX_CHARS[h0l >>> 16 & 15] + HEX_CHARS[h0l >>> 12 & 15] + HEX_CHARS[h0l >>> 8 & 15] + HEX_CHARS[h0l >>> 4 & 15] + HEX_CHARS[h0l & 15] + HEX_CHARS[h1h >>> 28 & 15] + HEX_CHARS[h1h >>> 24 & 15] + HEX_CHARS[h1h >>> 20 & 15] + HEX_CHARS[h1h >>> 16 & 15] + HEX_CHARS[h1h >>> 12 & 15] + HEX_CHARS[h1h >>> 8 & 15] + HEX_CHARS[h1h >>> 4 & 15] + HEX_CHARS[h1h & 15] + HEX_CHARS[h1l >>> 28 & 15] + HEX_CHARS[h1l >>> 24 & 15] + HEX_CHARS[h1l >>> 20 & 15] + HEX_CHARS[h1l >>> 16 & 15] + HEX_CHARS[h1l >>> 12 & 15] + HEX_CHARS[h1l >>> 8 & 15] + HEX_CHARS[h1l >>> 4 & 15] + HEX_CHARS[h1l & 15] + HEX_CHARS[h2h >>> 28 & 15] + HEX_CHARS[h2h >>> 24 & 15] + HEX_CHARS[h2h >>> 20 & 15] + HEX_CHARS[h2h >>> 16 & 15] + HEX_CHARS[h2h >>> 12 & 15] + HEX_CHARS[h2h >>> 8 & 15] + HEX_CHARS[h2h >>> 4 & 15] + HEX_CHARS[h2h & 15] + HEX_CHARS[h2l >>> 28 & 15] + HEX_CHARS[h2l >>> 24 & 15] + HEX_CHARS[h2l >>> 20 & 15] + HEX_CHARS[h2l >>> 16 & 15] + HEX_CHARS[h2l >>> 12 & 15] + HEX_CHARS[h2l >>> 8 & 15] + HEX_CHARS[h2l >>> 4 & 15] + HEX_CHARS[h2l & 15] + HEX_CHARS[h3h >>> 28 & 15] + HEX_CHARS[h3h >>> 24 & 15] + HEX_CHARS[h3h >>> 20 & 15] + HEX_CHARS[h3h >>> 16 & 15] + HEX_CHARS[h3h >>> 12 & 15] + HEX_CHARS[h3h >>> 8 & 15] + HEX_CHARS[h3h >>> 4 & 15] + HEX_CHARS[h3h & 15];
        if (bits >= 256) {
          hex += HEX_CHARS[h3l >>> 28 & 15] + HEX_CHARS[h3l >>> 24 & 15] + HEX_CHARS[h3l >>> 20 & 15] + HEX_CHARS[h3l >>> 16 & 15] + HEX_CHARS[h3l >>> 12 & 15] + HEX_CHARS[h3l >>> 8 & 15] + HEX_CHARS[h3l >>> 4 & 15] + HEX_CHARS[h3l & 15];
        }
        if (bits >= 384) {
          hex += HEX_CHARS[h4h >>> 28 & 15] + HEX_CHARS[h4h >>> 24 & 15] + HEX_CHARS[h4h >>> 20 & 15] + HEX_CHARS[h4h >>> 16 & 15] + HEX_CHARS[h4h >>> 12 & 15] + HEX_CHARS[h4h >>> 8 & 15] + HEX_CHARS[h4h >>> 4 & 15] + HEX_CHARS[h4h & 15] + HEX_CHARS[h4l >>> 28 & 15] + HEX_CHARS[h4l >>> 24 & 15] + HEX_CHARS[h4l >>> 20 & 15] + HEX_CHARS[h4l >>> 16 & 15] + HEX_CHARS[h4l >>> 12 & 15] + HEX_CHARS[h4l >>> 8 & 15] + HEX_CHARS[h4l >>> 4 & 15] + HEX_CHARS[h4l & 15] + HEX_CHARS[h5h >>> 28 & 15] + HEX_CHARS[h5h >>> 24 & 15] + HEX_CHARS[h5h >>> 20 & 15] + HEX_CHARS[h5h >>> 16 & 15] + HEX_CHARS[h5h >>> 12 & 15] + HEX_CHARS[h5h >>> 8 & 15] + HEX_CHARS[h5h >>> 4 & 15] + HEX_CHARS[h5h & 15] + HEX_CHARS[h5l >>> 28 & 15] + HEX_CHARS[h5l >>> 24 & 15] + HEX_CHARS[h5l >>> 20 & 15] + HEX_CHARS[h5l >>> 16 & 15] + HEX_CHARS[h5l >>> 12 & 15] + HEX_CHARS[h5l >>> 8 & 15] + HEX_CHARS[h5l >>> 4 & 15] + HEX_CHARS[h5l & 15];
        }
        if (bits == 512) {
          hex += HEX_CHARS[h6h >>> 28 & 15] + HEX_CHARS[h6h >>> 24 & 15] + HEX_CHARS[h6h >>> 20 & 15] + HEX_CHARS[h6h >>> 16 & 15] + HEX_CHARS[h6h >>> 12 & 15] + HEX_CHARS[h6h >>> 8 & 15] + HEX_CHARS[h6h >>> 4 & 15] + HEX_CHARS[h6h & 15] + HEX_CHARS[h6l >>> 28 & 15] + HEX_CHARS[h6l >>> 24 & 15] + HEX_CHARS[h6l >>> 20 & 15] + HEX_CHARS[h6l >>> 16 & 15] + HEX_CHARS[h6l >>> 12 & 15] + HEX_CHARS[h6l >>> 8 & 15] + HEX_CHARS[h6l >>> 4 & 15] + HEX_CHARS[h6l & 15] + HEX_CHARS[h7h >>> 28 & 15] + HEX_CHARS[h7h >>> 24 & 15] + HEX_CHARS[h7h >>> 20 & 15] + HEX_CHARS[h7h >>> 16 & 15] + HEX_CHARS[h7h >>> 12 & 15] + HEX_CHARS[h7h >>> 8 & 15] + HEX_CHARS[h7h >>> 4 & 15] + HEX_CHARS[h7h & 15] + HEX_CHARS[h7l >>> 28 & 15] + HEX_CHARS[h7l >>> 24 & 15] + HEX_CHARS[h7l >>> 20 & 15] + HEX_CHARS[h7l >>> 16 & 15] + HEX_CHARS[h7l >>> 12 & 15] + HEX_CHARS[h7l >>> 8 & 15] + HEX_CHARS[h7l >>> 4 & 15] + HEX_CHARS[h7l & 15];
        }
        return hex;
      };
      Sha512.prototype.toString = Sha512.prototype.hex;
      Sha512.prototype.digest = function() {
        this.finalize();
        var h0h = this.h0h, h0l = this.h0l, h1h = this.h1h, h1l = this.h1l, h2h = this.h2h, h2l = this.h2l, h3h = this.h3h, h3l = this.h3l, h4h = this.h4h, h4l = this.h4l, h5h = this.h5h, h5l = this.h5l, h6h = this.h6h, h6l = this.h6l, h7h = this.h7h, h7l = this.h7l, bits = this.bits;
        var arr = [
          h0h >>> 24 & 255,
          h0h >>> 16 & 255,
          h0h >>> 8 & 255,
          h0h & 255,
          h0l >>> 24 & 255,
          h0l >>> 16 & 255,
          h0l >>> 8 & 255,
          h0l & 255,
          h1h >>> 24 & 255,
          h1h >>> 16 & 255,
          h1h >>> 8 & 255,
          h1h & 255,
          h1l >>> 24 & 255,
          h1l >>> 16 & 255,
          h1l >>> 8 & 255,
          h1l & 255,
          h2h >>> 24 & 255,
          h2h >>> 16 & 255,
          h2h >>> 8 & 255,
          h2h & 255,
          h2l >>> 24 & 255,
          h2l >>> 16 & 255,
          h2l >>> 8 & 255,
          h2l & 255,
          h3h >>> 24 & 255,
          h3h >>> 16 & 255,
          h3h >>> 8 & 255,
          h3h & 255
        ];
        if (bits >= 256) {
          arr.push(h3l >>> 24 & 255, h3l >>> 16 & 255, h3l >>> 8 & 255, h3l & 255);
        }
        if (bits >= 384) {
          arr.push(
            h4h >>> 24 & 255,
            h4h >>> 16 & 255,
            h4h >>> 8 & 255,
            h4h & 255,
            h4l >>> 24 & 255,
            h4l >>> 16 & 255,
            h4l >>> 8 & 255,
            h4l & 255,
            h5h >>> 24 & 255,
            h5h >>> 16 & 255,
            h5h >>> 8 & 255,
            h5h & 255,
            h5l >>> 24 & 255,
            h5l >>> 16 & 255,
            h5l >>> 8 & 255,
            h5l & 255
          );
        }
        if (bits == 512) {
          arr.push(
            h6h >>> 24 & 255,
            h6h >>> 16 & 255,
            h6h >>> 8 & 255,
            h6h & 255,
            h6l >>> 24 & 255,
            h6l >>> 16 & 255,
            h6l >>> 8 & 255,
            h6l & 255,
            h7h >>> 24 & 255,
            h7h >>> 16 & 255,
            h7h >>> 8 & 255,
            h7h & 255,
            h7l >>> 24 & 255,
            h7l >>> 16 & 255,
            h7l >>> 8 & 255,
            h7l & 255
          );
        }
        return arr;
      };
      Sha512.prototype.array = Sha512.prototype.digest;
      Sha512.prototype.arrayBuffer = function() {
        this.finalize();
        var bits = this.bits;
        var buffer = new ArrayBuffer(bits / 8);
        var dataView = new DataView(buffer);
        dataView.setUint32(0, this.h0h);
        dataView.setUint32(4, this.h0l);
        dataView.setUint32(8, this.h1h);
        dataView.setUint32(12, this.h1l);
        dataView.setUint32(16, this.h2h);
        dataView.setUint32(20, this.h2l);
        dataView.setUint32(24, this.h3h);
        if (bits >= 256) {
          dataView.setUint32(28, this.h3l);
        }
        if (bits >= 384) {
          dataView.setUint32(32, this.h4h);
          dataView.setUint32(36, this.h4l);
          dataView.setUint32(40, this.h5h);
          dataView.setUint32(44, this.h5l);
        }
        if (bits == 512) {
          dataView.setUint32(48, this.h6h);
          dataView.setUint32(52, this.h6l);
          dataView.setUint32(56, this.h7h);
          dataView.setUint32(60, this.h7l);
        }
        return buffer;
      };
      Sha512.prototype.clone = function() {
        var hash = new Sha512(this.bits, false);
        this.copyTo(hash);
        return hash;
      };
      Sha512.prototype.copyTo = function(hash) {
        var i = 0, attrs = [
          "h0h",
          "h0l",
          "h1h",
          "h1l",
          "h2h",
          "h2l",
          "h3h",
          "h3l",
          "h4h",
          "h4l",
          "h5h",
          "h5l",
          "h6h",
          "h6l",
          "h7h",
          "h7l",
          "start",
          "bytes",
          "hBytes",
          "finalized",
          "hashed",
          "lastByteIndex"
        ];
        for (i = 0; i < attrs.length; ++i) {
          hash[attrs[i]] = this[attrs[i]];
        }
        for (i = 0; i < this.blocks.length; ++i) {
          hash.blocks[i] = this.blocks[i];
        }
      };
      function HmacSha512(key2, bits, sharedMemory) {
        var i, result = formatMessage(key2);
        key2 = result[0];
        if (result[1]) {
          var bytes = [], length2 = key2.length, index2 = 0, code;
          for (var i = 0; i < length2; ++i) {
            code = key2.charCodeAt(i);
            if (code < 128) {
              bytes[index2++] = code;
            } else if (code < 2048) {
              bytes[index2++] = 192 | code >>> 6;
              bytes[index2++] = 128 | code & 63;
            } else if (code < 55296 || code >= 57344) {
              bytes[index2++] = 224 | code >>> 12;
              bytes[index2++] = 128 | code >>> 6 & 63;
              bytes[index2++] = 128 | code & 63;
            } else {
              code = 65536 + ((code & 1023) << 10 | key2.charCodeAt(++i) & 1023);
              bytes[index2++] = 240 | code >>> 18;
              bytes[index2++] = 128 | code >>> 12 & 63;
              bytes[index2++] = 128 | code >>> 6 & 63;
              bytes[index2++] = 128 | code & 63;
            }
          }
          key2 = bytes;
        }
        if (key2.length > 128) {
          key2 = new Sha512(bits, true).update(key2).array();
        }
        var oKeyPad = [], iKeyPad = [];
        for (var i = 0; i < 128; ++i) {
          var b = key2[i] || 0;
          oKeyPad[i] = 92 ^ b;
          iKeyPad[i] = 54 ^ b;
        }
        Sha512.call(this, bits, sharedMemory);
        this.update(iKeyPad);
        this.oKeyPad = oKeyPad;
        this.inner = true;
        this.sharedMemory = sharedMemory;
      }
      HmacSha512.prototype = new Sha512();
      HmacSha512.prototype.finalize = function() {
        Sha512.prototype.finalize.call(this);
        if (this.inner) {
          this.inner = false;
          var innerHash = this.array();
          Sha512.call(this, this.bits, this.sharedMemory);
          this.update(this.oKeyPad);
          this.update(innerHash);
          Sha512.prototype.finalize.call(this);
        }
      };
      HmacSha512.prototype.clone = function() {
        var hash = new HmacSha512([], this.bits, false);
        this.copyTo(hash);
        hash.inner = this.inner;
        for (var i = 0; i < this.oKeyPad.length; ++i) {
          hash.oKeyPad[i] = this.oKeyPad[i];
        }
        return hash;
      };
      var exports3 = createMethod(512);
      exports3.sha512 = exports3;
      exports3.sha384 = createMethod(384);
      exports3.sha512_256 = createMethod(256);
      exports3.sha512_224 = createMethod(224);
      exports3.sha512.hmac = createHmacMethod(512);
      exports3.sha384.hmac = createHmacMethod(384);
      exports3.sha512_256.hmac = createHmacMethod(256);
      exports3.sha512_224.hmac = createHmacMethod(224);
      if (COMMON_JS) {
        module2.exports = exports3;
      } else {
        root.sha512 = exports3.sha512;
        root.sha384 = exports3.sha384;
        root.sha512_256 = exports3.sha512_256;
        root.sha512_224 = exports3.sha512_224;
        if (AMD) {
          define(function() {
            return exports3;
          });
        }
      }
    })();
  }
});

// node_modules/@selfxyz/common/node_modules/node-forge/lib/forge.js
var require_forge = __commonJS({
  "node_modules/@selfxyz/common/node_modules/node-forge/lib/forge.js"(exports2, module2) {
    module2.exports = {
      // default options
      options: {
        usePureJavaScript: false
      }
    };
  }
});

// node_modules/@selfxyz/common/node_modules/node-forge/lib/baseN.js
var require_baseN = __commonJS({
  "node_modules/@selfxyz/common/node_modules/node-forge/lib/baseN.js"(exports2, module2) {
    var api = {};
    module2.exports = api;
    var _reverseAlphabets = {};
    api.encode = function(input, alphabet, maxline) {
      if (typeof alphabet !== "string") {
        throw new TypeError('"alphabet" must be a string.');
      }
      if (maxline !== void 0 && typeof maxline !== "number") {
        throw new TypeError('"maxline" must be a number.');
      }
      var output = "";
      if (!(input instanceof Uint8Array)) {
        output = _encodeWithByteBuffer(input, alphabet);
      } else {
        var i = 0;
        var base = alphabet.length;
        var first = alphabet.charAt(0);
        var digits = [0];
        for (i = 0; i < input.length; ++i) {
          for (var j = 0, carry = input[i]; j < digits.length; ++j) {
            carry += digits[j] << 8;
            digits[j] = carry % base;
            carry = carry / base | 0;
          }
          while (carry > 0) {
            digits.push(carry % base);
            carry = carry / base | 0;
          }
        }
        for (i = 0; input[i] === 0 && i < input.length - 1; ++i) {
          output += first;
        }
        for (i = digits.length - 1; i >= 0; --i) {
          output += alphabet[digits[i]];
        }
      }
      if (maxline) {
        var regex = new RegExp(".{1," + maxline + "}", "g");
        output = output.match(regex).join("\r\n");
      }
      return output;
    };
    api.decode = function(input, alphabet) {
      if (typeof input !== "string") {
        throw new TypeError('"input" must be a string.');
      }
      if (typeof alphabet !== "string") {
        throw new TypeError('"alphabet" must be a string.');
      }
      var table = _reverseAlphabets[alphabet];
      if (!table) {
        table = _reverseAlphabets[alphabet] = [];
        for (var i = 0; i < alphabet.length; ++i) {
          table[alphabet.charCodeAt(i)] = i;
        }
      }
      input = input.replace(/\s/g, "");
      var base = alphabet.length;
      var first = alphabet.charAt(0);
      var bytes = [0];
      for (var i = 0; i < input.length; i++) {
        var value3 = table[input.charCodeAt(i)];
        if (value3 === void 0) {
          return;
        }
        for (var j = 0, carry = value3; j < bytes.length; ++j) {
          carry += bytes[j] * base;
          bytes[j] = carry & 255;
          carry >>= 8;
        }
        while (carry > 0) {
          bytes.push(carry & 255);
          carry >>= 8;
        }
      }
      for (var k = 0; input[k] === first && k < input.length - 1; ++k) {
        bytes.push(0);
      }
      if (typeof Buffer !== "undefined") {
        return Buffer.from(bytes.reverse());
      }
      return new Uint8Array(bytes.reverse());
    };
    function _encodeWithByteBuffer(input, alphabet) {
      var i = 0;
      var base = alphabet.length;
      var first = alphabet.charAt(0);
      var digits = [0];
      for (i = 0; i < input.length(); ++i) {
        for (var j = 0, carry = input.at(i); j < digits.length; ++j) {
          carry += digits[j] << 8;
          digits[j] = carry % base;
          carry = carry / base | 0;
        }
        while (carry > 0) {
          digits.push(carry % base);
          carry = carry / base | 0;
        }
      }
      var output = "";
      for (i = 0; input.at(i) === 0 && i < input.length() - 1; ++i) {
        output += first;
      }
      for (i = digits.length - 1; i >= 0; --i) {
        output += alphabet[digits[i]];
      }
      return output;
    }
  }
});

// node_modules/@selfxyz/common/node_modules/node-forge/lib/util.js
var require_util = __commonJS({
  "node_modules/@selfxyz/common/node_modules/node-forge/lib/util.js"(exports2, module2) {
    var forge2 = require_forge();
    var baseN = require_baseN();
    var util2 = module2.exports = forge2.util = forge2.util || {};
    (function() {
      if (typeof process !== "undefined" && process.nextTick && !process.browser) {
        util2.nextTick = process.nextTick;
        if (typeof setImmediate === "function") {
          util2.setImmediate = setImmediate;
        } else {
          util2.setImmediate = util2.nextTick;
        }
        return;
      }
      if (typeof setImmediate === "function") {
        util2.setImmediate = function() {
          return setImmediate.apply(void 0, arguments);
        };
        util2.nextTick = function(callback) {
          return setImmediate(callback);
        };
        return;
      }
      util2.setImmediate = function(callback) {
        setTimeout(callback, 0);
      };
      if (typeof window !== "undefined" && typeof window.postMessage === "function") {
        let handler2 = function(event) {
          if (event.source === window && event.data === msg) {
            event.stopPropagation();
            var copy = callbacks.slice();
            callbacks.length = 0;
            copy.forEach(function(callback) {
              callback();
            });
          }
        };
        var handler = handler2;
        var msg = "forge.setImmediate";
        var callbacks = [];
        util2.setImmediate = function(callback) {
          callbacks.push(callback);
          if (callbacks.length === 1) {
            window.postMessage(msg, "*");
          }
        };
        window.addEventListener("message", handler2, true);
      }
      if (typeof MutationObserver !== "undefined") {
        var now = Date.now();
        var attr = true;
        var div2 = document.createElement("div");
        var callbacks = [];
        new MutationObserver(function() {
          var copy = callbacks.slice();
          callbacks.length = 0;
          copy.forEach(function(callback) {
            callback();
          });
        }).observe(div2, { attributes: true });
        var oldSetImmediate = util2.setImmediate;
        util2.setImmediate = function(callback) {
          if (Date.now() - now > 15) {
            now = Date.now();
            oldSetImmediate(callback);
          } else {
            callbacks.push(callback);
            if (callbacks.length === 1) {
              div2.setAttribute("a", attr = !attr);
            }
          }
        };
      }
      util2.nextTick = util2.setImmediate;
    })();
    util2.isNodejs = typeof process !== "undefined" && process.versions && process.versions.node;
    util2.globalScope = function() {
      if (util2.isNodejs) {
        return globalThis;
      }
      return typeof self === "undefined" ? window : self;
    }();
    util2.isArray = Array.isArray || function(x) {
      return Object.prototype.toString.call(x) === "[object Array]";
    };
    util2.isArrayBuffer = function(x) {
      return typeof ArrayBuffer !== "undefined" && x instanceof ArrayBuffer;
    };
    util2.isArrayBufferView = function(x) {
      return x && util2.isArrayBuffer(x.buffer) && x.byteLength !== void 0;
    };
    function _checkBitsParam(n) {
      if (!(n === 8 || n === 16 || n === 24 || n === 32)) {
        throw new Error("Only 8, 16, 24, or 32 bits supported: " + n);
      }
    }
    util2.ByteBuffer = ByteStringBuffer;
    function ByteStringBuffer(b) {
      this.data = "";
      this.read = 0;
      if (typeof b === "string") {
        this.data = b;
      } else if (util2.isArrayBuffer(b) || util2.isArrayBufferView(b)) {
        if (typeof Buffer !== "undefined" && b instanceof Buffer) {
          this.data = b.toString("binary");
        } else {
          var arr = new Uint8Array(b);
          try {
            this.data = String.fromCharCode.apply(null, arr);
          } catch (e) {
            for (var i = 0; i < arr.length; ++i) {
              this.putByte(arr[i]);
            }
          }
        }
      } else if (b instanceof ByteStringBuffer || typeof b === "object" && typeof b.data === "string" && typeof b.read === "number") {
        this.data = b.data;
        this.read = b.read;
      }
      this._constructedStringLength = 0;
    }
    util2.ByteStringBuffer = ByteStringBuffer;
    var _MAX_CONSTRUCTED_STRING_LENGTH = 4096;
    util2.ByteStringBuffer.prototype._optimizeConstructedString = function(x) {
      this._constructedStringLength += x;
      if (this._constructedStringLength > _MAX_CONSTRUCTED_STRING_LENGTH) {
        this.data.substr(0, 1);
        this._constructedStringLength = 0;
      }
    };
    util2.ByteStringBuffer.prototype.length = function() {
      return this.data.length - this.read;
    };
    util2.ByteStringBuffer.prototype.isEmpty = function() {
      return this.length() <= 0;
    };
    util2.ByteStringBuffer.prototype.putByte = function(b) {
      return this.putBytes(String.fromCharCode(b));
    };
    util2.ByteStringBuffer.prototype.fillWithByte = function(b, n) {
      b = String.fromCharCode(b);
      var d = this.data;
      while (n > 0) {
        if (n & 1) {
          d += b;
        }
        n >>>= 1;
        if (n > 0) {
          b += b;
        }
      }
      this.data = d;
      this._optimizeConstructedString(n);
      return this;
    };
    util2.ByteStringBuffer.prototype.putBytes = function(bytes) {
      this.data += bytes;
      this._optimizeConstructedString(bytes.length);
      return this;
    };
    util2.ByteStringBuffer.prototype.putString = function(str) {
      return this.putBytes(util2.encodeUtf8(str));
    };
    util2.ByteStringBuffer.prototype.putInt16 = function(i) {
      return this.putBytes(
        String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i & 255)
      );
    };
    util2.ByteStringBuffer.prototype.putInt24 = function(i) {
      return this.putBytes(
        String.fromCharCode(i >> 16 & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i & 255)
      );
    };
    util2.ByteStringBuffer.prototype.putInt32 = function(i) {
      return this.putBytes(
        String.fromCharCode(i >> 24 & 255) + String.fromCharCode(i >> 16 & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i & 255)
      );
    };
    util2.ByteStringBuffer.prototype.putInt16Le = function(i) {
      return this.putBytes(
        String.fromCharCode(i & 255) + String.fromCharCode(i >> 8 & 255)
      );
    };
    util2.ByteStringBuffer.prototype.putInt24Le = function(i) {
      return this.putBytes(
        String.fromCharCode(i & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i >> 16 & 255)
      );
    };
    util2.ByteStringBuffer.prototype.putInt32Le = function(i) {
      return this.putBytes(
        String.fromCharCode(i & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i >> 16 & 255) + String.fromCharCode(i >> 24 & 255)
      );
    };
    util2.ByteStringBuffer.prototype.putInt = function(i, n) {
      _checkBitsParam(n);
      var bytes = "";
      do {
        n -= 8;
        bytes += String.fromCharCode(i >> n & 255);
      } while (n > 0);
      return this.putBytes(bytes);
    };
    util2.ByteStringBuffer.prototype.putSignedInt = function(i, n) {
      if (i < 0) {
        i += 2 << n - 1;
      }
      return this.putInt(i, n);
    };
    util2.ByteStringBuffer.prototype.putBuffer = function(buffer) {
      return this.putBytes(buffer.getBytes());
    };
    util2.ByteStringBuffer.prototype.getByte = function() {
      return this.data.charCodeAt(this.read++);
    };
    util2.ByteStringBuffer.prototype.getInt16 = function() {
      var rval = this.data.charCodeAt(this.read) << 8 ^ this.data.charCodeAt(this.read + 1);
      this.read += 2;
      return rval;
    };
    util2.ByteStringBuffer.prototype.getInt24 = function() {
      var rval = this.data.charCodeAt(this.read) << 16 ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2);
      this.read += 3;
      return rval;
    };
    util2.ByteStringBuffer.prototype.getInt32 = function() {
      var rval = this.data.charCodeAt(this.read) << 24 ^ this.data.charCodeAt(this.read + 1) << 16 ^ this.data.charCodeAt(this.read + 2) << 8 ^ this.data.charCodeAt(this.read + 3);
      this.read += 4;
      return rval;
    };
    util2.ByteStringBuffer.prototype.getInt16Le = function() {
      var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8;
      this.read += 2;
      return rval;
    };
    util2.ByteStringBuffer.prototype.getInt24Le = function() {
      var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16;
      this.read += 3;
      return rval;
    };
    util2.ByteStringBuffer.prototype.getInt32Le = function() {
      var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16 ^ this.data.charCodeAt(this.read + 3) << 24;
      this.read += 4;
      return rval;
    };
    util2.ByteStringBuffer.prototype.getInt = function(n) {
      _checkBitsParam(n);
      var rval = 0;
      do {
        rval = (rval << 8) + this.data.charCodeAt(this.read++);
        n -= 8;
      } while (n > 0);
      return rval;
    };
    util2.ByteStringBuffer.prototype.getSignedInt = function(n) {
      var x = this.getInt(n);
      var max = 2 << n - 2;
      if (x >= max) {
        x -= max << 1;
      }
      return x;
    };
    util2.ByteStringBuffer.prototype.getBytes = function(count) {
      var rval;
      if (count) {
        count = Math.min(this.length(), count);
        rval = this.data.slice(this.read, this.read + count);
        this.read += count;
      } else if (count === 0) {
        rval = "";
      } else {
        rval = this.read === 0 ? this.data : this.data.slice(this.read);
        this.clear();
      }
      return rval;
    };
    util2.ByteStringBuffer.prototype.bytes = function(count) {
      return typeof count === "undefined" ? this.data.slice(this.read) : this.data.slice(this.read, this.read + count);
    };
    util2.ByteStringBuffer.prototype.at = function(i) {
      return this.data.charCodeAt(this.read + i);
    };
    util2.ByteStringBuffer.prototype.setAt = function(i, b) {
      this.data = this.data.substr(0, this.read + i) + String.fromCharCode(b) + this.data.substr(this.read + i + 1);
      return this;
    };
    util2.ByteStringBuffer.prototype.last = function() {
      return this.data.charCodeAt(this.data.length - 1);
    };
    util2.ByteStringBuffer.prototype.copy = function() {
      var c = util2.createBuffer(this.data);
      c.read = this.read;
      return c;
    };
    util2.ByteStringBuffer.prototype.compact = function() {
      if (this.read > 0) {
        this.data = this.data.slice(this.read);
        this.read = 0;
      }
      return this;
    };
    util2.ByteStringBuffer.prototype.clear = function() {
      this.data = "";
      this.read = 0;
      return this;
    };
    util2.ByteStringBuffer.prototype.truncate = function(count) {
      var len = Math.max(0, this.length() - count);
      this.data = this.data.substr(this.read, len);
      this.read = 0;
      return this;
    };
    util2.ByteStringBuffer.prototype.toHex = function() {
      var rval = "";
      for (var i = this.read; i < this.data.length; ++i) {
        var b = this.data.charCodeAt(i);
        if (b < 16) {
          rval += "0";
        }
        rval += b.toString(16);
      }
      return rval;
    };
    util2.ByteStringBuffer.prototype.toString = function() {
      return util2.decodeUtf8(this.bytes());
    };
    function DataBuffer(b, options) {
      options = options || {};
      this.read = options.readOffset || 0;
      this.growSize = options.growSize || 1024;
      var isArrayBuffer = util2.isArrayBuffer(b);
      var isArrayBufferView = util2.isArrayBufferView(b);
      if (isArrayBuffer || isArrayBufferView) {
        if (isArrayBuffer) {
          this.data = new DataView(b);
        } else {
          this.data = new DataView(b.buffer, b.byteOffset, b.byteLength);
        }
        this.write = "writeOffset" in options ? options.writeOffset : this.data.byteLength;
        return;
      }
      this.data = new DataView(new ArrayBuffer(0));
      this.write = 0;
      if (b !== null && b !== void 0) {
        this.putBytes(b);
      }
      if ("writeOffset" in options) {
        this.write = options.writeOffset;
      }
    }
    util2.DataBuffer = DataBuffer;
    util2.DataBuffer.prototype.length = function() {
      return this.write - this.read;
    };
    util2.DataBuffer.prototype.isEmpty = function() {
      return this.length() <= 0;
    };
    util2.DataBuffer.prototype.accommodate = function(amount, growSize) {
      if (this.length() >= amount) {
        return this;
      }
      growSize = Math.max(growSize || this.growSize, amount);
      var src = new Uint8Array(
        this.data.buffer,
        this.data.byteOffset,
        this.data.byteLength
      );
      var dst = new Uint8Array(this.length() + growSize);
      dst.set(src);
      this.data = new DataView(dst.buffer);
      return this;
    };
    util2.DataBuffer.prototype.putByte = function(b) {
      this.accommodate(1);
      this.data.setUint8(this.write++, b);
      return this;
    };
    util2.DataBuffer.prototype.fillWithByte = function(b, n) {
      this.accommodate(n);
      for (var i = 0; i < n; ++i) {
        this.data.setUint8(b);
      }
      return this;
    };
    util2.DataBuffer.prototype.putBytes = function(bytes, encoding) {
      if (util2.isArrayBufferView(bytes)) {
        var src = new Uint8Array(bytes.buffer, bytes.byteOffset, bytes.byteLength);
        var len = src.byteLength - src.byteOffset;
        this.accommodate(len);
        var dst = new Uint8Array(this.data.buffer, this.write);
        dst.set(src);
        this.write += len;
        return this;
      }
      if (util2.isArrayBuffer(bytes)) {
        var src = new Uint8Array(bytes);
        this.accommodate(src.byteLength);
        var dst = new Uint8Array(this.data.buffer);
        dst.set(src, this.write);
        this.write += src.byteLength;
        return this;
      }
      if (bytes instanceof util2.DataBuffer || typeof bytes === "object" && typeof bytes.read === "number" && typeof bytes.write === "number" && util2.isArrayBufferView(bytes.data)) {
        var src = new Uint8Array(bytes.data.byteLength, bytes.read, bytes.length());
        this.accommodate(src.byteLength);
        var dst = new Uint8Array(bytes.data.byteLength, this.write);
        dst.set(src);
        this.write += src.byteLength;
        return this;
      }
      if (bytes instanceof util2.ByteStringBuffer) {
        bytes = bytes.data;
        encoding = "binary";
      }
      encoding = encoding || "binary";
      if (typeof bytes === "string") {
        var view;
        if (encoding === "hex") {
          this.accommodate(Math.ceil(bytes.length / 2));
          view = new Uint8Array(this.data.buffer, this.write);
          this.write += util2.binary.hex.decode(bytes, view, this.write);
          return this;
        }
        if (encoding === "base64") {
          this.accommodate(Math.ceil(bytes.length / 4) * 3);
          view = new Uint8Array(this.data.buffer, this.write);
          this.write += util2.binary.base64.decode(bytes, view, this.write);
          return this;
        }
        if (encoding === "utf8") {
          bytes = util2.encodeUtf8(bytes);
          encoding = "binary";
        }
        if (encoding === "binary" || encoding === "raw") {
          this.accommodate(bytes.length);
          view = new Uint8Array(this.data.buffer, this.write);
          this.write += util2.binary.raw.decode(view);
          return this;
        }
        if (encoding === "utf16") {
          this.accommodate(bytes.length * 2);
          view = new Uint16Array(this.data.buffer, this.write);
          this.write += util2.text.utf16.encode(view);
          return this;
        }
        throw new Error("Invalid encoding: " + encoding);
      }
      throw Error("Invalid parameter: " + bytes);
    };
    util2.DataBuffer.prototype.putBuffer = function(buffer) {
      this.putBytes(buffer);
      buffer.clear();
      return this;
    };
    util2.DataBuffer.prototype.putString = function(str) {
      return this.putBytes(str, "utf16");
    };
    util2.DataBuffer.prototype.putInt16 = function(i) {
      this.accommodate(2);
      this.data.setInt16(this.write, i);
      this.write += 2;
      return this;
    };
    util2.DataBuffer.prototype.putInt24 = function(i) {
      this.accommodate(3);
      this.data.setInt16(this.write, i >> 8 & 65535);
      this.data.setInt8(this.write, i >> 16 & 255);
      this.write += 3;
      return this;
    };
    util2.DataBuffer.prototype.putInt32 = function(i) {
      this.accommodate(4);
      this.data.setInt32(this.write, i);
      this.write += 4;
      return this;
    };
    util2.DataBuffer.prototype.putInt16Le = function(i) {
      this.accommodate(2);
      this.data.setInt16(this.write, i, true);
      this.write += 2;
      return this;
    };
    util2.DataBuffer.prototype.putInt24Le = function(i) {
      this.accommodate(3);
      this.data.setInt8(this.write, i >> 16 & 255);
      this.data.setInt16(this.write, i >> 8 & 65535, true);
      this.write += 3;
      return this;
    };
    util2.DataBuffer.prototype.putInt32Le = function(i) {
      this.accommodate(4);
      this.data.setInt32(this.write, i, true);
      this.write += 4;
      return this;
    };
    util2.DataBuffer.prototype.putInt = function(i, n) {
      _checkBitsParam(n);
      this.accommodate(n / 8);
      do {
        n -= 8;
        this.data.setInt8(this.write++, i >> n & 255);
      } while (n > 0);
      return this;
    };
    util2.DataBuffer.prototype.putSignedInt = function(i, n) {
      _checkBitsParam(n);
      this.accommodate(n / 8);
      if (i < 0) {
        i += 2 << n - 1;
      }
      return this.putInt(i, n);
    };
    util2.DataBuffer.prototype.getByte = function() {
      return this.data.getInt8(this.read++);
    };
    util2.DataBuffer.prototype.getInt16 = function() {
      var rval = this.data.getInt16(this.read);
      this.read += 2;
      return rval;
    };
    util2.DataBuffer.prototype.getInt24 = function() {
      var rval = this.data.getInt16(this.read) << 8 ^ this.data.getInt8(this.read + 2);
      this.read += 3;
      return rval;
    };
    util2.DataBuffer.prototype.getInt32 = function() {
      var rval = this.data.getInt32(this.read);
      this.read += 4;
      return rval;
    };
    util2.DataBuffer.prototype.getInt16Le = function() {
      var rval = this.data.getInt16(this.read, true);
      this.read += 2;
      return rval;
    };
    util2.DataBuffer.prototype.getInt24Le = function() {
      var rval = this.data.getInt8(this.read) ^ this.data.getInt16(this.read + 1, true) << 8;
      this.read += 3;
      return rval;
    };
    util2.DataBuffer.prototype.getInt32Le = function() {
      var rval = this.data.getInt32(this.read, true);
      this.read += 4;
      return rval;
    };
    util2.DataBuffer.prototype.getInt = function(n) {
      _checkBitsParam(n);
      var rval = 0;
      do {
        rval = (rval << 8) + this.data.getInt8(this.read++);
        n -= 8;
      } while (n > 0);
      return rval;
    };
    util2.DataBuffer.prototype.getSignedInt = function(n) {
      var x = this.getInt(n);
      var max = 2 << n - 2;
      if (x >= max) {
        x -= max << 1;
      }
      return x;
    };
    util2.DataBuffer.prototype.getBytes = function(count) {
      var rval;
      if (count) {
        count = Math.min(this.length(), count);
        rval = this.data.slice(this.read, this.read + count);
        this.read += count;
      } else if (count === 0) {
        rval = "";
      } else {
        rval = this.read === 0 ? this.data : this.data.slice(this.read);
        this.clear();
      }
      return rval;
    };
    util2.DataBuffer.prototype.bytes = function(count) {
      return typeof count === "undefined" ? this.data.slice(this.read) : this.data.slice(this.read, this.read + count);
    };
    util2.DataBuffer.prototype.at = function(i) {
      return this.data.getUint8(this.read + i);
    };
    util2.DataBuffer.prototype.setAt = function(i, b) {
      this.data.setUint8(i, b);
      return this;
    };
    util2.DataBuffer.prototype.last = function() {
      return this.data.getUint8(this.write - 1);
    };
    util2.DataBuffer.prototype.copy = function() {
      return new util2.DataBuffer(this);
    };
    util2.DataBuffer.prototype.compact = function() {
      if (this.read > 0) {
        var src = new Uint8Array(this.data.buffer, this.read);
        var dst = new Uint8Array(src.byteLength);
        dst.set(src);
        this.data = new DataView(dst);
        this.write -= this.read;
        this.read = 0;
      }
      return this;
    };
    util2.DataBuffer.prototype.clear = function() {
      this.data = new DataView(new ArrayBuffer(0));
      this.read = this.write = 0;
      return this;
    };
    util2.DataBuffer.prototype.truncate = function(count) {
      this.write = Math.max(0, this.length() - count);
      this.read = Math.min(this.read, this.write);
      return this;
    };
    util2.DataBuffer.prototype.toHex = function() {
      var rval = "";
      for (var i = this.read; i < this.data.byteLength; ++i) {
        var b = this.data.getUint8(i);
        if (b < 16) {
          rval += "0";
        }
        rval += b.toString(16);
      }
      return rval;
    };
    util2.DataBuffer.prototype.toString = function(encoding) {
      var view = new Uint8Array(this.data, this.read, this.length());
      encoding = encoding || "utf8";
      if (encoding === "binary" || encoding === "raw") {
        return util2.binary.raw.encode(view);
      }
      if (encoding === "hex") {
        return util2.binary.hex.encode(view);
      }
      if (encoding === "base64") {
        return util2.binary.base64.encode(view);
      }
      if (encoding === "utf8") {
        return util2.text.utf8.decode(view);
      }
      if (encoding === "utf16") {
        return util2.text.utf16.decode(view);
      }
      throw new Error("Invalid encoding: " + encoding);
    };
    util2.createBuffer = function(input, encoding) {
      encoding = encoding || "raw";
      if (input !== void 0 && encoding === "utf8") {
        input = util2.encodeUtf8(input);
      }
      return new util2.ByteBuffer(input);
    };
    util2.fillString = function(c, n) {
      var s = "";
      while (n > 0) {
        if (n & 1) {
          s += c;
        }
        n >>>= 1;
        if (n > 0) {
          c += c;
        }
      }
      return s;
    };
    util2.xorBytes = function(s1, s2, n) {
      var s3 = "";
      var b = "";
      var t = "";
      var i = 0;
      var c = 0;
      for (; n > 0; --n, ++i) {
        b = s1.charCodeAt(i) ^ s2.charCodeAt(i);
        if (c >= 10) {
          s3 += t;
          t = "";
          c = 0;
        }
        t += String.fromCharCode(b);
        ++c;
      }
      s3 += t;
      return s3;
    };
    util2.hexToBytes = function(hex) {
      var rval = "";
      var i = 0;
      if (hex.length & true) {
        i = 1;
        rval += String.fromCharCode(parseInt(hex[0], 16));
      }
      for (; i < hex.length; i += 2) {
        rval += String.fromCharCode(parseInt(hex.substr(i, 2), 16));
      }
      return rval;
    };
    util2.bytesToHex = function(bytes) {
      return util2.createBuffer(bytes).toHex();
    };
    util2.int32ToBytes = function(i) {
      return String.fromCharCode(i >> 24 & 255) + String.fromCharCode(i >> 16 & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i & 255);
    };
    var _base64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    var _base64Idx = [
      /*43 -43 = 0*/
      /*'+',  1,  2,  3,'/' */
      62,
      -1,
      -1,
      -1,
      63,
      /*'0','1','2','3','4','5','6','7','8','9' */
      52,
      53,
      54,
      55,
      56,
      57,
      58,
      59,
      60,
      61,
      /*15, 16, 17,'=', 19, 20, 21 */
      -1,
      -1,
      -1,
      64,
      -1,
      -1,
      -1,
      /*65 - 43 = 22*/
      /*'A','B','C','D','E','F','G','H','I','J','K','L','M', */
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      /*'N','O','P','Q','R','S','T','U','V','W','X','Y','Z' */
      13,
      14,
      15,
      16,
      17,
      18,
      19,
      20,
      21,
      22,
      23,
      24,
      25,
      /*91 - 43 = 48 */
      /*48, 49, 50, 51, 52, 53 */
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      /*97 - 43 = 54*/
      /*'a','b','c','d','e','f','g','h','i','j','k','l','m' */
      26,
      27,
      28,
      29,
      30,
      31,
      32,
      33,
      34,
      35,
      36,
      37,
      38,
      /*'n','o','p','q','r','s','t','u','v','w','x','y','z' */
      39,
      40,
      41,
      42,
      43,
      44,
      45,
      46,
      47,
      48,
      49,
      50,
      51
    ];
    var _base58 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
    util2.encode64 = function(input, maxline) {
      var line = "";
      var output = "";
      var chr1, chr2, chr3;
      var i = 0;
      while (i < input.length) {
        chr1 = input.charCodeAt(i++);
        chr2 = input.charCodeAt(i++);
        chr3 = input.charCodeAt(i++);
        line += _base64.charAt(chr1 >> 2);
        line += _base64.charAt((chr1 & 3) << 4 | chr2 >> 4);
        if (isNaN(chr2)) {
          line += "==";
        } else {
          line += _base64.charAt((chr2 & 15) << 2 | chr3 >> 6);
          line += isNaN(chr3) ? "=" : _base64.charAt(chr3 & 63);
        }
        if (maxline && line.length > maxline) {
          output += line.substr(0, maxline) + "\r\n";
          line = line.substr(maxline);
        }
      }
      output += line;
      return output;
    };
    util2.decode64 = function(input) {
      input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
      var output = "";
      var enc1, enc2, enc3, enc4;
      var i = 0;
      while (i < input.length) {
        enc1 = _base64Idx[input.charCodeAt(i++) - 43];
        enc2 = _base64Idx[input.charCodeAt(i++) - 43];
        enc3 = _base64Idx[input.charCodeAt(i++) - 43];
        enc4 = _base64Idx[input.charCodeAt(i++) - 43];
        output += String.fromCharCode(enc1 << 2 | enc2 >> 4);
        if (enc3 !== 64) {
          output += String.fromCharCode((enc2 & 15) << 4 | enc3 >> 2);
          if (enc4 !== 64) {
            output += String.fromCharCode((enc3 & 3) << 6 | enc4);
          }
        }
      }
      return output;
    };
    util2.encodeUtf8 = function(str) {
      return unescape(encodeURIComponent(str));
    };
    util2.decodeUtf8 = function(str) {
      return decodeURIComponent(escape(str));
    };
    util2.binary = {
      raw: {},
      hex: {},
      base64: {},
      base58: {},
      baseN: {
        encode: baseN.encode,
        decode: baseN.decode
      }
    };
    util2.binary.raw.encode = function(bytes) {
      return String.fromCharCode.apply(null, bytes);
    };
    util2.binary.raw.decode = function(str, output, offset) {
      var out = output;
      if (!out) {
        out = new Uint8Array(str.length);
      }
      offset = offset || 0;
      var j = offset;
      for (var i = 0; i < str.length; ++i) {
        out[j++] = str.charCodeAt(i);
      }
      return output ? j - offset : out;
    };
    util2.binary.hex.encode = util2.bytesToHex;
    util2.binary.hex.decode = function(hex, output, offset) {
      var out = output;
      if (!out) {
        out = new Uint8Array(Math.ceil(hex.length / 2));
      }
      offset = offset || 0;
      var i = 0, j = offset;
      if (hex.length & 1) {
        i = 1;
        out[j++] = parseInt(hex[0], 16);
      }
      for (; i < hex.length; i += 2) {
        out[j++] = parseInt(hex.substr(i, 2), 16);
      }
      return output ? j - offset : out;
    };
    util2.binary.base64.encode = function(input, maxline) {
      var line = "";
      var output = "";
      var chr1, chr2, chr3;
      var i = 0;
      while (i < input.byteLength) {
        chr1 = input[i++];
        chr2 = input[i++];
        chr3 = input[i++];
        line += _base64.charAt(chr1 >> 2);
        line += _base64.charAt((chr1 & 3) << 4 | chr2 >> 4);
        if (isNaN(chr2)) {
          line += "==";
        } else {
          line += _base64.charAt((chr2 & 15) << 2 | chr3 >> 6);
          line += isNaN(chr3) ? "=" : _base64.charAt(chr3 & 63);
        }
        if (maxline && line.length > maxline) {
          output += line.substr(0, maxline) + "\r\n";
          line = line.substr(maxline);
        }
      }
      output += line;
      return output;
    };
    util2.binary.base64.decode = function(input, output, offset) {
      var out = output;
      if (!out) {
        out = new Uint8Array(Math.ceil(input.length / 4) * 3);
      }
      input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
      offset = offset || 0;
      var enc1, enc2, enc3, enc4;
      var i = 0, j = offset;
      while (i < input.length) {
        enc1 = _base64Idx[input.charCodeAt(i++) - 43];
        enc2 = _base64Idx[input.charCodeAt(i++) - 43];
        enc3 = _base64Idx[input.charCodeAt(i++) - 43];
        enc4 = _base64Idx[input.charCodeAt(i++) - 43];
        out[j++] = enc1 << 2 | enc2 >> 4;
        if (enc3 !== 64) {
          out[j++] = (enc2 & 15) << 4 | enc3 >> 2;
          if (enc4 !== 64) {
            out[j++] = (enc3 & 3) << 6 | enc4;
          }
        }
      }
      return output ? j - offset : out.subarray(0, j);
    };
    util2.binary.base58.encode = function(input, maxline) {
      return util2.binary.baseN.encode(input, _base58, maxline);
    };
    util2.binary.base58.decode = function(input, maxline) {
      return util2.binary.baseN.decode(input, _base58, maxline);
    };
    util2.text = {
      utf8: {},
      utf16: {}
    };
    util2.text.utf8.encode = function(str, output, offset) {
      str = util2.encodeUtf8(str);
      var out = output;
      if (!out) {
        out = new Uint8Array(str.length);
      }
      offset = offset || 0;
      var j = offset;
      for (var i = 0; i < str.length; ++i) {
        out[j++] = str.charCodeAt(i);
      }
      return output ? j - offset : out;
    };
    util2.text.utf8.decode = function(bytes) {
      return util2.decodeUtf8(String.fromCharCode.apply(null, bytes));
    };
    util2.text.utf16.encode = function(str, output, offset) {
      var out = output;
      if (!out) {
        out = new Uint8Array(str.length * 2);
      }
      var view = new Uint16Array(out.buffer);
      offset = offset || 0;
      var j = offset;
      var k = offset;
      for (var i = 0; i < str.length; ++i) {
        view[k++] = str.charCodeAt(i);
        j += 2;
      }
      return output ? j - offset : out;
    };
    util2.text.utf16.decode = function(bytes) {
      return String.fromCharCode.apply(null, new Uint16Array(bytes.buffer));
    };
    util2.deflate = function(api, bytes, raw) {
      bytes = util2.decode64(api.deflate(util2.encode64(bytes)).rval);
      if (raw) {
        var start = 2;
        var flg = bytes.charCodeAt(1);
        if (flg & 32) {
          start = 6;
        }
        bytes = bytes.substring(start, bytes.length - 4);
      }
      return bytes;
    };
    util2.inflate = function(api, bytes, raw) {
      var rval = api.inflate(util2.encode64(bytes)).rval;
      return rval === null ? null : util2.decode64(rval);
    };
    var _setStorageObject = function(api, id, obj) {
      if (!api) {
        throw new Error("WebStorage not available.");
      }
      var rval;
      if (obj === null) {
        rval = api.removeItem(id);
      } else {
        obj = util2.encode64(JSON.stringify(obj));
        rval = api.setItem(id, obj);
      }
      if (typeof rval !== "undefined" && rval.rval !== true) {
        var error = new Error(rval.error.message);
        error.id = rval.error.id;
        error.name = rval.error.name;
        throw error;
      }
    };
    var _getStorageObject = function(api, id) {
      if (!api) {
        throw new Error("WebStorage not available.");
      }
      var rval = api.getItem(id);
      if (api.init) {
        if (rval.rval === null) {
          if (rval.error) {
            var error = new Error(rval.error.message);
            error.id = rval.error.id;
            error.name = rval.error.name;
            throw error;
          }
          rval = null;
        } else {
          rval = rval.rval;
        }
      }
      if (rval !== null) {
        rval = JSON.parse(util2.decode64(rval));
      }
      return rval;
    };
    var _setItem = function(api, id, key2, data2) {
      var obj = _getStorageObject(api, id);
      if (obj === null) {
        obj = {};
      }
      obj[key2] = data2;
      _setStorageObject(api, id, obj);
    };
    var _getItem = function(api, id, key2) {
      var rval = _getStorageObject(api, id);
      if (rval !== null) {
        rval = key2 in rval ? rval[key2] : null;
      }
      return rval;
    };
    var _removeItem = function(api, id, key2) {
      var obj = _getStorageObject(api, id);
      if (obj !== null && key2 in obj) {
        delete obj[key2];
        var empty2 = true;
        for (var prop in obj) {
          empty2 = false;
          break;
        }
        if (empty2) {
          obj = null;
        }
        _setStorageObject(api, id, obj);
      }
    };
    var _clearItems = function(api, id) {
      _setStorageObject(api, id, null);
    };
    var _callStorageFunction = function(func, args, location2) {
      var rval = null;
      if (typeof location2 === "undefined") {
        location2 = ["web", "flash"];
      }
      var type;
      var done = false;
      var exception = null;
      for (var idx in location2) {
        type = location2[idx];
        try {
          if (type === "flash" || type === "both") {
            if (args[0] === null) {
              throw new Error("Flash local storage not available.");
            }
            rval = func.apply(this, args);
            done = type === "flash";
          }
          if (type === "web" || type === "both") {
            args[0] = localStorage;
            rval = func.apply(this, args);
            done = true;
          }
        } catch (ex) {
          exception = ex;
        }
        if (done) {
          break;
        }
      }
      if (!done) {
        throw exception;
      }
      return rval;
    };
    util2.setItem = function(api, id, key2, data2, location2) {
      _callStorageFunction(_setItem, arguments, location2);
    };
    util2.getItem = function(api, id, key2, location2) {
      return _callStorageFunction(_getItem, arguments, location2);
    };
    util2.removeItem = function(api, id, key2, location2) {
      _callStorageFunction(_removeItem, arguments, location2);
    };
    util2.clearItems = function(api, id, location2) {
      _callStorageFunction(_clearItems, arguments, location2);
    };
    util2.isEmpty = function(obj) {
      for (var prop in obj) {
        if (obj.hasOwnProperty(prop)) {
          return false;
        }
      }
      return true;
    };
    util2.format = function(format) {
      var re2 = /%./g;
      var match;
      var part;
      var argi = 0;
      var parts2 = [];
      var last = 0;
      while (match = re2.exec(format)) {
        part = format.substring(last, re2.lastIndex - 2);
        if (part.length > 0) {
          parts2.push(part);
        }
        last = re2.lastIndex;
        var code = match[0][1];
        switch (code) {
          case "s":
          case "o":
            if (argi < arguments.length) {
              parts2.push(arguments[argi++ + 1]);
            } else {
              parts2.push("<?>");
            }
            break;
          // FIXME: do proper formating for numbers, etc
          //case 'f':
          //case 'd':
          case "%":
            parts2.push("%");
            break;
          default:
            parts2.push("<%" + code + "?>");
        }
      }
      parts2.push(format.substring(last));
      return parts2.join("");
    };
    util2.formatNumber = function(number, decimals, dec_point, thousands_sep) {
      var n = number, c = isNaN(decimals = Math.abs(decimals)) ? 2 : decimals;
      var d = dec_point === void 0 ? "," : dec_point;
      var t = thousands_sep === void 0 ? "." : thousands_sep, s = n < 0 ? "-" : "";
      var i = parseInt(n = Math.abs(+n || 0).toFixed(c), 10) + "";
      var j = i.length > 3 ? i.length % 3 : 0;
      return s + (j ? i.substr(0, j) + t : "") + i.substr(j).replace(/(\d{3})(?=\d)/g, "$1" + t) + (c ? d + Math.abs(n - i).toFixed(c).slice(2) : "");
    };
    util2.formatSize = function(size) {
      if (size >= 1073741824) {
        size = util2.formatNumber(size / 1073741824, 2, ".", "") + " GiB";
      } else if (size >= 1048576) {
        size = util2.formatNumber(size / 1048576, 2, ".", "") + " MiB";
      } else if (size >= 1024) {
        size = util2.formatNumber(size / 1024, 0) + " KiB";
      } else {
        size = util2.formatNumber(size, 0) + " bytes";
      }
      return size;
    };
    util2.bytesFromIP = function(ip) {
      if (ip.indexOf(".") !== -1) {
        return util2.bytesFromIPv4(ip);
      }
      if (ip.indexOf(":") !== -1) {
        return util2.bytesFromIPv6(ip);
      }
      return null;
    };
    util2.bytesFromIPv4 = function(ip) {
      ip = ip.split(".");
      if (ip.length !== 4) {
        return null;
      }
      var b = util2.createBuffer();
      for (var i = 0; i < ip.length; ++i) {
        var num = parseInt(ip[i], 10);
        if (isNaN(num)) {
          return null;
        }
        b.putByte(num);
      }
      return b.getBytes();
    };
    util2.bytesFromIPv6 = function(ip) {
      var blanks = 0;
      ip = ip.split(":").filter(function(e) {
        if (e.length === 0) ++blanks;
        return true;
      });
      var zeros = (8 - ip.length + blanks) * 2;
      var b = util2.createBuffer();
      for (var i = 0; i < 8; ++i) {
        if (!ip[i] || ip[i].length === 0) {
          b.fillWithByte(0, zeros);
          zeros = 0;
          continue;
        }
        var bytes = util2.hexToBytes(ip[i]);
        if (bytes.length < 2) {
          b.putByte(0);
        }
        b.putBytes(bytes);
      }
      return b.getBytes();
    };
    util2.bytesToIP = function(bytes) {
      if (bytes.length === 4) {
        return util2.bytesToIPv4(bytes);
      }
      if (bytes.length === 16) {
        return util2.bytesToIPv6(bytes);
      }
      return null;
    };
    util2.bytesToIPv4 = function(bytes) {
      if (bytes.length !== 4) {
        return null;
      }
      var ip = [];
      for (var i = 0; i < bytes.length; ++i) {
        ip.push(bytes.charCodeAt(i));
      }
      return ip.join(".");
    };
    util2.bytesToIPv6 = function(bytes) {
      if (bytes.length !== 16) {
        return null;
      }
      var ip = [];
      var zeroGroups = [];
      var zeroMaxGroup = 0;
      for (var i = 0; i < bytes.length; i += 2) {
        var hex = util2.bytesToHex(bytes[i] + bytes[i + 1]);
        while (hex[0] === "0" && hex !== "0") {
          hex = hex.substr(1);
        }
        if (hex === "0") {
          var last = zeroGroups[zeroGroups.length - 1];
          var idx = ip.length;
          if (!last || idx !== last.end + 1) {
            zeroGroups.push({ start: idx, end: idx });
          } else {
            last.end = idx;
            if (last.end - last.start > zeroGroups[zeroMaxGroup].end - zeroGroups[zeroMaxGroup].start) {
              zeroMaxGroup = zeroGroups.length - 1;
            }
          }
        }
        ip.push(hex);
      }
      if (zeroGroups.length > 0) {
        var group = zeroGroups[zeroMaxGroup];
        if (group.end - group.start > 0) {
          ip.splice(group.start, group.end - group.start + 1, "");
          if (group.start === 0) {
            ip.unshift("");
          }
          if (group.end === 7) {
            ip.push("");
          }
        }
      }
      return ip.join(":");
    };
    util2.estimateCores = function(options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      options = options || {};
      if ("cores" in util2 && !options.update) {
        return callback(null, util2.cores);
      }
      if (typeof navigator !== "undefined" && "hardwareConcurrency" in navigator && navigator.hardwareConcurrency > 0) {
        util2.cores = navigator.hardwareConcurrency;
        return callback(null, util2.cores);
      }
      if (typeof Worker === "undefined") {
        util2.cores = 1;
        return callback(null, util2.cores);
      }
      if (typeof Blob === "undefined") {
        util2.cores = 2;
        return callback(null, util2.cores);
      }
      var blobUrl = URL.createObjectURL(new Blob([
        "(",
        (function() {
          self.addEventListener("message", function(e) {
            var st = Date.now();
            var et = st + 4;
            while (Date.now() < et) ;
            self.postMessage({ st, et });
          });
        }).toString(),
        ")()"
      ], { type: "application/javascript" }));
      sample([], 5, 16);
      function sample(max, samples, numWorkers) {
        if (samples === 0) {
          var avg = Math.floor(max.reduce(function(avg2, x) {
            return avg2 + x;
          }, 0) / max.length);
          util2.cores = Math.max(1, avg);
          URL.revokeObjectURL(blobUrl);
          return callback(null, util2.cores);
        }
        map(numWorkers, function(err, results) {
          max.push(reduce(numWorkers, results));
          sample(max, samples - 1, numWorkers);
        });
      }
      function map(numWorkers, callback2) {
        var workers = [];
        var results = [];
        for (var i = 0; i < numWorkers; ++i) {
          var worker = new Worker(blobUrl);
          worker.addEventListener("message", function(e) {
            results.push(e.data);
            if (results.length === numWorkers) {
              for (var i2 = 0; i2 < numWorkers; ++i2) {
                workers[i2].terminate();
              }
              callback2(null, results);
            }
          });
          workers.push(worker);
        }
        for (var i = 0; i < numWorkers; ++i) {
          workers[i].postMessage(i);
        }
      }
      function reduce(numWorkers, results) {
        var overlaps = [];
        for (var n = 0; n < numWorkers; ++n) {
          var r1 = results[n];
          var overlap = overlaps[n] = [];
          for (var i = 0; i < numWorkers; ++i) {
            if (n === i) {
              continue;
            }
            var r2 = results[i];
            if (r1.st > r2.st && r1.st < r2.et || r2.st > r1.st && r2.st < r1.et) {
              overlap.push(i);
            }
          }
        }
        return overlaps.reduce(function(max, overlap2) {
          return Math.max(max, overlap2.length);
        }, 0);
      }
    };
  }
});

// node_modules/@selfxyz/common/node_modules/node-forge/lib/cipher.js
var require_cipher = __commonJS({
  "node_modules/@selfxyz/common/node_modules/node-forge/lib/cipher.js"(exports2, module2) {
    var forge2 = require_forge();
    require_util();
    module2.exports = forge2.cipher = forge2.cipher || {};
    forge2.cipher.algorithms = forge2.cipher.algorithms || {};
    forge2.cipher.createCipher = function(algorithm, key2) {
      var api = algorithm;
      if (typeof api === "string") {
        api = forge2.cipher.getAlgorithm(api);
        if (api) {
          api = api();
        }
      }
      if (!api) {
        throw new Error("Unsupported algorithm: " + algorithm);
      }
      return new forge2.cipher.BlockCipher({
        algorithm: api,
        key: key2,
        decrypt: false
      });
    };
    forge2.cipher.createDecipher = function(algorithm, key2) {
      var api = algorithm;
      if (typeof api === "string") {
        api = forge2.cipher.getAlgorithm(api);
        if (api) {
          api = api();
        }
      }
      if (!api) {
        throw new Error("Unsupported algorithm: " + algorithm);
      }
      return new forge2.cipher.BlockCipher({
        algorithm: api,
        key: key2,
        decrypt: true
      });
    };
    forge2.cipher.registerAlgorithm = function(name2, algorithm) {
      name2 = name2.toUpperCase();
      forge2.cipher.algorithms[name2] = algorithm;
    };
    forge2.cipher.getAlgorithm = function(name2) {
      name2 = name2.toUpperCase();
      if (name2 in forge2.cipher.algorithms) {
        return forge2.cipher.algorithms[name2];
      }
      return null;
    };
    var BlockCipher = forge2.cipher.BlockCipher = function(options) {
      this.algorithm = options.algorithm;
      this.mode = this.algorithm.mode;
      this.blockSize = this.mode.blockSize;
      this._finish = false;
      this._input = null;
      this.output = null;
      this._op = options.decrypt ? this.mode.decrypt : this.mode.encrypt;
      this._decrypt = options.decrypt;
      this.algorithm.initialize(options);
    };
    BlockCipher.prototype.start = function(options) {
      options = options || {};
      var opts = {};
      for (var key2 in options) {
        opts[key2] = options[key2];
      }
      opts.decrypt = this._decrypt;
      this._finish = false;
      this._input = forge2.util.createBuffer();
      this.output = options.output || forge2.util.createBuffer();
      this.mode.start(opts);
    };
    BlockCipher.prototype.update = function(input) {
      if (input) {
        this._input.putBuffer(input);
      }
      while (!this._op.call(this.mode, this._input, this.output, this._finish) && !this._finish) {
      }
      this._input.compact();
    };
    BlockCipher.prototype.finish = function(pad) {
      if (pad && (this.mode.name === "ECB" || this.mode.name === "CBC")) {
        this.mode.pad = function(input) {
          return pad(this.blockSize, input, false);
        };
        this.mode.unpad = function(output) {
          return pad(this.blockSize, output, true);
        };
      }
      var options = {};
      options.decrypt = this._decrypt;
      options.overflow = this._input.length() % this.blockSize;
      if (!this._decrypt && this.mode.pad) {
        if (!this.mode.pad(this._input, options)) {
          return false;
        }
      }
      this._finish = true;
      this.update();
      if (this._decrypt && this.mode.unpad) {
        if (!this.mode.unpad(this.output, options)) {
          return false;
        }
      }
      if (this.mode.afterFinish) {
        if (!this.mode.afterFinish(this.output, options)) {
          return false;
        }
      }
      return true;
    };
  }
});

// node_modules/@selfxyz/common/node_modules/node-forge/lib/cipherModes.js
var require_cipherModes = __commonJS({
  "node_modules/@selfxyz/common/node_modules/node-forge/lib/cipherModes.js"(exports2, module2) {
    var forge2 = require_forge();
    require_util();
    forge2.cipher = forge2.cipher || {};
    var modes = module2.exports = forge2.cipher.modes = forge2.cipher.modes || {};
    modes.ecb = function(options) {
      options = options || {};
      this.name = "ECB";
      this.cipher = options.cipher;
      this.blockSize = options.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = new Array(this._ints);
      this._outBlock = new Array(this._ints);
    };
    modes.ecb.prototype.start = function(options) {
    };
    modes.ecb.prototype.encrypt = function(input, output, finish) {
      if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
        return true;
      }
      for (var i = 0; i < this._ints; ++i) {
        this._inBlock[i] = input.getInt32();
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      for (var i = 0; i < this._ints; ++i) {
        output.putInt32(this._outBlock[i]);
      }
    };
    modes.ecb.prototype.decrypt = function(input, output, finish) {
      if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
        return true;
      }
      for (var i = 0; i < this._ints; ++i) {
        this._inBlock[i] = input.getInt32();
      }
      this.cipher.decrypt(this._inBlock, this._outBlock);
      for (var i = 0; i < this._ints; ++i) {
        output.putInt32(this._outBlock[i]);
      }
    };
    modes.ecb.prototype.pad = function(input, options) {
      var padding = input.length() === this.blockSize ? this.blockSize : this.blockSize - input.length();
      input.fillWithByte(padding, padding);
      return true;
    };
    modes.ecb.prototype.unpad = function(output, options) {
      if (options.overflow > 0) {
        return false;
      }
      var len = output.length();
      var count = output.at(len - 1);
      if (count > this.blockSize << 2) {
        return false;
      }
      output.truncate(count);
      return true;
    };
    modes.cbc = function(options) {
      options = options || {};
      this.name = "CBC";
      this.cipher = options.cipher;
      this.blockSize = options.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = new Array(this._ints);
      this._outBlock = new Array(this._ints);
    };
    modes.cbc.prototype.start = function(options) {
      if (options.iv === null) {
        if (!this._prev) {
          throw new Error("Invalid IV parameter.");
        }
        this._iv = this._prev.slice(0);
      } else if (!("iv" in options)) {
        throw new Error("Invalid IV parameter.");
      } else {
        this._iv = transformIV(options.iv, this.blockSize);
        this._prev = this._iv.slice(0);
      }
    };
    modes.cbc.prototype.encrypt = function(input, output, finish) {
      if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
        return true;
      }
      for (var i = 0; i < this._ints; ++i) {
        this._inBlock[i] = this._prev[i] ^ input.getInt32();
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      for (var i = 0; i < this._ints; ++i) {
        output.putInt32(this._outBlock[i]);
      }
      this._prev = this._outBlock;
    };
    modes.cbc.prototype.decrypt = function(input, output, finish) {
      if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
        return true;
      }
      for (var i = 0; i < this._ints; ++i) {
        this._inBlock[i] = input.getInt32();
      }
      this.cipher.decrypt(this._inBlock, this._outBlock);
      for (var i = 0; i < this._ints; ++i) {
        output.putInt32(this._prev[i] ^ this._outBlock[i]);
      }
      this._prev = this._inBlock.slice(0);
    };
    modes.cbc.prototype.pad = function(input, options) {
      var padding = input.length() === this.blockSize ? this.blockSize : this.blockSize - input.length();
      input.fillWithByte(padding, padding);
      return true;
    };
    modes.cbc.prototype.unpad = function(output, options) {
      if (options.overflow > 0) {
        return false;
      }
      var len = output.length();
      var count = output.at(len - 1);
      if (count > this.blockSize << 2) {
        return false;
      }
      output.truncate(count);
      return true;
    };
    modes.cfb = function(options) {
      options = options || {};
      this.name = "CFB";
      this.cipher = options.cipher;
      this.blockSize = options.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = null;
      this._outBlock = new Array(this._ints);
      this._partialBlock = new Array(this._ints);
      this._partialOutput = forge2.util.createBuffer();
      this._partialBytes = 0;
    };
    modes.cfb.prototype.start = function(options) {
      if (!("iv" in options)) {
        throw new Error("Invalid IV parameter.");
      }
      this._iv = transformIV(options.iv, this.blockSize);
      this._inBlock = this._iv.slice(0);
      this._partialBytes = 0;
    };
    modes.cfb.prototype.encrypt = function(input, output, finish) {
      var inputLength = input.length();
      if (inputLength === 0) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      if (this._partialBytes === 0 && inputLength >= this.blockSize) {
        for (var i = 0; i < this._ints; ++i) {
          this._inBlock[i] = input.getInt32() ^ this._outBlock[i];
          output.putInt32(this._inBlock[i]);
        }
        return;
      }
      var partialBytes = (this.blockSize - inputLength) % this.blockSize;
      if (partialBytes > 0) {
        partialBytes = this.blockSize - partialBytes;
      }
      this._partialOutput.clear();
      for (var i = 0; i < this._ints; ++i) {
        this._partialBlock[i] = input.getInt32() ^ this._outBlock[i];
        this._partialOutput.putInt32(this._partialBlock[i]);
      }
      if (partialBytes > 0) {
        input.read -= this.blockSize;
      } else {
        for (var i = 0; i < this._ints; ++i) {
          this._inBlock[i] = this._partialBlock[i];
        }
      }
      if (this._partialBytes > 0) {
        this._partialOutput.getBytes(this._partialBytes);
      }
      if (partialBytes > 0 && !finish) {
        output.putBytes(this._partialOutput.getBytes(
          partialBytes - this._partialBytes
        ));
        this._partialBytes = partialBytes;
        return true;
      }
      output.putBytes(this._partialOutput.getBytes(
        inputLength - this._partialBytes
      ));
      this._partialBytes = 0;
    };
    modes.cfb.prototype.decrypt = function(input, output, finish) {
      var inputLength = input.length();
      if (inputLength === 0) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      if (this._partialBytes === 0 && inputLength >= this.blockSize) {
        for (var i = 0; i < this._ints; ++i) {
          this._inBlock[i] = input.getInt32();
          output.putInt32(this._inBlock[i] ^ this._outBlock[i]);
        }
        return;
      }
      var partialBytes = (this.blockSize - inputLength) % this.blockSize;
      if (partialBytes > 0) {
        partialBytes = this.blockSize - partialBytes;
      }
      this._partialOutput.clear();
      for (var i = 0; i < this._ints; ++i) {
        this._partialBlock[i] = input.getInt32();
        this._partialOutput.putInt32(this._partialBlock[i] ^ this._outBlock[i]);
      }
      if (partialBytes > 0) {
        input.read -= this.blockSize;
      } else {
        for (var i = 0; i < this._ints; ++i) {
          this._inBlock[i] = this._partialBlock[i];
        }
      }
      if (this._partialBytes > 0) {
        this._partialOutput.getBytes(this._partialBytes);
      }
      if (partialBytes > 0 && !finish) {
        output.putBytes(this._partialOutput.getBytes(
          partialBytes - this._partialBytes
        ));
        this._partialBytes = partialBytes;
        return true;
      }
      output.putBytes(this._partialOutput.getBytes(
        inputLength - this._partialBytes
      ));
      this._partialBytes = 0;
    };
    modes.ofb = function(options) {
      options = options || {};
      this.name = "OFB";
      this.cipher = options.cipher;
      this.blockSize = options.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = null;
      this._outBlock = new Array(this._ints);
      this._partialOutput = forge2.util.createBuffer();
      this._partialBytes = 0;
    };
    modes.ofb.prototype.start = function(options) {
      if (!("iv" in options)) {
        throw new Error("Invalid IV parameter.");
      }
      this._iv = transformIV(options.iv, this.blockSize);
      this._inBlock = this._iv.slice(0);
      this._partialBytes = 0;
    };
    modes.ofb.prototype.encrypt = function(input, output, finish) {
      var inputLength = input.length();
      if (input.length() === 0) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      if (this._partialBytes === 0 && inputLength >= this.blockSize) {
        for (var i = 0; i < this._ints; ++i) {
          output.putInt32(input.getInt32() ^ this._outBlock[i]);
          this._inBlock[i] = this._outBlock[i];
        }
        return;
      }
      var partialBytes = (this.blockSize - inputLength) % this.blockSize;
      if (partialBytes > 0) {
        partialBytes = this.blockSize - partialBytes;
      }
      this._partialOutput.clear();
      for (var i = 0; i < this._ints; ++i) {
        this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);
      }
      if (partialBytes > 0) {
        input.read -= this.blockSize;
      } else {
        for (var i = 0; i < this._ints; ++i) {
          this._inBlock[i] = this._outBlock[i];
        }
      }
      if (this._partialBytes > 0) {
        this._partialOutput.getBytes(this._partialBytes);
      }
      if (partialBytes > 0 && !finish) {
        output.putBytes(this._partialOutput.getBytes(
          partialBytes - this._partialBytes
        ));
        this._partialBytes = partialBytes;
        return true;
      }
      output.putBytes(this._partialOutput.getBytes(
        inputLength - this._partialBytes
      ));
      this._partialBytes = 0;
    };
    modes.ofb.prototype.decrypt = modes.ofb.prototype.encrypt;
    modes.ctr = function(options) {
      options = options || {};
      this.name = "CTR";
      this.cipher = options.cipher;
      this.blockSize = options.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = null;
      this._outBlock = new Array(this._ints);
      this._partialOutput = forge2.util.createBuffer();
      this._partialBytes = 0;
    };
    modes.ctr.prototype.start = function(options) {
      if (!("iv" in options)) {
        throw new Error("Invalid IV parameter.");
      }
      this._iv = transformIV(options.iv, this.blockSize);
      this._inBlock = this._iv.slice(0);
      this._partialBytes = 0;
    };
    modes.ctr.prototype.encrypt = function(input, output, finish) {
      var inputLength = input.length();
      if (inputLength === 0) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      if (this._partialBytes === 0 && inputLength >= this.blockSize) {
        for (var i = 0; i < this._ints; ++i) {
          output.putInt32(input.getInt32() ^ this._outBlock[i]);
        }
      } else {
        var partialBytes = (this.blockSize - inputLength) % this.blockSize;
        if (partialBytes > 0) {
          partialBytes = this.blockSize - partialBytes;
        }
        this._partialOutput.clear();
        for (var i = 0; i < this._ints; ++i) {
          this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);
        }
        if (partialBytes > 0) {
          input.read -= this.blockSize;
        }
        if (this._partialBytes > 0) {
          this._partialOutput.getBytes(this._partialBytes);
        }
        if (partialBytes > 0 && !finish) {
          output.putBytes(this._partialOutput.getBytes(
            partialBytes - this._partialBytes
          ));
          this._partialBytes = partialBytes;
          return true;
        }
        output.putBytes(this._partialOutput.getBytes(
          inputLength - this._partialBytes
        ));
        this._partialBytes = 0;
      }
      inc32(this._inBlock);
    };
    modes.ctr.prototype.decrypt = modes.ctr.prototype.encrypt;
    modes.gcm = function(options) {
      options = options || {};
      this.name = "GCM";
      this.cipher = options.cipher;
      this.blockSize = options.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = new Array(this._ints);
      this._outBlock = new Array(this._ints);
      this._partialOutput = forge2.util.createBuffer();
      this._partialBytes = 0;
      this._R = 3774873600;
    };
    modes.gcm.prototype.start = function(options) {
      if (!("iv" in options)) {
        throw new Error("Invalid IV parameter.");
      }
      var iv = forge2.util.createBuffer(options.iv);
      this._cipherLength = 0;
      var additionalData;
      if ("additionalData" in options) {
        additionalData = forge2.util.createBuffer(options.additionalData);
      } else {
        additionalData = forge2.util.createBuffer();
      }
      if ("tagLength" in options) {
        this._tagLength = options.tagLength;
      } else {
        this._tagLength = 128;
      }
      this._tag = null;
      if (options.decrypt) {
        this._tag = forge2.util.createBuffer(options.tag).getBytes();
        if (this._tag.length !== this._tagLength / 8) {
          throw new Error("Authentication tag does not match tag length.");
        }
      }
      this._hashBlock = new Array(this._ints);
      this.tag = null;
      this._hashSubkey = new Array(this._ints);
      this.cipher.encrypt([0, 0, 0, 0], this._hashSubkey);
      this.componentBits = 4;
      this._m = this.generateHashTable(this._hashSubkey, this.componentBits);
      var ivLength = iv.length();
      if (ivLength === 12) {
        this._j0 = [iv.getInt32(), iv.getInt32(), iv.getInt32(), 1];
      } else {
        this._j0 = [0, 0, 0, 0];
        while (iv.length() > 0) {
          this._j0 = this.ghash(
            this._hashSubkey,
            this._j0,
            [iv.getInt32(), iv.getInt32(), iv.getInt32(), iv.getInt32()]
          );
        }
        this._j0 = this.ghash(
          this._hashSubkey,
          this._j0,
          [0, 0].concat(from64To32(ivLength * 8))
        );
      }
      this._inBlock = this._j0.slice(0);
      inc32(this._inBlock);
      this._partialBytes = 0;
      additionalData = forge2.util.createBuffer(additionalData);
      this._aDataLength = from64To32(additionalData.length() * 8);
      var overflow = additionalData.length() % this.blockSize;
      if (overflow) {
        additionalData.fillWithByte(0, this.blockSize - overflow);
      }
      this._s = [0, 0, 0, 0];
      while (additionalData.length() > 0) {
        this._s = this.ghash(this._hashSubkey, this._s, [
          additionalData.getInt32(),
          additionalData.getInt32(),
          additionalData.getInt32(),
          additionalData.getInt32()
        ]);
      }
    };
    modes.gcm.prototype.encrypt = function(input, output, finish) {
      var inputLength = input.length();
      if (inputLength === 0) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      if (this._partialBytes === 0 && inputLength >= this.blockSize) {
        for (var i = 0; i < this._ints; ++i) {
          output.putInt32(this._outBlock[i] ^= input.getInt32());
        }
        this._cipherLength += this.blockSize;
      } else {
        var partialBytes = (this.blockSize - inputLength) % this.blockSize;
        if (partialBytes > 0) {
          partialBytes = this.blockSize - partialBytes;
        }
        this._partialOutput.clear();
        for (var i = 0; i < this._ints; ++i) {
          this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);
        }
        if (partialBytes <= 0 || finish) {
          if (finish) {
            var overflow = inputLength % this.blockSize;
            this._cipherLength += overflow;
            this._partialOutput.truncate(this.blockSize - overflow);
          } else {
            this._cipherLength += this.blockSize;
          }
          for (var i = 0; i < this._ints; ++i) {
            this._outBlock[i] = this._partialOutput.getInt32();
          }
          this._partialOutput.read -= this.blockSize;
        }
        if (this._partialBytes > 0) {
          this._partialOutput.getBytes(this._partialBytes);
        }
        if (partialBytes > 0 && !finish) {
          input.read -= this.blockSize;
          output.putBytes(this._partialOutput.getBytes(
            partialBytes - this._partialBytes
          ));
          this._partialBytes = partialBytes;
          return true;
        }
        output.putBytes(this._partialOutput.getBytes(
          inputLength - this._partialBytes
        ));
        this._partialBytes = 0;
      }
      this._s = this.ghash(this._hashSubkey, this._s, this._outBlock);
      inc32(this._inBlock);
    };
    modes.gcm.prototype.decrypt = function(input, output, finish) {
      var inputLength = input.length();
      if (inputLength < this.blockSize && !(finish && inputLength > 0)) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      inc32(this._inBlock);
      this._hashBlock[0] = input.getInt32();
      this._hashBlock[1] = input.getInt32();
      this._hashBlock[2] = input.getInt32();
      this._hashBlock[3] = input.getInt32();
      this._s = this.ghash(this._hashSubkey, this._s, this._hashBlock);
      for (var i = 0; i < this._ints; ++i) {
        output.putInt32(this._outBlock[i] ^ this._hashBlock[i]);
      }
      if (inputLength < this.blockSize) {
        this._cipherLength += inputLength % this.blockSize;
      } else {
        this._cipherLength += this.blockSize;
      }
    };
    modes.gcm.prototype.afterFinish = function(output, options) {
      var rval = true;
      if (options.decrypt && options.overflow) {
        output.truncate(this.blockSize - options.overflow);
      }
      this.tag = forge2.util.createBuffer();
      var lengths = this._aDataLength.concat(from64To32(this._cipherLength * 8));
      this._s = this.ghash(this._hashSubkey, this._s, lengths);
      var tag = [];
      this.cipher.encrypt(this._j0, tag);
      for (var i = 0; i < this._ints; ++i) {
        this.tag.putInt32(this._s[i] ^ tag[i]);
      }
      this.tag.truncate(this.tag.length() % (this._tagLength / 8));
      if (options.decrypt && this.tag.bytes() !== this._tag) {
        rval = false;
      }
      return rval;
    };
    modes.gcm.prototype.multiply = function(x, y) {
      var z_i = [0, 0, 0, 0];
      var v_i = y.slice(0);
      for (var i = 0; i < 128; ++i) {
        var x_i = x[i / 32 | 0] & 1 << 31 - i % 32;
        if (x_i) {
          z_i[0] ^= v_i[0];
          z_i[1] ^= v_i[1];
          z_i[2] ^= v_i[2];
          z_i[3] ^= v_i[3];
        }
        this.pow(v_i, v_i);
      }
      return z_i;
    };
    modes.gcm.prototype.pow = function(x, out) {
      var lsb = x[3] & 1;
      for (var i = 3; i > 0; --i) {
        out[i] = x[i] >>> 1 | (x[i - 1] & 1) << 31;
      }
      out[0] = x[0] >>> 1;
      if (lsb) {
        out[0] ^= this._R;
      }
    };
    modes.gcm.prototype.tableMultiply = function(x) {
      var z = [0, 0, 0, 0];
      for (var i = 0; i < 32; ++i) {
        var idx = i / 8 | 0;
        var x_i = x[idx] >>> (7 - i % 8) * 4 & 15;
        var ah = this._m[i][x_i];
        z[0] ^= ah[0];
        z[1] ^= ah[1];
        z[2] ^= ah[2];
        z[3] ^= ah[3];
      }
      return z;
    };
    modes.gcm.prototype.ghash = function(h, y, x) {
      y[0] ^= x[0];
      y[1] ^= x[1];
      y[2] ^= x[2];
      y[3] ^= x[3];
      return this.tableMultiply(y);
    };
    modes.gcm.prototype.generateHashTable = function(h, bits) {
      var multiplier = 8 / bits;
      var perInt = 4 * multiplier;
      var size = 16 * multiplier;
      var m = new Array(size);
      for (var i = 0; i < size; ++i) {
        var tmp = [0, 0, 0, 0];
        var idx = i / perInt | 0;
        var shft = (perInt - 1 - i % perInt) * bits;
        tmp[idx] = 1 << bits - 1 << shft;
        m[i] = this.generateSubHashTable(this.multiply(tmp, h), bits);
      }
      return m;
    };
    modes.gcm.prototype.generateSubHashTable = function(mid, bits) {
      var size = 1 << bits;
      var half = size >>> 1;
      var m = new Array(size);
      m[half] = mid.slice(0);
      var i = half >>> 1;
      while (i > 0) {
        this.pow(m[2 * i], m[i] = []);
        i >>= 1;
      }
      i = 2;
      while (i < half) {
        for (var j = 1; j < i; ++j) {
          var m_i = m[i];
          var m_j = m[j];
          m[i + j] = [
            m_i[0] ^ m_j[0],
            m_i[1] ^ m_j[1],
            m_i[2] ^ m_j[2],
            m_i[3] ^ m_j[3]
          ];
        }
        i *= 2;
      }
      m[0] = [0, 0, 0, 0];
      for (i = half + 1; i < size; ++i) {
        var c = m[i ^ half];
        m[i] = [mid[0] ^ c[0], mid[1] ^ c[1], mid[2] ^ c[2], mid[3] ^ c[3]];
      }
      return m;
    };
    function transformIV(iv, blockSize) {
      if (typeof iv === "string") {
        iv = forge2.util.createBuffer(iv);
      }
      if (forge2.util.isArray(iv) && iv.length > 4) {
        var tmp = iv;
        iv = forge2.util.createBuffer();
        for (var i = 0; i < tmp.length; ++i) {
          iv.putByte(tmp[i]);
        }
      }
      if (iv.length() < blockSize) {
        throw new Error(
          "Invalid IV length; got " + iv.length() + " bytes and expected " + blockSize + " bytes."
        );
      }
      if (!forge2.util.isArray(iv)) {
        var ints = [];
        var blocks = blockSize / 4;
        for (var i = 0; i < blocks; ++i) {
          ints.push(iv.getInt32());
        }
        iv = ints;
      }
      return iv;
    }
    function inc32(block) {
      block[block.length - 1] = block[block.length - 1] + 1 & 4294967295;
    }
    function from64To32(num) {
      return [num / 4294967296 | 0, num & 4294967295];
    }
  }
});

// node_modules/@selfxyz/common/node_modules/node-forge/lib/aes.js
var require_aes = __commonJS({
  "node_modules/@selfxyz/common/node_modules/node-forge/lib/aes.js"(exports2, module2) {
    var forge2 = require_forge();
    require_cipher();
    require_cipherModes();
    require_util();
    module2.exports = forge2.aes = forge2.aes || {};
    forge2.aes.startEncrypting = function(key2, iv, output, mode) {
      var cipher = _createCipher({
        key: key2,
        output,
        decrypt: false,
        mode
      });
      cipher.start(iv);
      return cipher;
    };
    forge2.aes.createEncryptionCipher = function(key2, mode) {
      return _createCipher({
        key: key2,
        output: null,
        decrypt: false,
        mode
      });
    };
    forge2.aes.startDecrypting = function(key2, iv, output, mode) {
      var cipher = _createCipher({
        key: key2,
        output,
        decrypt: true,
        mode
      });
      cipher.start(iv);
      return cipher;
    };
    forge2.aes.createDecryptionCipher = function(key2, mode) {
      return _createCipher({
        key: key2,
        output: null,
        decrypt: true,
        mode
      });
    };
    forge2.aes.Algorithm = function(name2, mode) {
      if (!init) {
        initialize2();
      }
      var self2 = this;
      self2.name = name2;
      self2.mode = new mode({
        blockSize: 16,
        cipher: {
          encrypt: function(inBlock, outBlock) {
            return _updateBlock(self2._w, inBlock, outBlock, false);
          },
          decrypt: function(inBlock, outBlock) {
            return _updateBlock(self2._w, inBlock, outBlock, true);
          }
        }
      });
      self2._init = false;
    };
    forge2.aes.Algorithm.prototype.initialize = function(options) {
      if (this._init) {
        return;
      }
      var key2 = options.key;
      var tmp;
      if (typeof key2 === "string" && (key2.length === 16 || key2.length === 24 || key2.length === 32)) {
        key2 = forge2.util.createBuffer(key2);
      } else if (forge2.util.isArray(key2) && (key2.length === 16 || key2.length === 24 || key2.length === 32)) {
        tmp = key2;
        key2 = forge2.util.createBuffer();
        for (var i = 0; i < tmp.length; ++i) {
          key2.putByte(tmp[i]);
        }
      }
      if (!forge2.util.isArray(key2)) {
        tmp = key2;
        key2 = [];
        var len = tmp.length();
        if (len === 16 || len === 24 || len === 32) {
          len = len >>> 2;
          for (var i = 0; i < len; ++i) {
            key2.push(tmp.getInt32());
          }
        }
      }
      if (!forge2.util.isArray(key2) || !(key2.length === 4 || key2.length === 6 || key2.length === 8)) {
        throw new Error("Invalid key parameter.");
      }
      var mode = this.mode.name;
      var encryptOp = ["CFB", "OFB", "CTR", "GCM"].indexOf(mode) !== -1;
      this._w = _expandKey(key2, options.decrypt && !encryptOp);
      this._init = true;
    };
    forge2.aes._expandKey = function(key2, decrypt) {
      if (!init) {
        initialize2();
      }
      return _expandKey(key2, decrypt);
    };
    forge2.aes._updateBlock = _updateBlock;
    registerAlgorithm("AES-ECB", forge2.cipher.modes.ecb);
    registerAlgorithm("AES-CBC", forge2.cipher.modes.cbc);
    registerAlgorithm("AES-CFB", forge2.cipher.modes.cfb);
    registerAlgorithm("AES-OFB", forge2.cipher.modes.ofb);
    registerAlgorithm("AES-CTR", forge2.cipher.modes.ctr);
    registerAlgorithm("AES-GCM", forge2.cipher.modes.gcm);
    function registerAlgorithm(name2, mode) {
      var factory = function() {
        return new forge2.aes.Algorithm(name2, mode);
      };
      forge2.cipher.registerAlgorithm(name2, factory);
    }
    var init = false;
    var Nb = 4;
    var sbox;
    var isbox;
    var rcon;
    var mix;
    var imix;
    function initialize2() {
      init = true;
      rcon = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
      var xtime = new Array(256);
      for (var i = 0; i < 128; ++i) {
        xtime[i] = i << 1;
        xtime[i + 128] = i + 128 << 1 ^ 283;
      }
      sbox = new Array(256);
      isbox = new Array(256);
      mix = new Array(4);
      imix = new Array(4);
      for (var i = 0; i < 4; ++i) {
        mix[i] = new Array(256);
        imix[i] = new Array(256);
      }
      var e = 0, ei = 0, e2, e4, e8, sx, sx2, me, ime;
      for (var i = 0; i < 256; ++i) {
        sx = ei ^ ei << 1 ^ ei << 2 ^ ei << 3 ^ ei << 4;
        sx = sx >> 8 ^ sx & 255 ^ 99;
        sbox[e] = sx;
        isbox[sx] = e;
        sx2 = xtime[sx];
        e2 = xtime[e];
        e4 = xtime[e2];
        e8 = xtime[e4];
        me = sx2 << 24 ^ // 2
        sx << 16 ^ // 1
        sx << 8 ^ // 1
        (sx ^ sx2);
        ime = (e2 ^ e4 ^ e8) << 24 ^ // E (14)
        (e ^ e8) << 16 ^ // 9
        (e ^ e4 ^ e8) << 8 ^ // D (13)
        (e ^ e2 ^ e8);
        for (var n = 0; n < 4; ++n) {
          mix[n][e] = me;
          imix[n][sx] = ime;
          me = me << 24 | me >>> 8;
          ime = ime << 24 | ime >>> 8;
        }
        if (e === 0) {
          e = ei = 1;
        } else {
          e = e2 ^ xtime[xtime[xtime[e2 ^ e8]]];
          ei ^= xtime[xtime[ei]];
        }
      }
    }
    function _expandKey(key2, decrypt) {
      var w = key2.slice(0);
      var temp, iNk = 1;
      var Nk = w.length;
      var Nr1 = Nk + 6 + 1;
      var end = Nb * Nr1;
      for (var i = Nk; i < end; ++i) {
        temp = w[i - 1];
        if (i % Nk === 0) {
          temp = sbox[temp >>> 16 & 255] << 24 ^ sbox[temp >>> 8 & 255] << 16 ^ sbox[temp & 255] << 8 ^ sbox[temp >>> 24] ^ rcon[iNk] << 24;
          iNk++;
        } else if (Nk > 6 && i % Nk === 4) {
          temp = sbox[temp >>> 24] << 24 ^ sbox[temp >>> 16 & 255] << 16 ^ sbox[temp >>> 8 & 255] << 8 ^ sbox[temp & 255];
        }
        w[i] = w[i - Nk] ^ temp;
      }
      if (decrypt) {
        var tmp;
        var m0 = imix[0];
        var m1 = imix[1];
        var m2 = imix[2];
        var m3 = imix[3];
        var wnew = w.slice(0);
        end = w.length;
        for (var i = 0, wi = end - Nb; i < end; i += Nb, wi -= Nb) {
          if (i === 0 || i === end - Nb) {
            wnew[i] = w[wi];
            wnew[i + 1] = w[wi + 3];
            wnew[i + 2] = w[wi + 2];
            wnew[i + 3] = w[wi + 1];
          } else {
            for (var n = 0; n < Nb; ++n) {
              tmp = w[wi + n];
              wnew[i + (3 & -n)] = m0[sbox[tmp >>> 24]] ^ m1[sbox[tmp >>> 16 & 255]] ^ m2[sbox[tmp >>> 8 & 255]] ^ m3[sbox[tmp & 255]];
            }
          }
        }
        w = wnew;
      }
      return w;
    }
    function _updateBlock(w, input, output, decrypt) {
      var Nr = w.length / 4 - 1;
      var m0, m1, m2, m3, sub2;
      if (decrypt) {
        m0 = imix[0];
        m1 = imix[1];
        m2 = imix[2];
        m3 = imix[3];
        sub2 = isbox;
      } else {
        m0 = mix[0];
        m1 = mix[1];
        m2 = mix[2];
        m3 = mix[3];
        sub2 = sbox;
      }
      var a, b, c, d, a2, b2, c2;
      a = input[0] ^ w[0];
      b = input[decrypt ? 3 : 1] ^ w[1];
      c = input[2] ^ w[2];
      d = input[decrypt ? 1 : 3] ^ w[3];
      var i = 3;
      for (var round = 1; round < Nr; ++round) {
        a2 = m0[a >>> 24] ^ m1[b >>> 16 & 255] ^ m2[c >>> 8 & 255] ^ m3[d & 255] ^ w[++i];
        b2 = m0[b >>> 24] ^ m1[c >>> 16 & 255] ^ m2[d >>> 8 & 255] ^ m3[a & 255] ^ w[++i];
        c2 = m0[c >>> 24] ^ m1[d >>> 16 & 255] ^ m2[a >>> 8 & 255] ^ m3[b & 255] ^ w[++i];
        d = m0[d >>> 24] ^ m1[a >>> 16 & 255] ^ m2[b >>> 8 & 255] ^ m3[c & 255] ^ w[++i];
        a = a2;
        b = b2;
        c = c2;
      }
      output[0] = sub2[a >>> 24] << 24 ^ sub2[b >>> 16 & 255] << 16 ^ sub2[c >>> 8 & 255] << 8 ^ sub2[d & 255] ^ w[++i];
      output[decrypt ? 3 : 1] = sub2[b >>> 24] << 24 ^ sub2[c >>> 16 & 255] << 16 ^ sub2[d >>> 8 & 255] << 8 ^ sub2[a & 255] ^ w[++i];
      output[2] = sub2[c >>> 24] << 24 ^ sub2[d >>> 16 & 255] << 16 ^ sub2[a >>> 8 & 255] << 8 ^ sub2[b & 255] ^ w[++i];
      output[decrypt ? 1 : 3] = sub2[d >>> 24] << 24 ^ sub2[a >>> 16 & 255] << 16 ^ sub2[b >>> 8 & 255] << 8 ^ sub2[c & 255] ^ w[++i];
    }
    function _createCipher(options) {
      options = options || {};
      var mode = (options.mode || "CBC").toUpperCase();
      var algorithm = "AES-" + mode;
      var cipher;
      if (options.decrypt) {
        cipher = forge2.cipher.createDecipher(algorithm, options.key);
      } else {
        cipher = forge2.cipher.createCipher(algorithm, options.key);
      }
      var start = cipher.start;
      cipher.start = function(iv, options2) {
        var output = null;
        if (options2 instanceof forge2.util.ByteBuffer) {
          output = options2;
          options2 = {};
        }
        options2 = options2 || {};
        options2.output = output;
        options2.iv = iv;
        start.call(cipher, options2);
      };
      return cipher;
    }
  }
});

// node_modules/@selfxyz/common/node_modules/node-forge/lib/oids.js
var require_oids = __commonJS({
  "node_modules/@selfxyz/common/node_modules/node-forge/lib/oids.js"(exports2, module2) {
    var forge2 = require_forge();
    forge2.pki = forge2.pki || {};
    var oids = module2.exports = forge2.pki.oids = forge2.oids = forge2.oids || {};
    function _IN(id, name2) {
      oids[id] = name2;
      oids[name2] = id;
    }
    function _I_(id, name2) {
      oids[id] = name2;
    }
    _IN("1.2.840.113549.1.1.1", "rsaEncryption");
    _IN("1.2.840.113549.1.1.4", "md5WithRSAEncryption");
    _IN("1.2.840.113549.1.1.5", "sha1WithRSAEncryption");
    _IN("1.2.840.113549.1.1.7", "RSAES-OAEP");
    _IN("1.2.840.113549.1.1.8", "mgf1");
    _IN("1.2.840.113549.1.1.9", "pSpecified");
    _IN("1.2.840.113549.1.1.10", "RSASSA-PSS");
    _IN("1.2.840.113549.1.1.11", "sha256WithRSAEncryption");
    _IN("1.2.840.113549.1.1.12", "sha384WithRSAEncryption");
    _IN("1.2.840.113549.1.1.13", "sha512WithRSAEncryption");
    _IN("1.3.101.112", "EdDSA25519");
    _IN("1.2.840.10040.4.3", "dsa-with-sha1");
    _IN("1.3.14.3.2.7", "desCBC");
    _IN("1.3.14.3.2.26", "sha1");
    _IN("1.3.14.3.2.29", "sha1WithRSASignature");
    _IN("2.16.840.1.101.3.4.2.1", "sha256");
    _IN("2.16.840.1.101.3.4.2.2", "sha384");
    _IN("2.16.840.1.101.3.4.2.3", "sha512");
    _IN("2.16.840.1.101.3.4.2.4", "sha224");
    _IN("2.16.840.1.101.3.4.2.5", "sha512-224");
    _IN("2.16.840.1.101.3.4.2.6", "sha512-256");
    _IN("1.2.840.113549.2.2", "md2");
    _IN("1.2.840.113549.2.5", "md5");
    _IN("1.2.840.113549.1.7.1", "data");
    _IN("1.2.840.113549.1.7.2", "signedData");
    _IN("1.2.840.113549.1.7.3", "envelopedData");
    _IN("1.2.840.113549.1.7.4", "signedAndEnvelopedData");
    _IN("1.2.840.113549.1.7.5", "digestedData");
    _IN("1.2.840.113549.1.7.6", "encryptedData");
    _IN("1.2.840.113549.1.9.1", "emailAddress");
    _IN("1.2.840.113549.1.9.2", "unstructuredName");
    _IN("1.2.840.113549.1.9.3", "contentType");
    _IN("1.2.840.113549.1.9.4", "messageDigest");
    _IN("1.2.840.113549.1.9.5", "signingTime");
    _IN("1.2.840.113549.1.9.6", "counterSignature");
    _IN("1.2.840.113549.1.9.7", "challengePassword");
    _IN("1.2.840.113549.1.9.8", "unstructuredAddress");
    _IN("1.2.840.113549.1.9.14", "extensionRequest");
    _IN("1.2.840.113549.1.9.20", "friendlyName");
    _IN("1.2.840.113549.1.9.21", "localKeyId");
    _IN("1.2.840.113549.1.9.22.1", "x509Certificate");
    _IN("1.2.840.113549.1.12.10.1.1", "keyBag");
    _IN("1.2.840.113549.1.12.10.1.2", "pkcs8ShroudedKeyBag");
    _IN("1.2.840.113549.1.12.10.1.3", "certBag");
    _IN("1.2.840.113549.1.12.10.1.4", "crlBag");
    _IN("1.2.840.113549.1.12.10.1.5", "secretBag");
    _IN("1.2.840.113549.1.12.10.1.6", "safeContentsBag");
    _IN("1.2.840.113549.1.5.13", "pkcs5PBES2");
    _IN("1.2.840.113549.1.5.12", "pkcs5PBKDF2");
    _IN("1.2.840.113549.1.12.1.1", "pbeWithSHAAnd128BitRC4");
    _IN("1.2.840.113549.1.12.1.2", "pbeWithSHAAnd40BitRC4");
    _IN("1.2.840.113549.1.12.1.3", "pbeWithSHAAnd3-KeyTripleDES-CBC");
    _IN("1.2.840.113549.1.12.1.4", "pbeWithSHAAnd2-KeyTripleDES-CBC");
    _IN("1.2.840.113549.1.12.1.5", "pbeWithSHAAnd128BitRC2-CBC");
    _IN("1.2.840.113549.1.12.1.6", "pbewithSHAAnd40BitRC2-CBC");
    _IN("1.2.840.113549.2.7", "hmacWithSHA1");
    _IN("1.2.840.113549.2.8", "hmacWithSHA224");
    _IN("1.2.840.113549.2.9", "hmacWithSHA256");
    _IN("1.2.840.113549.2.10", "hmacWithSHA384");
    _IN("1.2.840.113549.2.11", "hmacWithSHA512");
    _IN("1.2.840.113549.3.7", "des-EDE3-CBC");
    _IN("2.16.840.1.101.3.4.1.2", "aes128-CBC");
    _IN("2.16.840.1.101.3.4.1.22", "aes192-CBC");
    _IN("2.16.840.1.101.3.4.1.42", "aes256-CBC");
    _IN("2.5.4.3", "commonName");
    _IN("2.5.4.4", "surname");
    _IN("2.5.4.5", "serialNumber");
    _IN("2.5.4.6", "countryName");
    _IN("2.5.4.7", "localityName");
    _IN("2.5.4.8", "stateOrProvinceName");
    _IN("2.5.4.9", "streetAddress");
    _IN("2.5.4.10", "organizationName");
    _IN("2.5.4.11", "organizationalUnitName");
    _IN("2.5.4.12", "title");
    _IN("2.5.4.13", "description");
    _IN("2.5.4.15", "businessCategory");
    _IN("2.5.4.17", "postalCode");
    _IN("2.5.4.42", "givenName");
    _IN("1.3.6.1.4.1.311.60.2.1.2", "jurisdictionOfIncorporationStateOrProvinceName");
    _IN("1.3.6.1.4.1.311.60.2.1.3", "jurisdictionOfIncorporationCountryName");
    _IN("2.16.840.1.113730.1.1", "nsCertType");
    _IN("2.16.840.1.113730.1.13", "nsComment");
    _I_("2.5.29.1", "authorityKeyIdentifier");
    _I_("2.5.29.2", "keyAttributes");
    _I_("2.5.29.3", "certificatePolicies");
    _I_("2.5.29.4", "keyUsageRestriction");
    _I_("2.5.29.5", "policyMapping");
    _I_("2.5.29.6", "subtreesConstraint");
    _I_("2.5.29.7", "subjectAltName");
    _I_("2.5.29.8", "issuerAltName");
    _I_("2.5.29.9", "subjectDirectoryAttributes");
    _I_("2.5.29.10", "basicConstraints");
    _I_("2.5.29.11", "nameConstraints");
    _I_("2.5.29.12", "policyConstraints");
    _I_("2.5.29.13", "basicConstraints");
    _IN("2.5.29.14", "subjectKeyIdentifier");
    _IN("2.5.29.15", "keyUsage");
    _I_("2.5.29.16", "privateKeyUsagePeriod");
    _IN("2.5.29.17", "subjectAltName");
    _IN("2.5.29.18", "issuerAltName");
    _IN("2.5.29.19", "basicConstraints");
    _I_("2.5.29.20", "cRLNumber");
    _I_("2.5.29.21", "cRLReason");
    _I_("2.5.29.22", "expirationDate");
    _I_("2.5.29.23", "instructionCode");
    _I_("2.5.29.24", "invalidityDate");
    _I_("2.5.29.25", "cRLDistributionPoints");
    _I_("2.5.29.26", "issuingDistributionPoint");
    _I_("2.5.29.27", "deltaCRLIndicator");
    _I_("2.5.29.28", "issuingDistributionPoint");
    _I_("2.5.29.29", "certificateIssuer");
    _I_("2.5.29.30", "nameConstraints");
    _IN("2.5.29.31", "cRLDistributionPoints");
    _IN("2.5.29.32", "certificatePolicies");
    _I_("2.5.29.33", "policyMappings");
    _I_("2.5.29.34", "policyConstraints");
    _IN("2.5.29.35", "authorityKeyIdentifier");
    _I_("2.5.29.36", "policyConstraints");
    _IN("2.5.29.37", "extKeyUsage");
    _I_("2.5.29.46", "freshestCRL");
    _I_("2.5.29.54", "inhibitAnyPolicy");
    _IN("1.3.6.1.4.1.11129.2.4.2", "timestampList");
    _IN("1.3.6.1.5.5.7.1.1", "authorityInfoAccess");
    _IN("1.3.6.1.5.5.7.3.1", "serverAuth");
    _IN("1.3.6.1.5.5.7.3.2", "clientAuth");
    _IN("1.3.6.1.5.5.7.3.3", "codeSigning");
    _IN("1.3.6.1.5.5.7.3.4", "emailProtection");
    _IN("1.3.6.1.5.5.7.3.8", "timeStamping");
  }
});

// node_modules/@selfxyz/common/node_modules/node-forge/lib/asn1.js
var require_asn1 = __commonJS({
  "node_modules/@selfxyz/common/node_modules/node-forge/lib/asn1.js"(exports2, module2) {
    var forge2 = require_forge();
    require_util();
    require_oids();
    var asn1 = module2.exports = forge2.asn1 = forge2.asn1 || {};
    asn1.Class = {
      UNIVERSAL: 0,
      APPLICATION: 64,
      CONTEXT_SPECIFIC: 128,
      PRIVATE: 192
    };
    asn1.Type = {
      NONE: 0,
      BOOLEAN: 1,
      INTEGER: 2,
      BITSTRING: 3,
      OCTETSTRING: 4,
      NULL: 5,
      OID: 6,
      ODESC: 7,
      EXTERNAL: 8,
      REAL: 9,
      ENUMERATED: 10,
      EMBEDDED: 11,
      UTF8: 12,
      ROID: 13,
      SEQUENCE: 16,
      SET: 17,
      PRINTABLESTRING: 19,
      IA5STRING: 22,
      UTCTIME: 23,
      GENERALIZEDTIME: 24,
      BMPSTRING: 30
    };
    asn1.create = function(tagClass, type, constructed, value3, options) {
      if (forge2.util.isArray(value3)) {
        var tmp = [];
        for (var i = 0; i < value3.length; ++i) {
          if (value3[i] !== void 0) {
            tmp.push(value3[i]);
          }
        }
        value3 = tmp;
      }
      var obj = {
        tagClass,
        type,
        constructed,
        composed: constructed || forge2.util.isArray(value3),
        value: value3
      };
      if (options && "bitStringContents" in options) {
        obj.bitStringContents = options.bitStringContents;
        obj.original = asn1.copy(obj);
      }
      return obj;
    };
    asn1.copy = function(obj, options) {
      var copy;
      if (forge2.util.isArray(obj)) {
        copy = [];
        for (var i = 0; i < obj.length; ++i) {
          copy.push(asn1.copy(obj[i], options));
        }
        return copy;
      }
      if (typeof obj === "string") {
        return obj;
      }
      copy = {
        tagClass: obj.tagClass,
        type: obj.type,
        constructed: obj.constructed,
        composed: obj.composed,
        value: asn1.copy(obj.value, options)
      };
      if (options && !options.excludeBitStringContents) {
        copy.bitStringContents = obj.bitStringContents;
      }
      return copy;
    };
    asn1.equals = function(obj1, obj2, options) {
      if (forge2.util.isArray(obj1)) {
        if (!forge2.util.isArray(obj2)) {
          return false;
        }
        if (obj1.length !== obj2.length) {
          return false;
        }
        for (var i = 0; i < obj1.length; ++i) {
          if (!asn1.equals(obj1[i], obj2[i])) {
            return false;
          }
        }
        return true;
      }
      if (typeof obj1 !== typeof obj2) {
        return false;
      }
      if (typeof obj1 === "string") {
        return obj1 === obj2;
      }
      var equal = obj1.tagClass === obj2.tagClass && obj1.type === obj2.type && obj1.constructed === obj2.constructed && obj1.composed === obj2.composed && asn1.equals(obj1.value, obj2.value);
      if (options && options.includeBitStringContents) {
        equal = equal && obj1.bitStringContents === obj2.bitStringContents;
      }
      return equal;
    };
    asn1.getBerValueLength = function(b) {
      var b2 = b.getByte();
      if (b2 === 128) {
        return void 0;
      }
      var length2;
      var longForm = b2 & 128;
      if (!longForm) {
        length2 = b2;
      } else {
        length2 = b.getInt((b2 & 127) << 3);
      }
      return length2;
    };
    function _checkBufferLength(bytes, remaining, n) {
      if (n > remaining) {
        var error = new Error("Too few bytes to parse DER.");
        error.available = bytes.length();
        error.remaining = remaining;
        error.requested = n;
        throw error;
      }
    }
    var _getValueLength = function(bytes, remaining) {
      var b2 = bytes.getByte();
      remaining--;
      if (b2 === 128) {
        return void 0;
      }
      var length2;
      var longForm = b2 & 128;
      if (!longForm) {
        length2 = b2;
      } else {
        var longFormBytes = b2 & 127;
        _checkBufferLength(bytes, remaining, longFormBytes);
        length2 = bytes.getInt(longFormBytes << 3);
      }
      if (length2 < 0) {
        throw new Error("Negative length: " + length2);
      }
      return length2;
    };
    asn1.fromDer = function(bytes, options) {
      if (options === void 0) {
        options = {
          strict: true,
          parseAllBytes: true,
          decodeBitStrings: true
        };
      }
      if (typeof options === "boolean") {
        options = {
          strict: options,
          parseAllBytes: true,
          decodeBitStrings: true
        };
      }
      if (!("strict" in options)) {
        options.strict = true;
      }
      if (!("parseAllBytes" in options)) {
        options.parseAllBytes = true;
      }
      if (!("decodeBitStrings" in options)) {
        options.decodeBitStrings = true;
      }
      if (typeof bytes === "string") {
        bytes = forge2.util.createBuffer(bytes);
      }
      var byteCount = bytes.length();
      var value3 = _fromDer(bytes, bytes.length(), 0, options);
      if (options.parseAllBytes && bytes.length() !== 0) {
        var error = new Error("Unparsed DER bytes remain after ASN.1 parsing.");
        error.byteCount = byteCount;
        error.remaining = bytes.length();
        throw error;
      }
      return value3;
    };
    function _fromDer(bytes, remaining, depth, options) {
      var start;
      _checkBufferLength(bytes, remaining, 2);
      var b1 = bytes.getByte();
      remaining--;
      var tagClass = b1 & 192;
      var type = b1 & 31;
      start = bytes.length();
      var length2 = _getValueLength(bytes, remaining);
      remaining -= start - bytes.length();
      if (length2 !== void 0 && length2 > remaining) {
        if (options.strict) {
          var error = new Error("Too few bytes to read ASN.1 value.");
          error.available = bytes.length();
          error.remaining = remaining;
          error.requested = length2;
          throw error;
        }
        length2 = remaining;
      }
      var value3;
      var bitStringContents;
      var constructed = (b1 & 32) === 32;
      if (constructed) {
        value3 = [];
        if (length2 === void 0) {
          for (; ; ) {
            _checkBufferLength(bytes, remaining, 2);
            if (bytes.bytes(2) === String.fromCharCode(0, 0)) {
              bytes.getBytes(2);
              remaining -= 2;
              break;
            }
            start = bytes.length();
            value3.push(_fromDer(bytes, remaining, depth + 1, options));
            remaining -= start - bytes.length();
          }
        } else {
          while (length2 > 0) {
            start = bytes.length();
            value3.push(_fromDer(bytes, length2, depth + 1, options));
            remaining -= start - bytes.length();
            length2 -= start - bytes.length();
          }
        }
      }
      if (value3 === void 0 && tagClass === asn1.Class.UNIVERSAL && type === asn1.Type.BITSTRING) {
        bitStringContents = bytes.bytes(length2);
      }
      if (value3 === void 0 && options.decodeBitStrings && tagClass === asn1.Class.UNIVERSAL && // FIXME: OCTET STRINGs not yet supported here
      // .. other parts of forge expect to decode OCTET STRINGs manually
      type === asn1.Type.BITSTRING && length2 > 1) {
        var savedRead = bytes.read;
        var savedRemaining = remaining;
        var unused = 0;
        if (type === asn1.Type.BITSTRING) {
          _checkBufferLength(bytes, remaining, 1);
          unused = bytes.getByte();
          remaining--;
        }
        if (unused === 0) {
          try {
            start = bytes.length();
            var subOptions = {
              // enforce strict mode to avoid parsing ASN.1 from plain data
              strict: true,
              decodeBitStrings: true
            };
            var composed = _fromDer(bytes, remaining, depth + 1, subOptions);
            var used = start - bytes.length();
            remaining -= used;
            if (type == asn1.Type.BITSTRING) {
              used++;
            }
            var tc = composed.tagClass;
            if (used === length2 && (tc === asn1.Class.UNIVERSAL || tc === asn1.Class.CONTEXT_SPECIFIC)) {
              value3 = [composed];
            }
          } catch (ex) {
          }
        }
        if (value3 === void 0) {
          bytes.read = savedRead;
          remaining = savedRemaining;
        }
      }
      if (value3 === void 0) {
        if (length2 === void 0) {
          if (options.strict) {
            throw new Error("Non-constructed ASN.1 object of indefinite length.");
          }
          length2 = remaining;
        }
        if (type === asn1.Type.BMPSTRING) {
          value3 = "";
          for (; length2 > 0; length2 -= 2) {
            _checkBufferLength(bytes, remaining, 2);
            value3 += String.fromCharCode(bytes.getInt16());
            remaining -= 2;
          }
        } else {
          value3 = bytes.getBytes(length2);
          remaining -= length2;
        }
      }
      var asn1Options = bitStringContents === void 0 ? null : {
        bitStringContents
      };
      return asn1.create(tagClass, type, constructed, value3, asn1Options);
    }
    asn1.toDer = function(obj) {
      var bytes = forge2.util.createBuffer();
      var b1 = obj.tagClass | obj.type;
      var value3 = forge2.util.createBuffer();
      var useBitStringContents = false;
      if ("bitStringContents" in obj) {
        useBitStringContents = true;
        if (obj.original) {
          useBitStringContents = asn1.equals(obj, obj.original);
        }
      }
      if (useBitStringContents) {
        value3.putBytes(obj.bitStringContents);
      } else if (obj.composed) {
        if (obj.constructed) {
          b1 |= 32;
        } else {
          value3.putByte(0);
        }
        for (var i = 0; i < obj.value.length; ++i) {
          if (obj.value[i] !== void 0) {
            value3.putBuffer(asn1.toDer(obj.value[i]));
          }
        }
      } else {
        if (obj.type === asn1.Type.BMPSTRING) {
          for (var i = 0; i < obj.value.length; ++i) {
            value3.putInt16(obj.value.charCodeAt(i));
          }
        } else {
          if (obj.type === asn1.Type.INTEGER && obj.value.length > 1 && // leading 0x00 for positive integer
          (obj.value.charCodeAt(0) === 0 && (obj.value.charCodeAt(1) & 128) === 0 || // leading 0xFF for negative integer
          obj.value.charCodeAt(0) === 255 && (obj.value.charCodeAt(1) & 128) === 128)) {
            value3.putBytes(obj.value.substr(1));
          } else {
            value3.putBytes(obj.value);
          }
        }
      }
      bytes.putByte(b1);
      if (value3.length() <= 127) {
        bytes.putByte(value3.length() & 127);
      } else {
        var len = value3.length();
        var lenBytes = "";
        do {
          lenBytes += String.fromCharCode(len & 255);
          len = len >>> 8;
        } while (len > 0);
        bytes.putByte(lenBytes.length | 128);
        for (var i = lenBytes.length - 1; i >= 0; --i) {
          bytes.putByte(lenBytes.charCodeAt(i));
        }
      }
      bytes.putBuffer(value3);
      return bytes;
    };
    asn1.oidToDer = function(oid) {
      var values = oid.split(".");
      var bytes = forge2.util.createBuffer();
      bytes.putByte(40 * parseInt(values[0], 10) + parseInt(values[1], 10));
      var last, valueBytes, value3, b;
      for (var i = 2; i < values.length; ++i) {
        last = true;
        valueBytes = [];
        value3 = parseInt(values[i], 10);
        do {
          b = value3 & 127;
          value3 = value3 >>> 7;
          if (!last) {
            b |= 128;
          }
          valueBytes.push(b);
          last = false;
        } while (value3 > 0);
        for (var n = valueBytes.length - 1; n >= 0; --n) {
          bytes.putByte(valueBytes[n]);
        }
      }
      return bytes;
    };
    asn1.derToOid = function(bytes) {
      var oid;
      if (typeof bytes === "string") {
        bytes = forge2.util.createBuffer(bytes);
      }
      var b = bytes.getByte();
      oid = Math.floor(b / 40) + "." + b % 40;
      var value3 = 0;
      while (bytes.length() > 0) {
        b = bytes.getByte();
        value3 = value3 << 7;
        if (b & 128) {
          value3 += b & 127;
        } else {
          oid += "." + (value3 + b);
          value3 = 0;
        }
      }
      return oid;
    };
    asn1.utcTimeToDate = function(utc) {
      var date = /* @__PURE__ */ new Date();
      var year = parseInt(utc.substr(0, 2), 10);
      year = year >= 50 ? 1900 + year : 2e3 + year;
      var MM = parseInt(utc.substr(2, 2), 10) - 1;
      var DD = parseInt(utc.substr(4, 2), 10);
      var hh = parseInt(utc.substr(6, 2), 10);
      var mm = parseInt(utc.substr(8, 2), 10);
      var ss = 0;
      if (utc.length > 11) {
        var c = utc.charAt(10);
        var end = 10;
        if (c !== "+" && c !== "-") {
          ss = parseInt(utc.substr(10, 2), 10);
          end += 2;
        }
      }
      date.setUTCFullYear(year, MM, DD);
      date.setUTCHours(hh, mm, ss, 0);
      if (end) {
        c = utc.charAt(end);
        if (c === "+" || c === "-") {
          var hhoffset = parseInt(utc.substr(end + 1, 2), 10);
          var mmoffset = parseInt(utc.substr(end + 4, 2), 10);
          var offset = hhoffset * 60 + mmoffset;
          offset *= 6e4;
          if (c === "+") {
            date.setTime(+date - offset);
          } else {
            date.setTime(+date + offset);
          }
        }
      }
      return date;
    };
    asn1.generalizedTimeToDate = function(gentime) {
      var date = /* @__PURE__ */ new Date();
      var YYYY = parseInt(gentime.substr(0, 4), 10);
      var MM = parseInt(gentime.substr(4, 2), 10) - 1;
      var DD = parseInt(gentime.substr(6, 2), 10);
      var hh = parseInt(gentime.substr(8, 2), 10);
      var mm = parseInt(gentime.substr(10, 2), 10);
      var ss = parseInt(gentime.substr(12, 2), 10);
      var fff = 0;
      var offset = 0;
      var isUTC = false;
      if (gentime.charAt(gentime.length - 1) === "Z") {
        isUTC = true;
      }
      var end = gentime.length - 5, c = gentime.charAt(end);
      if (c === "+" || c === "-") {
        var hhoffset = parseInt(gentime.substr(end + 1, 2), 10);
        var mmoffset = parseInt(gentime.substr(end + 4, 2), 10);
        offset = hhoffset * 60 + mmoffset;
        offset *= 6e4;
        if (c === "+") {
          offset *= -1;
        }
        isUTC = true;
      }
      if (gentime.charAt(14) === ".") {
        fff = parseFloat(gentime.substr(14), 10) * 1e3;
      }
      if (isUTC) {
        date.setUTCFullYear(YYYY, MM, DD);
        date.setUTCHours(hh, mm, ss, fff);
        date.setTime(+date + offset);
      } else {
        date.setFullYear(YYYY, MM, DD);
        date.setHours(hh, mm, ss, fff);
      }
      return date;
    };
    asn1.dateToUtcTime = function(date) {
      if (typeof date === "string") {
        return date;
      }
      var rval = "";
      var format = [];
      format.push(("" + date.getUTCFullYear()).substr(2));
      format.push("" + (date.getUTCMonth() + 1));
      format.push("" + date.getUTCDate());
      format.push("" + date.getUTCHours());
      format.push("" + date.getUTCMinutes());
      format.push("" + date.getUTCSeconds());
      for (var i = 0; i < format.length; ++i) {
        if (format[i].length < 2) {
          rval += "0";
        }
        rval += format[i];
      }
      rval += "Z";
      return rval;
    };
    asn1.dateToGeneralizedTime = function(date) {
      if (typeof date === "string") {
        return date;
      }
      var rval = "";
      var format = [];
      format.push("" + date.getUTCFullYear());
      format.push("" + (date.getUTCMonth() + 1));
      format.push("" + date.getUTCDate());
      format.push("" + date.getUTCHours());
      format.push("" + date.getUTCMinutes());
      format.push("" + date.getUTCSeconds());
      for (var i = 0; i < format.length; ++i) {
        if (format[i].length < 2) {
          rval += "0";
        }
        rval += format[i];
      }
      rval += "Z";
      return rval;
    };
    asn1.integerToDer = function(x) {
      var rval = forge2.util.createBuffer();
      if (x >= -128 && x < 128) {
        return rval.putSignedInt(x, 8);
      }
      if (x >= -32768 && x < 32768) {
        return rval.putSignedInt(x, 16);
      }
      if (x >= -8388608 && x < 8388608) {
        return rval.putSignedInt(x, 24);
      }
      if (x >= -2147483648 && x < 2147483648) {
        return rval.putSignedInt(x, 32);
      }
      var error = new Error("Integer too large; max is 32-bits.");
      error.integer = x;
      throw error;
    };
    asn1.derToInteger = function(bytes) {
      if (typeof bytes === "string") {
        bytes = forge2.util.createBuffer(bytes);
      }
      var n = bytes.length() * 8;
      if (n > 32) {
        throw new Error("Integer too large; max is 32-bits.");
      }
      return bytes.getSignedInt(n);
    };
    asn1.validate = function(obj, v, capture, errors) {
      var rval = false;
      if ((obj.tagClass === v.tagClass || typeof v.tagClass === "undefined") && (obj.type === v.type || typeof v.type === "undefined")) {
        if (obj.constructed === v.constructed || typeof v.constructed === "undefined") {
          rval = true;
          if (v.value && forge2.util.isArray(v.value)) {
            var j = 0;
            for (var i = 0; rval && i < v.value.length; ++i) {
              rval = v.value[i].optional || false;
              if (obj.value[j]) {
                rval = asn1.validate(obj.value[j], v.value[i], capture, errors);
                if (rval) {
                  ++j;
                } else if (v.value[i].optional) {
                  rval = true;
                }
              }
              if (!rval && errors) {
                errors.push(
                  "[" + v.name + '] Tag class "' + v.tagClass + '", type "' + v.type + '" expected value length "' + v.value.length + '", got "' + obj.value.length + '"'
                );
              }
            }
          }
          if (rval && capture) {
            if (v.capture) {
              capture[v.capture] = obj.value;
            }
            if (v.captureAsn1) {
              capture[v.captureAsn1] = obj;
            }
            if (v.captureBitStringContents && "bitStringContents" in obj) {
              capture[v.captureBitStringContents] = obj.bitStringContents;
            }
            if (v.captureBitStringValue && "bitStringContents" in obj) {
              var value3;
              if (obj.bitStringContents.length < 2) {
                capture[v.captureBitStringValue] = "";
              } else {
                var unused = obj.bitStringContents.charCodeAt(0);
                if (unused !== 0) {
                  throw new Error(
                    "captureBitStringValue only supported for zero unused bits"
                  );
                }
                capture[v.captureBitStringValue] = obj.bitStringContents.slice(1);
              }
            }
          }
        } else if (errors) {
          errors.push(
            "[" + v.name + '] Expected constructed "' + v.constructed + '", got "' + obj.constructed + '"'
          );
        }
      } else if (errors) {
        if (obj.tagClass !== v.tagClass) {
          errors.push(
            "[" + v.name + '] Expected tag class "' + v.tagClass + '", got "' + obj.tagClass + '"'
          );
        }
        if (obj.type !== v.type) {
          errors.push(
            "[" + v.name + '] Expected type "' + v.type + '", got "' + obj.type + '"'
          );
        }
      }
      return rval;
    };
    var _nonLatinRegex = /[^\\u0000-\\u00ff]/;
    asn1.prettyPrint = function(obj, level, indentation) {
      var rval = "";
      level = level || 0;
      indentation = indentation || 2;
      if (level > 0) {
        rval += "\n";
      }
      var indent = "";
      for (var i = 0; i < level * indentation; ++i) {
        indent += " ";
      }
      rval += indent + "Tag: ";
      switch (obj.tagClass) {
        case asn1.Class.UNIVERSAL:
          rval += "Universal:";
          break;
        case asn1.Class.APPLICATION:
          rval += "Application:";
          break;
        case asn1.Class.CONTEXT_SPECIFIC:
          rval += "Context-Specific:";
          break;
        case asn1.Class.PRIVATE:
          rval += "Private:";
          break;
      }
      if (obj.tagClass === asn1.Class.UNIVERSAL) {
        rval += obj.type;
        switch (obj.type) {
          case asn1.Type.NONE:
            rval += " (None)";
            break;
          case asn1.Type.BOOLEAN:
            rval += " (Boolean)";
            break;
          case asn1.Type.INTEGER:
            rval += " (Integer)";
            break;
          case asn1.Type.BITSTRING:
            rval += " (Bit string)";
            break;
          case asn1.Type.OCTETSTRING:
            rval += " (Octet string)";
            break;
          case asn1.Type.NULL:
            rval += " (Null)";
            break;
          case asn1.Type.OID:
            rval += " (Object Identifier)";
            break;
          case asn1.Type.ODESC:
            rval += " (Object Descriptor)";
            break;
          case asn1.Type.EXTERNAL:
            rval += " (External or Instance of)";
            break;
          case asn1.Type.REAL:
            rval += " (Real)";
            break;
          case asn1.Type.ENUMERATED:
            rval += " (Enumerated)";
            break;
          case asn1.Type.EMBEDDED:
            rval += " (Embedded PDV)";
            break;
          case asn1.Type.UTF8:
            rval += " (UTF8)";
            break;
          case asn1.Type.ROID:
            rval += " (Relative Object Identifier)";
            break;
          case asn1.Type.SEQUENCE:
            rval += " (Sequence)";
            break;
          case asn1.Type.SET:
            rval += " (Set)";
            break;
          case asn1.Type.PRINTABLESTRING:
            rval += " (Printable String)";
            break;
          case asn1.Type.IA5String:
            rval += " (IA5String (ASCII))";
            break;
          case asn1.Type.UTCTIME:
            rval += " (UTC time)";
            break;
          case asn1.Type.GENERALIZEDTIME:
            rval += " (Generalized time)";
            break;
          case asn1.Type.BMPSTRING:
            rval += " (BMP String)";
            break;
        }
      } else {
        rval += obj.type;
      }
      rval += "\n";
      rval += indent + "Constructed: " + obj.constructed + "\n";
      if (obj.composed) {
        var subvalues = 0;
        var sub2 = "";
        for (var i = 0; i < obj.value.length; ++i) {
          if (obj.value[i] !== void 0) {
            subvalues += 1;
            sub2 += asn1.prettyPrint(obj.value[i], level + 1, indentation);
            if (i + 1 < obj.value.length) {
              sub2 += ",";
            }
          }
        }
        rval += indent + "Sub values: " + subvalues + sub2;
      } else {
        rval += indent + "Value: ";
        if (obj.type === asn1.Type.OID) {
          var oid = asn1.derToOid(obj.value);
          rval += oid;
          if (forge2.pki && forge2.pki.oids) {
            if (oid in forge2.pki.oids) {
              rval += " (" + forge2.pki.oids[oid] + ") ";
            }
          }
        }
        if (obj.type === asn1.Type.INTEGER) {
          try {
            rval += asn1.derToInteger(obj.value);
          } catch (ex) {
            rval += "0x" + forge2.util.bytesToHex(obj.value);
          }
        } else if (obj.type === asn1.Type.BITSTRING) {
          if (obj.value.length > 1) {
            rval += "0x" + forge2.util.bytesToHex(obj.value.slice(1));
          } else {
            rval += "(none)";
          }
          if (obj.value.length > 0) {
            var unused = obj.value.charCodeAt(0);
            if (unused == 1) {
              rval += " (1 unused bit shown)";
            } else if (unused > 1) {
              rval += " (" + unused + " unused bits shown)";
            }
          }
        } else if (obj.type === asn1.Type.OCTETSTRING) {
          if (!_nonLatinRegex.test(obj.value)) {
            rval += "(" + obj.value + ") ";
          }
          rval += "0x" + forge2.util.bytesToHex(obj.value);
        } else if (obj.type === asn1.Type.UTF8) {
          try {
            rval += forge2.util.decodeUtf8(obj.value);
          } catch (e) {
            if (e.message === "URI malformed") {
              rval += "0x" + forge2.util.bytesToHex(obj.value) + " (malformed UTF8)";
            } else {
              throw e;
            }
          }
        } else if (obj.type === asn1.Type.PRINTABLESTRING || obj.type === asn1.Type.IA5String) {
          rval += obj.value;
        } else if (_nonLatinRegex.test(obj.value)) {
          rval += "0x" + forge2.util.bytesToHex(obj.value);
        } else if (obj.value.length === 0) {
          rval += "[null]";
        } else {
          rval += obj.value;
        }
      }
      return rval;
    };
  }
});

// node_modules/@selfxyz/common/node_modules/node-forge/lib/md.js
var require_md = __commonJS({
  "node_modules/@selfxyz/common/node_modules/node-forge/lib/md.js"(exports2, module2) {
    var forge2 = require_forge();
    module2.exports = forge2.md = forge2.md || {};
    forge2.md.algorithms = forge2.md.algorithms || {};
  }
});

// node_modules/@selfxyz/common/node_modules/node-forge/lib/hmac.js
var require_hmac = __commonJS({
  "node_modules/@selfxyz/common/node_modules/node-forge/lib/hmac.js"(exports2, module2) {
    var forge2 = require_forge();
    require_md();
    require_util();
    var hmac = module2.exports = forge2.hmac = forge2.hmac || {};
    hmac.create = function() {
      var _key = null;
      var _md = null;
      var _ipadding = null;
      var _opadding = null;
      var ctx = {};
      ctx.start = function(md, key2) {
        if (md !== null) {
          if (typeof md === "string") {
            md = md.toLowerCase();
            if (md in forge2.md.algorithms) {
              _md = forge2.md.algorithms[md].create();
            } else {
              throw new Error('Unknown hash algorithm "' + md + '"');
            }
          } else {
            _md = md;
          }
        }
        if (key2 === null) {
          key2 = _key;
        } else {
          if (typeof key2 === "string") {
            key2 = forge2.util.createBuffer(key2);
          } else if (forge2.util.isArray(key2)) {
            var tmp = key2;
            key2 = forge2.util.createBuffer();
            for (var i = 0; i < tmp.length; ++i) {
              key2.putByte(tmp[i]);
            }
          }
          var keylen = key2.length();
          if (keylen > _md.blockLength) {
            _md.start();
            _md.update(key2.bytes());
            key2 = _md.digest();
          }
          _ipadding = forge2.util.createBuffer();
          _opadding = forge2.util.createBuffer();
          keylen = key2.length();
          for (var i = 0; i < keylen; ++i) {
            var tmp = key2.at(i);
            _ipadding.putByte(54 ^ tmp);
            _opadding.putByte(92 ^ tmp);
          }
          if (keylen < _md.blockLength) {
            var tmp = _md.blockLength - keylen;
            for (var i = 0; i < tmp; ++i) {
              _ipadding.putByte(54);
              _opadding.putByte(92);
            }
          }
          _key = key2;
          _ipadding = _ipadding.bytes();
          _opadding = _opadding.bytes();
        }
        _md.start();
        _md.update(_ipadding);
      };
      ctx.update = function(bytes) {
        _md.update(bytes);
      };
      ctx.getMac = function() {
        var inner = _md.digest().bytes();
        _md.start();
        _md.update(_opadding);
        _md.update(inner);
        return _md.digest();
      };
      ctx.digest = ctx.getMac;
      return ctx;
    };
  }
});

// node_modules/@selfxyz/common/node_modules/node-forge/lib/md5.js
var require_md5 = __commonJS({
  "node_modules/@selfxyz/common/node_modules/node-forge/lib/md5.js"(exports2, module2) {
    var forge2 = require_forge();
    require_md();
    require_util();
    var md53 = module2.exports = forge2.md5 = forge2.md5 || {};
    forge2.md.md5 = forge2.md.algorithms.md5 = md53;
    md53.create = function() {
      if (!_initialized) {
        _init();
      }
      var _state = null;
      var _input = forge2.util.createBuffer();
      var _w = new Array(16);
      var md = {
        algorithm: "md5",
        blockLength: 64,
        digestLength: 16,
        // 56-bit length of message so far (does not including padding)
        messageLength: 0,
        // true message length
        fullMessageLength: null,
        // size of message length in bytes
        messageLengthSize: 8
      };
      md.start = function() {
        md.messageLength = 0;
        md.fullMessageLength = md.messageLength64 = [];
        var int32s = md.messageLengthSize / 4;
        for (var i = 0; i < int32s; ++i) {
          md.fullMessageLength.push(0);
        }
        _input = forge2.util.createBuffer();
        _state = {
          h0: 1732584193,
          h1: 4023233417,
          h2: 2562383102,
          h3: 271733878
        };
        return md;
      };
      md.start();
      md.update = function(msg, encoding) {
        if (encoding === "utf8") {
          msg = forge2.util.encodeUtf8(msg);
        }
        var len = msg.length;
        md.messageLength += len;
        len = [len / 4294967296 >>> 0, len >>> 0];
        for (var i = md.fullMessageLength.length - 1; i >= 0; --i) {
          md.fullMessageLength[i] += len[1];
          len[1] = len[0] + (md.fullMessageLength[i] / 4294967296 >>> 0);
          md.fullMessageLength[i] = md.fullMessageLength[i] >>> 0;
          len[0] = len[1] / 4294967296 >>> 0;
        }
        _input.putBytes(msg);
        _update(_state, _w, _input);
        if (_input.read > 2048 || _input.length() === 0) {
          _input.compact();
        }
        return md;
      };
      md.digest = function() {
        var finalBlock = forge2.util.createBuffer();
        finalBlock.putBytes(_input.bytes());
        var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize;
        var overflow = remaining & md.blockLength - 1;
        finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));
        var bits, carry = 0;
        for (var i = md.fullMessageLength.length - 1; i >= 0; --i) {
          bits = md.fullMessageLength[i] * 8 + carry;
          carry = bits / 4294967296 >>> 0;
          finalBlock.putInt32Le(bits >>> 0);
        }
        var s2 = {
          h0: _state.h0,
          h1: _state.h1,
          h2: _state.h2,
          h3: _state.h3
        };
        _update(s2, _w, finalBlock);
        var rval = forge2.util.createBuffer();
        rval.putInt32Le(s2.h0);
        rval.putInt32Le(s2.h1);
        rval.putInt32Le(s2.h2);
        rval.putInt32Le(s2.h3);
        return rval;
      };
      return md;
    };
    var _padding = null;
    var _g = null;
    var _r = null;
    var _k = null;
    var _initialized = false;
    function _init() {
      _padding = String.fromCharCode(128);
      _padding += forge2.util.fillString(String.fromCharCode(0), 64);
      _g = [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        1,
        6,
        11,
        0,
        5,
        10,
        15,
        4,
        9,
        14,
        3,
        8,
        13,
        2,
        7,
        12,
        5,
        8,
        11,
        14,
        1,
        4,
        7,
        10,
        13,
        0,
        3,
        6,
        9,
        12,
        15,
        2,
        0,
        7,
        14,
        5,
        12,
        3,
        10,
        1,
        8,
        15,
        6,
        13,
        4,
        11,
        2,
        9
      ];
      _r = [
        7,
        12,
        17,
        22,
        7,
        12,
        17,
        22,
        7,
        12,
        17,
        22,
        7,
        12,
        17,
        22,
        5,
        9,
        14,
        20,
        5,
        9,
        14,
        20,
        5,
        9,
        14,
        20,
        5,
        9,
        14,
        20,
        4,
        11,
        16,
        23,
        4,
        11,
        16,
        23,
        4,
        11,
        16,
        23,
        4,
        11,
        16,
        23,
        6,
        10,
        15,
        21,
        6,
        10,
        15,
        21,
        6,
        10,
        15,
        21,
        6,
        10,
        15,
        21
      ];
      _k = new Array(64);
      for (var i = 0; i < 64; ++i) {
        _k[i] = Math.floor(Math.abs(Math.sin(i + 1)) * 4294967296);
      }
      _initialized = true;
    }
    function _update(s, w, bytes) {
      var t, a, b, c, d, f3, r, i;
      var len = bytes.length();
      while (len >= 64) {
        a = s.h0;
        b = s.h1;
        c = s.h2;
        d = s.h3;
        for (i = 0; i < 16; ++i) {
          w[i] = bytes.getInt32Le();
          f3 = d ^ b & (c ^ d);
          t = a + f3 + _k[i] + w[i];
          r = _r[i];
          a = d;
          d = c;
          c = b;
          b += t << r | t >>> 32 - r;
        }
        for (; i < 32; ++i) {
          f3 = c ^ d & (b ^ c);
          t = a + f3 + _k[i] + w[_g[i]];
          r = _r[i];
          a = d;
          d = c;
          c = b;
          b += t << r | t >>> 32 - r;
        }
        for (; i < 48; ++i) {
          f3 = b ^ c ^ d;
          t = a + f3 + _k[i] + w[_g[i]];
          r = _r[i];
          a = d;
          d = c;
          c = b;
          b += t << r | t >>> 32 - r;
        }
        for (; i < 64; ++i) {
          f3 = c ^ (b | ~d);
          t = a + f3 + _k[i] + w[_g[i]];
          r = _r[i];
          a = d;
          d = c;
          c = b;
          b += t << r | t >>> 32 - r;
        }
        s.h0 = s.h0 + a | 0;
        s.h1 = s.h1 + b | 0;
        s.h2 = s.h2 + c | 0;
        s.h3 = s.h3 + d | 0;
        len -= 64;
      }
    }
  }
});

// node_modules/@selfxyz/common/node_modules/node-forge/lib/pem.js
var require_pem = __commonJS({
  "node_modules/@selfxyz/common/node_modules/node-forge/lib/pem.js"(exports2, module2) {
    var forge2 = require_forge();
    require_util();
    var pem = module2.exports = forge2.pem = forge2.pem || {};
    pem.encode = function(msg, options) {
      options = options || {};
      var rval = "-----BEGIN " + msg.type + "-----\r\n";
      var header;
      if (msg.procType) {
        header = {
          name: "Proc-Type",
          values: [String(msg.procType.version), msg.procType.type]
        };
        rval += foldHeader(header);
      }
      if (msg.contentDomain) {
        header = { name: "Content-Domain", values: [msg.contentDomain] };
        rval += foldHeader(header);
      }
      if (msg.dekInfo) {
        header = { name: "DEK-Info", values: [msg.dekInfo.algorithm] };
        if (msg.dekInfo.parameters) {
          header.values.push(msg.dekInfo.parameters);
        }
        rval += foldHeader(header);
      }
      if (msg.headers) {
        for (var i = 0; i < msg.headers.length; ++i) {
          rval += foldHeader(msg.headers[i]);
        }
      }
      if (msg.procType) {
        rval += "\r\n";
      }
      rval += forge2.util.encode64(msg.body, options.maxline || 64) + "\r\n";
      rval += "-----END " + msg.type + "-----\r\n";
      return rval;
    };
    pem.decode = function(str) {
      var rval = [];
      var rMessage = /\s*-----BEGIN ([A-Z0-9- ]+)-----\r?\n?([\x21-\x7e\s]+?(?:\r?\n\r?\n))?([:A-Za-z0-9+\/=\s]+?)-----END \1-----/g;
      var rHeader = /([\x21-\x7e]+):\s*([\x21-\x7e\s^:]+)/;
      var rCRLF = /\r?\n/;
      var match;
      while (true) {
        match = rMessage.exec(str);
        if (!match) {
          break;
        }
        var type = match[1];
        if (type === "NEW CERTIFICATE REQUEST") {
          type = "CERTIFICATE REQUEST";
        }
        var msg = {
          type,
          procType: null,
          contentDomain: null,
          dekInfo: null,
          headers: [],
          body: forge2.util.decode64(match[3])
        };
        rval.push(msg);
        if (!match[2]) {
          continue;
        }
        var lines = match[2].split(rCRLF);
        var li = 0;
        while (match && li < lines.length) {
          var line = lines[li].replace(/\s+$/, "");
          for (var nl = li + 1; nl < lines.length; ++nl) {
            var next = lines[nl];
            if (!/\s/.test(next[0])) {
              break;
            }
            line += next;
            li = nl;
          }
          match = line.match(rHeader);
          if (match) {
            var header = { name: match[1], values: [] };
            var values = match[2].split(",");
            for (var vi = 0; vi < values.length; ++vi) {
              header.values.push(ltrim(values[vi]));
            }
            if (!msg.procType) {
              if (header.name !== "Proc-Type") {
                throw new Error('Invalid PEM formatted message. The first encapsulated header must be "Proc-Type".');
              } else if (header.values.length !== 2) {
                throw new Error('Invalid PEM formatted message. The "Proc-Type" header must have two subfields.');
              }
              msg.procType = { version: values[0], type: values[1] };
            } else if (!msg.contentDomain && header.name === "Content-Domain") {
              msg.contentDomain = values[0] || "";
            } else if (!msg.dekInfo && header.name === "DEK-Info") {
              if (header.values.length === 0) {
                throw new Error('Invalid PEM formatted message. The "DEK-Info" header must have at least one subfield.');
              }
              msg.dekInfo = { algorithm: values[0], parameters: values[1] || null };
            } else {
              msg.headers.push(header);
            }
          }
          ++li;
        }
        if (msg.procType === "ENCRYPTED" && !msg.dekInfo) {
          throw new Error('Invalid PEM formatted message. The "DEK-Info" header must be present if "Proc-Type" is "ENCRYPTED".');
        }
      }
      if (rval.length === 0) {
        throw new Error("Invalid PEM formatted message.");
      }
      return rval;
    };
    function foldHeader(header) {
      var rval = header.name + ": ";
      var values = [];
      var insertSpace = function(match, $1) {
        return " " + $1;
      };
      for (var i = 0; i < header.values.length; ++i) {
        values.push(header.values[i].replace(/^(\S+\r\n)/, insertSpace));
      }
      rval += values.join(",") + "\r\n";
      var length2 = 0;
      var candidate = -1;
      for (var i = 0; i < rval.length; ++i, ++length2) {
        if (length2 > 65 && candidate !== -1) {
          var insert = rval[candidate];
          if (insert === ",") {
            ++candidate;
            rval = rval.substr(0, candidate) + "\r\n " + rval.substr(candidate);
          } else {
            rval = rval.substr(0, candidate) + "\r\n" + insert + rval.substr(candidate + 1);
          }
          length2 = i - candidate - 1;
          candidate = -1;
          ++i;
        } else if (rval[i] === " " || rval[i] === "	" || rval[i] === ",") {
          candidate = i;
        }
      }
      return rval;
    }
    function ltrim(str) {
      return str.replace(/^\s+/, "");
    }
  }
});

// node_modules/@selfxyz/common/node_modules/node-forge/lib/des.js
var require_des = __commonJS({
  "node_modules/@selfxyz/common/node_modules/node-forge/lib/des.js"(exports2, module2) {
    var forge2 = require_forge();
    require_cipher();
    require_cipherModes();
    require_util();
    module2.exports = forge2.des = forge2.des || {};
    forge2.des.startEncrypting = function(key2, iv, output, mode) {
      var cipher = _createCipher({
        key: key2,
        output,
        decrypt: false,
        mode: mode || (iv === null ? "ECB" : "CBC")
      });
      cipher.start(iv);
      return cipher;
    };
    forge2.des.createEncryptionCipher = function(key2, mode) {
      return _createCipher({
        key: key2,
        output: null,
        decrypt: false,
        mode
      });
    };
    forge2.des.startDecrypting = function(key2, iv, output, mode) {
      var cipher = _createCipher({
        key: key2,
        output,
        decrypt: true,
        mode: mode || (iv === null ? "ECB" : "CBC")
      });
      cipher.start(iv);
      return cipher;
    };
    forge2.des.createDecryptionCipher = function(key2, mode) {
      return _createCipher({
        key: key2,
        output: null,
        decrypt: true,
        mode
      });
    };
    forge2.des.Algorithm = function(name2, mode) {
      var self2 = this;
      self2.name = name2;
      self2.mode = new mode({
        blockSize: 8,
        cipher: {
          encrypt: function(inBlock, outBlock) {
            return _updateBlock(self2._keys, inBlock, outBlock, false);
          },
          decrypt: function(inBlock, outBlock) {
            return _updateBlock(self2._keys, inBlock, outBlock, true);
          }
        }
      });
      self2._init = false;
    };
    forge2.des.Algorithm.prototype.initialize = function(options) {
      if (this._init) {
        return;
      }
      var key2 = forge2.util.createBuffer(options.key);
      if (this.name.indexOf("3DES") === 0) {
        if (key2.length() !== 24) {
          throw new Error("Invalid Triple-DES key size: " + key2.length() * 8);
        }
      }
      this._keys = _createKeys(key2);
      this._init = true;
    };
    registerAlgorithm("DES-ECB", forge2.cipher.modes.ecb);
    registerAlgorithm("DES-CBC", forge2.cipher.modes.cbc);
    registerAlgorithm("DES-CFB", forge2.cipher.modes.cfb);
    registerAlgorithm("DES-OFB", forge2.cipher.modes.ofb);
    registerAlgorithm("DES-CTR", forge2.cipher.modes.ctr);
    registerAlgorithm("3DES-ECB", forge2.cipher.modes.ecb);
    registerAlgorithm("3DES-CBC", forge2.cipher.modes.cbc);
    registerAlgorithm("3DES-CFB", forge2.cipher.modes.cfb);
    registerAlgorithm("3DES-OFB", forge2.cipher.modes.ofb);
    registerAlgorithm("3DES-CTR", forge2.cipher.modes.ctr);
    function registerAlgorithm(name2, mode) {
      var factory = function() {
        return new forge2.des.Algorithm(name2, mode);
      };
      forge2.cipher.registerAlgorithm(name2, factory);
    }
    var spfunction1 = [16843776, 0, 65536, 16843780, 16842756, 66564, 4, 65536, 1024, 16843776, 16843780, 1024, 16778244, 16842756, 16777216, 4, 1028, 16778240, 16778240, 66560, 66560, 16842752, 16842752, 16778244, 65540, 16777220, 16777220, 65540, 0, 1028, 66564, 16777216, 65536, 16843780, 4, 16842752, 16843776, 16777216, 16777216, 1024, 16842756, 65536, 66560, 16777220, 1024, 4, 16778244, 66564, 16843780, 65540, 16842752, 16778244, 16777220, 1028, 66564, 16843776, 1028, 16778240, 16778240, 0, 65540, 66560, 0, 16842756];
    var spfunction2 = [-2146402272, -2147450880, 32768, 1081376, 1048576, 32, -2146435040, -2147450848, -2147483616, -2146402272, -2146402304, -2147483648, -2147450880, 1048576, 32, -2146435040, 1081344, 1048608, -2147450848, 0, -2147483648, 32768, 1081376, -2146435072, 1048608, -2147483616, 0, 1081344, 32800, -2146402304, -2146435072, 32800, 0, 1081376, -2146435040, 1048576, -2147450848, -2146435072, -2146402304, 32768, -2146435072, -2147450880, 32, -2146402272, 1081376, 32, 32768, -2147483648, 32800, -2146402304, 1048576, -2147483616, 1048608, -2147450848, -2147483616, 1048608, 1081344, 0, -2147450880, 32800, -2147483648, -2146435040, -2146402272, 1081344];
    var spfunction3 = [520, 134349312, 0, 134348808, 134218240, 0, 131592, 134218240, 131080, 134217736, 134217736, 131072, 134349320, 131080, 134348800, 520, 134217728, 8, 134349312, 512, 131584, 134348800, 134348808, 131592, 134218248, 131584, 131072, 134218248, 8, 134349320, 512, 134217728, 134349312, 134217728, 131080, 520, 131072, 134349312, 134218240, 0, 512, 131080, 134349320, 134218240, 134217736, 512, 0, 134348808, 134218248, 131072, 134217728, 134349320, 8, 131592, 131584, 134217736, 134348800, 134218248, 520, 134348800, 131592, 8, 134348808, 131584];
    var spfunction4 = [8396801, 8321, 8321, 128, 8396928, 8388737, 8388609, 8193, 0, 8396800, 8396800, 8396929, 129, 0, 8388736, 8388609, 1, 8192, 8388608, 8396801, 128, 8388608, 8193, 8320, 8388737, 1, 8320, 8388736, 8192, 8396928, 8396929, 129, 8388736, 8388609, 8396800, 8396929, 129, 0, 0, 8396800, 8320, 8388736, 8388737, 1, 8396801, 8321, 8321, 128, 8396929, 129, 1, 8192, 8388609, 8193, 8396928, 8388737, 8193, 8320, 8388608, 8396801, 128, 8388608, 8192, 8396928];
    var spfunction5 = [256, 34078976, 34078720, 1107296512, 524288, 256, 1073741824, 34078720, 1074266368, 524288, 33554688, 1074266368, 1107296512, 1107820544, 524544, 1073741824, 33554432, 1074266112, 1074266112, 0, 1073742080, 1107820800, 1107820800, 33554688, 1107820544, 1073742080, 0, 1107296256, 34078976, 33554432, 1107296256, 524544, 524288, 1107296512, 256, 33554432, 1073741824, 34078720, 1107296512, 1074266368, 33554688, 1073741824, 1107820544, 34078976, 1074266368, 256, 33554432, 1107820544, 1107820800, 524544, 1107296256, 1107820800, 34078720, 0, 1074266112, 1107296256, 524544, 33554688, 1073742080, 524288, 0, 1074266112, 34078976, 1073742080];
    var spfunction6 = [536870928, 541065216, 16384, 541081616, 541065216, 16, 541081616, 4194304, 536887296, 4210704, 4194304, 536870928, 4194320, 536887296, 536870912, 16400, 0, 4194320, 536887312, 16384, 4210688, 536887312, 16, 541065232, 541065232, 0, 4210704, 541081600, 16400, 4210688, 541081600, 536870912, 536887296, 16, 541065232, 4210688, 541081616, 4194304, 16400, 536870928, 4194304, 536887296, 536870912, 16400, 536870928, 541081616, 4210688, 541065216, 4210704, 541081600, 0, 541065232, 16, 16384, 541065216, 4210704, 16384, 4194320, 536887312, 0, 541081600, 536870912, 4194320, 536887312];
    var spfunction7 = [2097152, 69206018, 67110914, 0, 2048, 67110914, 2099202, 69208064, 69208066, 2097152, 0, 67108866, 2, 67108864, 69206018, 2050, 67110912, 2099202, 2097154, 67110912, 67108866, 69206016, 69208064, 2097154, 69206016, 2048, 2050, 69208066, 2099200, 2, 67108864, 2099200, 67108864, 2099200, 2097152, 67110914, 67110914, 69206018, 69206018, 2, 2097154, 67108864, 67110912, 2097152, 69208064, 2050, 2099202, 69208064, 2050, 67108866, 69208066, 69206016, 2099200, 0, 2, 69208066, 0, 2099202, 69206016, 2048, 67108866, 67110912, 2048, 2097154];
    var spfunction8 = [268439616, 4096, 262144, 268701760, 268435456, 268439616, 64, 268435456, 262208, 268697600, 268701760, 266240, 268701696, 266304, 4096, 64, 268697600, 268435520, 268439552, 4160, 266240, 262208, 268697664, 268701696, 4160, 0, 0, 268697664, 268435520, 268439552, 266304, 262144, 266304, 262144, 268701696, 4096, 64, 268697664, 4096, 266304, 268439552, 64, 268435520, 268697600, 268697664, 268435456, 262144, 268439616, 0, 268701760, 262208, 268435520, 268697600, 268439552, 268439616, 0, 268701760, 266240, 266240, 4160, 4160, 262208, 268435456, 268701696];
    function _createKeys(key2) {
      var pc2bytes0 = [0, 4, 536870912, 536870916, 65536, 65540, 536936448, 536936452, 512, 516, 536871424, 536871428, 66048, 66052, 536936960, 536936964], pc2bytes1 = [0, 1, 1048576, 1048577, 67108864, 67108865, 68157440, 68157441, 256, 257, 1048832, 1048833, 67109120, 67109121, 68157696, 68157697], pc2bytes2 = [0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272, 0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272], pc2bytes3 = [0, 2097152, 134217728, 136314880, 8192, 2105344, 134225920, 136323072, 131072, 2228224, 134348800, 136445952, 139264, 2236416, 134356992, 136454144], pc2bytes4 = [0, 262144, 16, 262160, 0, 262144, 16, 262160, 4096, 266240, 4112, 266256, 4096, 266240, 4112, 266256], pc2bytes5 = [0, 1024, 32, 1056, 0, 1024, 32, 1056, 33554432, 33555456, 33554464, 33555488, 33554432, 33555456, 33554464, 33555488], pc2bytes6 = [0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746, 0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746], pc2bytes7 = [0, 65536, 2048, 67584, 536870912, 536936448, 536872960, 536938496, 131072, 196608, 133120, 198656, 537001984, 537067520, 537004032, 537069568], pc2bytes8 = [0, 262144, 0, 262144, 2, 262146, 2, 262146, 33554432, 33816576, 33554432, 33816576, 33554434, 33816578, 33554434, 33816578], pc2bytes9 = [0, 268435456, 8, 268435464, 0, 268435456, 8, 268435464, 1024, 268436480, 1032, 268436488, 1024, 268436480, 1032, 268436488], pc2bytes10 = [0, 32, 0, 32, 1048576, 1048608, 1048576, 1048608, 8192, 8224, 8192, 8224, 1056768, 1056800, 1056768, 1056800], pc2bytes11 = [0, 16777216, 512, 16777728, 2097152, 18874368, 2097664, 18874880, 67108864, 83886080, 67109376, 83886592, 69206016, 85983232, 69206528, 85983744], pc2bytes12 = [0, 4096, 134217728, 134221824, 524288, 528384, 134742016, 134746112, 16, 4112, 134217744, 134221840, 524304, 528400, 134742032, 134746128], pc2bytes13 = [0, 4, 256, 260, 0, 4, 256, 260, 1, 5, 257, 261, 1, 5, 257, 261];
      var iterations = key2.length() > 8 ? 3 : 1;
      var keys = [];
      var shifts = [0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0];
      var n = 0, tmp;
      for (var j = 0; j < iterations; j++) {
        var left2 = key2.getInt32();
        var right2 = key2.getInt32();
        tmp = (left2 >>> 4 ^ right2) & 252645135;
        right2 ^= tmp;
        left2 ^= tmp << 4;
        tmp = (right2 >>> -16 ^ left2) & 65535;
        left2 ^= tmp;
        right2 ^= tmp << -16;
        tmp = (left2 >>> 2 ^ right2) & 858993459;
        right2 ^= tmp;
        left2 ^= tmp << 2;
        tmp = (right2 >>> -16 ^ left2) & 65535;
        left2 ^= tmp;
        right2 ^= tmp << -16;
        tmp = (left2 >>> 1 ^ right2) & 1431655765;
        right2 ^= tmp;
        left2 ^= tmp << 1;
        tmp = (right2 >>> 8 ^ left2) & 16711935;
        left2 ^= tmp;
        right2 ^= tmp << 8;
        tmp = (left2 >>> 1 ^ right2) & 1431655765;
        right2 ^= tmp;
        left2 ^= tmp << 1;
        tmp = left2 << 8 | right2 >>> 20 & 240;
        left2 = right2 << 24 | right2 << 8 & 16711680 | right2 >>> 8 & 65280 | right2 >>> 24 & 240;
        right2 = tmp;
        for (var i = 0; i < shifts.length; ++i) {
          if (shifts[i]) {
            left2 = left2 << 2 | left2 >>> 26;
            right2 = right2 << 2 | right2 >>> 26;
          } else {
            left2 = left2 << 1 | left2 >>> 27;
            right2 = right2 << 1 | right2 >>> 27;
          }
          left2 &= -15;
          right2 &= -15;
          var lefttmp = pc2bytes0[left2 >>> 28] | pc2bytes1[left2 >>> 24 & 15] | pc2bytes2[left2 >>> 20 & 15] | pc2bytes3[left2 >>> 16 & 15] | pc2bytes4[left2 >>> 12 & 15] | pc2bytes5[left2 >>> 8 & 15] | pc2bytes6[left2 >>> 4 & 15];
          var righttmp = pc2bytes7[right2 >>> 28] | pc2bytes8[right2 >>> 24 & 15] | pc2bytes9[right2 >>> 20 & 15] | pc2bytes10[right2 >>> 16 & 15] | pc2bytes11[right2 >>> 12 & 15] | pc2bytes12[right2 >>> 8 & 15] | pc2bytes13[right2 >>> 4 & 15];
          tmp = (righttmp >>> 16 ^ lefttmp) & 65535;
          keys[n++] = lefttmp ^ tmp;
          keys[n++] = righttmp ^ tmp << 16;
        }
      }
      return keys;
    }
    function _updateBlock(keys, input, output, decrypt) {
      var iterations = keys.length === 32 ? 3 : 9;
      var looping;
      if (iterations === 3) {
        looping = decrypt ? [30, -2, -2] : [0, 32, 2];
      } else {
        looping = decrypt ? [94, 62, -2, 32, 64, 2, 30, -2, -2] : [0, 32, 2, 62, 30, -2, 64, 96, 2];
      }
      var tmp;
      var left2 = input[0];
      var right2 = input[1];
      tmp = (left2 >>> 4 ^ right2) & 252645135;
      right2 ^= tmp;
      left2 ^= tmp << 4;
      tmp = (left2 >>> 16 ^ right2) & 65535;
      right2 ^= tmp;
      left2 ^= tmp << 16;
      tmp = (right2 >>> 2 ^ left2) & 858993459;
      left2 ^= tmp;
      right2 ^= tmp << 2;
      tmp = (right2 >>> 8 ^ left2) & 16711935;
      left2 ^= tmp;
      right2 ^= tmp << 8;
      tmp = (left2 >>> 1 ^ right2) & 1431655765;
      right2 ^= tmp;
      left2 ^= tmp << 1;
      left2 = left2 << 1 | left2 >>> 31;
      right2 = right2 << 1 | right2 >>> 31;
      for (var j = 0; j < iterations; j += 3) {
        var endloop = looping[j + 1];
        var loopinc = looping[j + 2];
        for (var i = looping[j]; i != endloop; i += loopinc) {
          var right1 = right2 ^ keys[i];
          var right22 = (right2 >>> 4 | right2 << 28) ^ keys[i + 1];
          tmp = left2;
          left2 = right2;
          right2 = tmp ^ (spfunction2[right1 >>> 24 & 63] | spfunction4[right1 >>> 16 & 63] | spfunction6[right1 >>> 8 & 63] | spfunction8[right1 & 63] | spfunction1[right22 >>> 24 & 63] | spfunction3[right22 >>> 16 & 63] | spfunction5[right22 >>> 8 & 63] | spfunction7[right22 & 63]);
        }
        tmp = left2;
        left2 = right2;
        right2 = tmp;
      }
      left2 = left2 >>> 1 | left2 << 31;
      right2 = right2 >>> 1 | right2 << 31;
      tmp = (left2 >>> 1 ^ right2) & 1431655765;
      right2 ^= tmp;
      left2 ^= tmp << 1;
      tmp = (right2 >>> 8 ^ left2) & 16711935;
      left2 ^= tmp;
      right2 ^= tmp << 8;
      tmp = (right2 >>> 2 ^ left2) & 858993459;
      left2 ^= tmp;
      right2 ^= tmp << 2;
      tmp = (left2 >>> 16 ^ right2) & 65535;
      right2 ^= tmp;
      left2 ^= tmp << 16;
      tmp = (left2 >>> 4 ^ right2) & 252645135;
      right2 ^= tmp;
      left2 ^= tmp << 4;
      output[0] = left2;
      output[1] = right2;
    }
    function _createCipher(options) {
      options = options || {};
      var mode = (options.mode || "CBC").toUpperCase();
      var algorithm = "DES-" + mode;
      var cipher;
      if (options.decrypt) {
        cipher = forge2.cipher.createDecipher(algorithm, options.key);
      } else {
        cipher = forge2.cipher.createCipher(algorithm, options.key);
      }
      var start = cipher.start;
      cipher.start = function(iv, options2) {
        var output = null;
        if (options2 instanceof forge2.util.ByteBuffer) {
          output = options2;
          options2 = {};
        }
        options2 = options2 || {};
        options2.output = output;
        options2.iv = iv;
        start.call(cipher, options2);
      };
      return cipher;
    }
  }
});

// node_modules/@selfxyz/common/node_modules/node-forge/lib/pbkdf2.js
var require_pbkdf2 = __commonJS({
  "node_modules/@selfxyz/common/node_modules/node-forge/lib/pbkdf2.js"(exports2, module2) {
    var forge2 = require_forge();
    require_hmac();
    require_md();
    require_util();
    var pkcs5 = forge2.pkcs5 = forge2.pkcs5 || {};
    var crypto2;
    if (forge2.util.isNodejs && !forge2.options.usePureJavaScript) {
      crypto2 = require_crypto_browserify();
    }
    module2.exports = forge2.pbkdf2 = pkcs5.pbkdf2 = function(p, s, c, dkLen, md, callback) {
      if (typeof md === "function") {
        callback = md;
        md = null;
      }
      if (forge2.util.isNodejs && !forge2.options.usePureJavaScript && crypto2.pbkdf2 && (md === null || typeof md !== "object") && (crypto2.pbkdf2Sync.length > 4 || (!md || md === "sha1"))) {
        if (typeof md !== "string") {
          md = "sha1";
        }
        p = Buffer.from(p, "binary");
        s = Buffer.from(s, "binary");
        if (!callback) {
          if (crypto2.pbkdf2Sync.length === 4) {
            return crypto2.pbkdf2Sync(p, s, c, dkLen).toString("binary");
          }
          return crypto2.pbkdf2Sync(p, s, c, dkLen, md).toString("binary");
        }
        if (crypto2.pbkdf2Sync.length === 4) {
          return crypto2.pbkdf2(p, s, c, dkLen, function(err2, key2) {
            if (err2) {
              return callback(err2);
            }
            callback(null, key2.toString("binary"));
          });
        }
        return crypto2.pbkdf2(p, s, c, dkLen, md, function(err2, key2) {
          if (err2) {
            return callback(err2);
          }
          callback(null, key2.toString("binary"));
        });
      }
      if (typeof md === "undefined" || md === null) {
        md = "sha1";
      }
      if (typeof md === "string") {
        if (!(md in forge2.md.algorithms)) {
          throw new Error("Unknown hash algorithm: " + md);
        }
        md = forge2.md[md].create();
      }
      var hLen = md.digestLength;
      if (dkLen > 4294967295 * hLen) {
        var err = new Error("Derived key is too long.");
        if (callback) {
          return callback(err);
        }
        throw err;
      }
      var len = Math.ceil(dkLen / hLen);
      var r = dkLen - (len - 1) * hLen;
      var prf = forge2.hmac.create();
      prf.start(md, p);
      var dk = "";
      var xor, u_c, u_c1;
      if (!callback) {
        for (var i = 1; i <= len; ++i) {
          prf.start(null, null);
          prf.update(s);
          prf.update(forge2.util.int32ToBytes(i));
          xor = u_c1 = prf.digest().getBytes();
          for (var j = 2; j <= c; ++j) {
            prf.start(null, null);
            prf.update(u_c1);
            u_c = prf.digest().getBytes();
            xor = forge2.util.xorBytes(xor, u_c, hLen);
            u_c1 = u_c;
          }
          dk += i < len ? xor : xor.substr(0, r);
        }
        return dk;
      }
      var i = 1, j;
      function outer() {
        if (i > len) {
          return callback(null, dk);
        }
        prf.start(null, null);
        prf.update(s);
        prf.update(forge2.util.int32ToBytes(i));
        xor = u_c1 = prf.digest().getBytes();
        j = 2;
        inner();
      }
      function inner() {
        if (j <= c) {
          prf.start(null, null);
          prf.update(u_c1);
          u_c = prf.digest().getBytes();
          xor = forge2.util.xorBytes(xor, u_c, hLen);
          u_c1 = u_c;
          ++j;
          return forge2.util.setImmediate(inner);
        }
        dk += i < len ? xor : xor.substr(0, r);
        ++i;
        outer();
      }
      outer();
    };
  }
});

// node_modules/@selfxyz/common/node_modules/node-forge/lib/sha256.js
var require_sha2562 = __commonJS({
  "node_modules/@selfxyz/common/node_modules/node-forge/lib/sha256.js"(exports2, module2) {
    var forge2 = require_forge();
    require_md();
    require_util();
    var sha2562 = module2.exports = forge2.sha256 = forge2.sha256 || {};
    forge2.md.sha256 = forge2.md.algorithms.sha256 = sha2562;
    sha2562.create = function() {
      if (!_initialized) {
        _init();
      }
      var _state = null;
      var _input = forge2.util.createBuffer();
      var _w = new Array(64);
      var md = {
        algorithm: "sha256",
        blockLength: 64,
        digestLength: 32,
        // 56-bit length of message so far (does not including padding)
        messageLength: 0,
        // true message length
        fullMessageLength: null,
        // size of message length in bytes
        messageLengthSize: 8
      };
      md.start = function() {
        md.messageLength = 0;
        md.fullMessageLength = md.messageLength64 = [];
        var int32s = md.messageLengthSize / 4;
        for (var i = 0; i < int32s; ++i) {
          md.fullMessageLength.push(0);
        }
        _input = forge2.util.createBuffer();
        _state = {
          h0: 1779033703,
          h1: 3144134277,
          h2: 1013904242,
          h3: 2773480762,
          h4: 1359893119,
          h5: 2600822924,
          h6: 528734635,
          h7: 1541459225
        };
        return md;
      };
      md.start();
      md.update = function(msg, encoding) {
        if (encoding === "utf8") {
          msg = forge2.util.encodeUtf8(msg);
        }
        var len = msg.length;
        md.messageLength += len;
        len = [len / 4294967296 >>> 0, len >>> 0];
        for (var i = md.fullMessageLength.length - 1; i >= 0; --i) {
          md.fullMessageLength[i] += len[1];
          len[1] = len[0] + (md.fullMessageLength[i] / 4294967296 >>> 0);
          md.fullMessageLength[i] = md.fullMessageLength[i] >>> 0;
          len[0] = len[1] / 4294967296 >>> 0;
        }
        _input.putBytes(msg);
        _update(_state, _w, _input);
        if (_input.read > 2048 || _input.length() === 0) {
          _input.compact();
        }
        return md;
      };
      md.digest = function() {
        var finalBlock = forge2.util.createBuffer();
        finalBlock.putBytes(_input.bytes());
        var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize;
        var overflow = remaining & md.blockLength - 1;
        finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));
        var next, carry;
        var bits = md.fullMessageLength[0] * 8;
        for (var i = 0; i < md.fullMessageLength.length - 1; ++i) {
          next = md.fullMessageLength[i + 1] * 8;
          carry = next / 4294967296 >>> 0;
          bits += carry;
          finalBlock.putInt32(bits >>> 0);
          bits = next >>> 0;
        }
        finalBlock.putInt32(bits);
        var s2 = {
          h0: _state.h0,
          h1: _state.h1,
          h2: _state.h2,
          h3: _state.h3,
          h4: _state.h4,
          h5: _state.h5,
          h6: _state.h6,
          h7: _state.h7
        };
        _update(s2, _w, finalBlock);
        var rval = forge2.util.createBuffer();
        rval.putInt32(s2.h0);
        rval.putInt32(s2.h1);
        rval.putInt32(s2.h2);
        rval.putInt32(s2.h3);
        rval.putInt32(s2.h4);
        rval.putInt32(s2.h5);
        rval.putInt32(s2.h6);
        rval.putInt32(s2.h7);
        return rval;
      };
      return md;
    };
    var _padding = null;
    var _initialized = false;
    var _k = null;
    function _init() {
      _padding = String.fromCharCode(128);
      _padding += forge2.util.fillString(String.fromCharCode(0), 64);
      _k = [
        1116352408,
        1899447441,
        3049323471,
        3921009573,
        961987163,
        1508970993,
        2453635748,
        2870763221,
        3624381080,
        310598401,
        607225278,
        1426881987,
        1925078388,
        2162078206,
        2614888103,
        3248222580,
        3835390401,
        4022224774,
        264347078,
        604807628,
        770255983,
        1249150122,
        1555081692,
        1996064986,
        2554220882,
        2821834349,
        2952996808,
        3210313671,
        3336571891,
        3584528711,
        113926993,
        338241895,
        666307205,
        773529912,
        1294757372,
        1396182291,
        1695183700,
        1986661051,
        2177026350,
        2456956037,
        2730485921,
        2820302411,
        3259730800,
        3345764771,
        3516065817,
        3600352804,
        4094571909,
        275423344,
        430227734,
        506948616,
        659060556,
        883997877,
        958139571,
        1322822218,
        1537002063,
        1747873779,
        1955562222,
        2024104815,
        2227730452,
        2361852424,
        2428436474,
        2756734187,
        3204031479,
        3329325298
      ];
      _initialized = true;
    }
    function _update(s, w, bytes) {
      var t1, t2, s0, s1, ch, maj, i, a, b, c, d, e, f3, g, h;
      var len = bytes.length();
      while (len >= 64) {
        for (i = 0; i < 16; ++i) {
          w[i] = bytes.getInt32();
        }
        for (; i < 64; ++i) {
          t1 = w[i - 2];
          t1 = (t1 >>> 17 | t1 << 15) ^ (t1 >>> 19 | t1 << 13) ^ t1 >>> 10;
          t2 = w[i - 15];
          t2 = (t2 >>> 7 | t2 << 25) ^ (t2 >>> 18 | t2 << 14) ^ t2 >>> 3;
          w[i] = t1 + w[i - 7] + t2 + w[i - 16] | 0;
        }
        a = s.h0;
        b = s.h1;
        c = s.h2;
        d = s.h3;
        e = s.h4;
        f3 = s.h5;
        g = s.h6;
        h = s.h7;
        for (i = 0; i < 64; ++i) {
          s1 = (e >>> 6 | e << 26) ^ (e >>> 11 | e << 21) ^ (e >>> 25 | e << 7);
          ch = g ^ e & (f3 ^ g);
          s0 = (a >>> 2 | a << 30) ^ (a >>> 13 | a << 19) ^ (a >>> 22 | a << 10);
          maj = a & b | c & (a ^ b);
          t1 = h + s1 + ch + _k[i] + w[i];
          t2 = s0 + maj;
          h = g;
          g = f3;
          f3 = e;
          e = d + t1 >>> 0;
          d = c;
          c = b;
          b = a;
          a = t1 + t2 >>> 0;
        }
        s.h0 = s.h0 + a | 0;
        s.h1 = s.h1 + b | 0;
        s.h2 = s.h2 + c | 0;
        s.h3 = s.h3 + d | 0;
        s.h4 = s.h4 + e | 0;
        s.h5 = s.h5 + f3 | 0;
        s.h6 = s.h6 + g | 0;
        s.h7 = s.h7 + h | 0;
        len -= 64;
      }
    }
  }
});

// node_modules/@selfxyz/common/node_modules/node-forge/lib/prng.js
var require_prng = __commonJS({
  "node_modules/@selfxyz/common/node_modules/node-forge/lib/prng.js"(exports2, module2) {
    var forge2 = require_forge();
    require_util();
    var _crypto = null;
    if (forge2.util.isNodejs && !forge2.options.usePureJavaScript && !process.versions["node-webkit"]) {
      _crypto = require_crypto_browserify();
    }
    var prng = module2.exports = forge2.prng = forge2.prng || {};
    prng.create = function(plugin) {
      var ctx = {
        plugin,
        key: null,
        seed: null,
        time: null,
        // number of reseeds so far
        reseeds: 0,
        // amount of data generated so far
        generated: 0,
        // no initial key bytes
        keyBytes: ""
      };
      var md = plugin.md;
      var pools = new Array(32);
      for (var i = 0; i < 32; ++i) {
        pools[i] = md.create();
      }
      ctx.pools = pools;
      ctx.pool = 0;
      ctx.generate = function(count, callback) {
        if (!callback) {
          return ctx.generateSync(count);
        }
        var cipher = ctx.plugin.cipher;
        var increment = ctx.plugin.increment;
        var formatKey = ctx.plugin.formatKey;
        var formatSeed = ctx.plugin.formatSeed;
        var b = forge2.util.createBuffer();
        ctx.key = null;
        generate();
        function generate(err) {
          if (err) {
            return callback(err);
          }
          if (b.length() >= count) {
            return callback(null, b.getBytes(count));
          }
          if (ctx.generated > 1048575) {
            ctx.key = null;
          }
          if (ctx.key === null) {
            return forge2.util.nextTick(function() {
              _reseed(generate);
            });
          }
          var bytes = cipher(ctx.key, ctx.seed);
          ctx.generated += bytes.length;
          b.putBytes(bytes);
          ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed)));
          ctx.seed = formatSeed(cipher(ctx.key, ctx.seed));
          forge2.util.setImmediate(generate);
        }
      };
      ctx.generateSync = function(count) {
        var cipher = ctx.plugin.cipher;
        var increment = ctx.plugin.increment;
        var formatKey = ctx.plugin.formatKey;
        var formatSeed = ctx.plugin.formatSeed;
        ctx.key = null;
        var b = forge2.util.createBuffer();
        while (b.length() < count) {
          if (ctx.generated > 1048575) {
            ctx.key = null;
          }
          if (ctx.key === null) {
            _reseedSync();
          }
          var bytes = cipher(ctx.key, ctx.seed);
          ctx.generated += bytes.length;
          b.putBytes(bytes);
          ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed)));
          ctx.seed = formatSeed(cipher(ctx.key, ctx.seed));
        }
        return b.getBytes(count);
      };
      function _reseed(callback) {
        if (ctx.pools[0].messageLength >= 32) {
          _seed();
          return callback();
        }
        var needed = 32 - ctx.pools[0].messageLength << 5;
        ctx.seedFile(needed, function(err, bytes) {
          if (err) {
            return callback(err);
          }
          ctx.collect(bytes);
          _seed();
          callback();
        });
      }
      function _reseedSync() {
        if (ctx.pools[0].messageLength >= 32) {
          return _seed();
        }
        var needed = 32 - ctx.pools[0].messageLength << 5;
        ctx.collect(ctx.seedFileSync(needed));
        _seed();
      }
      function _seed() {
        ctx.reseeds = ctx.reseeds === 4294967295 ? 0 : ctx.reseeds + 1;
        var md2 = ctx.plugin.md.create();
        md2.update(ctx.keyBytes);
        var _2powK = 1;
        for (var k = 0; k < 32; ++k) {
          if (ctx.reseeds % _2powK === 0) {
            md2.update(ctx.pools[k].digest().getBytes());
            ctx.pools[k].start();
          }
          _2powK = _2powK << 1;
        }
        ctx.keyBytes = md2.digest().getBytes();
        md2.start();
        md2.update(ctx.keyBytes);
        var seedBytes = md2.digest().getBytes();
        ctx.key = ctx.plugin.formatKey(ctx.keyBytes);
        ctx.seed = ctx.plugin.formatSeed(seedBytes);
        ctx.generated = 0;
      }
      function defaultSeedFile(needed) {
        var getRandomValues3 = null;
        var globalScope = forge2.util.globalScope;
        var _crypto2 = globalScope.crypto || globalScope.msCrypto;
        if (_crypto2 && _crypto2.getRandomValues) {
          getRandomValues3 = function(arr) {
            return _crypto2.getRandomValues(arr);
          };
        }
        var b = forge2.util.createBuffer();
        if (getRandomValues3) {
          while (b.length() < needed) {
            var count = Math.max(1, Math.min(needed - b.length(), 65536) / 4);
            var entropy = new Uint32Array(Math.floor(count));
            try {
              getRandomValues3(entropy);
              for (var i2 = 0; i2 < entropy.length; ++i2) {
                b.putInt32(entropy[i2]);
              }
            } catch (e) {
              if (!(typeof QuotaExceededError !== "undefined" && e instanceof QuotaExceededError)) {
                throw e;
              }
            }
          }
        }
        if (b.length() < needed) {
          var hi, lo, next;
          var seed = Math.floor(Math.random() * 65536);
          while (b.length() < needed) {
            lo = 16807 * (seed & 65535);
            hi = 16807 * (seed >> 16);
            lo += (hi & 32767) << 16;
            lo += hi >> 15;
            lo = (lo & 2147483647) + (lo >> 31);
            seed = lo & 4294967295;
            for (var i2 = 0; i2 < 3; ++i2) {
              next = seed >>> (i2 << 3);
              next ^= Math.floor(Math.random() * 256);
              b.putByte(next & 255);
            }
          }
        }
        return b.getBytes(needed);
      }
      if (_crypto) {
        ctx.seedFile = function(needed, callback) {
          _crypto.randomBytes(needed, function(err, bytes) {
            if (err) {
              return callback(err);
            }
            callback(null, bytes.toString());
          });
        };
        ctx.seedFileSync = function(needed) {
          return _crypto.randomBytes(needed).toString();
        };
      } else {
        ctx.seedFile = function(needed, callback) {
          try {
            callback(null, defaultSeedFile(needed));
          } catch (e) {
            callback(e);
          }
        };
        ctx.seedFileSync = defaultSeedFile;
      }
      ctx.collect = function(bytes) {
        var count = bytes.length;
        for (var i2 = 0; i2 < count; ++i2) {
          ctx.pools[ctx.pool].update(bytes.substr(i2, 1));
          ctx.pool = ctx.pool === 31 ? 0 : ctx.pool + 1;
        }
      };
      ctx.collectInt = function(i2, n) {
        var bytes = "";
        for (var x = 0; x < n; x += 8) {
          bytes += String.fromCharCode(i2 >> x & 255);
        }
        ctx.collect(bytes);
      };
      ctx.registerWorker = function(worker) {
        if (worker === self) {
          ctx.seedFile = function(needed, callback) {
            function listener2(e) {
              var data2 = e.data;
              if (data2.forge && data2.forge.prng) {
                self.removeEventListener("message", listener2);
                callback(data2.forge.prng.err, data2.forge.prng.bytes);
              }
            }
            self.addEventListener("message", listener2);
            self.postMessage({ forge: { prng: { needed } } });
          };
        } else {
          var listener = function(e) {
            var data2 = e.data;
            if (data2.forge && data2.forge.prng) {
              ctx.seedFile(data2.forge.prng.needed, function(err, bytes) {
                worker.postMessage({ forge: { prng: { err, bytes } } });
              });
            }
          };
          worker.addEventListener("message", listener);
        }
      };
      return ctx;
    };
  }
});

// node_modules/@selfxyz/common/node_modules/node-forge/lib/random.js
var require_random = __commonJS({
  "node_modules/@selfxyz/common/node_modules/node-forge/lib/random.js"(exports2, module2) {
    var forge2 = require_forge();
    require_aes();
    require_sha2562();
    require_prng();
    require_util();
    (function() {
      if (forge2.random && forge2.random.getBytes) {
        module2.exports = forge2.random;
        return;
      }
      (function(jQuery2) {
        var prng_aes = {};
        var _prng_aes_output = new Array(4);
        var _prng_aes_buffer = forge2.util.createBuffer();
        prng_aes.formatKey = function(key3) {
          var tmp = forge2.util.createBuffer(key3);
          key3 = new Array(4);
          key3[0] = tmp.getInt32();
          key3[1] = tmp.getInt32();
          key3[2] = tmp.getInt32();
          key3[3] = tmp.getInt32();
          return forge2.aes._expandKey(key3, false);
        };
        prng_aes.formatSeed = function(seed) {
          var tmp = forge2.util.createBuffer(seed);
          seed = new Array(4);
          seed[0] = tmp.getInt32();
          seed[1] = tmp.getInt32();
          seed[2] = tmp.getInt32();
          seed[3] = tmp.getInt32();
          return seed;
        };
        prng_aes.cipher = function(key3, seed) {
          forge2.aes._updateBlock(key3, seed, _prng_aes_output, false);
          _prng_aes_buffer.putInt32(_prng_aes_output[0]);
          _prng_aes_buffer.putInt32(_prng_aes_output[1]);
          _prng_aes_buffer.putInt32(_prng_aes_output[2]);
          _prng_aes_buffer.putInt32(_prng_aes_output[3]);
          return _prng_aes_buffer.getBytes();
        };
        prng_aes.increment = function(seed) {
          ++seed[3];
          return seed;
        };
        prng_aes.md = forge2.md.sha256;
        function spawnPrng() {
          var ctx = forge2.prng.create(prng_aes);
          ctx.getBytes = function(count, callback) {
            return ctx.generate(count, callback);
          };
          ctx.getBytesSync = function(count) {
            return ctx.generate(count);
          };
          return ctx;
        }
        var _ctx = spawnPrng();
        var getRandomValues3 = null;
        var globalScope = forge2.util.globalScope;
        var _crypto = globalScope.crypto || globalScope.msCrypto;
        if (_crypto && _crypto.getRandomValues) {
          getRandomValues3 = function(arr) {
            return _crypto.getRandomValues(arr);
          };
        }
        if (forge2.options.usePureJavaScript || !forge2.util.isNodejs && !getRandomValues3) {
          if (typeof window === "undefined" || window.document === void 0) {
          }
          _ctx.collectInt(+/* @__PURE__ */ new Date(), 32);
          if (typeof navigator !== "undefined") {
            var _navBytes = "";
            for (var key2 in navigator) {
              try {
                if (typeof navigator[key2] == "string") {
                  _navBytes += navigator[key2];
                }
              } catch (e) {
              }
            }
            _ctx.collect(_navBytes);
            _navBytes = null;
          }
          if (jQuery2) {
            jQuery2().mousemove(function(e) {
              _ctx.collectInt(e.clientX, 16);
              _ctx.collectInt(e.clientY, 16);
            });
            jQuery2().keypress(function(e) {
              _ctx.collectInt(e.charCode, 8);
            });
          }
        }
        if (!forge2.random) {
          forge2.random = _ctx;
        } else {
          for (var key2 in _ctx) {
            forge2.random[key2] = _ctx[key2];
          }
        }
        forge2.random.createInstance = spawnPrng;
        module2.exports = forge2.random;
      })(typeof jQuery !== "undefined" ? jQuery : null);
    })();
  }
});

// node_modules/@selfxyz/common/node_modules/node-forge/lib/rc2.js
var require_rc2 = __commonJS({
  "node_modules/@selfxyz/common/node_modules/node-forge/lib/rc2.js"(exports2, module2) {
    var forge2 = require_forge();
    require_util();
    var piTable = [
      217,
      120,
      249,
      196,
      25,
      221,
      181,
      237,
      40,
      233,
      253,
      121,
      74,
      160,
      216,
      157,
      198,
      126,
      55,
      131,
      43,
      118,
      83,
      142,
      98,
      76,
      100,
      136,
      68,
      139,
      251,
      162,
      23,
      154,
      89,
      245,
      135,
      179,
      79,
      19,
      97,
      69,
      109,
      141,
      9,
      129,
      125,
      50,
      189,
      143,
      64,
      235,
      134,
      183,
      123,
      11,
      240,
      149,
      33,
      34,
      92,
      107,
      78,
      130,
      84,
      214,
      101,
      147,
      206,
      96,
      178,
      28,
      115,
      86,
      192,
      20,
      167,
      140,
      241,
      220,
      18,
      117,
      202,
      31,
      59,
      190,
      228,
      209,
      66,
      61,
      212,
      48,
      163,
      60,
      182,
      38,
      111,
      191,
      14,
      218,
      70,
      105,
      7,
      87,
      39,
      242,
      29,
      155,
      188,
      148,
      67,
      3,
      248,
      17,
      199,
      246,
      144,
      239,
      62,
      231,
      6,
      195,
      213,
      47,
      200,
      102,
      30,
      215,
      8,
      232,
      234,
      222,
      128,
      82,
      238,
      247,
      132,
      170,
      114,
      172,
      53,
      77,
      106,
      42,
      150,
      26,
      210,
      113,
      90,
      21,
      73,
      116,
      75,
      159,
      208,
      94,
      4,
      24,
      164,
      236,
      194,
      224,
      65,
      110,
      15,
      81,
      203,
      204,
      36,
      145,
      175,
      80,
      161,
      244,
      112,
      57,
      153,
      124,
      58,
      133,
      35,
      184,
      180,
      122,
      252,
      2,
      54,
      91,
      37,
      85,
      151,
      49,
      45,
      93,
      250,
      152,
      227,
      138,
      146,
      174,
      5,
      223,
      41,
      16,
      103,
      108,
      186,
      201,
      211,
      0,
      230,
      207,
      225,
      158,
      168,
      44,
      99,
      22,
      1,
      63,
      88,
      226,
      137,
      169,
      13,
      56,
      52,
      27,
      171,
      51,
      255,
      176,
      187,
      72,
      12,
      95,
      185,
      177,
      205,
      46,
      197,
      243,
      219,
      71,
      229,
      165,
      156,
      119,
      10,
      166,
      32,
      104,
      254,
      127,
      193,
      173
    ];
    var s = [1, 2, 3, 5];
    var rol = function(word, bits) {
      return word << bits & 65535 | (word & 65535) >> 16 - bits;
    };
    var ror = function(word, bits) {
      return (word & 65535) >> bits | word << 16 - bits & 65535;
    };
    module2.exports = forge2.rc2 = forge2.rc2 || {};
    forge2.rc2.expandKey = function(key2, effKeyBits) {
      if (typeof key2 === "string") {
        key2 = forge2.util.createBuffer(key2);
      }
      effKeyBits = effKeyBits || 128;
      var L = key2;
      var T = key2.length();
      var T1 = effKeyBits;
      var T8 = Math.ceil(T1 / 8);
      var TM = 255 >> (T1 & 7);
      var i;
      for (i = T; i < 128; i++) {
        L.putByte(piTable[L.at(i - 1) + L.at(i - T) & 255]);
      }
      L.setAt(128 - T8, piTable[L.at(128 - T8) & TM]);
      for (i = 127 - T8; i >= 0; i--) {
        L.setAt(i, piTable[L.at(i + 1) ^ L.at(i + T8)]);
      }
      return L;
    };
    var createCipher = function(key2, bits, encrypt) {
      var _finish = false, _input = null, _output = null, _iv = null;
      var mixRound, mashRound;
      var i, j, K = [];
      key2 = forge2.rc2.expandKey(key2, bits);
      for (i = 0; i < 64; i++) {
        K.push(key2.getInt16Le());
      }
      if (encrypt) {
        mixRound = function(R) {
          for (i = 0; i < 4; i++) {
            R[i] += K[j] + (R[(i + 3) % 4] & R[(i + 2) % 4]) + (~R[(i + 3) % 4] & R[(i + 1) % 4]);
            R[i] = rol(R[i], s[i]);
            j++;
          }
        };
        mashRound = function(R) {
          for (i = 0; i < 4; i++) {
            R[i] += K[R[(i + 3) % 4] & 63];
          }
        };
      } else {
        mixRound = function(R) {
          for (i = 3; i >= 0; i--) {
            R[i] = ror(R[i], s[i]);
            R[i] -= K[j] + (R[(i + 3) % 4] & R[(i + 2) % 4]) + (~R[(i + 3) % 4] & R[(i + 1) % 4]);
            j--;
          }
        };
        mashRound = function(R) {
          for (i = 3; i >= 0; i--) {
            R[i] -= K[R[(i + 3) % 4] & 63];
          }
        };
      }
      var runPlan = function(plan) {
        var R = [];
        for (i = 0; i < 4; i++) {
          var val2 = _input.getInt16Le();
          if (_iv !== null) {
            if (encrypt) {
              val2 ^= _iv.getInt16Le();
            } else {
              _iv.putInt16Le(val2);
            }
          }
          R.push(val2 & 65535);
        }
        j = encrypt ? 0 : 63;
        for (var ptr = 0; ptr < plan.length; ptr++) {
          for (var ctr = 0; ctr < plan[ptr][0]; ctr++) {
            plan[ptr][1](R);
          }
        }
        for (i = 0; i < 4; i++) {
          if (_iv !== null) {
            if (encrypt) {
              _iv.putInt16Le(R[i]);
            } else {
              R[i] ^= _iv.getInt16Le();
            }
          }
          _output.putInt16Le(R[i]);
        }
      };
      var cipher = null;
      cipher = {
        /**
         * Starts or restarts the encryption or decryption process, whichever
         * was previously configured.
         *
         * To use the cipher in CBC mode, iv may be given either as a string
         * of bytes, or as a byte buffer.  For ECB mode, give null as iv.
         *
         * @param iv the initialization vector to use, null for ECB mode.
         * @param output the output the buffer to write to, null to create one.
         */
        start: function(iv, output) {
          if (iv) {
            if (typeof iv === "string") {
              iv = forge2.util.createBuffer(iv);
            }
          }
          _finish = false;
          _input = forge2.util.createBuffer();
          _output = output || new forge2.util.createBuffer();
          _iv = iv;
          cipher.output = _output;
        },
        /**
         * Updates the next block.
         *
         * @param input the buffer to read from.
         */
        update: function(input) {
          if (!_finish) {
            _input.putBuffer(input);
          }
          while (_input.length() >= 8) {
            runPlan([
              [5, mixRound],
              [1, mashRound],
              [6, mixRound],
              [1, mashRound],
              [5, mixRound]
            ]);
          }
        },
        /**
         * Finishes encrypting or decrypting.
         *
         * @param pad a padding function to use, null for PKCS#7 padding,
         *           signature(blockSize, buffer, decrypt).
         *
         * @return true if successful, false on error.
         */
        finish: function(pad) {
          var rval = true;
          if (encrypt) {
            if (pad) {
              rval = pad(8, _input, !encrypt);
            } else {
              var padding = _input.length() === 8 ? 8 : 8 - _input.length();
              _input.fillWithByte(padding, padding);
            }
          }
          if (rval) {
            _finish = true;
            cipher.update();
          }
          if (!encrypt) {
            rval = _input.length() === 0;
            if (rval) {
              if (pad) {
                rval = pad(8, _output, !encrypt);
              } else {
                var len = _output.length();
                var count = _output.at(len - 1);
                if (count > len) {
                  rval = false;
                } else {
                  _output.truncate(count);
                }
              }
            }
          }
          return rval;
        }
      };
      return cipher;
    };
    forge2.rc2.startEncrypting = function(key2, iv, output) {
      var cipher = forge2.rc2.createEncryptionCipher(key2, 128);
      cipher.start(iv, output);
      return cipher;
    };
    forge2.rc2.createEncryptionCipher = function(key2, bits) {
      return createCipher(key2, bits, true);
    };
    forge2.rc2.startDecrypting = function(key2, iv, output) {
      var cipher = forge2.rc2.createDecryptionCipher(key2, 128);
      cipher.start(iv, output);
      return cipher;
    };
    forge2.rc2.createDecryptionCipher = function(key2, bits) {
      return createCipher(key2, bits, false);
    };
  }
});

// node_modules/@selfxyz/common/node_modules/node-forge/lib/jsbn.js
var require_jsbn = __commonJS({
  "node_modules/@selfxyz/common/node_modules/node-forge/lib/jsbn.js"(exports2, module2) {
    var forge2 = require_forge();
    module2.exports = forge2.jsbn = forge2.jsbn || {};
    var dbits;
    var canary = 244837814094590;
    var j_lm = (canary & 16777215) == 15715070;
    function BigInteger(a, b, c) {
      this.data = [];
      if (a != null)
        if ("number" == typeof a) this.fromNumber(a, b, c);
        else if (b == null && "string" != typeof a) this.fromString(a, 256);
        else this.fromString(a, b);
    }
    forge2.jsbn.BigInteger = BigInteger;
    function nbi() {
      return new BigInteger(null);
    }
    function am1(i, x, w, j, c, n) {
      while (--n >= 0) {
        var v = x * this.data[i++] + w.data[j] + c;
        c = Math.floor(v / 67108864);
        w.data[j++] = v & 67108863;
      }
      return c;
    }
    function am2(i, x, w, j, c, n) {
      var xl = x & 32767, xh = x >> 15;
      while (--n >= 0) {
        var l = this.data[i] & 32767;
        var h = this.data[i++] >> 15;
        var m = xh * l + h * xl;
        l = xl * l + ((m & 32767) << 15) + w.data[j] + (c & 1073741823);
        c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);
        w.data[j++] = l & 1073741823;
      }
      return c;
    }
    function am3(i, x, w, j, c, n) {
      var xl = x & 16383, xh = x >> 14;
      while (--n >= 0) {
        var l = this.data[i] & 16383;
        var h = this.data[i++] >> 14;
        var m = xh * l + h * xl;
        l = xl * l + ((m & 16383) << 14) + w.data[j] + c;
        c = (l >> 28) + (m >> 14) + xh * h;
        w.data[j++] = l & 268435455;
      }
      return c;
    }
    if (typeof navigator === "undefined") {
      BigInteger.prototype.am = am3;
      dbits = 28;
    } else if (j_lm && navigator.appName == "Microsoft Internet Explorer") {
      BigInteger.prototype.am = am2;
      dbits = 30;
    } else if (j_lm && navigator.appName != "Netscape") {
      BigInteger.prototype.am = am1;
      dbits = 26;
    } else {
      BigInteger.prototype.am = am3;
      dbits = 28;
    }
    BigInteger.prototype.DB = dbits;
    BigInteger.prototype.DM = (1 << dbits) - 1;
    BigInteger.prototype.DV = 1 << dbits;
    var BI_FP = 52;
    BigInteger.prototype.FV = Math.pow(2, BI_FP);
    BigInteger.prototype.F1 = BI_FP - dbits;
    BigInteger.prototype.F2 = 2 * dbits - BI_FP;
    var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
    var BI_RC = new Array();
    var rr;
    var vv;
    rr = "0".charCodeAt(0);
    for (vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;
    rr = "a".charCodeAt(0);
    for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;
    rr = "A".charCodeAt(0);
    for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;
    function int2char(n) {
      return BI_RM.charAt(n);
    }
    function intAt(s, i) {
      var c = BI_RC[s.charCodeAt(i)];
      return c == null ? -1 : c;
    }
    function bnpCopyTo(r) {
      for (var i = this.t - 1; i >= 0; --i) r.data[i] = this.data[i];
      r.t = this.t;
      r.s = this.s;
    }
    function bnpFromInt(x) {
      this.t = 1;
      this.s = x < 0 ? -1 : 0;
      if (x > 0) this.data[0] = x;
      else if (x < -1) this.data[0] = x + this.DV;
      else this.t = 0;
    }
    function nbv(i) {
      var r = nbi();
      r.fromInt(i);
      return r;
    }
    function bnpFromString(s, b) {
      var k;
      if (b == 16) k = 4;
      else if (b == 8) k = 3;
      else if (b == 256) k = 8;
      else if (b == 2) k = 1;
      else if (b == 32) k = 5;
      else if (b == 4) k = 2;
      else {
        this.fromRadix(s, b);
        return;
      }
      this.t = 0;
      this.s = 0;
      var i = s.length, mi = false, sh = 0;
      while (--i >= 0) {
        var x = k == 8 ? s[i] & 255 : intAt(s, i);
        if (x < 0) {
          if (s.charAt(i) == "-") mi = true;
          continue;
        }
        mi = false;
        if (sh == 0)
          this.data[this.t++] = x;
        else if (sh + k > this.DB) {
          this.data[this.t - 1] |= (x & (1 << this.DB - sh) - 1) << sh;
          this.data[this.t++] = x >> this.DB - sh;
        } else
          this.data[this.t - 1] |= x << sh;
        sh += k;
        if (sh >= this.DB) sh -= this.DB;
      }
      if (k == 8 && (s[0] & 128) != 0) {
        this.s = -1;
        if (sh > 0) this.data[this.t - 1] |= (1 << this.DB - sh) - 1 << sh;
      }
      this.clamp();
      if (mi) BigInteger.ZERO.subTo(this, this);
    }
    function bnpClamp() {
      var c = this.s & this.DM;
      while (this.t > 0 && this.data[this.t - 1] == c) --this.t;
    }
    function bnToString(b) {
      if (this.s < 0) return "-" + this.negate().toString(b);
      var k;
      if (b == 16) k = 4;
      else if (b == 8) k = 3;
      else if (b == 2) k = 1;
      else if (b == 32) k = 5;
      else if (b == 4) k = 2;
      else return this.toRadix(b);
      var km = (1 << k) - 1, d, m = false, r = "", i = this.t;
      var p = this.DB - i * this.DB % k;
      if (i-- > 0) {
        if (p < this.DB && (d = this.data[i] >> p) > 0) {
          m = true;
          r = int2char(d);
        }
        while (i >= 0) {
          if (p < k) {
            d = (this.data[i] & (1 << p) - 1) << k - p;
            d |= this.data[--i] >> (p += this.DB - k);
          } else {
            d = this.data[i] >> (p -= k) & km;
            if (p <= 0) {
              p += this.DB;
              --i;
            }
          }
          if (d > 0) m = true;
          if (m) r += int2char(d);
        }
      }
      return m ? r : "0";
    }
    function bnNegate() {
      var r = nbi();
      BigInteger.ZERO.subTo(this, r);
      return r;
    }
    function bnAbs() {
      return this.s < 0 ? this.negate() : this;
    }
    function bnCompareTo(a) {
      var r = this.s - a.s;
      if (r != 0) return r;
      var i = this.t;
      r = i - a.t;
      if (r != 0) return this.s < 0 ? -r : r;
      while (--i >= 0) if ((r = this.data[i] - a.data[i]) != 0) return r;
      return 0;
    }
    function nbits(x) {
      var r = 1, t;
      if ((t = x >>> 16) != 0) {
        x = t;
        r += 16;
      }
      if ((t = x >> 8) != 0) {
        x = t;
        r += 8;
      }
      if ((t = x >> 4) != 0) {
        x = t;
        r += 4;
      }
      if ((t = x >> 2) != 0) {
        x = t;
        r += 2;
      }
      if ((t = x >> 1) != 0) {
        x = t;
        r += 1;
      }
      return r;
    }
    function bnBitLength() {
      if (this.t <= 0) return 0;
      return this.DB * (this.t - 1) + nbits(this.data[this.t - 1] ^ this.s & this.DM);
    }
    function bnpDLShiftTo(n, r) {
      var i;
      for (i = this.t - 1; i >= 0; --i) r.data[i + n] = this.data[i];
      for (i = n - 1; i >= 0; --i) r.data[i] = 0;
      r.t = this.t + n;
      r.s = this.s;
    }
    function bnpDRShiftTo(n, r) {
      for (var i = n; i < this.t; ++i) r.data[i - n] = this.data[i];
      r.t = Math.max(this.t - n, 0);
      r.s = this.s;
    }
    function bnpLShiftTo(n, r) {
      var bs = n % this.DB;
      var cbs = this.DB - bs;
      var bm = (1 << cbs) - 1;
      var ds = Math.floor(n / this.DB), c = this.s << bs & this.DM, i;
      for (i = this.t - 1; i >= 0; --i) {
        r.data[i + ds + 1] = this.data[i] >> cbs | c;
        c = (this.data[i] & bm) << bs;
      }
      for (i = ds - 1; i >= 0; --i) r.data[i] = 0;
      r.data[ds] = c;
      r.t = this.t + ds + 1;
      r.s = this.s;
      r.clamp();
    }
    function bnpRShiftTo(n, r) {
      r.s = this.s;
      var ds = Math.floor(n / this.DB);
      if (ds >= this.t) {
        r.t = 0;
        return;
      }
      var bs = n % this.DB;
      var cbs = this.DB - bs;
      var bm = (1 << bs) - 1;
      r.data[0] = this.data[ds] >> bs;
      for (var i = ds + 1; i < this.t; ++i) {
        r.data[i - ds - 1] |= (this.data[i] & bm) << cbs;
        r.data[i - ds] = this.data[i] >> bs;
      }
      if (bs > 0) r.data[this.t - ds - 1] |= (this.s & bm) << cbs;
      r.t = this.t - ds;
      r.clamp();
    }
    function bnpSubTo(a, r) {
      var i = 0, c = 0, m = Math.min(a.t, this.t);
      while (i < m) {
        c += this.data[i] - a.data[i];
        r.data[i++] = c & this.DM;
        c >>= this.DB;
      }
      if (a.t < this.t) {
        c -= a.s;
        while (i < this.t) {
          c += this.data[i];
          r.data[i++] = c & this.DM;
          c >>= this.DB;
        }
        c += this.s;
      } else {
        c += this.s;
        while (i < a.t) {
          c -= a.data[i];
          r.data[i++] = c & this.DM;
          c >>= this.DB;
        }
        c -= a.s;
      }
      r.s = c < 0 ? -1 : 0;
      if (c < -1) r.data[i++] = this.DV + c;
      else if (c > 0) r.data[i++] = c;
      r.t = i;
      r.clamp();
    }
    function bnpMultiplyTo(a, r) {
      var x = this.abs(), y = a.abs();
      var i = x.t;
      r.t = i + y.t;
      while (--i >= 0) r.data[i] = 0;
      for (i = 0; i < y.t; ++i) r.data[i + x.t] = x.am(0, y.data[i], r, i, 0, x.t);
      r.s = 0;
      r.clamp();
      if (this.s != a.s) BigInteger.ZERO.subTo(r, r);
    }
    function bnpSquareTo(r) {
      var x = this.abs();
      var i = r.t = 2 * x.t;
      while (--i >= 0) r.data[i] = 0;
      for (i = 0; i < x.t - 1; ++i) {
        var c = x.am(i, x.data[i], r, 2 * i, 0, 1);
        if ((r.data[i + x.t] += x.am(i + 1, 2 * x.data[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV) {
          r.data[i + x.t] -= x.DV;
          r.data[i + x.t + 1] = 1;
        }
      }
      if (r.t > 0) r.data[r.t - 1] += x.am(i, x.data[i], r, 2 * i, 0, 1);
      r.s = 0;
      r.clamp();
    }
    function bnpDivRemTo(m, q, r) {
      var pm = m.abs();
      if (pm.t <= 0) return;
      var pt = this.abs();
      if (pt.t < pm.t) {
        if (q != null) q.fromInt(0);
        if (r != null) this.copyTo(r);
        return;
      }
      if (r == null) r = nbi();
      var y = nbi(), ts = this.s, ms = m.s;
      var nsh = this.DB - nbits(pm.data[pm.t - 1]);
      if (nsh > 0) {
        pm.lShiftTo(nsh, y);
        pt.lShiftTo(nsh, r);
      } else {
        pm.copyTo(y);
        pt.copyTo(r);
      }
      var ys = y.t;
      var y0 = y.data[ys - 1];
      if (y0 == 0) return;
      var yt = y0 * (1 << this.F1) + (ys > 1 ? y.data[ys - 2] >> this.F2 : 0);
      var d1 = this.FV / yt, d2 = (1 << this.F1) / yt, e = 1 << this.F2;
      var i = r.t, j = i - ys, t = q == null ? nbi() : q;
      y.dlShiftTo(j, t);
      if (r.compareTo(t) >= 0) {
        r.data[r.t++] = 1;
        r.subTo(t, r);
      }
      BigInteger.ONE.dlShiftTo(ys, t);
      t.subTo(y, y);
      while (y.t < ys) y.data[y.t++] = 0;
      while (--j >= 0) {
        var qd = r.data[--i] == y0 ? this.DM : Math.floor(r.data[i] * d1 + (r.data[i - 1] + e) * d2);
        if ((r.data[i] += y.am(0, qd, r, j, 0, ys)) < qd) {
          y.dlShiftTo(j, t);
          r.subTo(t, r);
          while (r.data[i] < --qd) r.subTo(t, r);
        }
      }
      if (q != null) {
        r.drShiftTo(ys, q);
        if (ts != ms) BigInteger.ZERO.subTo(q, q);
      }
      r.t = ys;
      r.clamp();
      if (nsh > 0) r.rShiftTo(nsh, r);
      if (ts < 0) BigInteger.ZERO.subTo(r, r);
    }
    function bnMod(a) {
      var r = nbi();
      this.abs().divRemTo(a, null, r);
      if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r, r);
      return r;
    }
    function Classic(m) {
      this.m = m;
    }
    function cConvert(x) {
      if (x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);
      else return x;
    }
    function cRevert(x) {
      return x;
    }
    function cReduce(x) {
      x.divRemTo(this.m, null, x);
    }
    function cMulTo(x, y, r) {
      x.multiplyTo(y, r);
      this.reduce(r);
    }
    function cSqrTo(x, r) {
      x.squareTo(r);
      this.reduce(r);
    }
    Classic.prototype.convert = cConvert;
    Classic.prototype.revert = cRevert;
    Classic.prototype.reduce = cReduce;
    Classic.prototype.mulTo = cMulTo;
    Classic.prototype.sqrTo = cSqrTo;
    function bnpInvDigit() {
      if (this.t < 1) return 0;
      var x = this.data[0];
      if ((x & 1) == 0) return 0;
      var y = x & 3;
      y = y * (2 - (x & 15) * y) & 15;
      y = y * (2 - (x & 255) * y) & 255;
      y = y * (2 - ((x & 65535) * y & 65535)) & 65535;
      y = y * (2 - x * y % this.DV) % this.DV;
      return y > 0 ? this.DV - y : -y;
    }
    function Montgomery(m) {
      this.m = m;
      this.mp = m.invDigit();
      this.mpl = this.mp & 32767;
      this.mph = this.mp >> 15;
      this.um = (1 << m.DB - 15) - 1;
      this.mt2 = 2 * m.t;
    }
    function montConvert(x) {
      var r = nbi();
      x.abs().dlShiftTo(this.m.t, r);
      r.divRemTo(this.m, null, r);
      if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r, r);
      return r;
    }
    function montRevert(x) {
      var r = nbi();
      x.copyTo(r);
      this.reduce(r);
      return r;
    }
    function montReduce(x) {
      while (x.t <= this.mt2)
        x.data[x.t++] = 0;
      for (var i = 0; i < this.m.t; ++i) {
        var j = x.data[i] & 32767;
        var u0 = j * this.mpl + ((j * this.mph + (x.data[i] >> 15) * this.mpl & this.um) << 15) & x.DM;
        j = i + this.m.t;
        x.data[j] += this.m.am(0, u0, x, i, 0, this.m.t);
        while (x.data[j] >= x.DV) {
          x.data[j] -= x.DV;
          x.data[++j]++;
        }
      }
      x.clamp();
      x.drShiftTo(this.m.t, x);
      if (x.compareTo(this.m) >= 0) x.subTo(this.m, x);
    }
    function montSqrTo(x, r) {
      x.squareTo(r);
      this.reduce(r);
    }
    function montMulTo(x, y, r) {
      x.multiplyTo(y, r);
      this.reduce(r);
    }
    Montgomery.prototype.convert = montConvert;
    Montgomery.prototype.revert = montRevert;
    Montgomery.prototype.reduce = montReduce;
    Montgomery.prototype.mulTo = montMulTo;
    Montgomery.prototype.sqrTo = montSqrTo;
    function bnpIsEven() {
      return (this.t > 0 ? this.data[0] & 1 : this.s) == 0;
    }
    function bnpExp(e, z) {
      if (e > 4294967295 || e < 1) return BigInteger.ONE;
      var r = nbi(), r2 = nbi(), g = z.convert(this), i = nbits(e) - 1;
      g.copyTo(r);
      while (--i >= 0) {
        z.sqrTo(r, r2);
        if ((e & 1 << i) > 0) z.mulTo(r2, g, r);
        else {
          var t = r;
          r = r2;
          r2 = t;
        }
      }
      return z.revert(r);
    }
    function bnModPowInt(e, m) {
      var z;
      if (e < 256 || m.isEven()) z = new Classic(m);
      else z = new Montgomery(m);
      return this.exp(e, z);
    }
    BigInteger.prototype.copyTo = bnpCopyTo;
    BigInteger.prototype.fromInt = bnpFromInt;
    BigInteger.prototype.fromString = bnpFromString;
    BigInteger.prototype.clamp = bnpClamp;
    BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
    BigInteger.prototype.drShiftTo = bnpDRShiftTo;
    BigInteger.prototype.lShiftTo = bnpLShiftTo;
    BigInteger.prototype.rShiftTo = bnpRShiftTo;
    BigInteger.prototype.subTo = bnpSubTo;
    BigInteger.prototype.multiplyTo = bnpMultiplyTo;
    BigInteger.prototype.squareTo = bnpSquareTo;
    BigInteger.prototype.divRemTo = bnpDivRemTo;
    BigInteger.prototype.invDigit = bnpInvDigit;
    BigInteger.prototype.isEven = bnpIsEven;
    BigInteger.prototype.exp = bnpExp;
    BigInteger.prototype.toString = bnToString;
    BigInteger.prototype.negate = bnNegate;
    BigInteger.prototype.abs = bnAbs;
    BigInteger.prototype.compareTo = bnCompareTo;
    BigInteger.prototype.bitLength = bnBitLength;
    BigInteger.prototype.mod = bnMod;
    BigInteger.prototype.modPowInt = bnModPowInt;
    BigInteger.ZERO = nbv(0);
    BigInteger.ONE = nbv(1);
    function bnClone() {
      var r = nbi();
      this.copyTo(r);
      return r;
    }
    function bnIntValue() {
      if (this.s < 0) {
        if (this.t == 1) return this.data[0] - this.DV;
        else if (this.t == 0) return -1;
      } else if (this.t == 1) return this.data[0];
      else if (this.t == 0) return 0;
      return (this.data[1] & (1 << 32 - this.DB) - 1) << this.DB | this.data[0];
    }
    function bnByteValue() {
      return this.t == 0 ? this.s : this.data[0] << 24 >> 24;
    }
    function bnShortValue() {
      return this.t == 0 ? this.s : this.data[0] << 16 >> 16;
    }
    function bnpChunkSize(r) {
      return Math.floor(Math.LN2 * this.DB / Math.log(r));
    }
    function bnSigNum() {
      if (this.s < 0) return -1;
      else if (this.t <= 0 || this.t == 1 && this.data[0] <= 0) return 0;
      else return 1;
    }
    function bnpToRadix(b) {
      if (b == null) b = 10;
      if (this.signum() == 0 || b < 2 || b > 36) return "0";
      var cs = this.chunkSize(b);
      var a = Math.pow(b, cs);
      var d = nbv(a), y = nbi(), z = nbi(), r = "";
      this.divRemTo(d, y, z);
      while (y.signum() > 0) {
        r = (a + z.intValue()).toString(b).substr(1) + r;
        y.divRemTo(d, y, z);
      }
      return z.intValue().toString(b) + r;
    }
    function bnpFromRadix(s, b) {
      this.fromInt(0);
      if (b == null) b = 10;
      var cs = this.chunkSize(b);
      var d = Math.pow(b, cs), mi = false, j = 0, w = 0;
      for (var i = 0; i < s.length; ++i) {
        var x = intAt(s, i);
        if (x < 0) {
          if (s.charAt(i) == "-" && this.signum() == 0) mi = true;
          continue;
        }
        w = b * w + x;
        if (++j >= cs) {
          this.dMultiply(d);
          this.dAddOffset(w, 0);
          j = 0;
          w = 0;
        }
      }
      if (j > 0) {
        this.dMultiply(Math.pow(b, j));
        this.dAddOffset(w, 0);
      }
      if (mi) BigInteger.ZERO.subTo(this, this);
    }
    function bnpFromNumber(a, b, c) {
      if ("number" == typeof b) {
        if (a < 2) this.fromInt(1);
        else {
          this.fromNumber(a, c);
          if (!this.testBit(a - 1))
            this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);
          if (this.isEven()) this.dAddOffset(1, 0);
          while (!this.isProbablePrime(b)) {
            this.dAddOffset(2, 0);
            if (this.bitLength() > a) this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);
          }
        }
      } else {
        var x = new Array(), t = a & 7;
        x.length = (a >> 3) + 1;
        b.nextBytes(x);
        if (t > 0) x[0] &= (1 << t) - 1;
        else x[0] = 0;
        this.fromString(x, 256);
      }
    }
    function bnToByteArray() {
      var i = this.t, r = new Array();
      r[0] = this.s;
      var p = this.DB - i * this.DB % 8, d, k = 0;
      if (i-- > 0) {
        if (p < this.DB && (d = this.data[i] >> p) != (this.s & this.DM) >> p)
          r[k++] = d | this.s << this.DB - p;
        while (i >= 0) {
          if (p < 8) {
            d = (this.data[i] & (1 << p) - 1) << 8 - p;
            d |= this.data[--i] >> (p += this.DB - 8);
          } else {
            d = this.data[i] >> (p -= 8) & 255;
            if (p <= 0) {
              p += this.DB;
              --i;
            }
          }
          if ((d & 128) != 0) d |= -256;
          if (k == 0 && (this.s & 128) != (d & 128)) ++k;
          if (k > 0 || d != this.s) r[k++] = d;
        }
      }
      return r;
    }
    function bnEquals(a) {
      return this.compareTo(a) == 0;
    }
    function bnMin(a) {
      return this.compareTo(a) < 0 ? this : a;
    }
    function bnMax(a) {
      return this.compareTo(a) > 0 ? this : a;
    }
    function bnpBitwiseTo(a, op, r) {
      var i, f3, m = Math.min(a.t, this.t);
      for (i = 0; i < m; ++i) r.data[i] = op(this.data[i], a.data[i]);
      if (a.t < this.t) {
        f3 = a.s & this.DM;
        for (i = m; i < this.t; ++i) r.data[i] = op(this.data[i], f3);
        r.t = this.t;
      } else {
        f3 = this.s & this.DM;
        for (i = m; i < a.t; ++i) r.data[i] = op(f3, a.data[i]);
        r.t = a.t;
      }
      r.s = op(this.s, a.s);
      r.clamp();
    }
    function op_and(x, y) {
      return x & y;
    }
    function bnAnd(a) {
      var r = nbi();
      this.bitwiseTo(a, op_and, r);
      return r;
    }
    function op_or(x, y) {
      return x | y;
    }
    function bnOr(a) {
      var r = nbi();
      this.bitwiseTo(a, op_or, r);
      return r;
    }
    function op_xor(x, y) {
      return x ^ y;
    }
    function bnXor(a) {
      var r = nbi();
      this.bitwiseTo(a, op_xor, r);
      return r;
    }
    function op_andnot(x, y) {
      return x & ~y;
    }
    function bnAndNot(a) {
      var r = nbi();
      this.bitwiseTo(a, op_andnot, r);
      return r;
    }
    function bnNot() {
      var r = nbi();
      for (var i = 0; i < this.t; ++i) r.data[i] = this.DM & ~this.data[i];
      r.t = this.t;
      r.s = ~this.s;
      return r;
    }
    function bnShiftLeft(n) {
      var r = nbi();
      if (n < 0) this.rShiftTo(-n, r);
      else this.lShiftTo(n, r);
      return r;
    }
    function bnShiftRight(n) {
      var r = nbi();
      if (n < 0) this.lShiftTo(-n, r);
      else this.rShiftTo(n, r);
      return r;
    }
    function lbit(x) {
      if (x == 0) return -1;
      var r = 0;
      if ((x & 65535) == 0) {
        x >>= 16;
        r += 16;
      }
      if ((x & 255) == 0) {
        x >>= 8;
        r += 8;
      }
      if ((x & 15) == 0) {
        x >>= 4;
        r += 4;
      }
      if ((x & 3) == 0) {
        x >>= 2;
        r += 2;
      }
      if ((x & 1) == 0) ++r;
      return r;
    }
    function bnGetLowestSetBit() {
      for (var i = 0; i < this.t; ++i)
        if (this.data[i] != 0) return i * this.DB + lbit(this.data[i]);
      if (this.s < 0) return this.t * this.DB;
      return -1;
    }
    function cbit(x) {
      var r = 0;
      while (x != 0) {
        x &= x - 1;
        ++r;
      }
      return r;
    }
    function bnBitCount() {
      var r = 0, x = this.s & this.DM;
      for (var i = 0; i < this.t; ++i) r += cbit(this.data[i] ^ x);
      return r;
    }
    function bnTestBit(n) {
      var j = Math.floor(n / this.DB);
      if (j >= this.t) return this.s != 0;
      return (this.data[j] & 1 << n % this.DB) != 0;
    }
    function bnpChangeBit(n, op) {
      var r = BigInteger.ONE.shiftLeft(n);
      this.bitwiseTo(r, op, r);
      return r;
    }
    function bnSetBit(n) {
      return this.changeBit(n, op_or);
    }
    function bnClearBit(n) {
      return this.changeBit(n, op_andnot);
    }
    function bnFlipBit(n) {
      return this.changeBit(n, op_xor);
    }
    function bnpAddTo(a, r) {
      var i = 0, c = 0, m = Math.min(a.t, this.t);
      while (i < m) {
        c += this.data[i] + a.data[i];
        r.data[i++] = c & this.DM;
        c >>= this.DB;
      }
      if (a.t < this.t) {
        c += a.s;
        while (i < this.t) {
          c += this.data[i];
          r.data[i++] = c & this.DM;
          c >>= this.DB;
        }
        c += this.s;
      } else {
        c += this.s;
        while (i < a.t) {
          c += a.data[i];
          r.data[i++] = c & this.DM;
          c >>= this.DB;
        }
        c += a.s;
      }
      r.s = c < 0 ? -1 : 0;
      if (c > 0) r.data[i++] = c;
      else if (c < -1) r.data[i++] = this.DV + c;
      r.t = i;
      r.clamp();
    }
    function bnAdd(a) {
      var r = nbi();
      this.addTo(a, r);
      return r;
    }
    function bnSubtract(a) {
      var r = nbi();
      this.subTo(a, r);
      return r;
    }
    function bnMultiply(a) {
      var r = nbi();
      this.multiplyTo(a, r);
      return r;
    }
    function bnDivide(a) {
      var r = nbi();
      this.divRemTo(a, r, null);
      return r;
    }
    function bnRemainder(a) {
      var r = nbi();
      this.divRemTo(a, null, r);
      return r;
    }
    function bnDivideAndRemainder(a) {
      var q = nbi(), r = nbi();
      this.divRemTo(a, q, r);
      return new Array(q, r);
    }
    function bnpDMultiply(n) {
      this.data[this.t] = this.am(0, n - 1, this, 0, 0, this.t);
      ++this.t;
      this.clamp();
    }
    function bnpDAddOffset(n, w) {
      if (n == 0) return;
      while (this.t <= w) this.data[this.t++] = 0;
      this.data[w] += n;
      while (this.data[w] >= this.DV) {
        this.data[w] -= this.DV;
        if (++w >= this.t) this.data[this.t++] = 0;
        ++this.data[w];
      }
    }
    function NullExp() {
    }
    function nNop(x) {
      return x;
    }
    function nMulTo(x, y, r) {
      x.multiplyTo(y, r);
    }
    function nSqrTo(x, r) {
      x.squareTo(r);
    }
    NullExp.prototype.convert = nNop;
    NullExp.prototype.revert = nNop;
    NullExp.prototype.mulTo = nMulTo;
    NullExp.prototype.sqrTo = nSqrTo;
    function bnPow(e) {
      return this.exp(e, new NullExp());
    }
    function bnpMultiplyLowerTo(a, n, r) {
      var i = Math.min(this.t + a.t, n);
      r.s = 0;
      r.t = i;
      while (i > 0) r.data[--i] = 0;
      var j;
      for (j = r.t - this.t; i < j; ++i) r.data[i + this.t] = this.am(0, a.data[i], r, i, 0, this.t);
      for (j = Math.min(a.t, n); i < j; ++i) this.am(0, a.data[i], r, i, 0, n - i);
      r.clamp();
    }
    function bnpMultiplyUpperTo(a, n, r) {
      --n;
      var i = r.t = this.t + a.t - n;
      r.s = 0;
      while (--i >= 0) r.data[i] = 0;
      for (i = Math.max(n - this.t, 0); i < a.t; ++i)
        r.data[this.t + i - n] = this.am(n - i, a.data[i], r, 0, 0, this.t + i - n);
      r.clamp();
      r.drShiftTo(1, r);
    }
    function Barrett(m) {
      this.r2 = nbi();
      this.q3 = nbi();
      BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);
      this.mu = this.r2.divide(m);
      this.m = m;
    }
    function barrettConvert(x) {
      if (x.s < 0 || x.t > 2 * this.m.t) return x.mod(this.m);
      else if (x.compareTo(this.m) < 0) return x;
      else {
        var r = nbi();
        x.copyTo(r);
        this.reduce(r);
        return r;
      }
    }
    function barrettRevert(x) {
      return x;
    }
    function barrettReduce(x) {
      x.drShiftTo(this.m.t - 1, this.r2);
      if (x.t > this.m.t + 1) {
        x.t = this.m.t + 1;
        x.clamp();
      }
      this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
      this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
      while (x.compareTo(this.r2) < 0) x.dAddOffset(1, this.m.t + 1);
      x.subTo(this.r2, x);
      while (x.compareTo(this.m) >= 0) x.subTo(this.m, x);
    }
    function barrettSqrTo(x, r) {
      x.squareTo(r);
      this.reduce(r);
    }
    function barrettMulTo(x, y, r) {
      x.multiplyTo(y, r);
      this.reduce(r);
    }
    Barrett.prototype.convert = barrettConvert;
    Barrett.prototype.revert = barrettRevert;
    Barrett.prototype.reduce = barrettReduce;
    Barrett.prototype.mulTo = barrettMulTo;
    Barrett.prototype.sqrTo = barrettSqrTo;
    function bnModPow(e, m) {
      var i = e.bitLength(), k, r = nbv(1), z;
      if (i <= 0) return r;
      else if (i < 18) k = 1;
      else if (i < 48) k = 3;
      else if (i < 144) k = 4;
      else if (i < 768) k = 5;
      else k = 6;
      if (i < 8)
        z = new Classic(m);
      else if (m.isEven())
        z = new Barrett(m);
      else
        z = new Montgomery(m);
      var g = new Array(), n = 3, k1 = k - 1, km = (1 << k) - 1;
      g[1] = z.convert(this);
      if (k > 1) {
        var g2 = nbi();
        z.sqrTo(g[1], g2);
        while (n <= km) {
          g[n] = nbi();
          z.mulTo(g2, g[n - 2], g[n]);
          n += 2;
        }
      }
      var j = e.t - 1, w, is1 = true, r2 = nbi(), t;
      i = nbits(e.data[j]) - 1;
      while (j >= 0) {
        if (i >= k1) w = e.data[j] >> i - k1 & km;
        else {
          w = (e.data[j] & (1 << i + 1) - 1) << k1 - i;
          if (j > 0) w |= e.data[j - 1] >> this.DB + i - k1;
        }
        n = k;
        while ((w & 1) == 0) {
          w >>= 1;
          --n;
        }
        if ((i -= n) < 0) {
          i += this.DB;
          --j;
        }
        if (is1) {
          g[w].copyTo(r);
          is1 = false;
        } else {
          while (n > 1) {
            z.sqrTo(r, r2);
            z.sqrTo(r2, r);
            n -= 2;
          }
          if (n > 0) z.sqrTo(r, r2);
          else {
            t = r;
            r = r2;
            r2 = t;
          }
          z.mulTo(r2, g[w], r);
        }
        while (j >= 0 && (e.data[j] & 1 << i) == 0) {
          z.sqrTo(r, r2);
          t = r;
          r = r2;
          r2 = t;
          if (--i < 0) {
            i = this.DB - 1;
            --j;
          }
        }
      }
      return z.revert(r);
    }
    function bnGCD(a) {
      var x = this.s < 0 ? this.negate() : this.clone();
      var y = a.s < 0 ? a.negate() : a.clone();
      if (x.compareTo(y) < 0) {
        var t = x;
        x = y;
        y = t;
      }
      var i = x.getLowestSetBit(), g = y.getLowestSetBit();
      if (g < 0) return x;
      if (i < g) g = i;
      if (g > 0) {
        x.rShiftTo(g, x);
        y.rShiftTo(g, y);
      }
      while (x.signum() > 0) {
        if ((i = x.getLowestSetBit()) > 0) x.rShiftTo(i, x);
        if ((i = y.getLowestSetBit()) > 0) y.rShiftTo(i, y);
        if (x.compareTo(y) >= 0) {
          x.subTo(y, x);
          x.rShiftTo(1, x);
        } else {
          y.subTo(x, y);
          y.rShiftTo(1, y);
        }
      }
      if (g > 0) y.lShiftTo(g, y);
      return y;
    }
    function bnpModInt(n) {
      if (n <= 0) return 0;
      var d = this.DV % n, r = this.s < 0 ? n - 1 : 0;
      if (this.t > 0)
        if (d == 0) r = this.data[0] % n;
        else for (var i = this.t - 1; i >= 0; --i) r = (d * r + this.data[i]) % n;
      return r;
    }
    function bnModInverse(m) {
      var ac = m.isEven();
      if (this.isEven() && ac || m.signum() == 0) return BigInteger.ZERO;
      var u = m.clone(), v = this.clone();
      var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);
      while (u.signum() != 0) {
        while (u.isEven()) {
          u.rShiftTo(1, u);
          if (ac) {
            if (!a.isEven() || !b.isEven()) {
              a.addTo(this, a);
              b.subTo(m, b);
            }
            a.rShiftTo(1, a);
          } else if (!b.isEven()) b.subTo(m, b);
          b.rShiftTo(1, b);
        }
        while (v.isEven()) {
          v.rShiftTo(1, v);
          if (ac) {
            if (!c.isEven() || !d.isEven()) {
              c.addTo(this, c);
              d.subTo(m, d);
            }
            c.rShiftTo(1, c);
          } else if (!d.isEven()) d.subTo(m, d);
          d.rShiftTo(1, d);
        }
        if (u.compareTo(v) >= 0) {
          u.subTo(v, u);
          if (ac) a.subTo(c, a);
          b.subTo(d, b);
        } else {
          v.subTo(u, v);
          if (ac) c.subTo(a, c);
          d.subTo(b, d);
        }
      }
      if (v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;
      if (d.compareTo(m) >= 0) return d.subtract(m);
      if (d.signum() < 0) d.addTo(m, d);
      else return d;
      if (d.signum() < 0) return d.add(m);
      else return d;
    }
    var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509];
    var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];
    function bnIsProbablePrime(t) {
      var i, x = this.abs();
      if (x.t == 1 && x.data[0] <= lowprimes[lowprimes.length - 1]) {
        for (i = 0; i < lowprimes.length; ++i)
          if (x.data[0] == lowprimes[i]) return true;
        return false;
      }
      if (x.isEven()) return false;
      i = 1;
      while (i < lowprimes.length) {
        var m = lowprimes[i], j = i + 1;
        while (j < lowprimes.length && m < lplim) m *= lowprimes[j++];
        m = x.modInt(m);
        while (i < j) if (m % lowprimes[i++] == 0) return false;
      }
      return x.millerRabin(t);
    }
    function bnpMillerRabin(t) {
      var n1 = this.subtract(BigInteger.ONE);
      var k = n1.getLowestSetBit();
      if (k <= 0) return false;
      var r = n1.shiftRight(k);
      var prng = bnGetPrng();
      var a;
      for (var i = 0; i < t; ++i) {
        do {
          a = new BigInteger(this.bitLength(), prng);
        } while (a.compareTo(BigInteger.ONE) <= 0 || a.compareTo(n1) >= 0);
        var y = a.modPow(r, this);
        if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {
          var j = 1;
          while (j++ < k && y.compareTo(n1) != 0) {
            y = y.modPowInt(2, this);
            if (y.compareTo(BigInteger.ONE) == 0) return false;
          }
          if (y.compareTo(n1) != 0) return false;
        }
      }
      return true;
    }
    function bnGetPrng() {
      return {
        // x is an array to fill with bytes
        nextBytes: function(x) {
          for (var i = 0; i < x.length; ++i) {
            x[i] = Math.floor(Math.random() * 256);
          }
        }
      };
    }
    BigInteger.prototype.chunkSize = bnpChunkSize;
    BigInteger.prototype.toRadix = bnpToRadix;
    BigInteger.prototype.fromRadix = bnpFromRadix;
    BigInteger.prototype.fromNumber = bnpFromNumber;
    BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
    BigInteger.prototype.changeBit = bnpChangeBit;
    BigInteger.prototype.addTo = bnpAddTo;
    BigInteger.prototype.dMultiply = bnpDMultiply;
    BigInteger.prototype.dAddOffset = bnpDAddOffset;
    BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
    BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
    BigInteger.prototype.modInt = bnpModInt;
    BigInteger.prototype.millerRabin = bnpMillerRabin;
    BigInteger.prototype.clone = bnClone;
    BigInteger.prototype.intValue = bnIntValue;
    BigInteger.prototype.byteValue = bnByteValue;
    BigInteger.prototype.shortValue = bnShortValue;
    BigInteger.prototype.signum = bnSigNum;
    BigInteger.prototype.toByteArray = bnToByteArray;
    BigInteger.prototype.equals = bnEquals;
    BigInteger.prototype.min = bnMin;
    BigInteger.prototype.max = bnMax;
    BigInteger.prototype.and = bnAnd;
    BigInteger.prototype.or = bnOr;
    BigInteger.prototype.xor = bnXor;
    BigInteger.prototype.andNot = bnAndNot;
    BigInteger.prototype.not = bnNot;
    BigInteger.prototype.shiftLeft = bnShiftLeft;
    BigInteger.prototype.shiftRight = bnShiftRight;
    BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
    BigInteger.prototype.bitCount = bnBitCount;
    BigInteger.prototype.testBit = bnTestBit;
    BigInteger.prototype.setBit = bnSetBit;
    BigInteger.prototype.clearBit = bnClearBit;
    BigInteger.prototype.flipBit = bnFlipBit;
    BigInteger.prototype.add = bnAdd;
    BigInteger.prototype.subtract = bnSubtract;
    BigInteger.prototype.multiply = bnMultiply;
    BigInteger.prototype.divide = bnDivide;
    BigInteger.prototype.remainder = bnRemainder;
    BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
    BigInteger.prototype.modPow = bnModPow;
    BigInteger.prototype.modInverse = bnModInverse;
    BigInteger.prototype.pow = bnPow;
    BigInteger.prototype.gcd = bnGCD;
    BigInteger.prototype.isProbablePrime = bnIsProbablePrime;
  }
});

// node_modules/@selfxyz/common/node_modules/node-forge/lib/sha1.js
var require_sha12 = __commonJS({
  "node_modules/@selfxyz/common/node_modules/node-forge/lib/sha1.js"(exports2, module2) {
    var forge2 = require_forge();
    require_md();
    require_util();
    var sha14 = module2.exports = forge2.sha1 = forge2.sha1 || {};
    forge2.md.sha1 = forge2.md.algorithms.sha1 = sha14;
    sha14.create = function() {
      if (!_initialized) {
        _init();
      }
      var _state = null;
      var _input = forge2.util.createBuffer();
      var _w = new Array(80);
      var md = {
        algorithm: "sha1",
        blockLength: 64,
        digestLength: 20,
        // 56-bit length of message so far (does not including padding)
        messageLength: 0,
        // true message length
        fullMessageLength: null,
        // size of message length in bytes
        messageLengthSize: 8
      };
      md.start = function() {
        md.messageLength = 0;
        md.fullMessageLength = md.messageLength64 = [];
        var int32s = md.messageLengthSize / 4;
        for (var i = 0; i < int32s; ++i) {
          md.fullMessageLength.push(0);
        }
        _input = forge2.util.createBuffer();
        _state = {
          h0: 1732584193,
          h1: 4023233417,
          h2: 2562383102,
          h3: 271733878,
          h4: 3285377520
        };
        return md;
      };
      md.start();
      md.update = function(msg, encoding) {
        if (encoding === "utf8") {
          msg = forge2.util.encodeUtf8(msg);
        }
        var len = msg.length;
        md.messageLength += len;
        len = [len / 4294967296 >>> 0, len >>> 0];
        for (var i = md.fullMessageLength.length - 1; i >= 0; --i) {
          md.fullMessageLength[i] += len[1];
          len[1] = len[0] + (md.fullMessageLength[i] / 4294967296 >>> 0);
          md.fullMessageLength[i] = md.fullMessageLength[i] >>> 0;
          len[0] = len[1] / 4294967296 >>> 0;
        }
        _input.putBytes(msg);
        _update(_state, _w, _input);
        if (_input.read > 2048 || _input.length() === 0) {
          _input.compact();
        }
        return md;
      };
      md.digest = function() {
        var finalBlock = forge2.util.createBuffer();
        finalBlock.putBytes(_input.bytes());
        var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize;
        var overflow = remaining & md.blockLength - 1;
        finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));
        var next, carry;
        var bits = md.fullMessageLength[0] * 8;
        for (var i = 0; i < md.fullMessageLength.length - 1; ++i) {
          next = md.fullMessageLength[i + 1] * 8;
          carry = next / 4294967296 >>> 0;
          bits += carry;
          finalBlock.putInt32(bits >>> 0);
          bits = next >>> 0;
        }
        finalBlock.putInt32(bits);
        var s2 = {
          h0: _state.h0,
          h1: _state.h1,
          h2: _state.h2,
          h3: _state.h3,
          h4: _state.h4
        };
        _update(s2, _w, finalBlock);
        var rval = forge2.util.createBuffer();
        rval.putInt32(s2.h0);
        rval.putInt32(s2.h1);
        rval.putInt32(s2.h2);
        rval.putInt32(s2.h3);
        rval.putInt32(s2.h4);
        return rval;
      };
      return md;
    };
    var _padding = null;
    var _initialized = false;
    function _init() {
      _padding = String.fromCharCode(128);
      _padding += forge2.util.fillString(String.fromCharCode(0), 64);
      _initialized = true;
    }
    function _update(s, w, bytes) {
      var t, a, b, c, d, e, f3, i;
      var len = bytes.length();
      while (len >= 64) {
        a = s.h0;
        b = s.h1;
        c = s.h2;
        d = s.h3;
        e = s.h4;
        for (i = 0; i < 16; ++i) {
          t = bytes.getInt32();
          w[i] = t;
          f3 = d ^ b & (c ^ d);
          t = (a << 5 | a >>> 27) + f3 + e + 1518500249 + t;
          e = d;
          d = c;
          c = (b << 30 | b >>> 2) >>> 0;
          b = a;
          a = t;
        }
        for (; i < 20; ++i) {
          t = w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16];
          t = t << 1 | t >>> 31;
          w[i] = t;
          f3 = d ^ b & (c ^ d);
          t = (a << 5 | a >>> 27) + f3 + e + 1518500249 + t;
          e = d;
          d = c;
          c = (b << 30 | b >>> 2) >>> 0;
          b = a;
          a = t;
        }
        for (; i < 32; ++i) {
          t = w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16];
          t = t << 1 | t >>> 31;
          w[i] = t;
          f3 = b ^ c ^ d;
          t = (a << 5 | a >>> 27) + f3 + e + 1859775393 + t;
          e = d;
          d = c;
          c = (b << 30 | b >>> 2) >>> 0;
          b = a;
          a = t;
        }
        for (; i < 40; ++i) {
          t = w[i - 6] ^ w[i - 16] ^ w[i - 28] ^ w[i - 32];
          t = t << 2 | t >>> 30;
          w[i] = t;
          f3 = b ^ c ^ d;
          t = (a << 5 | a >>> 27) + f3 + e + 1859775393 + t;
          e = d;
          d = c;
          c = (b << 30 | b >>> 2) >>> 0;
          b = a;
          a = t;
        }
        for (; i < 60; ++i) {
          t = w[i - 6] ^ w[i - 16] ^ w[i - 28] ^ w[i - 32];
          t = t << 2 | t >>> 30;
          w[i] = t;
          f3 = b & c | d & (b ^ c);
          t = (a << 5 | a >>> 27) + f3 + e + 2400959708 + t;
          e = d;
          d = c;
          c = (b << 30 | b >>> 2) >>> 0;
          b = a;
          a = t;
        }
        for (; i < 80; ++i) {
          t = w[i - 6] ^ w[i - 16] ^ w[i - 28] ^ w[i - 32];
          t = t << 2 | t >>> 30;
          w[i] = t;
          f3 = b ^ c ^ d;
          t = (a << 5 | a >>> 27) + f3 + e + 3395469782 + t;
          e = d;
          d = c;
          c = (b << 30 | b >>> 2) >>> 0;
          b = a;
          a = t;
        }
        s.h0 = s.h0 + a | 0;
        s.h1 = s.h1 + b | 0;
        s.h2 = s.h2 + c | 0;
        s.h3 = s.h3 + d | 0;
        s.h4 = s.h4 + e | 0;
        len -= 64;
      }
    }
  }
});

// node_modules/@selfxyz/common/node_modules/node-forge/lib/pkcs1.js
var require_pkcs1 = __commonJS({
  "node_modules/@selfxyz/common/node_modules/node-forge/lib/pkcs1.js"(exports2, module2) {
    var forge2 = require_forge();
    require_util();
    require_random();
    require_sha12();
    var pkcs1 = module2.exports = forge2.pkcs1 = forge2.pkcs1 || {};
    pkcs1.encode_rsa_oaep = function(key2, message, options) {
      var label;
      var seed;
      var md;
      var mgf1Md;
      if (typeof options === "string") {
        label = options;
        seed = arguments[3] || void 0;
        md = arguments[4] || void 0;
      } else if (options) {
        label = options.label || void 0;
        seed = options.seed || void 0;
        md = options.md || void 0;
        if (options.mgf1 && options.mgf1.md) {
          mgf1Md = options.mgf1.md;
        }
      }
      if (!md) {
        md = forge2.md.sha1.create();
      } else {
        md.start();
      }
      if (!mgf1Md) {
        mgf1Md = md;
      }
      var keyLength = Math.ceil(key2.n.bitLength() / 8);
      var maxLength = keyLength - 2 * md.digestLength - 2;
      if (message.length > maxLength) {
        var error = new Error("RSAES-OAEP input message length is too long.");
        error.length = message.length;
        error.maxLength = maxLength;
        throw error;
      }
      if (!label) {
        label = "";
      }
      md.update(label, "raw");
      var lHash = md.digest();
      var PS = "";
      var PS_length = maxLength - message.length;
      for (var i = 0; i < PS_length; i++) {
        PS += "\0";
      }
      var DB = lHash.getBytes() + PS + "" + message;
      if (!seed) {
        seed = forge2.random.getBytes(md.digestLength);
      } else if (seed.length !== md.digestLength) {
        var error = new Error("Invalid RSAES-OAEP seed. The seed length must match the digest length.");
        error.seedLength = seed.length;
        error.digestLength = md.digestLength;
        throw error;
      }
      var dbMask = rsa_mgf1(seed, keyLength - md.digestLength - 1, mgf1Md);
      var maskedDB = forge2.util.xorBytes(DB, dbMask, DB.length);
      var seedMask = rsa_mgf1(maskedDB, md.digestLength, mgf1Md);
      var maskedSeed = forge2.util.xorBytes(seed, seedMask, seed.length);
      return "\0" + maskedSeed + maskedDB;
    };
    pkcs1.decode_rsa_oaep = function(key2, em, options) {
      var label;
      var md;
      var mgf1Md;
      if (typeof options === "string") {
        label = options;
        md = arguments[3] || void 0;
      } else if (options) {
        label = options.label || void 0;
        md = options.md || void 0;
        if (options.mgf1 && options.mgf1.md) {
          mgf1Md = options.mgf1.md;
        }
      }
      var keyLength = Math.ceil(key2.n.bitLength() / 8);
      if (em.length !== keyLength) {
        var error = new Error("RSAES-OAEP encoded message length is invalid.");
        error.length = em.length;
        error.expectedLength = keyLength;
        throw error;
      }
      if (md === void 0) {
        md = forge2.md.sha1.create();
      } else {
        md.start();
      }
      if (!mgf1Md) {
        mgf1Md = md;
      }
      if (keyLength < 2 * md.digestLength + 2) {
        throw new Error("RSAES-OAEP key is too short for the hash function.");
      }
      if (!label) {
        label = "";
      }
      md.update(label, "raw");
      var lHash = md.digest().getBytes();
      var y = em.charAt(0);
      var maskedSeed = em.substring(1, md.digestLength + 1);
      var maskedDB = em.substring(1 + md.digestLength);
      var seedMask = rsa_mgf1(maskedDB, md.digestLength, mgf1Md);
      var seed = forge2.util.xorBytes(maskedSeed, seedMask, maskedSeed.length);
      var dbMask = rsa_mgf1(seed, keyLength - md.digestLength - 1, mgf1Md);
      var db = forge2.util.xorBytes(maskedDB, dbMask, maskedDB.length);
      var lHashPrime = db.substring(0, md.digestLength);
      var error = y !== "\0";
      for (var i = 0; i < md.digestLength; ++i) {
        error |= lHash.charAt(i) !== lHashPrime.charAt(i);
      }
      var in_ps = 1;
      var index2 = md.digestLength;
      for (var j = md.digestLength; j < db.length; j++) {
        var code = db.charCodeAt(j);
        var is_0 = code & 1 ^ 1;
        var error_mask = in_ps ? 65534 : 0;
        error |= code & error_mask;
        in_ps = in_ps & is_0;
        index2 += in_ps;
      }
      if (error || db.charCodeAt(index2) !== 1) {
        throw new Error("Invalid RSAES-OAEP padding.");
      }
      return db.substring(index2 + 1);
    };
    function rsa_mgf1(seed, maskLength, hash) {
      if (!hash) {
        hash = forge2.md.sha1.create();
      }
      var t = "";
      var count = Math.ceil(maskLength / hash.digestLength);
      for (var i = 0; i < count; ++i) {
        var c = String.fromCharCode(
          i >> 24 & 255,
          i >> 16 & 255,
          i >> 8 & 255,
          i & 255
        );
        hash.start();
        hash.update(seed + c);
        t += hash.digest().getBytes();
      }
      return t.substring(0, maskLength);
    }
  }
});

// node_modules/@selfxyz/common/node_modules/node-forge/lib/prime.js
var require_prime = __commonJS({
  "node_modules/@selfxyz/common/node_modules/node-forge/lib/prime.js"(exports2, module2) {
    var forge2 = require_forge();
    require_util();
    require_jsbn();
    require_random();
    (function() {
      if (forge2.prime) {
        module2.exports = forge2.prime;
        return;
      }
      var prime = module2.exports = forge2.prime = forge2.prime || {};
      var BigInteger = forge2.jsbn.BigInteger;
      var GCD_30_DELTA = [6, 4, 2, 4, 2, 4, 6, 2];
      var THIRTY = new BigInteger(null);
      THIRTY.fromInt(30);
      var op_or = function(x, y) {
        return x | y;
      };
      prime.generateProbablePrime = function(bits, options, callback) {
        if (typeof options === "function") {
          callback = options;
          options = {};
        }
        options = options || {};
        var algorithm = options.algorithm || "PRIMEINC";
        if (typeof algorithm === "string") {
          algorithm = { name: algorithm };
        }
        algorithm.options = algorithm.options || {};
        var prng = options.prng || forge2.random;
        var rng3 = {
          // x is an array to fill with bytes
          nextBytes: function(x) {
            var b = prng.getBytesSync(x.length);
            for (var i = 0; i < x.length; ++i) {
              x[i] = b.charCodeAt(i);
            }
          }
        };
        if (algorithm.name === "PRIMEINC") {
          return primeincFindPrime(bits, rng3, algorithm.options, callback);
        }
        throw new Error("Invalid prime generation algorithm: " + algorithm.name);
      };
      function primeincFindPrime(bits, rng3, options, callback) {
        if ("workers" in options) {
          return primeincFindPrimeWithWorkers(bits, rng3, options, callback);
        }
        return primeincFindPrimeWithoutWorkers(bits, rng3, options, callback);
      }
      function primeincFindPrimeWithoutWorkers(bits, rng3, options, callback) {
        var num = generateRandom(bits, rng3);
        var deltaIdx = 0;
        var mrTests = getMillerRabinTests(num.bitLength());
        if ("millerRabinTests" in options) {
          mrTests = options.millerRabinTests;
        }
        var maxBlockTime = 10;
        if ("maxBlockTime" in options) {
          maxBlockTime = options.maxBlockTime;
        }
        _primeinc(num, bits, rng3, deltaIdx, mrTests, maxBlockTime, callback);
      }
      function _primeinc(num, bits, rng3, deltaIdx, mrTests, maxBlockTime, callback) {
        var start = +/* @__PURE__ */ new Date();
        do {
          if (num.bitLength() > bits) {
            num = generateRandom(bits, rng3);
          }
          if (num.isProbablePrime(mrTests)) {
            return callback(null, num);
          }
          num.dAddOffset(GCD_30_DELTA[deltaIdx++ % 8], 0);
        } while (maxBlockTime < 0 || +/* @__PURE__ */ new Date() - start < maxBlockTime);
        forge2.util.setImmediate(function() {
          _primeinc(num, bits, rng3, deltaIdx, mrTests, maxBlockTime, callback);
        });
      }
      function primeincFindPrimeWithWorkers(bits, rng3, options, callback) {
        if (typeof Worker === "undefined") {
          return primeincFindPrimeWithoutWorkers(bits, rng3, options, callback);
        }
        var num = generateRandom(bits, rng3);
        var numWorkers = options.workers;
        var workLoad = options.workLoad || 100;
        var range = workLoad * 30 / 8;
        var workerScript = options.workerScript || "forge/prime.worker.js";
        if (numWorkers === -1) {
          return forge2.util.estimateCores(function(err, cores) {
            if (err) {
              cores = 2;
            }
            numWorkers = cores - 1;
            generate();
          });
        }
        generate();
        function generate() {
          numWorkers = Math.max(1, numWorkers);
          var workers = [];
          for (var i = 0; i < numWorkers; ++i) {
            workers[i] = new Worker(workerScript);
          }
          var running = numWorkers;
          for (var i = 0; i < numWorkers; ++i) {
            workers[i].addEventListener("message", workerMessage);
          }
          var found = false;
          function workerMessage(e) {
            if (found) {
              return;
            }
            --running;
            var data2 = e.data;
            if (data2.found) {
              for (var i2 = 0; i2 < workers.length; ++i2) {
                workers[i2].terminate();
              }
              found = true;
              return callback(null, new BigInteger(data2.prime, 16));
            }
            if (num.bitLength() > bits) {
              num = generateRandom(bits, rng3);
            }
            var hex = num.toString(16);
            e.target.postMessage({
              hex,
              workLoad
            });
            num.dAddOffset(range, 0);
          }
        }
      }
      function generateRandom(bits, rng3) {
        var num = new BigInteger(bits, rng3);
        var bits1 = bits - 1;
        if (!num.testBit(bits1)) {
          num.bitwiseTo(BigInteger.ONE.shiftLeft(bits1), op_or, num);
        }
        num.dAddOffset(31 - num.mod(THIRTY).byteValue(), 0);
        return num;
      }
      function getMillerRabinTests(bits) {
        if (bits <= 100) return 27;
        if (bits <= 150) return 18;
        if (bits <= 200) return 15;
        if (bits <= 250) return 12;
        if (bits <= 300) return 9;
        if (bits <= 350) return 8;
        if (bits <= 400) return 7;
        if (bits <= 500) return 6;
        if (bits <= 600) return 5;
        if (bits <= 800) return 4;
        if (bits <= 1250) return 3;
        return 2;
      }
    })();
  }
});

// node_modules/@selfxyz/common/node_modules/node-forge/lib/rsa.js
var require_rsa = __commonJS({
  "node_modules/@selfxyz/common/node_modules/node-forge/lib/rsa.js"(exports2, module2) {
    var forge2 = require_forge();
    require_asn1();
    require_jsbn();
    require_oids();
    require_pkcs1();
    require_prime();
    require_random();
    require_util();
    if (typeof BigInteger === "undefined") {
      BigInteger = forge2.jsbn.BigInteger;
    }
    var BigInteger;
    var _crypto = forge2.util.isNodejs ? require_crypto_browserify() : null;
    var asn1 = forge2.asn1;
    var util2 = forge2.util;
    forge2.pki = forge2.pki || {};
    module2.exports = forge2.pki.rsa = forge2.rsa = forge2.rsa || {};
    var pki = forge2.pki;
    var GCD_30_DELTA = [6, 4, 2, 4, 2, 4, 6, 2];
    var privateKeyValidator = {
      // PrivateKeyInfo
      name: "PrivateKeyInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        // Version (INTEGER)
        name: "PrivateKeyInfo.version",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyVersion"
      }, {
        // privateKeyAlgorithm
        name: "PrivateKeyInfo.privateKeyAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "AlgorithmIdentifier.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "privateKeyOid"
        }]
      }, {
        // PrivateKey
        name: "PrivateKeyInfo",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: false,
        capture: "privateKey"
      }]
    };
    var rsaPrivateKeyValidator = {
      // RSAPrivateKey
      name: "RSAPrivateKey",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        // Version (INTEGER)
        name: "RSAPrivateKey.version",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyVersion"
      }, {
        // modulus (n)
        name: "RSAPrivateKey.modulus",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyModulus"
      }, {
        // publicExponent (e)
        name: "RSAPrivateKey.publicExponent",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyPublicExponent"
      }, {
        // privateExponent (d)
        name: "RSAPrivateKey.privateExponent",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyPrivateExponent"
      }, {
        // prime1 (p)
        name: "RSAPrivateKey.prime1",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyPrime1"
      }, {
        // prime2 (q)
        name: "RSAPrivateKey.prime2",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyPrime2"
      }, {
        // exponent1 (d mod (p-1))
        name: "RSAPrivateKey.exponent1",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyExponent1"
      }, {
        // exponent2 (d mod (q-1))
        name: "RSAPrivateKey.exponent2",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyExponent2"
      }, {
        // coefficient ((inverse of q) mod p)
        name: "RSAPrivateKey.coefficient",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyCoefficient"
      }]
    };
    var rsaPublicKeyValidator = {
      // RSAPublicKey
      name: "RSAPublicKey",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        // modulus (n)
        name: "RSAPublicKey.modulus",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "publicKeyModulus"
      }, {
        // publicExponent (e)
        name: "RSAPublicKey.exponent",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "publicKeyExponent"
      }]
    };
    var publicKeyValidator = forge2.pki.rsa.publicKeyValidator = {
      name: "SubjectPublicKeyInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      captureAsn1: "subjectPublicKeyInfo",
      value: [{
        name: "SubjectPublicKeyInfo.AlgorithmIdentifier",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "AlgorithmIdentifier.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "publicKeyOid"
        }]
      }, {
        // subjectPublicKey
        name: "SubjectPublicKeyInfo.subjectPublicKey",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.BITSTRING,
        constructed: false,
        value: [{
          // RSAPublicKey
          name: "SubjectPublicKeyInfo.subjectPublicKey.RSAPublicKey",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          optional: true,
          captureAsn1: "rsaPublicKey"
        }]
      }]
    };
    var digestInfoValidator = {
      name: "DigestInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "DigestInfo.DigestAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "DigestInfo.DigestAlgorithm.algorithmIdentifier",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "algorithmIdentifier"
        }, {
          // NULL paramters
          name: "DigestInfo.DigestAlgorithm.parameters",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.NULL,
          // captured only to check existence for md2 and md5
          capture: "parameters",
          optional: true,
          constructed: false
        }]
      }, {
        // digest
        name: "DigestInfo.digest",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: false,
        capture: "digest"
      }]
    };
    var emsaPkcs1v15encode = function(md) {
      var oid;
      if (md.algorithm in pki.oids) {
        oid = pki.oids[md.algorithm];
      } else {
        var error = new Error("Unknown message digest algorithm.");
        error.algorithm = md.algorithm;
        throw error;
      }
      var oidBytes = asn1.oidToDer(oid).getBytes();
      var digestInfo = asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.SEQUENCE,
        true,
        []
      );
      var digestAlgorithm = asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.SEQUENCE,
        true,
        []
      );
      digestAlgorithm.value.push(asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.OID,
        false,
        oidBytes
      ));
      digestAlgorithm.value.push(asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.NULL,
        false,
        ""
      ));
      var digest = asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.OCTETSTRING,
        false,
        md.digest().getBytes()
      );
      digestInfo.value.push(digestAlgorithm);
      digestInfo.value.push(digest);
      return asn1.toDer(digestInfo).getBytes();
    };
    var _modPow = function(x, key2, pub) {
      if (pub) {
        return x.modPow(key2.e, key2.n);
      }
      if (!key2.p || !key2.q) {
        return x.modPow(key2.d, key2.n);
      }
      if (!key2.dP) {
        key2.dP = key2.d.mod(key2.p.subtract(BigInteger.ONE));
      }
      if (!key2.dQ) {
        key2.dQ = key2.d.mod(key2.q.subtract(BigInteger.ONE));
      }
      if (!key2.qInv) {
        key2.qInv = key2.q.modInverse(key2.p);
      }
      var r;
      do {
        r = new BigInteger(
          forge2.util.bytesToHex(forge2.random.getBytes(key2.n.bitLength() / 8)),
          16
        );
      } while (r.compareTo(key2.n) >= 0 || !r.gcd(key2.n).equals(BigInteger.ONE));
      x = x.multiply(r.modPow(key2.e, key2.n)).mod(key2.n);
      var xp = x.mod(key2.p).modPow(key2.dP, key2.p);
      var xq = x.mod(key2.q).modPow(key2.dQ, key2.q);
      while (xp.compareTo(xq) < 0) {
        xp = xp.add(key2.p);
      }
      var y = xp.subtract(xq).multiply(key2.qInv).mod(key2.p).multiply(key2.q).add(xq);
      y = y.multiply(r.modInverse(key2.n)).mod(key2.n);
      return y;
    };
    pki.rsa.encrypt = function(m, key2, bt) {
      var pub = bt;
      var eb;
      var k = Math.ceil(key2.n.bitLength() / 8);
      if (bt !== false && bt !== true) {
        pub = bt === 2;
        eb = _encodePkcs1_v1_5(m, key2, bt);
      } else {
        eb = forge2.util.createBuffer();
        eb.putBytes(m);
      }
      var x = new BigInteger(eb.toHex(), 16);
      var y = _modPow(x, key2, pub);
      var yhex = y.toString(16);
      var ed = forge2.util.createBuffer();
      var zeros = k - Math.ceil(yhex.length / 2);
      while (zeros > 0) {
        ed.putByte(0);
        --zeros;
      }
      ed.putBytes(forge2.util.hexToBytes(yhex));
      return ed.getBytes();
    };
    pki.rsa.decrypt = function(ed, key2, pub, ml) {
      var k = Math.ceil(key2.n.bitLength() / 8);
      if (ed.length !== k) {
        var error = new Error("Encrypted message length is invalid.");
        error.length = ed.length;
        error.expected = k;
        throw error;
      }
      var y = new BigInteger(forge2.util.createBuffer(ed).toHex(), 16);
      if (y.compareTo(key2.n) >= 0) {
        throw new Error("Encrypted message is invalid.");
      }
      var x = _modPow(y, key2, pub);
      var xhex = x.toString(16);
      var eb = forge2.util.createBuffer();
      var zeros = k - Math.ceil(xhex.length / 2);
      while (zeros > 0) {
        eb.putByte(0);
        --zeros;
      }
      eb.putBytes(forge2.util.hexToBytes(xhex));
      if (ml !== false) {
        return _decodePkcs1_v1_5(eb.getBytes(), key2, pub);
      }
      return eb.getBytes();
    };
    pki.rsa.createKeyPairGenerationState = function(bits, e, options) {
      if (typeof bits === "string") {
        bits = parseInt(bits, 10);
      }
      bits = bits || 2048;
      options = options || {};
      var prng = options.prng || forge2.random;
      var rng3 = {
        // x is an array to fill with bytes
        nextBytes: function(x) {
          var b = prng.getBytesSync(x.length);
          for (var i = 0; i < x.length; ++i) {
            x[i] = b.charCodeAt(i);
          }
        }
      };
      var algorithm = options.algorithm || "PRIMEINC";
      var rval;
      if (algorithm === "PRIMEINC") {
        rval = {
          algorithm,
          state: 0,
          bits,
          rng: rng3,
          eInt: e || 65537,
          e: new BigInteger(null),
          p: null,
          q: null,
          qBits: bits >> 1,
          pBits: bits - (bits >> 1),
          pqState: 0,
          num: null,
          keys: null
        };
        rval.e.fromInt(rval.eInt);
      } else {
        throw new Error("Invalid key generation algorithm: " + algorithm);
      }
      return rval;
    };
    pki.rsa.stepKeyPairGenerationState = function(state, n) {
      if (!("algorithm" in state)) {
        state.algorithm = "PRIMEINC";
      }
      var THIRTY = new BigInteger(null);
      THIRTY.fromInt(30);
      var deltaIdx = 0;
      var op_or = function(x, y) {
        return x | y;
      };
      var t1 = +/* @__PURE__ */ new Date();
      var t2;
      var total = 0;
      while (state.keys === null && (n <= 0 || total < n)) {
        if (state.state === 0) {
          var bits = state.p === null ? state.pBits : state.qBits;
          var bits1 = bits - 1;
          if (state.pqState === 0) {
            state.num = new BigInteger(bits, state.rng);
            if (!state.num.testBit(bits1)) {
              state.num.bitwiseTo(
                BigInteger.ONE.shiftLeft(bits1),
                op_or,
                state.num
              );
            }
            state.num.dAddOffset(31 - state.num.mod(THIRTY).byteValue(), 0);
            deltaIdx = 0;
            ++state.pqState;
          } else if (state.pqState === 1) {
            if (state.num.bitLength() > bits) {
              state.pqState = 0;
            } else if (state.num.isProbablePrime(
              _getMillerRabinTests(state.num.bitLength())
            )) {
              ++state.pqState;
            } else {
              state.num.dAddOffset(GCD_30_DELTA[deltaIdx++ % 8], 0);
            }
          } else if (state.pqState === 2) {
            state.pqState = state.num.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE) === 0 ? 3 : 0;
          } else if (state.pqState === 3) {
            state.pqState = 0;
            if (state.p === null) {
              state.p = state.num;
            } else {
              state.q = state.num;
            }
            if (state.p !== null && state.q !== null) {
              ++state.state;
            }
            state.num = null;
          }
        } else if (state.state === 1) {
          if (state.p.compareTo(state.q) < 0) {
            state.num = state.p;
            state.p = state.q;
            state.q = state.num;
          }
          ++state.state;
        } else if (state.state === 2) {
          state.p1 = state.p.subtract(BigInteger.ONE);
          state.q1 = state.q.subtract(BigInteger.ONE);
          state.phi = state.p1.multiply(state.q1);
          ++state.state;
        } else if (state.state === 3) {
          if (state.phi.gcd(state.e).compareTo(BigInteger.ONE) === 0) {
            ++state.state;
          } else {
            state.p = null;
            state.q = null;
            state.state = 0;
          }
        } else if (state.state === 4) {
          state.n = state.p.multiply(state.q);
          if (state.n.bitLength() === state.bits) {
            ++state.state;
          } else {
            state.q = null;
            state.state = 0;
          }
        } else if (state.state === 5) {
          var d = state.e.modInverse(state.phi);
          state.keys = {
            privateKey: pki.rsa.setPrivateKey(
              state.n,
              state.e,
              d,
              state.p,
              state.q,
              d.mod(state.p1),
              d.mod(state.q1),
              state.q.modInverse(state.p)
            ),
            publicKey: pki.rsa.setPublicKey(state.n, state.e)
          };
        }
        t2 = +/* @__PURE__ */ new Date();
        total += t2 - t1;
        t1 = t2;
      }
      return state.keys !== null;
    };
    pki.rsa.generateKeyPair = function(bits, e, options, callback) {
      if (arguments.length === 1) {
        if (typeof bits === "object") {
          options = bits;
          bits = void 0;
        } else if (typeof bits === "function") {
          callback = bits;
          bits = void 0;
        }
      } else if (arguments.length === 2) {
        if (typeof bits === "number") {
          if (typeof e === "function") {
            callback = e;
            e = void 0;
          } else if (typeof e !== "number") {
            options = e;
            e = void 0;
          }
        } else {
          options = bits;
          callback = e;
          bits = void 0;
          e = void 0;
        }
      } else if (arguments.length === 3) {
        if (typeof e === "number") {
          if (typeof options === "function") {
            callback = options;
            options = void 0;
          }
        } else {
          callback = options;
          options = e;
          e = void 0;
        }
      }
      options = options || {};
      if (bits === void 0) {
        bits = options.bits || 2048;
      }
      if (e === void 0) {
        e = options.e || 65537;
      }
      if (!forge2.options.usePureJavaScript && !options.prng && bits >= 256 && bits <= 16384 && (e === 65537 || e === 3)) {
        if (callback) {
          if (_detectNodeCrypto("generateKeyPair")) {
            return _crypto.generateKeyPair("rsa", {
              modulusLength: bits,
              publicExponent: e,
              publicKeyEncoding: {
                type: "spki",
                format: "pem"
              },
              privateKeyEncoding: {
                type: "pkcs8",
                format: "pem"
              }
            }, function(err, pub, priv) {
              if (err) {
                return callback(err);
              }
              callback(null, {
                privateKey: pki.privateKeyFromPem(priv),
                publicKey: pki.publicKeyFromPem(pub)
              });
            });
          }
          if (_detectSubtleCrypto("generateKey") && _detectSubtleCrypto("exportKey")) {
            return util2.globalScope.crypto.subtle.generateKey({
              name: "RSASSA-PKCS1-v1_5",
              modulusLength: bits,
              publicExponent: _intToUint8Array(e),
              hash: { name: "SHA-256" }
            }, true, ["sign", "verify"]).then(function(pair) {
              return util2.globalScope.crypto.subtle.exportKey(
                "pkcs8",
                pair.privateKey
              );
            }).then(void 0, function(err) {
              callback(err);
            }).then(function(pkcs8) {
              if (pkcs8) {
                var privateKey = pki.privateKeyFromAsn1(
                  asn1.fromDer(forge2.util.createBuffer(pkcs8))
                );
                callback(null, {
                  privateKey,
                  publicKey: pki.setRsaPublicKey(privateKey.n, privateKey.e)
                });
              }
            });
          }
          if (_detectSubtleMsCrypto("generateKey") && _detectSubtleMsCrypto("exportKey")) {
            var genOp = util2.globalScope.msCrypto.subtle.generateKey({
              name: "RSASSA-PKCS1-v1_5",
              modulusLength: bits,
              publicExponent: _intToUint8Array(e),
              hash: { name: "SHA-256" }
            }, true, ["sign", "verify"]);
            genOp.oncomplete = function(e2) {
              var pair = e2.target.result;
              var exportOp = util2.globalScope.msCrypto.subtle.exportKey(
                "pkcs8",
                pair.privateKey
              );
              exportOp.oncomplete = function(e3) {
                var pkcs8 = e3.target.result;
                var privateKey = pki.privateKeyFromAsn1(
                  asn1.fromDer(forge2.util.createBuffer(pkcs8))
                );
                callback(null, {
                  privateKey,
                  publicKey: pki.setRsaPublicKey(privateKey.n, privateKey.e)
                });
              };
              exportOp.onerror = function(err) {
                callback(err);
              };
            };
            genOp.onerror = function(err) {
              callback(err);
            };
            return;
          }
        } else {
          if (_detectNodeCrypto("generateKeyPairSync")) {
            var keypair = _crypto.generateKeyPairSync("rsa", {
              modulusLength: bits,
              publicExponent: e,
              publicKeyEncoding: {
                type: "spki",
                format: "pem"
              },
              privateKeyEncoding: {
                type: "pkcs8",
                format: "pem"
              }
            });
            return {
              privateKey: pki.privateKeyFromPem(keypair.privateKey),
              publicKey: pki.publicKeyFromPem(keypair.publicKey)
            };
          }
        }
      }
      var state = pki.rsa.createKeyPairGenerationState(bits, e, options);
      if (!callback) {
        pki.rsa.stepKeyPairGenerationState(state, 0);
        return state.keys;
      }
      _generateKeyPair(state, options, callback);
    };
    pki.setRsaPublicKey = pki.rsa.setPublicKey = function(n, e) {
      var key2 = {
        n,
        e
      };
      key2.encrypt = function(data2, scheme, schemeOptions) {
        if (typeof scheme === "string") {
          scheme = scheme.toUpperCase();
        } else if (scheme === void 0) {
          scheme = "RSAES-PKCS1-V1_5";
        }
        if (scheme === "RSAES-PKCS1-V1_5") {
          scheme = {
            encode: function(m, key3, pub) {
              return _encodePkcs1_v1_5(m, key3, 2).getBytes();
            }
          };
        } else if (scheme === "RSA-OAEP" || scheme === "RSAES-OAEP") {
          scheme = {
            encode: function(m, key3) {
              return forge2.pkcs1.encode_rsa_oaep(key3, m, schemeOptions);
            }
          };
        } else if (["RAW", "NONE", "NULL", null].indexOf(scheme) !== -1) {
          scheme = { encode: function(e3) {
            return e3;
          } };
        } else if (typeof scheme === "string") {
          throw new Error('Unsupported encryption scheme: "' + scheme + '".');
        }
        var e2 = scheme.encode(data2, key2, true);
        return pki.rsa.encrypt(e2, key2, true);
      };
      key2.verify = function(digest, signature, scheme, options) {
        if (typeof scheme === "string") {
          scheme = scheme.toUpperCase();
        } else if (scheme === void 0) {
          scheme = "RSASSA-PKCS1-V1_5";
        }
        if (options === void 0) {
          options = {
            _parseAllDigestBytes: true
          };
        }
        if (!("_parseAllDigestBytes" in options)) {
          options._parseAllDigestBytes = true;
        }
        if (scheme === "RSASSA-PKCS1-V1_5") {
          scheme = {
            verify: function(digest2, d2) {
              d2 = _decodePkcs1_v1_5(d2, key2, true);
              var obj = asn1.fromDer(d2, {
                parseAllBytes: options._parseAllDigestBytes
              });
              var capture = {};
              var errors = [];
              if (!asn1.validate(obj, digestInfoValidator, capture, errors)) {
                var error = new Error(
                  "ASN.1 object does not contain a valid RSASSA-PKCS1-v1_5 DigestInfo value."
                );
                error.errors = errors;
                throw error;
              }
              var oid = asn1.derToOid(capture.algorithmIdentifier);
              if (!(oid === forge2.oids.md2 || oid === forge2.oids.md5 || oid === forge2.oids.sha1 || oid === forge2.oids.sha224 || oid === forge2.oids.sha256 || oid === forge2.oids.sha384 || oid === forge2.oids.sha512 || oid === forge2.oids["sha512-224"] || oid === forge2.oids["sha512-256"])) {
                var error = new Error(
                  "Unknown RSASSA-PKCS1-v1_5 DigestAlgorithm identifier."
                );
                error.oid = oid;
                throw error;
              }
              if (oid === forge2.oids.md2 || oid === forge2.oids.md5) {
                if (!("parameters" in capture)) {
                  throw new Error(
                    "ASN.1 object does not contain a valid RSASSA-PKCS1-v1_5 DigestInfo value. Missing algorithm identifer NULL parameters."
                  );
                }
              }
              return digest2 === capture.digest;
            }
          };
        } else if (scheme === "NONE" || scheme === "NULL" || scheme === null) {
          scheme = {
            verify: function(digest2, d2) {
              d2 = _decodePkcs1_v1_5(d2, key2, true);
              return digest2 === d2;
            }
          };
        }
        var d = pki.rsa.decrypt(signature, key2, true, false);
        return scheme.verify(digest, d, key2.n.bitLength());
      };
      return key2;
    };
    pki.setRsaPrivateKey = pki.rsa.setPrivateKey = function(n, e, d, p, q, dP, dQ, qInv) {
      var key2 = {
        n,
        e,
        d,
        p,
        q,
        dP,
        dQ,
        qInv
      };
      key2.decrypt = function(data2, scheme, schemeOptions) {
        if (typeof scheme === "string") {
          scheme = scheme.toUpperCase();
        } else if (scheme === void 0) {
          scheme = "RSAES-PKCS1-V1_5";
        }
        var d2 = pki.rsa.decrypt(data2, key2, false, false);
        if (scheme === "RSAES-PKCS1-V1_5") {
          scheme = { decode: _decodePkcs1_v1_5 };
        } else if (scheme === "RSA-OAEP" || scheme === "RSAES-OAEP") {
          scheme = {
            decode: function(d3, key3) {
              return forge2.pkcs1.decode_rsa_oaep(key3, d3, schemeOptions);
            }
          };
        } else if (["RAW", "NONE", "NULL", null].indexOf(scheme) !== -1) {
          scheme = { decode: function(d3) {
            return d3;
          } };
        } else {
          throw new Error('Unsupported encryption scheme: "' + scheme + '".');
        }
        return scheme.decode(d2, key2, false);
      };
      key2.sign = function(md, scheme) {
        var bt = false;
        if (typeof scheme === "string") {
          scheme = scheme.toUpperCase();
        }
        if (scheme === void 0 || scheme === "RSASSA-PKCS1-V1_5") {
          scheme = { encode: emsaPkcs1v15encode };
          bt = 1;
        } else if (scheme === "NONE" || scheme === "NULL" || scheme === null) {
          scheme = { encode: function() {
            return md;
          } };
          bt = 1;
        }
        var d2 = scheme.encode(md, key2.n.bitLength());
        return pki.rsa.encrypt(d2, key2, bt);
      };
      return key2;
    };
    pki.wrapRsaPrivateKey = function(rsaKey) {
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // version (0)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          asn1.integerToDer(0).getBytes()
        ),
        // privateKeyAlgorithm
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(pki.oids.rsaEncryption).getBytes()
          ),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
        ]),
        // PrivateKey
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OCTETSTRING,
          false,
          asn1.toDer(rsaKey).getBytes()
        )
      ]);
    };
    pki.privateKeyFromAsn1 = function(obj) {
      var capture = {};
      var errors = [];
      if (asn1.validate(obj, privateKeyValidator, capture, errors)) {
        obj = asn1.fromDer(forge2.util.createBuffer(capture.privateKey));
      }
      capture = {};
      errors = [];
      if (!asn1.validate(obj, rsaPrivateKeyValidator, capture, errors)) {
        var error = new Error("Cannot read private key. ASN.1 object does not contain an RSAPrivateKey.");
        error.errors = errors;
        throw error;
      }
      var n, e, d, p, q, dP, dQ, qInv;
      n = forge2.util.createBuffer(capture.privateKeyModulus).toHex();
      e = forge2.util.createBuffer(capture.privateKeyPublicExponent).toHex();
      d = forge2.util.createBuffer(capture.privateKeyPrivateExponent).toHex();
      p = forge2.util.createBuffer(capture.privateKeyPrime1).toHex();
      q = forge2.util.createBuffer(capture.privateKeyPrime2).toHex();
      dP = forge2.util.createBuffer(capture.privateKeyExponent1).toHex();
      dQ = forge2.util.createBuffer(capture.privateKeyExponent2).toHex();
      qInv = forge2.util.createBuffer(capture.privateKeyCoefficient).toHex();
      return pki.setRsaPrivateKey(
        new BigInteger(n, 16),
        new BigInteger(e, 16),
        new BigInteger(d, 16),
        new BigInteger(p, 16),
        new BigInteger(q, 16),
        new BigInteger(dP, 16),
        new BigInteger(dQ, 16),
        new BigInteger(qInv, 16)
      );
    };
    pki.privateKeyToAsn1 = pki.privateKeyToRSAPrivateKey = function(key2) {
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // version (0 = only 2 primes, 1 multiple primes)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          asn1.integerToDer(0).getBytes()
        ),
        // modulus (n)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key2.n)
        ),
        // publicExponent (e)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key2.e)
        ),
        // privateExponent (d)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key2.d)
        ),
        // privateKeyPrime1 (p)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key2.p)
        ),
        // privateKeyPrime2 (q)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key2.q)
        ),
        // privateKeyExponent1 (dP)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key2.dP)
        ),
        // privateKeyExponent2 (dQ)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key2.dQ)
        ),
        // coefficient (qInv)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key2.qInv)
        )
      ]);
    };
    pki.publicKeyFromAsn1 = function(obj) {
      var capture = {};
      var errors = [];
      if (asn1.validate(obj, publicKeyValidator, capture, errors)) {
        var oid = asn1.derToOid(capture.publicKeyOid);
        if (oid !== pki.oids.rsaEncryption && oid !== "1.2.840.113549.1.1.10") {
          var error = new Error("Cannot read public key. Unknown OID.");
          error.oid = oid;
          throw error;
        }
        obj = capture.rsaPublicKey;
      }
      errors = [];
      if (!asn1.validate(obj, rsaPublicKeyValidator, capture, errors)) {
        var error = new Error("Cannot read public key. ASN.1 object does not contain an RSAPublicKey.");
        error.errors = errors;
        throw error;
      }
      var n = forge2.util.createBuffer(capture.publicKeyModulus).toHex();
      var e = forge2.util.createBuffer(capture.publicKeyExponent).toHex();
      return pki.setRsaPublicKey(
        new BigInteger(n, 16),
        new BigInteger(e, 16)
      );
    };
    pki.publicKeyToAsn1 = pki.publicKeyToSubjectPublicKeyInfo = function(key2) {
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // AlgorithmIdentifier
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // algorithm
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(pki.oids.rsaEncryption).getBytes()
          ),
          // parameters (null)
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
        ]),
        // subjectPublicKey
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, [
          pki.publicKeyToRSAPublicKey(key2)
        ])
      ]);
    };
    pki.publicKeyToRSAPublicKey = function(key2) {
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // modulus (n)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key2.n)
        ),
        // publicExponent (e)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key2.e)
        )
      ]);
    };
    function _encodePkcs1_v1_5(m, key2, bt) {
      var eb = forge2.util.createBuffer();
      var k = Math.ceil(key2.n.bitLength() / 8);
      if (m.length > k - 11) {
        var error = new Error("Message is too long for PKCS#1 v1.5 padding.");
        error.length = m.length;
        error.max = k - 11;
        throw error;
      }
      eb.putByte(0);
      eb.putByte(bt);
      var padNum = k - 3 - m.length;
      var padByte;
      if (bt === 0 || bt === 1) {
        padByte = bt === 0 ? 0 : 255;
        for (var i = 0; i < padNum; ++i) {
          eb.putByte(padByte);
        }
      } else {
        while (padNum > 0) {
          var numZeros = 0;
          var padBytes = forge2.random.getBytes(padNum);
          for (var i = 0; i < padNum; ++i) {
            padByte = padBytes.charCodeAt(i);
            if (padByte === 0) {
              ++numZeros;
            } else {
              eb.putByte(padByte);
            }
          }
          padNum = numZeros;
        }
      }
      eb.putByte(0);
      eb.putBytes(m);
      return eb;
    }
    function _decodePkcs1_v1_5(em, key2, pub, ml) {
      var k = Math.ceil(key2.n.bitLength() / 8);
      var eb = forge2.util.createBuffer(em);
      var first = eb.getByte();
      var bt = eb.getByte();
      if (first !== 0 || pub && bt !== 0 && bt !== 1 || !pub && bt != 2 || pub && bt === 0 && typeof ml === "undefined") {
        throw new Error("Encryption block is invalid.");
      }
      var padNum = 0;
      if (bt === 0) {
        padNum = k - 3 - ml;
        for (var i = 0; i < padNum; ++i) {
          if (eb.getByte() !== 0) {
            throw new Error("Encryption block is invalid.");
          }
        }
      } else if (bt === 1) {
        padNum = 0;
        while (eb.length() > 1) {
          if (eb.getByte() !== 255) {
            --eb.read;
            break;
          }
          ++padNum;
        }
      } else if (bt === 2) {
        padNum = 0;
        while (eb.length() > 1) {
          if (eb.getByte() === 0) {
            --eb.read;
            break;
          }
          ++padNum;
        }
      }
      var zero = eb.getByte();
      if (zero !== 0 || padNum !== k - 3 - eb.length()) {
        throw new Error("Encryption block is invalid.");
      }
      return eb.getBytes();
    }
    function _generateKeyPair(state, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      options = options || {};
      var opts = {
        algorithm: {
          name: options.algorithm || "PRIMEINC",
          options: {
            workers: options.workers || 2,
            workLoad: options.workLoad || 100,
            workerScript: options.workerScript
          }
        }
      };
      if ("prng" in options) {
        opts.prng = options.prng;
      }
      generate();
      function generate() {
        getPrime(state.pBits, function(err, num) {
          if (err) {
            return callback(err);
          }
          state.p = num;
          if (state.q !== null) {
            return finish(err, state.q);
          }
          getPrime(state.qBits, finish);
        });
      }
      function getPrime(bits, callback2) {
        forge2.prime.generateProbablePrime(bits, opts, callback2);
      }
      function finish(err, num) {
        if (err) {
          return callback(err);
        }
        state.q = num;
        if (state.p.compareTo(state.q) < 0) {
          var tmp = state.p;
          state.p = state.q;
          state.q = tmp;
        }
        if (state.p.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE) !== 0) {
          state.p = null;
          generate();
          return;
        }
        if (state.q.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE) !== 0) {
          state.q = null;
          getPrime(state.qBits, finish);
          return;
        }
        state.p1 = state.p.subtract(BigInteger.ONE);
        state.q1 = state.q.subtract(BigInteger.ONE);
        state.phi = state.p1.multiply(state.q1);
        if (state.phi.gcd(state.e).compareTo(BigInteger.ONE) !== 0) {
          state.p = state.q = null;
          generate();
          return;
        }
        state.n = state.p.multiply(state.q);
        if (state.n.bitLength() !== state.bits) {
          state.q = null;
          getPrime(state.qBits, finish);
          return;
        }
        var d = state.e.modInverse(state.phi);
        state.keys = {
          privateKey: pki.rsa.setPrivateKey(
            state.n,
            state.e,
            d,
            state.p,
            state.q,
            d.mod(state.p1),
            d.mod(state.q1),
            state.q.modInverse(state.p)
          ),
          publicKey: pki.rsa.setPublicKey(state.n, state.e)
        };
        callback(null, state.keys);
      }
    }
    function _bnToBytes(b) {
      var hex = b.toString(16);
      if (hex[0] >= "8") {
        hex = "00" + hex;
      }
      var bytes = forge2.util.hexToBytes(hex);
      if (bytes.length > 1 && // leading 0x00 for positive integer
      (bytes.charCodeAt(0) === 0 && (bytes.charCodeAt(1) & 128) === 0 || // leading 0xFF for negative integer
      bytes.charCodeAt(0) === 255 && (bytes.charCodeAt(1) & 128) === 128)) {
        return bytes.substr(1);
      }
      return bytes;
    }
    function _getMillerRabinTests(bits) {
      if (bits <= 100) return 27;
      if (bits <= 150) return 18;
      if (bits <= 200) return 15;
      if (bits <= 250) return 12;
      if (bits <= 300) return 9;
      if (bits <= 350) return 8;
      if (bits <= 400) return 7;
      if (bits <= 500) return 6;
      if (bits <= 600) return 5;
      if (bits <= 800) return 4;
      if (bits <= 1250) return 3;
      return 2;
    }
    function _detectNodeCrypto(fn) {
      return forge2.util.isNodejs && typeof _crypto[fn] === "function";
    }
    function _detectSubtleCrypto(fn) {
      return typeof util2.globalScope !== "undefined" && typeof util2.globalScope.crypto === "object" && typeof util2.globalScope.crypto.subtle === "object" && typeof util2.globalScope.crypto.subtle[fn] === "function";
    }
    function _detectSubtleMsCrypto(fn) {
      return typeof util2.globalScope !== "undefined" && typeof util2.globalScope.msCrypto === "object" && typeof util2.globalScope.msCrypto.subtle === "object" && typeof util2.globalScope.msCrypto.subtle[fn] === "function";
    }
    function _intToUint8Array(x) {
      var bytes = forge2.util.hexToBytes(x.toString(16));
      var buffer = new Uint8Array(bytes.length);
      for (var i = 0; i < bytes.length; ++i) {
        buffer[i] = bytes.charCodeAt(i);
      }
      return buffer;
    }
  }
});

// node_modules/@selfxyz/common/node_modules/node-forge/lib/pbe.js
var require_pbe = __commonJS({
  "node_modules/@selfxyz/common/node_modules/node-forge/lib/pbe.js"(exports2, module2) {
    var forge2 = require_forge();
    require_aes();
    require_asn1();
    require_des();
    require_md();
    require_oids();
    require_pbkdf2();
    require_pem();
    require_random();
    require_rc2();
    require_rsa();
    require_util();
    if (typeof BigInteger === "undefined") {
      BigInteger = forge2.jsbn.BigInteger;
    }
    var BigInteger;
    var asn1 = forge2.asn1;
    var pki = forge2.pki = forge2.pki || {};
    module2.exports = pki.pbe = forge2.pbe = forge2.pbe || {};
    var oids = pki.oids;
    var encryptedPrivateKeyValidator = {
      name: "EncryptedPrivateKeyInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "EncryptedPrivateKeyInfo.encryptionAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "AlgorithmIdentifier.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "encryptionOid"
        }, {
          name: "AlgorithmIdentifier.parameters",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          captureAsn1: "encryptionParams"
        }]
      }, {
        // encryptedData
        name: "EncryptedPrivateKeyInfo.encryptedData",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: false,
        capture: "encryptedData"
      }]
    };
    var PBES2AlgorithmsValidator = {
      name: "PBES2Algorithms",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "PBES2Algorithms.keyDerivationFunc",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "PBES2Algorithms.keyDerivationFunc.oid",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "kdfOid"
        }, {
          name: "PBES2Algorithms.params",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "PBES2Algorithms.params.salt",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OCTETSTRING,
            constructed: false,
            capture: "kdfSalt"
          }, {
            name: "PBES2Algorithms.params.iterationCount",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.INTEGER,
            constructed: false,
            capture: "kdfIterationCount"
          }, {
            name: "PBES2Algorithms.params.keyLength",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.INTEGER,
            constructed: false,
            optional: true,
            capture: "keyLength"
          }, {
            // prf
            name: "PBES2Algorithms.params.prf",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            optional: true,
            value: [{
              name: "PBES2Algorithms.params.prf.algorithm",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.OID,
              constructed: false,
              capture: "prfOid"
            }]
          }]
        }]
      }, {
        name: "PBES2Algorithms.encryptionScheme",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "PBES2Algorithms.encryptionScheme.oid",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "encOid"
        }, {
          name: "PBES2Algorithms.encryptionScheme.iv",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OCTETSTRING,
          constructed: false,
          capture: "encIv"
        }]
      }]
    };
    var pkcs12PbeParamsValidator = {
      name: "pkcs-12PbeParams",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "pkcs-12PbeParams.salt",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: false,
        capture: "salt"
      }, {
        name: "pkcs-12PbeParams.iterations",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "iterations"
      }]
    };
    pki.encryptPrivateKeyInfo = function(obj, password, options) {
      options = options || {};
      options.saltSize = options.saltSize || 8;
      options.count = options.count || 2048;
      options.algorithm = options.algorithm || "aes128";
      options.prfAlgorithm = options.prfAlgorithm || "sha1";
      var salt = forge2.random.getBytesSync(options.saltSize);
      var count = options.count;
      var countBytes = asn1.integerToDer(count);
      var dkLen;
      var encryptionAlgorithm;
      var encryptedData;
      if (options.algorithm.indexOf("aes") === 0 || options.algorithm === "des") {
        var ivLen, encOid, cipherFn;
        switch (options.algorithm) {
          case "aes128":
            dkLen = 16;
            ivLen = 16;
            encOid = oids["aes128-CBC"];
            cipherFn = forge2.aes.createEncryptionCipher;
            break;
          case "aes192":
            dkLen = 24;
            ivLen = 16;
            encOid = oids["aes192-CBC"];
            cipherFn = forge2.aes.createEncryptionCipher;
            break;
          case "aes256":
            dkLen = 32;
            ivLen = 16;
            encOid = oids["aes256-CBC"];
            cipherFn = forge2.aes.createEncryptionCipher;
            break;
          case "des":
            dkLen = 8;
            ivLen = 8;
            encOid = oids["desCBC"];
            cipherFn = forge2.des.createEncryptionCipher;
            break;
          default:
            var error = new Error("Cannot encrypt private key. Unknown encryption algorithm.");
            error.algorithm = options.algorithm;
            throw error;
        }
        var prfAlgorithm = "hmacWith" + options.prfAlgorithm.toUpperCase();
        var md = prfAlgorithmToMessageDigest(prfAlgorithm);
        var dk = forge2.pkcs5.pbkdf2(password, salt, count, dkLen, md);
        var iv = forge2.random.getBytesSync(ivLen);
        var cipher = cipherFn(dk);
        cipher.start(iv);
        cipher.update(asn1.toDer(obj));
        cipher.finish();
        encryptedData = cipher.output.getBytes();
        var params = createPbkdf2Params(salt, countBytes, dkLen, prfAlgorithm);
        encryptionAlgorithm = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.SEQUENCE,
          true,
          [
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(oids["pkcs5PBES2"]).getBytes()
            ),
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              // keyDerivationFunc
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.OID,
                  false,
                  asn1.oidToDer(oids["pkcs5PBKDF2"]).getBytes()
                ),
                // PBKDF2-params
                params
              ]),
              // encryptionScheme
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.OID,
                  false,
                  asn1.oidToDer(encOid).getBytes()
                ),
                // iv
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.OCTETSTRING,
                  false,
                  iv
                )
              ])
            ])
          ]
        );
      } else if (options.algorithm === "3des") {
        dkLen = 24;
        var saltBytes = new forge2.util.ByteBuffer(salt);
        var dk = pki.pbe.generatePkcs12Key(password, saltBytes, 1, count, dkLen);
        var iv = pki.pbe.generatePkcs12Key(password, saltBytes, 2, count, dkLen);
        var cipher = forge2.des.createEncryptionCipher(dk);
        cipher.start(iv);
        cipher.update(asn1.toDer(obj));
        cipher.finish();
        encryptedData = cipher.output.getBytes();
        encryptionAlgorithm = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.SEQUENCE,
          true,
          [
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]).getBytes()
            ),
            // pkcs-12PbeParams
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              // salt
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, salt),
              // iteration count
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.INTEGER,
                false,
                countBytes.getBytes()
              )
            ])
          ]
        );
      } else {
        var error = new Error("Cannot encrypt private key. Unknown encryption algorithm.");
        error.algorithm = options.algorithm;
        throw error;
      }
      var rval = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // encryptionAlgorithm
        encryptionAlgorithm,
        // encryptedData
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OCTETSTRING,
          false,
          encryptedData
        )
      ]);
      return rval;
    };
    pki.decryptPrivateKeyInfo = function(obj, password) {
      var rval = null;
      var capture = {};
      var errors = [];
      if (!asn1.validate(obj, encryptedPrivateKeyValidator, capture, errors)) {
        var error = new Error("Cannot read encrypted private key. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
        error.errors = errors;
        throw error;
      }
      var oid = asn1.derToOid(capture.encryptionOid);
      var cipher = pki.pbe.getCipher(oid, capture.encryptionParams, password);
      var encrypted = forge2.util.createBuffer(capture.encryptedData);
      cipher.update(encrypted);
      if (cipher.finish()) {
        rval = asn1.fromDer(cipher.output);
      }
      return rval;
    };
    pki.encryptedPrivateKeyToPem = function(epki, maxline) {
      var msg = {
        type: "ENCRYPTED PRIVATE KEY",
        body: asn1.toDer(epki).getBytes()
      };
      return forge2.pem.encode(msg, { maxline });
    };
    pki.encryptedPrivateKeyFromPem = function(pem) {
      var msg = forge2.pem.decode(pem)[0];
      if (msg.type !== "ENCRYPTED PRIVATE KEY") {
        var error = new Error('Could not convert encrypted private key from PEM; PEM header type is "ENCRYPTED PRIVATE KEY".');
        error.headerType = msg.type;
        throw error;
      }
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        throw new Error("Could not convert encrypted private key from PEM; PEM is encrypted.");
      }
      return asn1.fromDer(msg.body);
    };
    pki.encryptRsaPrivateKey = function(rsaKey, password, options) {
      options = options || {};
      if (!options.legacy) {
        var rval = pki.wrapRsaPrivateKey(pki.privateKeyToAsn1(rsaKey));
        rval = pki.encryptPrivateKeyInfo(rval, password, options);
        return pki.encryptedPrivateKeyToPem(rval);
      }
      var algorithm;
      var iv;
      var dkLen;
      var cipherFn;
      switch (options.algorithm) {
        case "aes128":
          algorithm = "AES-128-CBC";
          dkLen = 16;
          iv = forge2.random.getBytesSync(16);
          cipherFn = forge2.aes.createEncryptionCipher;
          break;
        case "aes192":
          algorithm = "AES-192-CBC";
          dkLen = 24;
          iv = forge2.random.getBytesSync(16);
          cipherFn = forge2.aes.createEncryptionCipher;
          break;
        case "aes256":
          algorithm = "AES-256-CBC";
          dkLen = 32;
          iv = forge2.random.getBytesSync(16);
          cipherFn = forge2.aes.createEncryptionCipher;
          break;
        case "3des":
          algorithm = "DES-EDE3-CBC";
          dkLen = 24;
          iv = forge2.random.getBytesSync(8);
          cipherFn = forge2.des.createEncryptionCipher;
          break;
        case "des":
          algorithm = "DES-CBC";
          dkLen = 8;
          iv = forge2.random.getBytesSync(8);
          cipherFn = forge2.des.createEncryptionCipher;
          break;
        default:
          var error = new Error('Could not encrypt RSA private key; unsupported encryption algorithm "' + options.algorithm + '".');
          error.algorithm = options.algorithm;
          throw error;
      }
      var dk = forge2.pbe.opensslDeriveBytes(password, iv.substr(0, 8), dkLen);
      var cipher = cipherFn(dk);
      cipher.start(iv);
      cipher.update(asn1.toDer(pki.privateKeyToAsn1(rsaKey)));
      cipher.finish();
      var msg = {
        type: "RSA PRIVATE KEY",
        procType: {
          version: "4",
          type: "ENCRYPTED"
        },
        dekInfo: {
          algorithm,
          parameters: forge2.util.bytesToHex(iv).toUpperCase()
        },
        body: cipher.output.getBytes()
      };
      return forge2.pem.encode(msg);
    };
    pki.decryptRsaPrivateKey = function(pem, password) {
      var rval = null;
      var msg = forge2.pem.decode(pem)[0];
      if (msg.type !== "ENCRYPTED PRIVATE KEY" && msg.type !== "PRIVATE KEY" && msg.type !== "RSA PRIVATE KEY") {
        var error = new Error('Could not convert private key from PEM; PEM header type is not "ENCRYPTED PRIVATE KEY", "PRIVATE KEY", or "RSA PRIVATE KEY".');
        error.headerType = error;
        throw error;
      }
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        var dkLen;
        var cipherFn;
        switch (msg.dekInfo.algorithm) {
          case "DES-CBC":
            dkLen = 8;
            cipherFn = forge2.des.createDecryptionCipher;
            break;
          case "DES-EDE3-CBC":
            dkLen = 24;
            cipherFn = forge2.des.createDecryptionCipher;
            break;
          case "AES-128-CBC":
            dkLen = 16;
            cipherFn = forge2.aes.createDecryptionCipher;
            break;
          case "AES-192-CBC":
            dkLen = 24;
            cipherFn = forge2.aes.createDecryptionCipher;
            break;
          case "AES-256-CBC":
            dkLen = 32;
            cipherFn = forge2.aes.createDecryptionCipher;
            break;
          case "RC2-40-CBC":
            dkLen = 5;
            cipherFn = function(key2) {
              return forge2.rc2.createDecryptionCipher(key2, 40);
            };
            break;
          case "RC2-64-CBC":
            dkLen = 8;
            cipherFn = function(key2) {
              return forge2.rc2.createDecryptionCipher(key2, 64);
            };
            break;
          case "RC2-128-CBC":
            dkLen = 16;
            cipherFn = function(key2) {
              return forge2.rc2.createDecryptionCipher(key2, 128);
            };
            break;
          default:
            var error = new Error('Could not decrypt private key; unsupported encryption algorithm "' + msg.dekInfo.algorithm + '".');
            error.algorithm = msg.dekInfo.algorithm;
            throw error;
        }
        var iv = forge2.util.hexToBytes(msg.dekInfo.parameters);
        var dk = forge2.pbe.opensslDeriveBytes(password, iv.substr(0, 8), dkLen);
        var cipher = cipherFn(dk);
        cipher.start(iv);
        cipher.update(forge2.util.createBuffer(msg.body));
        if (cipher.finish()) {
          rval = cipher.output.getBytes();
        } else {
          return rval;
        }
      } else {
        rval = msg.body;
      }
      if (msg.type === "ENCRYPTED PRIVATE KEY") {
        rval = pki.decryptPrivateKeyInfo(asn1.fromDer(rval), password);
      } else {
        rval = asn1.fromDer(rval);
      }
      if (rval !== null) {
        rval = pki.privateKeyFromAsn1(rval);
      }
      return rval;
    };
    pki.pbe.generatePkcs12Key = function(password, salt, id, iter, n, md) {
      var j, l;
      if (typeof md === "undefined" || md === null) {
        if (!("sha1" in forge2.md)) {
          throw new Error('"sha1" hash algorithm unavailable.');
        }
        md = forge2.md.sha1.create();
      }
      var u = md.digestLength;
      var v = md.blockLength;
      var result = new forge2.util.ByteBuffer();
      var passBuf = new forge2.util.ByteBuffer();
      if (password !== null && password !== void 0) {
        for (l = 0; l < password.length; l++) {
          passBuf.putInt16(password.charCodeAt(l));
        }
        passBuf.putInt16(0);
      }
      var p = passBuf.length();
      var s = salt.length();
      var D = new forge2.util.ByteBuffer();
      D.fillWithByte(id, v);
      var Slen = v * Math.ceil(s / v);
      var S = new forge2.util.ByteBuffer();
      for (l = 0; l < Slen; l++) {
        S.putByte(salt.at(l % s));
      }
      var Plen = v * Math.ceil(p / v);
      var P = new forge2.util.ByteBuffer();
      for (l = 0; l < Plen; l++) {
        P.putByte(passBuf.at(l % p));
      }
      var I = S;
      I.putBuffer(P);
      var c = Math.ceil(n / u);
      for (var i = 1; i <= c; i++) {
        var buf = new forge2.util.ByteBuffer();
        buf.putBytes(D.bytes());
        buf.putBytes(I.bytes());
        for (var round = 0; round < iter; round++) {
          md.start();
          md.update(buf.getBytes());
          buf = md.digest();
        }
        var B = new forge2.util.ByteBuffer();
        for (l = 0; l < v; l++) {
          B.putByte(buf.at(l % u));
        }
        var k = Math.ceil(s / v) + Math.ceil(p / v);
        var Inew = new forge2.util.ByteBuffer();
        for (j = 0; j < k; j++) {
          var chunk = new forge2.util.ByteBuffer(I.getBytes(v));
          var x = 511;
          for (l = B.length() - 1; l >= 0; l--) {
            x = x >> 8;
            x += B.at(l) + chunk.at(l);
            chunk.setAt(l, x & 255);
          }
          Inew.putBuffer(chunk);
        }
        I = Inew;
        result.putBuffer(buf);
      }
      result.truncate(result.length() - n);
      return result;
    };
    pki.pbe.getCipher = function(oid, params, password) {
      switch (oid) {
        case pki.oids["pkcs5PBES2"]:
          return pki.pbe.getCipherForPBES2(oid, params, password);
        case pki.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:
        case pki.oids["pbewithSHAAnd40BitRC2-CBC"]:
          return pki.pbe.getCipherForPKCS12PBE(oid, params, password);
        default:
          var error = new Error("Cannot read encrypted PBE data block. Unsupported OID.");
          error.oid = oid;
          error.supportedOids = [
            "pkcs5PBES2",
            "pbeWithSHAAnd3-KeyTripleDES-CBC",
            "pbewithSHAAnd40BitRC2-CBC"
          ];
          throw error;
      }
    };
    pki.pbe.getCipherForPBES2 = function(oid, params, password) {
      var capture = {};
      var errors = [];
      if (!asn1.validate(params, PBES2AlgorithmsValidator, capture, errors)) {
        var error = new Error("Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
        error.errors = errors;
        throw error;
      }
      oid = asn1.derToOid(capture.kdfOid);
      if (oid !== pki.oids["pkcs5PBKDF2"]) {
        var error = new Error("Cannot read encrypted private key. Unsupported key derivation function OID.");
        error.oid = oid;
        error.supportedOids = ["pkcs5PBKDF2"];
        throw error;
      }
      oid = asn1.derToOid(capture.encOid);
      if (oid !== pki.oids["aes128-CBC"] && oid !== pki.oids["aes192-CBC"] && oid !== pki.oids["aes256-CBC"] && oid !== pki.oids["des-EDE3-CBC"] && oid !== pki.oids["desCBC"]) {
        var error = new Error("Cannot read encrypted private key. Unsupported encryption scheme OID.");
        error.oid = oid;
        error.supportedOids = [
          "aes128-CBC",
          "aes192-CBC",
          "aes256-CBC",
          "des-EDE3-CBC",
          "desCBC"
        ];
        throw error;
      }
      var salt = capture.kdfSalt;
      var count = forge2.util.createBuffer(capture.kdfIterationCount);
      count = count.getInt(count.length() << 3);
      var dkLen;
      var cipherFn;
      switch (pki.oids[oid]) {
        case "aes128-CBC":
          dkLen = 16;
          cipherFn = forge2.aes.createDecryptionCipher;
          break;
        case "aes192-CBC":
          dkLen = 24;
          cipherFn = forge2.aes.createDecryptionCipher;
          break;
        case "aes256-CBC":
          dkLen = 32;
          cipherFn = forge2.aes.createDecryptionCipher;
          break;
        case "des-EDE3-CBC":
          dkLen = 24;
          cipherFn = forge2.des.createDecryptionCipher;
          break;
        case "desCBC":
          dkLen = 8;
          cipherFn = forge2.des.createDecryptionCipher;
          break;
      }
      var md = prfOidToMessageDigest(capture.prfOid);
      var dk = forge2.pkcs5.pbkdf2(password, salt, count, dkLen, md);
      var iv = capture.encIv;
      var cipher = cipherFn(dk);
      cipher.start(iv);
      return cipher;
    };
    pki.pbe.getCipherForPKCS12PBE = function(oid, params, password) {
      var capture = {};
      var errors = [];
      if (!asn1.validate(params, pkcs12PbeParamsValidator, capture, errors)) {
        var error = new Error("Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
        error.errors = errors;
        throw error;
      }
      var salt = forge2.util.createBuffer(capture.salt);
      var count = forge2.util.createBuffer(capture.iterations);
      count = count.getInt(count.length() << 3);
      var dkLen, dIvLen, cipherFn;
      switch (oid) {
        case pki.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:
          dkLen = 24;
          dIvLen = 8;
          cipherFn = forge2.des.startDecrypting;
          break;
        case pki.oids["pbewithSHAAnd40BitRC2-CBC"]:
          dkLen = 5;
          dIvLen = 8;
          cipherFn = function(key3, iv2) {
            var cipher = forge2.rc2.createDecryptionCipher(key3, 40);
            cipher.start(iv2, null);
            return cipher;
          };
          break;
        default:
          var error = new Error("Cannot read PKCS #12 PBE data block. Unsupported OID.");
          error.oid = oid;
          throw error;
      }
      var md = prfOidToMessageDigest(capture.prfOid);
      var key2 = pki.pbe.generatePkcs12Key(password, salt, 1, count, dkLen, md);
      md.start();
      var iv = pki.pbe.generatePkcs12Key(password, salt, 2, count, dIvLen, md);
      return cipherFn(key2, iv);
    };
    pki.pbe.opensslDeriveBytes = function(password, salt, dkLen, md) {
      if (typeof md === "undefined" || md === null) {
        if (!("md5" in forge2.md)) {
          throw new Error('"md5" hash algorithm unavailable.');
        }
        md = forge2.md.md5.create();
      }
      if (salt === null) {
        salt = "";
      }
      var digests = [hash(md, password + salt)];
      for (var length2 = 16, i = 1; length2 < dkLen; ++i, length2 += 16) {
        digests.push(hash(md, digests[i - 1] + password + salt));
      }
      return digests.join("").substr(0, dkLen);
    };
    function hash(md, bytes) {
      return md.start().update(bytes).digest().getBytes();
    }
    function prfOidToMessageDigest(prfOid) {
      var prfAlgorithm;
      if (!prfOid) {
        prfAlgorithm = "hmacWithSHA1";
      } else {
        prfAlgorithm = pki.oids[asn1.derToOid(prfOid)];
        if (!prfAlgorithm) {
          var error = new Error("Unsupported PRF OID.");
          error.oid = prfOid;
          error.supported = [
            "hmacWithSHA1",
            "hmacWithSHA224",
            "hmacWithSHA256",
            "hmacWithSHA384",
            "hmacWithSHA512"
          ];
          throw error;
        }
      }
      return prfAlgorithmToMessageDigest(prfAlgorithm);
    }
    function prfAlgorithmToMessageDigest(prfAlgorithm) {
      var factory = forge2.md;
      switch (prfAlgorithm) {
        case "hmacWithSHA224":
          factory = forge2.md.sha512;
        case "hmacWithSHA1":
        case "hmacWithSHA256":
        case "hmacWithSHA384":
        case "hmacWithSHA512":
          prfAlgorithm = prfAlgorithm.substr(8).toLowerCase();
          break;
        default:
          var error = new Error("Unsupported PRF algorithm.");
          error.algorithm = prfAlgorithm;
          error.supported = [
            "hmacWithSHA1",
            "hmacWithSHA224",
            "hmacWithSHA256",
            "hmacWithSHA384",
            "hmacWithSHA512"
          ];
          throw error;
      }
      if (!factory || !(prfAlgorithm in factory)) {
        throw new Error("Unknown hash algorithm: " + prfAlgorithm);
      }
      return factory[prfAlgorithm].create();
    }
    function createPbkdf2Params(salt, countBytes, dkLen, prfAlgorithm) {
      var params = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // salt
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OCTETSTRING,
          false,
          salt
        ),
        // iteration count
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          countBytes.getBytes()
        )
      ]);
      if (prfAlgorithm !== "hmacWithSHA1") {
        params.value.push(
          // key length
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.INTEGER,
            false,
            forge2.util.hexToBytes(dkLen.toString(16))
          ),
          // AlgorithmIdentifier
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            // algorithm
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(pki.oids[prfAlgorithm]).getBytes()
            ),
            // parameters (null)
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
          ])
        );
      }
      return params;
    }
  }
});

// node_modules/@selfxyz/common/node_modules/node-forge/lib/pkcs7asn1.js
var require_pkcs7asn1 = __commonJS({
  "node_modules/@selfxyz/common/node_modules/node-forge/lib/pkcs7asn1.js"(exports2, module2) {
    var forge2 = require_forge();
    require_asn1();
    require_util();
    var asn1 = forge2.asn1;
    var p7v = module2.exports = forge2.pkcs7asn1 = forge2.pkcs7asn1 || {};
    forge2.pkcs7 = forge2.pkcs7 || {};
    forge2.pkcs7.asn1 = p7v;
    var contentInfoValidator = {
      name: "ContentInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "ContentInfo.ContentType",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: "contentType"
      }, {
        name: "ContentInfo.content",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 0,
        constructed: true,
        optional: true,
        captureAsn1: "content"
      }]
    };
    p7v.contentInfoValidator = contentInfoValidator;
    var encryptedContentInfoValidator = {
      name: "EncryptedContentInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "EncryptedContentInfo.contentType",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: "contentType"
      }, {
        name: "EncryptedContentInfo.contentEncryptionAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "EncryptedContentInfo.contentEncryptionAlgorithm.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "encAlgorithm"
        }, {
          name: "EncryptedContentInfo.contentEncryptionAlgorithm.parameter",
          tagClass: asn1.Class.UNIVERSAL,
          captureAsn1: "encParameter"
        }]
      }, {
        name: "EncryptedContentInfo.encryptedContent",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 0,
        /* The PKCS#7 structure output by OpenSSL somewhat differs from what
         * other implementations do generate.
         *
         * OpenSSL generates a structure like this:
         * SEQUENCE {
         *    ...
         *    [0]
         *       26 DA 67 D2 17 9C 45 3C B1 2A A8 59 2F 29 33 38
         *       C3 C3 DF 86 71 74 7A 19 9F 40 D0 29 BE 85 90 45
         *       ...
         * }
         *
         * Whereas other implementations (and this PKCS#7 module) generate:
         * SEQUENCE {
         *    ...
         *    [0] {
         *       OCTET STRING
         *          26 DA 67 D2 17 9C 45 3C B1 2A A8 59 2F 29 33 38
         *          C3 C3 DF 86 71 74 7A 19 9F 40 D0 29 BE 85 90 45
         *          ...
         *    }
         * }
         *
         * In order to support both, we just capture the context specific
         * field here.  The OCTET STRING bit is removed below.
         */
        capture: "encryptedContent",
        captureAsn1: "encryptedContentAsn1"
      }]
    };
    p7v.envelopedDataValidator = {
      name: "EnvelopedData",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "EnvelopedData.Version",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "version"
      }, {
        name: "EnvelopedData.RecipientInfos",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SET,
        constructed: true,
        captureAsn1: "recipientInfos"
      }].concat(encryptedContentInfoValidator)
    };
    p7v.encryptedDataValidator = {
      name: "EncryptedData",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "EncryptedData.Version",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "version"
      }].concat(encryptedContentInfoValidator)
    };
    var signerValidator = {
      name: "SignerInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "SignerInfo.version",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false
      }, {
        name: "SignerInfo.issuerAndSerialNumber",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "SignerInfo.issuerAndSerialNumber.issuer",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          captureAsn1: "issuer"
        }, {
          name: "SignerInfo.issuerAndSerialNumber.serialNumber",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          capture: "serial"
        }]
      }, {
        name: "SignerInfo.digestAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "SignerInfo.digestAlgorithm.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "digestAlgorithm"
        }, {
          name: "SignerInfo.digestAlgorithm.parameter",
          tagClass: asn1.Class.UNIVERSAL,
          constructed: false,
          captureAsn1: "digestParameter",
          optional: true
        }]
      }, {
        name: "SignerInfo.authenticatedAttributes",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 0,
        constructed: true,
        optional: true,
        capture: "authenticatedAttributes"
      }, {
        name: "SignerInfo.digestEncryptionAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        capture: "signatureAlgorithm"
      }, {
        name: "SignerInfo.encryptedDigest",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: false,
        capture: "signature"
      }, {
        name: "SignerInfo.unauthenticatedAttributes",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 1,
        constructed: true,
        optional: true,
        capture: "unauthenticatedAttributes"
      }]
    };
    p7v.signedDataValidator = {
      name: "SignedData",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [
        {
          name: "SignedData.Version",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          capture: "version"
        },
        {
          name: "SignedData.DigestAlgorithms",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SET,
          constructed: true,
          captureAsn1: "digestAlgorithms"
        },
        contentInfoValidator,
        {
          name: "SignedData.Certificates",
          tagClass: asn1.Class.CONTEXT_SPECIFIC,
          type: 0,
          optional: true,
          captureAsn1: "certificates"
        },
        {
          name: "SignedData.CertificateRevocationLists",
          tagClass: asn1.Class.CONTEXT_SPECIFIC,
          type: 1,
          optional: true,
          captureAsn1: "crls"
        },
        {
          name: "SignedData.SignerInfos",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SET,
          capture: "signerInfos",
          optional: true,
          value: [signerValidator]
        }
      ]
    };
    p7v.recipientInfoValidator = {
      name: "RecipientInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "RecipientInfo.version",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "version"
      }, {
        name: "RecipientInfo.issuerAndSerial",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "RecipientInfo.issuerAndSerial.issuer",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          captureAsn1: "issuer"
        }, {
          name: "RecipientInfo.issuerAndSerial.serialNumber",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          capture: "serial"
        }]
      }, {
        name: "RecipientInfo.keyEncryptionAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "RecipientInfo.keyEncryptionAlgorithm.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "encAlgorithm"
        }, {
          name: "RecipientInfo.keyEncryptionAlgorithm.parameter",
          tagClass: asn1.Class.UNIVERSAL,
          constructed: false,
          captureAsn1: "encParameter",
          optional: true
        }]
      }, {
        name: "RecipientInfo.encryptedKey",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: false,
        capture: "encKey"
      }]
    };
  }
});

// node_modules/@selfxyz/common/node_modules/node-forge/lib/mgf1.js
var require_mgf1 = __commonJS({
  "node_modules/@selfxyz/common/node_modules/node-forge/lib/mgf1.js"(exports2, module2) {
    var forge2 = require_forge();
    require_util();
    forge2.mgf = forge2.mgf || {};
    var mgf1 = module2.exports = forge2.mgf.mgf1 = forge2.mgf1 = forge2.mgf1 || {};
    mgf1.create = function(md) {
      var mgf = {
        /**
         * Generate mask of specified length.
         *
         * @param {String} seed The seed for mask generation.
         * @param maskLen Number of bytes to generate.
         * @return {String} The generated mask.
         */
        generate: function(seed, maskLen) {
          var t = new forge2.util.ByteBuffer();
          var len = Math.ceil(maskLen / md.digestLength);
          for (var i = 0; i < len; i++) {
            var c = new forge2.util.ByteBuffer();
            c.putInt32(i);
            md.start();
            md.update(seed + c.getBytes());
            t.putBuffer(md.digest());
          }
          t.truncate(t.length() - maskLen);
          return t.getBytes();
        }
      };
      return mgf;
    };
  }
});

// node_modules/@selfxyz/common/node_modules/node-forge/lib/mgf.js
var require_mgf = __commonJS({
  "node_modules/@selfxyz/common/node_modules/node-forge/lib/mgf.js"(exports2, module2) {
    var forge2 = require_forge();
    require_mgf1();
    module2.exports = forge2.mgf = forge2.mgf || {};
    forge2.mgf.mgf1 = forge2.mgf1;
  }
});

// node_modules/@selfxyz/common/node_modules/node-forge/lib/pss.js
var require_pss = __commonJS({
  "node_modules/@selfxyz/common/node_modules/node-forge/lib/pss.js"(exports2, module2) {
    var forge2 = require_forge();
    require_random();
    require_util();
    var pss = module2.exports = forge2.pss = forge2.pss || {};
    pss.create = function(options) {
      if (arguments.length === 3) {
        options = {
          md: arguments[0],
          mgf: arguments[1],
          saltLength: arguments[2]
        };
      }
      var hash = options.md;
      var mgf = options.mgf;
      var hLen = hash.digestLength;
      var salt_ = options.salt || null;
      if (typeof salt_ === "string") {
        salt_ = forge2.util.createBuffer(salt_);
      }
      var sLen;
      if ("saltLength" in options) {
        sLen = options.saltLength;
      } else if (salt_ !== null) {
        sLen = salt_.length();
      } else {
        throw new Error("Salt length not specified or specific salt not given.");
      }
      if (salt_ !== null && salt_.length() !== sLen) {
        throw new Error("Given salt length does not match length of given salt.");
      }
      var prng = options.prng || forge2.random;
      var pssobj = {};
      pssobj.encode = function(md, modBits) {
        var i;
        var emBits = modBits - 1;
        var emLen = Math.ceil(emBits / 8);
        var mHash = md.digest().getBytes();
        if (emLen < hLen + sLen + 2) {
          throw new Error("Message is too long to encrypt.");
        }
        var salt;
        if (salt_ === null) {
          salt = prng.getBytesSync(sLen);
        } else {
          salt = salt_.bytes();
        }
        var m_ = new forge2.util.ByteBuffer();
        m_.fillWithByte(0, 8);
        m_.putBytes(mHash);
        m_.putBytes(salt);
        hash.start();
        hash.update(m_.getBytes());
        var h = hash.digest().getBytes();
        var ps = new forge2.util.ByteBuffer();
        ps.fillWithByte(0, emLen - sLen - hLen - 2);
        ps.putByte(1);
        ps.putBytes(salt);
        var db = ps.getBytes();
        var maskLen = emLen - hLen - 1;
        var dbMask = mgf.generate(h, maskLen);
        var maskedDB = "";
        for (i = 0; i < maskLen; i++) {
          maskedDB += String.fromCharCode(db.charCodeAt(i) ^ dbMask.charCodeAt(i));
        }
        var mask2 = 65280 >> 8 * emLen - emBits & 255;
        maskedDB = String.fromCharCode(maskedDB.charCodeAt(0) & ~mask2) + maskedDB.substr(1);
        return maskedDB + h + String.fromCharCode(188);
      };
      pssobj.verify = function(mHash, em, modBits) {
        var i;
        var emBits = modBits - 1;
        var emLen = Math.ceil(emBits / 8);
        em = em.substr(-emLen);
        if (emLen < hLen + sLen + 2) {
          throw new Error("Inconsistent parameters to PSS signature verification.");
        }
        if (em.charCodeAt(emLen - 1) !== 188) {
          throw new Error("Encoded message does not end in 0xBC.");
        }
        var maskLen = emLen - hLen - 1;
        var maskedDB = em.substr(0, maskLen);
        var h = em.substr(maskLen, hLen);
        var mask2 = 65280 >> 8 * emLen - emBits & 255;
        if ((maskedDB.charCodeAt(0) & mask2) !== 0) {
          throw new Error("Bits beyond keysize not zero as expected.");
        }
        var dbMask = mgf.generate(h, maskLen);
        var db = "";
        for (i = 0; i < maskLen; i++) {
          db += String.fromCharCode(maskedDB.charCodeAt(i) ^ dbMask.charCodeAt(i));
        }
        db = String.fromCharCode(db.charCodeAt(0) & ~mask2) + db.substr(1);
        var checkLen = emLen - hLen - sLen - 2;
        for (i = 0; i < checkLen; i++) {
          if (db.charCodeAt(i) !== 0) {
            throw new Error("Leftmost octets not zero as expected");
          }
        }
        if (db.charCodeAt(checkLen) !== 1) {
          throw new Error("Inconsistent PSS signature, 0x01 marker not found");
        }
        var salt = db.substr(-sLen);
        var m_ = new forge2.util.ByteBuffer();
        m_.fillWithByte(0, 8);
        m_.putBytes(mHash);
        m_.putBytes(salt);
        hash.start();
        hash.update(m_.getBytes());
        var h_ = hash.digest().getBytes();
        return h === h_;
      };
      return pssobj;
    };
  }
});

// node_modules/@selfxyz/common/node_modules/node-forge/lib/x509.js
var require_x509 = __commonJS({
  "node_modules/@selfxyz/common/node_modules/node-forge/lib/x509.js"(exports2, module2) {
    var forge2 = require_forge();
    require_aes();
    require_asn1();
    require_des();
    require_md();
    require_mgf();
    require_oids();
    require_pem();
    require_pss();
    require_rsa();
    require_util();
    var asn1 = forge2.asn1;
    var pki = module2.exports = forge2.pki = forge2.pki || {};
    var oids = pki.oids;
    var _shortNames = {};
    _shortNames["CN"] = oids["commonName"];
    _shortNames["commonName"] = "CN";
    _shortNames["C"] = oids["countryName"];
    _shortNames["countryName"] = "C";
    _shortNames["L"] = oids["localityName"];
    _shortNames["localityName"] = "L";
    _shortNames["ST"] = oids["stateOrProvinceName"];
    _shortNames["stateOrProvinceName"] = "ST";
    _shortNames["O"] = oids["organizationName"];
    _shortNames["organizationName"] = "O";
    _shortNames["OU"] = oids["organizationalUnitName"];
    _shortNames["organizationalUnitName"] = "OU";
    _shortNames["E"] = oids["emailAddress"];
    _shortNames["emailAddress"] = "E";
    var publicKeyValidator = forge2.pki.rsa.publicKeyValidator;
    var x509CertificateValidator = {
      name: "Certificate",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "Certificate.TBSCertificate",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        captureAsn1: "tbsCertificate",
        value: [
          {
            name: "Certificate.TBSCertificate.version",
            tagClass: asn1.Class.CONTEXT_SPECIFIC,
            type: 0,
            constructed: true,
            optional: true,
            value: [{
              name: "Certificate.TBSCertificate.version.integer",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.INTEGER,
              constructed: false,
              capture: "certVersion"
            }]
          },
          {
            name: "Certificate.TBSCertificate.serialNumber",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.INTEGER,
            constructed: false,
            capture: "certSerialNumber"
          },
          {
            name: "Certificate.TBSCertificate.signature",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            value: [{
              name: "Certificate.TBSCertificate.signature.algorithm",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.OID,
              constructed: false,
              capture: "certinfoSignatureOid"
            }, {
              name: "Certificate.TBSCertificate.signature.parameters",
              tagClass: asn1.Class.UNIVERSAL,
              optional: true,
              captureAsn1: "certinfoSignatureParams"
            }]
          },
          {
            name: "Certificate.TBSCertificate.issuer",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            captureAsn1: "certIssuer"
          },
          {
            name: "Certificate.TBSCertificate.validity",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            // Note: UTC and generalized times may both appear so the capture
            // names are based on their detected order, the names used below
            // are only for the common case, which validity time really means
            // "notBefore" and which means "notAfter" will be determined by order
            value: [{
              // notBefore (Time) (UTC time case)
              name: "Certificate.TBSCertificate.validity.notBefore (utc)",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.UTCTIME,
              constructed: false,
              optional: true,
              capture: "certValidity1UTCTime"
            }, {
              // notBefore (Time) (generalized time case)
              name: "Certificate.TBSCertificate.validity.notBefore (generalized)",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.GENERALIZEDTIME,
              constructed: false,
              optional: true,
              capture: "certValidity2GeneralizedTime"
            }, {
              // notAfter (Time) (only UTC time is supported)
              name: "Certificate.TBSCertificate.validity.notAfter (utc)",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.UTCTIME,
              constructed: false,
              optional: true,
              capture: "certValidity3UTCTime"
            }, {
              // notAfter (Time) (only UTC time is supported)
              name: "Certificate.TBSCertificate.validity.notAfter (generalized)",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.GENERALIZEDTIME,
              constructed: false,
              optional: true,
              capture: "certValidity4GeneralizedTime"
            }]
          },
          {
            // Name (subject) (RDNSequence)
            name: "Certificate.TBSCertificate.subject",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            captureAsn1: "certSubject"
          },
          // SubjectPublicKeyInfo
          publicKeyValidator,
          {
            // issuerUniqueID (optional)
            name: "Certificate.TBSCertificate.issuerUniqueID",
            tagClass: asn1.Class.CONTEXT_SPECIFIC,
            type: 1,
            constructed: true,
            optional: true,
            value: [{
              name: "Certificate.TBSCertificate.issuerUniqueID.id",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.BITSTRING,
              constructed: false,
              // TODO: support arbitrary bit length ids
              captureBitStringValue: "certIssuerUniqueId"
            }]
          },
          {
            // subjectUniqueID (optional)
            name: "Certificate.TBSCertificate.subjectUniqueID",
            tagClass: asn1.Class.CONTEXT_SPECIFIC,
            type: 2,
            constructed: true,
            optional: true,
            value: [{
              name: "Certificate.TBSCertificate.subjectUniqueID.id",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.BITSTRING,
              constructed: false,
              // TODO: support arbitrary bit length ids
              captureBitStringValue: "certSubjectUniqueId"
            }]
          },
          {
            // Extensions (optional)
            name: "Certificate.TBSCertificate.extensions",
            tagClass: asn1.Class.CONTEXT_SPECIFIC,
            type: 3,
            constructed: true,
            captureAsn1: "certExtensions",
            optional: true
          }
        ]
      }, {
        // AlgorithmIdentifier (signature algorithm)
        name: "Certificate.signatureAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          // algorithm
          name: "Certificate.signatureAlgorithm.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "certSignatureOid"
        }, {
          name: "Certificate.TBSCertificate.signature.parameters",
          tagClass: asn1.Class.UNIVERSAL,
          optional: true,
          captureAsn1: "certSignatureParams"
        }]
      }, {
        // SignatureValue
        name: "Certificate.signatureValue",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.BITSTRING,
        constructed: false,
        captureBitStringValue: "certSignature"
      }]
    };
    var rsassaPssParameterValidator = {
      name: "rsapss",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "rsapss.hashAlgorithm",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 0,
        constructed: true,
        value: [{
          name: "rsapss.hashAlgorithm.AlgorithmIdentifier",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Class.SEQUENCE,
          constructed: true,
          optional: true,
          value: [{
            name: "rsapss.hashAlgorithm.AlgorithmIdentifier.algorithm",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OID,
            constructed: false,
            capture: "hashOid"
            /* parameter block omitted, for SHA1 NULL anyhow. */
          }]
        }]
      }, {
        name: "rsapss.maskGenAlgorithm",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 1,
        constructed: true,
        value: [{
          name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Class.SEQUENCE,
          constructed: true,
          optional: true,
          value: [{
            name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.algorithm",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OID,
            constructed: false,
            capture: "maskGenOid"
          }, {
            name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.params",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            value: [{
              name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.params.algorithm",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.OID,
              constructed: false,
              capture: "maskGenHashOid"
              /* parameter block omitted, for SHA1 NULL anyhow. */
            }]
          }]
        }]
      }, {
        name: "rsapss.saltLength",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 2,
        optional: true,
        value: [{
          name: "rsapss.saltLength.saltLength",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Class.INTEGER,
          constructed: false,
          capture: "saltLength"
        }]
      }, {
        name: "rsapss.trailerField",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 3,
        optional: true,
        value: [{
          name: "rsapss.trailer.trailer",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Class.INTEGER,
          constructed: false,
          capture: "trailer"
        }]
      }]
    };
    var certificationRequestInfoValidator = {
      name: "CertificationRequestInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      captureAsn1: "certificationRequestInfo",
      value: [
        {
          name: "CertificationRequestInfo.integer",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          capture: "certificationRequestInfoVersion"
        },
        {
          // Name (subject) (RDNSequence)
          name: "CertificationRequestInfo.subject",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          captureAsn1: "certificationRequestInfoSubject"
        },
        // SubjectPublicKeyInfo
        publicKeyValidator,
        {
          name: "CertificationRequestInfo.attributes",
          tagClass: asn1.Class.CONTEXT_SPECIFIC,
          type: 0,
          constructed: true,
          optional: true,
          capture: "certificationRequestInfoAttributes",
          value: [{
            name: "CertificationRequestInfo.attributes",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            value: [{
              name: "CertificationRequestInfo.attributes.type",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.OID,
              constructed: false
            }, {
              name: "CertificationRequestInfo.attributes.value",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.SET,
              constructed: true
            }]
          }]
        }
      ]
    };
    var certificationRequestValidator = {
      name: "CertificationRequest",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      captureAsn1: "csr",
      value: [
        certificationRequestInfoValidator,
        {
          // AlgorithmIdentifier (signature algorithm)
          name: "CertificationRequest.signatureAlgorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          value: [{
            // algorithm
            name: "CertificationRequest.signatureAlgorithm.algorithm",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OID,
            constructed: false,
            capture: "csrSignatureOid"
          }, {
            name: "CertificationRequest.signatureAlgorithm.parameters",
            tagClass: asn1.Class.UNIVERSAL,
            optional: true,
            captureAsn1: "csrSignatureParams"
          }]
        },
        {
          // signature
          name: "CertificationRequest.signature",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.BITSTRING,
          constructed: false,
          captureBitStringValue: "csrSignature"
        }
      ]
    };
    pki.RDNAttributesAsArray = function(rdn, md) {
      var rval = [];
      var set, attr, obj;
      for (var si = 0; si < rdn.value.length; ++si) {
        set = rdn.value[si];
        for (var i = 0; i < set.value.length; ++i) {
          obj = {};
          attr = set.value[i];
          obj.type = asn1.derToOid(attr.value[0].value);
          obj.value = attr.value[1].value;
          obj.valueTagClass = attr.value[1].type;
          if (obj.type in oids) {
            obj.name = oids[obj.type];
            if (obj.name in _shortNames) {
              obj.shortName = _shortNames[obj.name];
            }
          }
          if (md) {
            md.update(obj.type);
            md.update(obj.value);
          }
          rval.push(obj);
        }
      }
      return rval;
    };
    pki.CRIAttributesAsArray = function(attributes) {
      var rval = [];
      for (var si = 0; si < attributes.length; ++si) {
        var seq = attributes[si];
        var type = asn1.derToOid(seq.value[0].value);
        var values = seq.value[1].value;
        for (var vi = 0; vi < values.length; ++vi) {
          var obj = {};
          obj.type = type;
          obj.value = values[vi].value;
          obj.valueTagClass = values[vi].type;
          if (obj.type in oids) {
            obj.name = oids[obj.type];
            if (obj.name in _shortNames) {
              obj.shortName = _shortNames[obj.name];
            }
          }
          if (obj.type === oids.extensionRequest) {
            obj.extensions = [];
            for (var ei = 0; ei < obj.value.length; ++ei) {
              obj.extensions.push(pki.certificateExtensionFromAsn1(obj.value[ei]));
            }
          }
          rval.push(obj);
        }
      }
      return rval;
    };
    function _getAttribute(obj, options) {
      if (typeof options === "string") {
        options = { shortName: options };
      }
      var rval = null;
      var attr;
      for (var i = 0; rval === null && i < obj.attributes.length; ++i) {
        attr = obj.attributes[i];
        if (options.type && options.type === attr.type) {
          rval = attr;
        } else if (options.name && options.name === attr.name) {
          rval = attr;
        } else if (options.shortName && options.shortName === attr.shortName) {
          rval = attr;
        }
      }
      return rval;
    }
    var _readSignatureParameters = function(oid, obj, fillDefaults) {
      var params = {};
      if (oid !== oids["RSASSA-PSS"]) {
        return params;
      }
      if (fillDefaults) {
        params = {
          hash: {
            algorithmOid: oids["sha1"]
          },
          mgf: {
            algorithmOid: oids["mgf1"],
            hash: {
              algorithmOid: oids["sha1"]
            }
          },
          saltLength: 20
        };
      }
      var capture = {};
      var errors = [];
      if (!asn1.validate(obj, rsassaPssParameterValidator, capture, errors)) {
        var error = new Error("Cannot read RSASSA-PSS parameter block.");
        error.errors = errors;
        throw error;
      }
      if (capture.hashOid !== void 0) {
        params.hash = params.hash || {};
        params.hash.algorithmOid = asn1.derToOid(capture.hashOid);
      }
      if (capture.maskGenOid !== void 0) {
        params.mgf = params.mgf || {};
        params.mgf.algorithmOid = asn1.derToOid(capture.maskGenOid);
        params.mgf.hash = params.mgf.hash || {};
        params.mgf.hash.algorithmOid = asn1.derToOid(capture.maskGenHashOid);
      }
      if (capture.saltLength !== void 0) {
        params.saltLength = capture.saltLength.charCodeAt(0);
      }
      return params;
    };
    var _createSignatureDigest = function(options) {
      switch (oids[options.signatureOid]) {
        case "sha1WithRSAEncryption":
        // deprecated alias
        case "sha1WithRSASignature":
          return forge2.md.sha1.create();
        case "md5WithRSAEncryption":
          return forge2.md.md5.create();
        case "sha256WithRSAEncryption":
          return forge2.md.sha256.create();
        case "sha384WithRSAEncryption":
          return forge2.md.sha384.create();
        case "sha512WithRSAEncryption":
          return forge2.md.sha512.create();
        case "RSASSA-PSS":
          return forge2.md.sha256.create();
        default:
          var error = new Error(
            "Could not compute " + options.type + " digest. Unknown signature OID."
          );
          error.signatureOid = options.signatureOid;
          throw error;
      }
    };
    var _verifySignature = function(options) {
      var cert = options.certificate;
      var scheme;
      switch (cert.signatureOid) {
        case oids.sha1WithRSAEncryption:
        // deprecated alias
        case oids.sha1WithRSASignature:
          break;
        case oids["RSASSA-PSS"]:
          var hash, mgf;
          hash = oids[cert.signatureParameters.mgf.hash.algorithmOid];
          if (hash === void 0 || forge2.md[hash] === void 0) {
            var error = new Error("Unsupported MGF hash function.");
            error.oid = cert.signatureParameters.mgf.hash.algorithmOid;
            error.name = hash;
            throw error;
          }
          mgf = oids[cert.signatureParameters.mgf.algorithmOid];
          if (mgf === void 0 || forge2.mgf[mgf] === void 0) {
            var error = new Error("Unsupported MGF function.");
            error.oid = cert.signatureParameters.mgf.algorithmOid;
            error.name = mgf;
            throw error;
          }
          mgf = forge2.mgf[mgf].create(forge2.md[hash].create());
          hash = oids[cert.signatureParameters.hash.algorithmOid];
          if (hash === void 0 || forge2.md[hash] === void 0) {
            var error = new Error("Unsupported RSASSA-PSS hash function.");
            error.oid = cert.signatureParameters.hash.algorithmOid;
            error.name = hash;
            throw error;
          }
          scheme = forge2.pss.create(
            forge2.md[hash].create(),
            mgf,
            cert.signatureParameters.saltLength
          );
          break;
      }
      return cert.publicKey.verify(
        options.md.digest().getBytes(),
        options.signature,
        scheme
      );
    };
    pki.certificateFromPem = function(pem, computeHash, strict) {
      var msg = forge2.pem.decode(pem)[0];
      if (msg.type !== "CERTIFICATE" && msg.type !== "X509 CERTIFICATE" && msg.type !== "TRUSTED CERTIFICATE") {
        var error = new Error(
          'Could not convert certificate from PEM; PEM header type is not "CERTIFICATE", "X509 CERTIFICATE", or "TRUSTED CERTIFICATE".'
        );
        error.headerType = msg.type;
        throw error;
      }
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        throw new Error(
          "Could not convert certificate from PEM; PEM is encrypted."
        );
      }
      var obj = asn1.fromDer(msg.body, strict);
      return pki.certificateFromAsn1(obj, computeHash);
    };
    pki.certificateToPem = function(cert, maxline) {
      var msg = {
        type: "CERTIFICATE",
        body: asn1.toDer(pki.certificateToAsn1(cert)).getBytes()
      };
      return forge2.pem.encode(msg, { maxline });
    };
    pki.publicKeyFromPem = function(pem) {
      var msg = forge2.pem.decode(pem)[0];
      if (msg.type !== "PUBLIC KEY" && msg.type !== "RSA PUBLIC KEY") {
        var error = new Error('Could not convert public key from PEM; PEM header type is not "PUBLIC KEY" or "RSA PUBLIC KEY".');
        error.headerType = msg.type;
        throw error;
      }
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        throw new Error("Could not convert public key from PEM; PEM is encrypted.");
      }
      var obj = asn1.fromDer(msg.body);
      return pki.publicKeyFromAsn1(obj);
    };
    pki.publicKeyToPem = function(key2, maxline) {
      var msg = {
        type: "PUBLIC KEY",
        body: asn1.toDer(pki.publicKeyToAsn1(key2)).getBytes()
      };
      return forge2.pem.encode(msg, { maxline });
    };
    pki.publicKeyToRSAPublicKeyPem = function(key2, maxline) {
      var msg = {
        type: "RSA PUBLIC KEY",
        body: asn1.toDer(pki.publicKeyToRSAPublicKey(key2)).getBytes()
      };
      return forge2.pem.encode(msg, { maxline });
    };
    pki.getPublicKeyFingerprint = function(key2, options) {
      options = options || {};
      var md = options.md || forge2.md.sha1.create();
      var type = options.type || "RSAPublicKey";
      var bytes;
      switch (type) {
        case "RSAPublicKey":
          bytes = asn1.toDer(pki.publicKeyToRSAPublicKey(key2)).getBytes();
          break;
        case "SubjectPublicKeyInfo":
          bytes = asn1.toDer(pki.publicKeyToAsn1(key2)).getBytes();
          break;
        default:
          throw new Error('Unknown fingerprint type "' + options.type + '".');
      }
      md.start();
      md.update(bytes);
      var digest = md.digest();
      if (options.encoding === "hex") {
        var hex = digest.toHex();
        if (options.delimiter) {
          return hex.match(/.{2}/g).join(options.delimiter);
        }
        return hex;
      } else if (options.encoding === "binary") {
        return digest.getBytes();
      } else if (options.encoding) {
        throw new Error('Unknown encoding "' + options.encoding + '".');
      }
      return digest;
    };
    pki.certificationRequestFromPem = function(pem, computeHash, strict) {
      var msg = forge2.pem.decode(pem)[0];
      if (msg.type !== "CERTIFICATE REQUEST") {
        var error = new Error('Could not convert certification request from PEM; PEM header type is not "CERTIFICATE REQUEST".');
        error.headerType = msg.type;
        throw error;
      }
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        throw new Error("Could not convert certification request from PEM; PEM is encrypted.");
      }
      var obj = asn1.fromDer(msg.body, strict);
      return pki.certificationRequestFromAsn1(obj, computeHash);
    };
    pki.certificationRequestToPem = function(csr, maxline) {
      var msg = {
        type: "CERTIFICATE REQUEST",
        body: asn1.toDer(pki.certificationRequestToAsn1(csr)).getBytes()
      };
      return forge2.pem.encode(msg, { maxline });
    };
    pki.createCertificate = function() {
      var cert = {};
      cert.version = 2;
      cert.serialNumber = "00";
      cert.signatureOid = null;
      cert.signature = null;
      cert.siginfo = {};
      cert.siginfo.algorithmOid = null;
      cert.validity = {};
      cert.validity.notBefore = /* @__PURE__ */ new Date();
      cert.validity.notAfter = /* @__PURE__ */ new Date();
      cert.issuer = {};
      cert.issuer.getField = function(sn) {
        return _getAttribute(cert.issuer, sn);
      };
      cert.issuer.addField = function(attr) {
        _fillMissingFields([attr]);
        cert.issuer.attributes.push(attr);
      };
      cert.issuer.attributes = [];
      cert.issuer.hash = null;
      cert.subject = {};
      cert.subject.getField = function(sn) {
        return _getAttribute(cert.subject, sn);
      };
      cert.subject.addField = function(attr) {
        _fillMissingFields([attr]);
        cert.subject.attributes.push(attr);
      };
      cert.subject.attributes = [];
      cert.subject.hash = null;
      cert.extensions = [];
      cert.publicKey = null;
      cert.md = null;
      cert.setSubject = function(attrs, uniqueId) {
        _fillMissingFields(attrs);
        cert.subject.attributes = attrs;
        delete cert.subject.uniqueId;
        if (uniqueId) {
          cert.subject.uniqueId = uniqueId;
        }
        cert.subject.hash = null;
      };
      cert.setIssuer = function(attrs, uniqueId) {
        _fillMissingFields(attrs);
        cert.issuer.attributes = attrs;
        delete cert.issuer.uniqueId;
        if (uniqueId) {
          cert.issuer.uniqueId = uniqueId;
        }
        cert.issuer.hash = null;
      };
      cert.setExtensions = function(exts) {
        for (var i = 0; i < exts.length; ++i) {
          _fillMissingExtensionFields(exts[i], { cert });
        }
        cert.extensions = exts;
      };
      cert.getExtension = function(options) {
        if (typeof options === "string") {
          options = { name: options };
        }
        var rval = null;
        var ext;
        for (var i = 0; rval === null && i < cert.extensions.length; ++i) {
          ext = cert.extensions[i];
          if (options.id && ext.id === options.id) {
            rval = ext;
          } else if (options.name && ext.name === options.name) {
            rval = ext;
          }
        }
        return rval;
      };
      cert.sign = function(key2, md) {
        cert.md = md || forge2.md.sha1.create();
        var algorithmOid = oids[cert.md.algorithm + "WithRSAEncryption"];
        if (!algorithmOid) {
          var error = new Error("Could not compute certificate digest. Unknown message digest algorithm OID.");
          error.algorithm = cert.md.algorithm;
          throw error;
        }
        cert.signatureOid = cert.siginfo.algorithmOid = algorithmOid;
        cert.tbsCertificate = pki.getTBSCertificate(cert);
        var bytes = asn1.toDer(cert.tbsCertificate);
        cert.md.update(bytes.getBytes());
        cert.signature = key2.sign(cert.md);
      };
      cert.verify = function(child) {
        var rval = false;
        if (!cert.issued(child)) {
          var issuer = child.issuer;
          var subject = cert.subject;
          var error = new Error(
            "The parent certificate did not issue the given child certificate; the child certificate's issuer does not match the parent's subject."
          );
          error.expectedIssuer = subject.attributes;
          error.actualIssuer = issuer.attributes;
          throw error;
        }
        var md = child.md;
        if (md === null) {
          md = _createSignatureDigest({
            signatureOid: child.signatureOid,
            type: "certificate"
          });
          var tbsCertificate = child.tbsCertificate || pki.getTBSCertificate(child);
          var bytes = asn1.toDer(tbsCertificate);
          md.update(bytes.getBytes());
        }
        if (md !== null) {
          rval = _verifySignature({
            certificate: cert,
            md,
            signature: child.signature
          });
        }
        return rval;
      };
      cert.isIssuer = function(parent2) {
        var rval = false;
        var i = cert.issuer;
        var s = parent2.subject;
        if (i.hash && s.hash) {
          rval = i.hash === s.hash;
        } else if (i.attributes.length === s.attributes.length) {
          rval = true;
          var iattr, sattr;
          for (var n = 0; rval && n < i.attributes.length; ++n) {
            iattr = i.attributes[n];
            sattr = s.attributes[n];
            if (iattr.type !== sattr.type || iattr.value !== sattr.value) {
              rval = false;
            }
          }
        }
        return rval;
      };
      cert.issued = function(child) {
        return child.isIssuer(cert);
      };
      cert.generateSubjectKeyIdentifier = function() {
        return pki.getPublicKeyFingerprint(cert.publicKey, { type: "RSAPublicKey" });
      };
      cert.verifySubjectKeyIdentifier = function() {
        var oid = oids["subjectKeyIdentifier"];
        for (var i = 0; i < cert.extensions.length; ++i) {
          var ext = cert.extensions[i];
          if (ext.id === oid) {
            var ski = cert.generateSubjectKeyIdentifier().getBytes();
            return forge2.util.hexToBytes(ext.subjectKeyIdentifier) === ski;
          }
        }
        return false;
      };
      return cert;
    };
    pki.certificateFromAsn1 = function(obj, computeHash) {
      var capture = {};
      var errors = [];
      if (!asn1.validate(obj, x509CertificateValidator, capture, errors)) {
        var error = new Error("Cannot read X.509 certificate. ASN.1 object is not an X509v3 Certificate.");
        error.errors = errors;
        throw error;
      }
      var oid = asn1.derToOid(capture.publicKeyOid);
      if (oid !== pki.oids.rsaEncryption && oid !== "1.2.840.113549.1.1.10") {
        throw new Error("Cannot read public key. OID is not RSA.");
      }
      var cert = pki.createCertificate();
      cert.version = capture.certVersion ? capture.certVersion.charCodeAt(0) : 0;
      var serial = forge2.util.createBuffer(capture.certSerialNumber);
      cert.serialNumber = serial.toHex();
      cert.signatureOid = forge2.asn1.derToOid(capture.certSignatureOid);
      cert.signatureParameters = _readSignatureParameters(
        cert.signatureOid,
        capture.certSignatureParams,
        true
      );
      cert.siginfo.algorithmOid = forge2.asn1.derToOid(capture.certinfoSignatureOid);
      cert.siginfo.parameters = _readSignatureParameters(
        cert.siginfo.algorithmOid,
        capture.certinfoSignatureParams,
        false
      );
      cert.signature = capture.certSignature;
      var validity = [];
      if (capture.certValidity1UTCTime !== void 0) {
        validity.push(asn1.utcTimeToDate(capture.certValidity1UTCTime));
      }
      if (capture.certValidity2GeneralizedTime !== void 0) {
        validity.push(asn1.generalizedTimeToDate(
          capture.certValidity2GeneralizedTime
        ));
      }
      if (capture.certValidity3UTCTime !== void 0) {
        validity.push(asn1.utcTimeToDate(capture.certValidity3UTCTime));
      }
      if (capture.certValidity4GeneralizedTime !== void 0) {
        validity.push(asn1.generalizedTimeToDate(
          capture.certValidity4GeneralizedTime
        ));
      }
      if (validity.length > 2) {
        throw new Error("Cannot read notBefore/notAfter validity times; more than two times were provided in the certificate.");
      }
      if (validity.length < 2) {
        throw new Error("Cannot read notBefore/notAfter validity times; they were not provided as either UTCTime or GeneralizedTime.");
      }
      cert.validity.notBefore = validity[0];
      cert.validity.notAfter = validity[1];
      cert.tbsCertificate = capture.tbsCertificate;
      if (computeHash) {
        cert.md = _createSignatureDigest({
          signatureOid: cert.signatureOid,
          type: "certificate"
        });
        var bytes = asn1.toDer(cert.tbsCertificate);
        cert.md.update(bytes.getBytes());
      }
      var imd = forge2.md.sha1.create();
      var ibytes = asn1.toDer(capture.certIssuer);
      imd.update(ibytes.getBytes());
      cert.issuer.getField = function(sn) {
        return _getAttribute(cert.issuer, sn);
      };
      cert.issuer.addField = function(attr) {
        _fillMissingFields([attr]);
        cert.issuer.attributes.push(attr);
      };
      cert.issuer.attributes = pki.RDNAttributesAsArray(capture.certIssuer);
      if (capture.certIssuerUniqueId) {
        cert.issuer.uniqueId = capture.certIssuerUniqueId;
      }
      cert.issuer.hash = imd.digest().toHex();
      var smd = forge2.md.sha1.create();
      var sbytes = asn1.toDer(capture.certSubject);
      smd.update(sbytes.getBytes());
      cert.subject.getField = function(sn) {
        return _getAttribute(cert.subject, sn);
      };
      cert.subject.addField = function(attr) {
        _fillMissingFields([attr]);
        cert.subject.attributes.push(attr);
      };
      cert.subject.attributes = pki.RDNAttributesAsArray(capture.certSubject);
      if (capture.certSubjectUniqueId) {
        cert.subject.uniqueId = capture.certSubjectUniqueId;
      }
      cert.subject.hash = smd.digest().toHex();
      if (capture.certExtensions) {
        cert.extensions = pki.certificateExtensionsFromAsn1(capture.certExtensions);
      } else {
        cert.extensions = [];
      }
      cert.publicKey = pki.publicKeyFromAsn1(capture.subjectPublicKeyInfo);
      return cert;
    };
    pki.certificateExtensionsFromAsn1 = function(exts) {
      var rval = [];
      for (var i = 0; i < exts.value.length; ++i) {
        var extseq = exts.value[i];
        for (var ei = 0; ei < extseq.value.length; ++ei) {
          rval.push(pki.certificateExtensionFromAsn1(extseq.value[ei]));
        }
      }
      return rval;
    };
    pki.certificateExtensionFromAsn1 = function(ext) {
      var e = {};
      e.id = asn1.derToOid(ext.value[0].value);
      e.critical = false;
      if (ext.value[1].type === asn1.Type.BOOLEAN) {
        e.critical = ext.value[1].value.charCodeAt(0) !== 0;
        e.value = ext.value[2].value;
      } else {
        e.value = ext.value[1].value;
      }
      if (e.id in oids) {
        e.name = oids[e.id];
        if (e.name === "keyUsage") {
          var ev = asn1.fromDer(e.value);
          var b2 = 0;
          var b3 = 0;
          if (ev.value.length > 1) {
            b2 = ev.value.charCodeAt(1);
            b3 = ev.value.length > 2 ? ev.value.charCodeAt(2) : 0;
          }
          e.digitalSignature = (b2 & 128) === 128;
          e.nonRepudiation = (b2 & 64) === 64;
          e.keyEncipherment = (b2 & 32) === 32;
          e.dataEncipherment = (b2 & 16) === 16;
          e.keyAgreement = (b2 & 8) === 8;
          e.keyCertSign = (b2 & 4) === 4;
          e.cRLSign = (b2 & 2) === 2;
          e.encipherOnly = (b2 & 1) === 1;
          e.decipherOnly = (b3 & 128) === 128;
        } else if (e.name === "basicConstraints") {
          var ev = asn1.fromDer(e.value);
          if (ev.value.length > 0 && ev.value[0].type === asn1.Type.BOOLEAN) {
            e.cA = ev.value[0].value.charCodeAt(0) !== 0;
          } else {
            e.cA = false;
          }
          var value3 = null;
          if (ev.value.length > 0 && ev.value[0].type === asn1.Type.INTEGER) {
            value3 = ev.value[0].value;
          } else if (ev.value.length > 1) {
            value3 = ev.value[1].value;
          }
          if (value3 !== null) {
            e.pathLenConstraint = asn1.derToInteger(value3);
          }
        } else if (e.name === "extKeyUsage") {
          var ev = asn1.fromDer(e.value);
          for (var vi = 0; vi < ev.value.length; ++vi) {
            var oid = asn1.derToOid(ev.value[vi].value);
            if (oid in oids) {
              e[oids[oid]] = true;
            } else {
              e[oid] = true;
            }
          }
        } else if (e.name === "nsCertType") {
          var ev = asn1.fromDer(e.value);
          var b2 = 0;
          if (ev.value.length > 1) {
            b2 = ev.value.charCodeAt(1);
          }
          e.client = (b2 & 128) === 128;
          e.server = (b2 & 64) === 64;
          e.email = (b2 & 32) === 32;
          e.objsign = (b2 & 16) === 16;
          e.reserved = (b2 & 8) === 8;
          e.sslCA = (b2 & 4) === 4;
          e.emailCA = (b2 & 2) === 2;
          e.objCA = (b2 & 1) === 1;
        } else if (e.name === "subjectAltName" || e.name === "issuerAltName") {
          e.altNames = [];
          var gn;
          var ev = asn1.fromDer(e.value);
          for (var n = 0; n < ev.value.length; ++n) {
            gn = ev.value[n];
            var altName = {
              type: gn.type,
              value: gn.value
            };
            e.altNames.push(altName);
            switch (gn.type) {
              // rfc822Name
              case 1:
              // dNSName
              case 2:
              // uniformResourceIdentifier (URI)
              case 6:
                break;
              // IPAddress
              case 7:
                altName.ip = forge2.util.bytesToIP(gn.value);
                break;
              // registeredID
              case 8:
                altName.oid = asn1.derToOid(gn.value);
                break;
              default:
            }
          }
        } else if (e.name === "subjectKeyIdentifier") {
          var ev = asn1.fromDer(e.value);
          e.subjectKeyIdentifier = forge2.util.bytesToHex(ev.value);
        }
      }
      return e;
    };
    pki.certificationRequestFromAsn1 = function(obj, computeHash) {
      var capture = {};
      var errors = [];
      if (!asn1.validate(obj, certificationRequestValidator, capture, errors)) {
        var error = new Error("Cannot read PKCS#10 certificate request. ASN.1 object is not a PKCS#10 CertificationRequest.");
        error.errors = errors;
        throw error;
      }
      var oid = asn1.derToOid(capture.publicKeyOid);
      if (oid !== pki.oids.rsaEncryption) {
        throw new Error("Cannot read public key. OID is not RSA.");
      }
      var csr = pki.createCertificationRequest();
      csr.version = capture.csrVersion ? capture.csrVersion.charCodeAt(0) : 0;
      csr.signatureOid = forge2.asn1.derToOid(capture.csrSignatureOid);
      csr.signatureParameters = _readSignatureParameters(
        csr.signatureOid,
        capture.csrSignatureParams,
        true
      );
      csr.siginfo.algorithmOid = forge2.asn1.derToOid(capture.csrSignatureOid);
      csr.siginfo.parameters = _readSignatureParameters(
        csr.siginfo.algorithmOid,
        capture.csrSignatureParams,
        false
      );
      csr.signature = capture.csrSignature;
      csr.certificationRequestInfo = capture.certificationRequestInfo;
      if (computeHash) {
        csr.md = _createSignatureDigest({
          signatureOid: csr.signatureOid,
          type: "certification request"
        });
        var bytes = asn1.toDer(csr.certificationRequestInfo);
        csr.md.update(bytes.getBytes());
      }
      var smd = forge2.md.sha1.create();
      csr.subject.getField = function(sn) {
        return _getAttribute(csr.subject, sn);
      };
      csr.subject.addField = function(attr) {
        _fillMissingFields([attr]);
        csr.subject.attributes.push(attr);
      };
      csr.subject.attributes = pki.RDNAttributesAsArray(
        capture.certificationRequestInfoSubject,
        smd
      );
      csr.subject.hash = smd.digest().toHex();
      csr.publicKey = pki.publicKeyFromAsn1(capture.subjectPublicKeyInfo);
      csr.getAttribute = function(sn) {
        return _getAttribute(csr, sn);
      };
      csr.addAttribute = function(attr) {
        _fillMissingFields([attr]);
        csr.attributes.push(attr);
      };
      csr.attributes = pki.CRIAttributesAsArray(
        capture.certificationRequestInfoAttributes || []
      );
      return csr;
    };
    pki.createCertificationRequest = function() {
      var csr = {};
      csr.version = 0;
      csr.signatureOid = null;
      csr.signature = null;
      csr.siginfo = {};
      csr.siginfo.algorithmOid = null;
      csr.subject = {};
      csr.subject.getField = function(sn) {
        return _getAttribute(csr.subject, sn);
      };
      csr.subject.addField = function(attr) {
        _fillMissingFields([attr]);
        csr.subject.attributes.push(attr);
      };
      csr.subject.attributes = [];
      csr.subject.hash = null;
      csr.publicKey = null;
      csr.attributes = [];
      csr.getAttribute = function(sn) {
        return _getAttribute(csr, sn);
      };
      csr.addAttribute = function(attr) {
        _fillMissingFields([attr]);
        csr.attributes.push(attr);
      };
      csr.md = null;
      csr.setSubject = function(attrs) {
        _fillMissingFields(attrs);
        csr.subject.attributes = attrs;
        csr.subject.hash = null;
      };
      csr.setAttributes = function(attrs) {
        _fillMissingFields(attrs);
        csr.attributes = attrs;
      };
      csr.sign = function(key2, md) {
        csr.md = md || forge2.md.sha1.create();
        var algorithmOid = oids[csr.md.algorithm + "WithRSAEncryption"];
        if (!algorithmOid) {
          var error = new Error("Could not compute certification request digest. Unknown message digest algorithm OID.");
          error.algorithm = csr.md.algorithm;
          throw error;
        }
        csr.signatureOid = csr.siginfo.algorithmOid = algorithmOid;
        csr.certificationRequestInfo = pki.getCertificationRequestInfo(csr);
        var bytes = asn1.toDer(csr.certificationRequestInfo);
        csr.md.update(bytes.getBytes());
        csr.signature = key2.sign(csr.md);
      };
      csr.verify = function() {
        var rval = false;
        var md = csr.md;
        if (md === null) {
          md = _createSignatureDigest({
            signatureOid: csr.signatureOid,
            type: "certification request"
          });
          var cri = csr.certificationRequestInfo || pki.getCertificationRequestInfo(csr);
          var bytes = asn1.toDer(cri);
          md.update(bytes.getBytes());
        }
        if (md !== null) {
          rval = _verifySignature({
            certificate: csr,
            md,
            signature: csr.signature
          });
        }
        return rval;
      };
      return csr;
    };
    function _dnToAsn1(obj) {
      var rval = asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.SEQUENCE,
        true,
        []
      );
      var attr, set;
      var attrs = obj.attributes;
      for (var i = 0; i < attrs.length; ++i) {
        attr = attrs[i];
        var value3 = attr.value;
        var valueTagClass = asn1.Type.PRINTABLESTRING;
        if ("valueTagClass" in attr) {
          valueTagClass = attr.valueTagClass;
          if (valueTagClass === asn1.Type.UTF8) {
            value3 = forge2.util.encodeUtf8(value3);
          }
        }
        set = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            // AttributeType
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(attr.type).getBytes()
            ),
            // AttributeValue
            asn1.create(asn1.Class.UNIVERSAL, valueTagClass, false, value3)
          ])
        ]);
        rval.value.push(set);
      }
      return rval;
    }
    function _fillMissingFields(attrs) {
      var attr;
      for (var i = 0; i < attrs.length; ++i) {
        attr = attrs[i];
        if (typeof attr.name === "undefined") {
          if (attr.type && attr.type in pki.oids) {
            attr.name = pki.oids[attr.type];
          } else if (attr.shortName && attr.shortName in _shortNames) {
            attr.name = pki.oids[_shortNames[attr.shortName]];
          }
        }
        if (typeof attr.type === "undefined") {
          if (attr.name && attr.name in pki.oids) {
            attr.type = pki.oids[attr.name];
          } else {
            var error = new Error("Attribute type not specified.");
            error.attribute = attr;
            throw error;
          }
        }
        if (typeof attr.shortName === "undefined") {
          if (attr.name && attr.name in _shortNames) {
            attr.shortName = _shortNames[attr.name];
          }
        }
        if (attr.type === oids.extensionRequest) {
          attr.valueConstructed = true;
          attr.valueTagClass = asn1.Type.SEQUENCE;
          if (!attr.value && attr.extensions) {
            attr.value = [];
            for (var ei = 0; ei < attr.extensions.length; ++ei) {
              attr.value.push(pki.certificateExtensionToAsn1(
                _fillMissingExtensionFields(attr.extensions[ei])
              ));
            }
          }
        }
        if (typeof attr.value === "undefined") {
          var error = new Error("Attribute value not specified.");
          error.attribute = attr;
          throw error;
        }
      }
    }
    function _fillMissingExtensionFields(e, options) {
      options = options || {};
      if (typeof e.name === "undefined") {
        if (e.id && e.id in pki.oids) {
          e.name = pki.oids[e.id];
        }
      }
      if (typeof e.id === "undefined") {
        if (e.name && e.name in pki.oids) {
          e.id = pki.oids[e.name];
        } else {
          var error = new Error("Extension ID not specified.");
          error.extension = e;
          throw error;
        }
      }
      if (typeof e.value !== "undefined") {
        return e;
      }
      if (e.name === "keyUsage") {
        var unused = 0;
        var b2 = 0;
        var b3 = 0;
        if (e.digitalSignature) {
          b2 |= 128;
          unused = 7;
        }
        if (e.nonRepudiation) {
          b2 |= 64;
          unused = 6;
        }
        if (e.keyEncipherment) {
          b2 |= 32;
          unused = 5;
        }
        if (e.dataEncipherment) {
          b2 |= 16;
          unused = 4;
        }
        if (e.keyAgreement) {
          b2 |= 8;
          unused = 3;
        }
        if (e.keyCertSign) {
          b2 |= 4;
          unused = 2;
        }
        if (e.cRLSign) {
          b2 |= 2;
          unused = 1;
        }
        if (e.encipherOnly) {
          b2 |= 1;
          unused = 0;
        }
        if (e.decipherOnly) {
          b3 |= 128;
          unused = 7;
        }
        var value3 = String.fromCharCode(unused);
        if (b3 !== 0) {
          value3 += String.fromCharCode(b2) + String.fromCharCode(b3);
        } else if (b2 !== 0) {
          value3 += String.fromCharCode(b2);
        }
        e.value = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.BITSTRING,
          false,
          value3
        );
      } else if (e.name === "basicConstraints") {
        e.value = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.SEQUENCE,
          true,
          []
        );
        if (e.cA) {
          e.value.value.push(asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.BOOLEAN,
            false,
            String.fromCharCode(255)
          ));
        }
        if ("pathLenConstraint" in e) {
          e.value.value.push(asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.INTEGER,
            false,
            asn1.integerToDer(e.pathLenConstraint).getBytes()
          ));
        }
      } else if (e.name === "extKeyUsage") {
        e.value = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.SEQUENCE,
          true,
          []
        );
        var seq = e.value.value;
        for (var key2 in e) {
          if (e[key2] !== true) {
            continue;
          }
          if (key2 in oids) {
            seq.push(asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(oids[key2]).getBytes()
            ));
          } else if (key2.indexOf(".") !== -1) {
            seq.push(asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(key2).getBytes()
            ));
          }
        }
      } else if (e.name === "nsCertType") {
        var unused = 0;
        var b2 = 0;
        if (e.client) {
          b2 |= 128;
          unused = 7;
        }
        if (e.server) {
          b2 |= 64;
          unused = 6;
        }
        if (e.email) {
          b2 |= 32;
          unused = 5;
        }
        if (e.objsign) {
          b2 |= 16;
          unused = 4;
        }
        if (e.reserved) {
          b2 |= 8;
          unused = 3;
        }
        if (e.sslCA) {
          b2 |= 4;
          unused = 2;
        }
        if (e.emailCA) {
          b2 |= 2;
          unused = 1;
        }
        if (e.objCA) {
          b2 |= 1;
          unused = 0;
        }
        var value3 = String.fromCharCode(unused);
        if (b2 !== 0) {
          value3 += String.fromCharCode(b2);
        }
        e.value = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.BITSTRING,
          false,
          value3
        );
      } else if (e.name === "subjectAltName" || e.name === "issuerAltName") {
        e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
        var altName;
        for (var n = 0; n < e.altNames.length; ++n) {
          altName = e.altNames[n];
          var value3 = altName.value;
          if (altName.type === 7 && altName.ip) {
            value3 = forge2.util.bytesFromIP(altName.ip);
            if (value3 === null) {
              var error = new Error(
                'Extension "ip" value is not a valid IPv4 or IPv6 address.'
              );
              error.extension = e;
              throw error;
            }
          } else if (altName.type === 8) {
            if (altName.oid) {
              value3 = asn1.oidToDer(asn1.oidToDer(altName.oid));
            } else {
              value3 = asn1.oidToDer(value3);
            }
          }
          e.value.value.push(asn1.create(
            asn1.Class.CONTEXT_SPECIFIC,
            altName.type,
            false,
            value3
          ));
        }
      } else if (e.name === "nsComment" && options.cert) {
        if (!/^[\x00-\x7F]*$/.test(e.comment) || e.comment.length < 1 || e.comment.length > 128) {
          throw new Error('Invalid "nsComment" content.');
        }
        e.value = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.IA5STRING,
          false,
          e.comment
        );
      } else if (e.name === "subjectKeyIdentifier" && options.cert) {
        var ski = options.cert.generateSubjectKeyIdentifier();
        e.subjectKeyIdentifier = ski.toHex();
        e.value = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OCTETSTRING,
          false,
          ski.getBytes()
        );
      } else if (e.name === "authorityKeyIdentifier" && options.cert) {
        e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
        var seq = e.value.value;
        if (e.keyIdentifier) {
          var keyIdentifier = e.keyIdentifier === true ? options.cert.generateSubjectKeyIdentifier().getBytes() : e.keyIdentifier;
          seq.push(
            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, false, keyIdentifier)
          );
        }
        if (e.authorityCertIssuer) {
          var authorityCertIssuer = [
            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 4, true, [
              _dnToAsn1(e.authorityCertIssuer === true ? options.cert.issuer : e.authorityCertIssuer)
            ])
          ];
          seq.push(
            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, authorityCertIssuer)
          );
        }
        if (e.serialNumber) {
          var serialNumber = forge2.util.hexToBytes(e.serialNumber === true ? options.cert.serialNumber : e.serialNumber);
          seq.push(
            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, false, serialNumber)
          );
        }
      } else if (e.name === "cRLDistributionPoints") {
        e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
        var seq = e.value.value;
        var subSeq = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.SEQUENCE,
          true,
          []
        );
        var fullNameGeneralNames = asn1.create(
          asn1.Class.CONTEXT_SPECIFIC,
          0,
          true,
          []
        );
        var altName;
        for (var n = 0; n < e.altNames.length; ++n) {
          altName = e.altNames[n];
          var value3 = altName.value;
          if (altName.type === 7 && altName.ip) {
            value3 = forge2.util.bytesFromIP(altName.ip);
            if (value3 === null) {
              var error = new Error(
                'Extension "ip" value is not a valid IPv4 or IPv6 address.'
              );
              error.extension = e;
              throw error;
            }
          } else if (altName.type === 8) {
            if (altName.oid) {
              value3 = asn1.oidToDer(asn1.oidToDer(altName.oid));
            } else {
              value3 = asn1.oidToDer(value3);
            }
          }
          fullNameGeneralNames.value.push(asn1.create(
            asn1.Class.CONTEXT_SPECIFIC,
            altName.type,
            false,
            value3
          ));
        }
        subSeq.value.push(asn1.create(
          asn1.Class.CONTEXT_SPECIFIC,
          0,
          true,
          [fullNameGeneralNames]
        ));
        seq.push(subSeq);
      }
      if (typeof e.value === "undefined") {
        var error = new Error("Extension value not specified.");
        error.extension = e;
        throw error;
      }
      return e;
    }
    function _signatureParametersToAsn1(oid, params) {
      switch (oid) {
        case oids["RSASSA-PSS"]:
          var parts2 = [];
          if (params.hash.algorithmOid !== void 0) {
            parts2.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.OID,
                  false,
                  asn1.oidToDer(params.hash.algorithmOid).getBytes()
                ),
                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
              ])
            ]));
          }
          if (params.mgf.algorithmOid !== void 0) {
            parts2.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, [
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.OID,
                  false,
                  asn1.oidToDer(params.mgf.algorithmOid).getBytes()
                ),
                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                  asn1.create(
                    asn1.Class.UNIVERSAL,
                    asn1.Type.OID,
                    false,
                    asn1.oidToDer(params.mgf.hash.algorithmOid).getBytes()
                  ),
                  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
                ])
              ])
            ]));
          }
          if (params.saltLength !== void 0) {
            parts2.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, true, [
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.INTEGER,
                false,
                asn1.integerToDer(params.saltLength).getBytes()
              )
            ]));
          }
          return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, parts2);
        default:
          return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "");
      }
    }
    function _CRIAttributesToAsn1(csr) {
      var rval = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, []);
      if (csr.attributes.length === 0) {
        return rval;
      }
      var attrs = csr.attributes;
      for (var i = 0; i < attrs.length; ++i) {
        var attr = attrs[i];
        var value3 = attr.value;
        var valueTagClass = asn1.Type.UTF8;
        if ("valueTagClass" in attr) {
          valueTagClass = attr.valueTagClass;
        }
        if (valueTagClass === asn1.Type.UTF8) {
          value3 = forge2.util.encodeUtf8(value3);
        }
        var valueConstructed = false;
        if ("valueConstructed" in attr) {
          valueConstructed = attr.valueConstructed;
        }
        var seq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // AttributeType
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(attr.type).getBytes()
          ),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [
            // AttributeValue
            asn1.create(
              asn1.Class.UNIVERSAL,
              valueTagClass,
              valueConstructed,
              value3
            )
          ])
        ]);
        rval.value.push(seq);
      }
      return rval;
    }
    var jan_1_1950 = /* @__PURE__ */ new Date("1950-01-01T00:00:00Z");
    var jan_1_2050 = /* @__PURE__ */ new Date("2050-01-01T00:00:00Z");
    function _dateToAsn1(date) {
      if (date >= jan_1_1950 && date < jan_1_2050) {
        return asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.UTCTIME,
          false,
          asn1.dateToUtcTime(date)
        );
      } else {
        return asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.GENERALIZEDTIME,
          false,
          asn1.dateToGeneralizedTime(date)
        );
      }
    }
    pki.getTBSCertificate = function(cert) {
      var notBefore = _dateToAsn1(cert.validity.notBefore);
      var notAfter = _dateToAsn1(cert.validity.notAfter);
      var tbs = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // version
        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
          // integer
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.INTEGER,
            false,
            asn1.integerToDer(cert.version).getBytes()
          )
        ]),
        // serialNumber
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          forge2.util.hexToBytes(cert.serialNumber)
        ),
        // signature
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // algorithm
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(cert.siginfo.algorithmOid).getBytes()
          ),
          // parameters
          _signatureParametersToAsn1(
            cert.siginfo.algorithmOid,
            cert.siginfo.parameters
          )
        ]),
        // issuer
        _dnToAsn1(cert.issuer),
        // validity
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          notBefore,
          notAfter
        ]),
        // subject
        _dnToAsn1(cert.subject),
        // SubjectPublicKeyInfo
        pki.publicKeyToAsn1(cert.publicKey)
      ]);
      if (cert.issuer.uniqueId) {
        tbs.value.push(
          asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, [
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.BITSTRING,
              false,
              // TODO: support arbitrary bit length ids
              String.fromCharCode(0) + cert.issuer.uniqueId
            )
          ])
        );
      }
      if (cert.subject.uniqueId) {
        tbs.value.push(
          asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, true, [
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.BITSTRING,
              false,
              // TODO: support arbitrary bit length ids
              String.fromCharCode(0) + cert.subject.uniqueId
            )
          ])
        );
      }
      if (cert.extensions.length > 0) {
        tbs.value.push(pki.certificateExtensionsToAsn1(cert.extensions));
      }
      return tbs;
    };
    pki.getCertificationRequestInfo = function(csr) {
      var cri = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // version
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          asn1.integerToDer(csr.version).getBytes()
        ),
        // subject
        _dnToAsn1(csr.subject),
        // SubjectPublicKeyInfo
        pki.publicKeyToAsn1(csr.publicKey),
        // attributes
        _CRIAttributesToAsn1(csr)
      ]);
      return cri;
    };
    pki.distinguishedNameToAsn1 = function(dn) {
      return _dnToAsn1(dn);
    };
    pki.certificateToAsn1 = function(cert) {
      var tbsCertificate = cert.tbsCertificate || pki.getTBSCertificate(cert);
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // TBSCertificate
        tbsCertificate,
        // AlgorithmIdentifier (signature algorithm)
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // algorithm
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(cert.signatureOid).getBytes()
          ),
          // parameters
          _signatureParametersToAsn1(cert.signatureOid, cert.signatureParameters)
        ]),
        // SignatureValue
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.BITSTRING,
          false,
          String.fromCharCode(0) + cert.signature
        )
      ]);
    };
    pki.certificateExtensionsToAsn1 = function(exts) {
      var rval = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 3, true, []);
      var seq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
      rval.value.push(seq);
      for (var i = 0; i < exts.length; ++i) {
        seq.value.push(pki.certificateExtensionToAsn1(exts[i]));
      }
      return rval;
    };
    pki.certificateExtensionToAsn1 = function(ext) {
      var extseq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
      extseq.value.push(asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.OID,
        false,
        asn1.oidToDer(ext.id).getBytes()
      ));
      if (ext.critical) {
        extseq.value.push(asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.BOOLEAN,
          false,
          String.fromCharCode(255)
        ));
      }
      var value3 = ext.value;
      if (typeof ext.value !== "string") {
        value3 = asn1.toDer(value3).getBytes();
      }
      extseq.value.push(asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.OCTETSTRING,
        false,
        value3
      ));
      return extseq;
    };
    pki.certificationRequestToAsn1 = function(csr) {
      var cri = csr.certificationRequestInfo || pki.getCertificationRequestInfo(csr);
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // CertificationRequestInfo
        cri,
        // AlgorithmIdentifier (signature algorithm)
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // algorithm
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(csr.signatureOid).getBytes()
          ),
          // parameters
          _signatureParametersToAsn1(csr.signatureOid, csr.signatureParameters)
        ]),
        // signature
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.BITSTRING,
          false,
          String.fromCharCode(0) + csr.signature
        )
      ]);
    };
    pki.createCaStore = function(certs) {
      var caStore = {
        // stored certificates
        certs: {}
      };
      caStore.getIssuer = function(cert2) {
        var rval = getBySubject(cert2.issuer);
        return rval;
      };
      caStore.addCertificate = function(cert2) {
        if (typeof cert2 === "string") {
          cert2 = forge2.pki.certificateFromPem(cert2);
        }
        ensureSubjectHasHash(cert2.subject);
        if (!caStore.hasCertificate(cert2)) {
          if (cert2.subject.hash in caStore.certs) {
            var tmp = caStore.certs[cert2.subject.hash];
            if (!forge2.util.isArray(tmp)) {
              tmp = [tmp];
            }
            tmp.push(cert2);
            caStore.certs[cert2.subject.hash] = tmp;
          } else {
            caStore.certs[cert2.subject.hash] = cert2;
          }
        }
      };
      caStore.hasCertificate = function(cert2) {
        if (typeof cert2 === "string") {
          cert2 = forge2.pki.certificateFromPem(cert2);
        }
        var match = getBySubject(cert2.subject);
        if (!match) {
          return false;
        }
        if (!forge2.util.isArray(match)) {
          match = [match];
        }
        var der1 = asn1.toDer(pki.certificateToAsn1(cert2)).getBytes();
        for (var i2 = 0; i2 < match.length; ++i2) {
          var der2 = asn1.toDer(pki.certificateToAsn1(match[i2])).getBytes();
          if (der1 === der2) {
            return true;
          }
        }
        return false;
      };
      caStore.listAllCertificates = function() {
        var certList = [];
        for (var hash in caStore.certs) {
          if (caStore.certs.hasOwnProperty(hash)) {
            var value3 = caStore.certs[hash];
            if (!forge2.util.isArray(value3)) {
              certList.push(value3);
            } else {
              for (var i2 = 0; i2 < value3.length; ++i2) {
                certList.push(value3[i2]);
              }
            }
          }
        }
        return certList;
      };
      caStore.removeCertificate = function(cert2) {
        var result;
        if (typeof cert2 === "string") {
          cert2 = forge2.pki.certificateFromPem(cert2);
        }
        ensureSubjectHasHash(cert2.subject);
        if (!caStore.hasCertificate(cert2)) {
          return null;
        }
        var match = getBySubject(cert2.subject);
        if (!forge2.util.isArray(match)) {
          result = caStore.certs[cert2.subject.hash];
          delete caStore.certs[cert2.subject.hash];
          return result;
        }
        var der1 = asn1.toDer(pki.certificateToAsn1(cert2)).getBytes();
        for (var i2 = 0; i2 < match.length; ++i2) {
          var der2 = asn1.toDer(pki.certificateToAsn1(match[i2])).getBytes();
          if (der1 === der2) {
            result = match[i2];
            match.splice(i2, 1);
          }
        }
        if (match.length === 0) {
          delete caStore.certs[cert2.subject.hash];
        }
        return result;
      };
      function getBySubject(subject) {
        ensureSubjectHasHash(subject);
        return caStore.certs[subject.hash] || null;
      }
      function ensureSubjectHasHash(subject) {
        if (!subject.hash) {
          var md = forge2.md.sha1.create();
          subject.attributes = pki.RDNAttributesAsArray(_dnToAsn1(subject), md);
          subject.hash = md.digest().toHex();
        }
      }
      if (certs) {
        for (var i = 0; i < certs.length; ++i) {
          var cert = certs[i];
          caStore.addCertificate(cert);
        }
      }
      return caStore;
    };
    pki.certificateError = {
      bad_certificate: "forge.pki.BadCertificate",
      unsupported_certificate: "forge.pki.UnsupportedCertificate",
      certificate_revoked: "forge.pki.CertificateRevoked",
      certificate_expired: "forge.pki.CertificateExpired",
      certificate_unknown: "forge.pki.CertificateUnknown",
      unknown_ca: "forge.pki.UnknownCertificateAuthority"
    };
    pki.verifyCertificateChain = function(caStore, chain, options) {
      if (typeof options === "function") {
        options = { verify: options };
      }
      options = options || {};
      chain = chain.slice(0);
      var certs = chain.slice(0);
      var validityCheckDate = options.validityCheckDate;
      if (typeof validityCheckDate === "undefined") {
        validityCheckDate = /* @__PURE__ */ new Date();
      }
      var first = true;
      var error = null;
      var depth = 0;
      do {
        var cert = chain.shift();
        var parent2 = null;
        var selfSigned = false;
        if (validityCheckDate) {
          if (validityCheckDate < cert.validity.notBefore || validityCheckDate > cert.validity.notAfter) {
            error = {
              message: "Certificate is not valid yet or has expired.",
              error: pki.certificateError.certificate_expired,
              notBefore: cert.validity.notBefore,
              notAfter: cert.validity.notAfter,
              // TODO: we might want to reconsider renaming 'now' to
              // 'validityCheckDate' should this API be changed in the future.
              now: validityCheckDate
            };
          }
        }
        if (error === null) {
          parent2 = chain[0] || caStore.getIssuer(cert);
          if (parent2 === null) {
            if (cert.isIssuer(cert)) {
              selfSigned = true;
              parent2 = cert;
            }
          }
          if (parent2) {
            var parents = parent2;
            if (!forge2.util.isArray(parents)) {
              parents = [parents];
            }
            var verified = false;
            while (!verified && parents.length > 0) {
              parent2 = parents.shift();
              try {
                verified = parent2.verify(cert);
              } catch (ex) {
              }
            }
            if (!verified) {
              error = {
                message: "Certificate signature is invalid.",
                error: pki.certificateError.bad_certificate
              };
            }
          }
          if (error === null && (!parent2 || selfSigned) && !caStore.hasCertificate(cert)) {
            error = {
              message: "Certificate is not trusted.",
              error: pki.certificateError.unknown_ca
            };
          }
        }
        if (error === null && parent2 && !cert.isIssuer(parent2)) {
          error = {
            message: "Certificate issuer is invalid.",
            error: pki.certificateError.bad_certificate
          };
        }
        if (error === null) {
          var se = {
            keyUsage: true,
            basicConstraints: true
          };
          for (var i = 0; error === null && i < cert.extensions.length; ++i) {
            var ext = cert.extensions[i];
            if (ext.critical && !(ext.name in se)) {
              error = {
                message: "Certificate has an unsupported critical extension.",
                error: pki.certificateError.unsupported_certificate
              };
            }
          }
        }
        if (error === null && (!first || chain.length === 0 && (!parent2 || selfSigned))) {
          var bcExt = cert.getExtension("basicConstraints");
          var keyUsageExt = cert.getExtension("keyUsage");
          if (keyUsageExt !== null) {
            if (!keyUsageExt.keyCertSign || bcExt === null) {
              error = {
                message: "Certificate keyUsage or basicConstraints conflict or indicate that the certificate is not a CA. If the certificate is the only one in the chain or isn't the first then the certificate must be a valid CA.",
                error: pki.certificateError.bad_certificate
              };
            }
          }
          if (error === null && bcExt !== null && !bcExt.cA) {
            error = {
              message: "Certificate basicConstraints indicates the certificate is not a CA.",
              error: pki.certificateError.bad_certificate
            };
          }
          if (error === null && keyUsageExt !== null && "pathLenConstraint" in bcExt) {
            var pathLen = depth - 1;
            if (pathLen > bcExt.pathLenConstraint) {
              error = {
                message: "Certificate basicConstraints pathLenConstraint violated.",
                error: pki.certificateError.bad_certificate
              };
            }
          }
        }
        var vfd = error === null ? true : error.error;
        var ret = options.verify ? options.verify(vfd, depth, certs) : vfd;
        if (ret === true) {
          error = null;
        } else {
          if (vfd === true) {
            error = {
              message: "The application rejected the certificate.",
              error: pki.certificateError.bad_certificate
            };
          }
          if (ret || ret === 0) {
            if (typeof ret === "object" && !forge2.util.isArray(ret)) {
              if (ret.message) {
                error.message = ret.message;
              }
              if (ret.error) {
                error.error = ret.error;
              }
            } else if (typeof ret === "string") {
              error.error = ret;
            }
          }
          throw error;
        }
        first = false;
        ++depth;
      } while (chain.length > 0);
      return true;
    };
  }
});

// node_modules/@selfxyz/common/node_modules/node-forge/lib/pkcs12.js
var require_pkcs12 = __commonJS({
  "node_modules/@selfxyz/common/node_modules/node-forge/lib/pkcs12.js"(exports2, module2) {
    var forge2 = require_forge();
    require_asn1();
    require_hmac();
    require_oids();
    require_pkcs7asn1();
    require_pbe();
    require_random();
    require_rsa();
    require_sha12();
    require_util();
    require_x509();
    var asn1 = forge2.asn1;
    var pki = forge2.pki;
    var p12 = module2.exports = forge2.pkcs12 = forge2.pkcs12 || {};
    var contentInfoValidator = {
      name: "ContentInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      // a ContentInfo
      constructed: true,
      value: [{
        name: "ContentInfo.contentType",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: "contentType"
      }, {
        name: "ContentInfo.content",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        constructed: true,
        captureAsn1: "content"
      }]
    };
    var pfxValidator = {
      name: "PFX",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [
        {
          name: "PFX.version",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          capture: "version"
        },
        contentInfoValidator,
        {
          name: "PFX.macData",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          optional: true,
          captureAsn1: "mac",
          value: [{
            name: "PFX.macData.mac",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            // DigestInfo
            constructed: true,
            value: [{
              name: "PFX.macData.mac.digestAlgorithm",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.SEQUENCE,
              // DigestAlgorithmIdentifier
              constructed: true,
              value: [{
                name: "PFX.macData.mac.digestAlgorithm.algorithm",
                tagClass: asn1.Class.UNIVERSAL,
                type: asn1.Type.OID,
                constructed: false,
                capture: "macAlgorithm"
              }, {
                name: "PFX.macData.mac.digestAlgorithm.parameters",
                tagClass: asn1.Class.UNIVERSAL,
                captureAsn1: "macAlgorithmParameters"
              }]
            }, {
              name: "PFX.macData.mac.digest",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.OCTETSTRING,
              constructed: false,
              capture: "macDigest"
            }]
          }, {
            name: "PFX.macData.macSalt",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OCTETSTRING,
            constructed: false,
            capture: "macSalt"
          }, {
            name: "PFX.macData.iterations",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.INTEGER,
            constructed: false,
            optional: true,
            capture: "macIterations"
          }]
        }
      ]
    };
    var safeBagValidator = {
      name: "SafeBag",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "SafeBag.bagId",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: "bagId"
      }, {
        name: "SafeBag.bagValue",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        constructed: true,
        captureAsn1: "bagValue"
      }, {
        name: "SafeBag.bagAttributes",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SET,
        constructed: true,
        optional: true,
        capture: "bagAttributes"
      }]
    };
    var attributeValidator = {
      name: "Attribute",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "Attribute.attrId",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: "oid"
      }, {
        name: "Attribute.attrValues",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SET,
        constructed: true,
        capture: "values"
      }]
    };
    var certBagValidator = {
      name: "CertBag",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "CertBag.certId",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: "certId"
      }, {
        name: "CertBag.certValue",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        constructed: true,
        /* So far we only support X.509 certificates (which are wrapped in
           an OCTET STRING, hence hard code that here). */
        value: [{
          name: "CertBag.certValue[0]",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Class.OCTETSTRING,
          constructed: false,
          capture: "cert"
        }]
      }]
    };
    function _getBagsByAttribute(safeContents, attrName, attrValue, bagType) {
      var result = [];
      for (var i = 0; i < safeContents.length; i++) {
        for (var j = 0; j < safeContents[i].safeBags.length; j++) {
          var bag = safeContents[i].safeBags[j];
          if (bagType !== void 0 && bag.type !== bagType) {
            continue;
          }
          if (attrName === null) {
            result.push(bag);
            continue;
          }
          if (bag.attributes[attrName] !== void 0 && bag.attributes[attrName].indexOf(attrValue) >= 0) {
            result.push(bag);
          }
        }
      }
      return result;
    }
    p12.pkcs12FromAsn1 = function(obj, strict, password) {
      if (typeof strict === "string") {
        password = strict;
        strict = true;
      } else if (strict === void 0) {
        strict = true;
      }
      var capture = {};
      var errors = [];
      if (!asn1.validate(obj, pfxValidator, capture, errors)) {
        var error = new Error("Cannot read PKCS#12 PFX. ASN.1 object is not an PKCS#12 PFX.");
        error.errors = error;
        throw error;
      }
      var pfx = {
        version: capture.version.charCodeAt(0),
        safeContents: [],
        /**
         * Gets bags with matching attributes.
         *
         * @param filter the attributes to filter by:
         *          [localKeyId] the localKeyId to search for.
         *          [localKeyIdHex] the localKeyId in hex to search for.
         *          [friendlyName] the friendly name to search for.
         *          [bagType] bag type to narrow each attribute search by.
         *
         * @return a map of attribute type to an array of matching bags or, if no
         *           attribute was given but a bag type, the map key will be the
         *           bag type.
         */
        getBags: function(filter) {
          var rval = {};
          var localKeyId;
          if ("localKeyId" in filter) {
            localKeyId = filter.localKeyId;
          } else if ("localKeyIdHex" in filter) {
            localKeyId = forge2.util.hexToBytes(filter.localKeyIdHex);
          }
          if (localKeyId === void 0 && !("friendlyName" in filter) && "bagType" in filter) {
            rval[filter.bagType] = _getBagsByAttribute(
              pfx.safeContents,
              null,
              null,
              filter.bagType
            );
          }
          if (localKeyId !== void 0) {
            rval.localKeyId = _getBagsByAttribute(
              pfx.safeContents,
              "localKeyId",
              localKeyId,
              filter.bagType
            );
          }
          if ("friendlyName" in filter) {
            rval.friendlyName = _getBagsByAttribute(
              pfx.safeContents,
              "friendlyName",
              filter.friendlyName,
              filter.bagType
            );
          }
          return rval;
        },
        /**
         * DEPRECATED: use getBags() instead.
         *
         * Get bags with matching friendlyName attribute.
         *
         * @param friendlyName the friendly name to search for.
         * @param [bagType] bag type to narrow search by.
         *
         * @return an array of bags with matching friendlyName attribute.
         */
        getBagsByFriendlyName: function(friendlyName, bagType) {
          return _getBagsByAttribute(
            pfx.safeContents,
            "friendlyName",
            friendlyName,
            bagType
          );
        },
        /**
         * DEPRECATED: use getBags() instead.
         *
         * Get bags with matching localKeyId attribute.
         *
         * @param localKeyId the localKeyId to search for.
         * @param [bagType] bag type to narrow search by.
         *
         * @return an array of bags with matching localKeyId attribute.
         */
        getBagsByLocalKeyId: function(localKeyId, bagType) {
          return _getBagsByAttribute(
            pfx.safeContents,
            "localKeyId",
            localKeyId,
            bagType
          );
        }
      };
      if (capture.version.charCodeAt(0) !== 3) {
        var error = new Error("PKCS#12 PFX of version other than 3 not supported.");
        error.version = capture.version.charCodeAt(0);
        throw error;
      }
      if (asn1.derToOid(capture.contentType) !== pki.oids.data) {
        var error = new Error("Only PKCS#12 PFX in password integrity mode supported.");
        error.oid = asn1.derToOid(capture.contentType);
        throw error;
      }
      var data2 = capture.content.value[0];
      if (data2.tagClass !== asn1.Class.UNIVERSAL || data2.type !== asn1.Type.OCTETSTRING) {
        throw new Error("PKCS#12 authSafe content data is not an OCTET STRING.");
      }
      data2 = _decodePkcs7Data(data2);
      if (capture.mac) {
        var md = null;
        var macKeyBytes = 0;
        var macAlgorithm = asn1.derToOid(capture.macAlgorithm);
        switch (macAlgorithm) {
          case pki.oids.sha1:
            md = forge2.md.sha1.create();
            macKeyBytes = 20;
            break;
          case pki.oids.sha256:
            md = forge2.md.sha256.create();
            macKeyBytes = 32;
            break;
          case pki.oids.sha384:
            md = forge2.md.sha384.create();
            macKeyBytes = 48;
            break;
          case pki.oids.sha512:
            md = forge2.md.sha512.create();
            macKeyBytes = 64;
            break;
          case pki.oids.md5:
            md = forge2.md.md5.create();
            macKeyBytes = 16;
            break;
        }
        if (md === null) {
          throw new Error("PKCS#12 uses unsupported MAC algorithm: " + macAlgorithm);
        }
        var macSalt = new forge2.util.ByteBuffer(capture.macSalt);
        var macIterations = "macIterations" in capture ? parseInt(forge2.util.bytesToHex(capture.macIterations), 16) : 1;
        var macKey = p12.generateKey(
          password,
          macSalt,
          3,
          macIterations,
          macKeyBytes,
          md
        );
        var mac = forge2.hmac.create();
        mac.start(md, macKey);
        mac.update(data2.value);
        var macValue = mac.getMac();
        if (macValue.getBytes() !== capture.macDigest) {
          throw new Error("PKCS#12 MAC could not be verified. Invalid password?");
        }
      }
      _decodeAuthenticatedSafe(pfx, data2.value, strict, password);
      return pfx;
    };
    function _decodePkcs7Data(data2) {
      if (data2.composed || data2.constructed) {
        var value3 = forge2.util.createBuffer();
        for (var i = 0; i < data2.value.length; ++i) {
          value3.putBytes(data2.value[i].value);
        }
        data2.composed = data2.constructed = false;
        data2.value = value3.getBytes();
      }
      return data2;
    }
    function _decodeAuthenticatedSafe(pfx, authSafe, strict, password) {
      authSafe = asn1.fromDer(authSafe, strict);
      if (authSafe.tagClass !== asn1.Class.UNIVERSAL || authSafe.type !== asn1.Type.SEQUENCE || authSafe.constructed !== true) {
        throw new Error("PKCS#12 AuthenticatedSafe expected to be a SEQUENCE OF ContentInfo");
      }
      for (var i = 0; i < authSafe.value.length; i++) {
        var contentInfo = authSafe.value[i];
        var capture = {};
        var errors = [];
        if (!asn1.validate(contentInfo, contentInfoValidator, capture, errors)) {
          var error = new Error("Cannot read ContentInfo.");
          error.errors = errors;
          throw error;
        }
        var obj = {
          encrypted: false
        };
        var safeContents = null;
        var data2 = capture.content.value[0];
        switch (asn1.derToOid(capture.contentType)) {
          case pki.oids.data:
            if (data2.tagClass !== asn1.Class.UNIVERSAL || data2.type !== asn1.Type.OCTETSTRING) {
              throw new Error("PKCS#12 SafeContents Data is not an OCTET STRING.");
            }
            safeContents = _decodePkcs7Data(data2).value;
            break;
          case pki.oids.encryptedData:
            safeContents = _decryptSafeContents(data2, password);
            obj.encrypted = true;
            break;
          default:
            var error = new Error("Unsupported PKCS#12 contentType.");
            error.contentType = asn1.derToOid(capture.contentType);
            throw error;
        }
        obj.safeBags = _decodeSafeContents(safeContents, strict, password);
        pfx.safeContents.push(obj);
      }
    }
    function _decryptSafeContents(data2, password) {
      var capture = {};
      var errors = [];
      if (!asn1.validate(
        data2,
        forge2.pkcs7.asn1.encryptedDataValidator,
        capture,
        errors
      )) {
        var error = new Error("Cannot read EncryptedContentInfo.");
        error.errors = errors;
        throw error;
      }
      var oid = asn1.derToOid(capture.contentType);
      if (oid !== pki.oids.data) {
        var error = new Error(
          "PKCS#12 EncryptedContentInfo ContentType is not Data."
        );
        error.oid = oid;
        throw error;
      }
      oid = asn1.derToOid(capture.encAlgorithm);
      var cipher = pki.pbe.getCipher(oid, capture.encParameter, password);
      var encryptedContentAsn1 = _decodePkcs7Data(capture.encryptedContentAsn1);
      var encrypted = forge2.util.createBuffer(encryptedContentAsn1.value);
      cipher.update(encrypted);
      if (!cipher.finish()) {
        throw new Error("Failed to decrypt PKCS#12 SafeContents.");
      }
      return cipher.output.getBytes();
    }
    function _decodeSafeContents(safeContents, strict, password) {
      if (!strict && safeContents.length === 0) {
        return [];
      }
      safeContents = asn1.fromDer(safeContents, strict);
      if (safeContents.tagClass !== asn1.Class.UNIVERSAL || safeContents.type !== asn1.Type.SEQUENCE || safeContents.constructed !== true) {
        throw new Error(
          "PKCS#12 SafeContents expected to be a SEQUENCE OF SafeBag."
        );
      }
      var res = [];
      for (var i = 0; i < safeContents.value.length; i++) {
        var safeBag = safeContents.value[i];
        var capture = {};
        var errors = [];
        if (!asn1.validate(safeBag, safeBagValidator, capture, errors)) {
          var error = new Error("Cannot read SafeBag.");
          error.errors = errors;
          throw error;
        }
        var bag = {
          type: asn1.derToOid(capture.bagId),
          attributes: _decodeBagAttributes(capture.bagAttributes)
        };
        res.push(bag);
        var validator, decoder;
        var bagAsn1 = capture.bagValue.value[0];
        switch (bag.type) {
          case pki.oids.pkcs8ShroudedKeyBag:
            bagAsn1 = pki.decryptPrivateKeyInfo(bagAsn1, password);
            if (bagAsn1 === null) {
              throw new Error(
                "Unable to decrypt PKCS#8 ShroudedKeyBag, wrong password?"
              );
            }
          /* fall through */
          case pki.oids.keyBag:
            try {
              bag.key = pki.privateKeyFromAsn1(bagAsn1);
            } catch (e) {
              bag.key = null;
              bag.asn1 = bagAsn1;
            }
            continue;
          /* Nothing more to do. */
          case pki.oids.certBag:
            validator = certBagValidator;
            decoder = function() {
              if (asn1.derToOid(capture.certId) !== pki.oids.x509Certificate) {
                var error2 = new Error(
                  "Unsupported certificate type, only X.509 supported."
                );
                error2.oid = asn1.derToOid(capture.certId);
                throw error2;
              }
              var certAsn1 = asn1.fromDer(capture.cert, strict);
              try {
                bag.cert = pki.certificateFromAsn1(certAsn1, true);
              } catch (e) {
                bag.cert = null;
                bag.asn1 = certAsn1;
              }
            };
            break;
          default:
            var error = new Error("Unsupported PKCS#12 SafeBag type.");
            error.oid = bag.type;
            throw error;
        }
        if (validator !== void 0 && !asn1.validate(bagAsn1, validator, capture, errors)) {
          var error = new Error("Cannot read PKCS#12 " + validator.name);
          error.errors = errors;
          throw error;
        }
        decoder();
      }
      return res;
    }
    function _decodeBagAttributes(attributes) {
      var decodedAttrs = {};
      if (attributes !== void 0) {
        for (var i = 0; i < attributes.length; ++i) {
          var capture = {};
          var errors = [];
          if (!asn1.validate(attributes[i], attributeValidator, capture, errors)) {
            var error = new Error("Cannot read PKCS#12 BagAttribute.");
            error.errors = errors;
            throw error;
          }
          var oid = asn1.derToOid(capture.oid);
          if (pki.oids[oid] === void 0) {
            continue;
          }
          decodedAttrs[pki.oids[oid]] = [];
          for (var j = 0; j < capture.values.length; ++j) {
            decodedAttrs[pki.oids[oid]].push(capture.values[j].value);
          }
        }
      }
      return decodedAttrs;
    }
    p12.toPkcs12Asn1 = function(key2, cert, password, options) {
      options = options || {};
      options.saltSize = options.saltSize || 8;
      options.count = options.count || 2048;
      options.algorithm = options.algorithm || options.encAlgorithm || "aes128";
      if (!("useMac" in options)) {
        options.useMac = true;
      }
      if (!("localKeyId" in options)) {
        options.localKeyId = null;
      }
      if (!("generateLocalKeyId" in options)) {
        options.generateLocalKeyId = true;
      }
      var localKeyId = options.localKeyId;
      var bagAttrs;
      if (localKeyId !== null) {
        localKeyId = forge2.util.hexToBytes(localKeyId);
      } else if (options.generateLocalKeyId) {
        if (cert) {
          var pairedCert = forge2.util.isArray(cert) ? cert[0] : cert;
          if (typeof pairedCert === "string") {
            pairedCert = pki.certificateFromPem(pairedCert);
          }
          var sha14 = forge2.md.sha1.create();
          sha14.update(asn1.toDer(pki.certificateToAsn1(pairedCert)).getBytes());
          localKeyId = sha14.digest().getBytes();
        } else {
          localKeyId = forge2.random.getBytes(20);
        }
      }
      var attrs = [];
      if (localKeyId !== null) {
        attrs.push(
          // localKeyID
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            // attrId
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(pki.oids.localKeyId).getBytes()
            ),
            // attrValues
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.OCTETSTRING,
                false,
                localKeyId
              )
            ])
          ])
        );
      }
      if ("friendlyName" in options) {
        attrs.push(
          // friendlyName
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            // attrId
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(pki.oids.friendlyName).getBytes()
            ),
            // attrValues
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.BMPSTRING,
                false,
                options.friendlyName
              )
            ])
          ])
        );
      }
      if (attrs.length > 0) {
        bagAttrs = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, attrs);
      }
      var contents = [];
      var chain = [];
      if (cert !== null) {
        if (forge2.util.isArray(cert)) {
          chain = cert;
        } else {
          chain = [cert];
        }
      }
      var certSafeBags = [];
      for (var i = 0; i < chain.length; ++i) {
        cert = chain[i];
        if (typeof cert === "string") {
          cert = pki.certificateFromPem(cert);
        }
        var certBagAttrs = i === 0 ? bagAttrs : void 0;
        var certAsn1 = pki.certificateToAsn1(cert);
        var certSafeBag = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // bagId
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(pki.oids.certBag).getBytes()
          ),
          // bagValue
          asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
            // CertBag
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              // certId
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.OID,
                false,
                asn1.oidToDer(pki.oids.x509Certificate).getBytes()
              ),
              // certValue (x509Certificate)
              asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.OCTETSTRING,
                  false,
                  asn1.toDer(certAsn1).getBytes()
                )
              ])
            ])
          ]),
          // bagAttributes (OPTIONAL)
          certBagAttrs
        ]);
        certSafeBags.push(certSafeBag);
      }
      if (certSafeBags.length > 0) {
        var certSafeContents = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.SEQUENCE,
          true,
          certSafeBags
        );
        var certCI = (
          // PKCS#7 ContentInfo
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            // contentType
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              // OID for the content type is 'data'
              asn1.oidToDer(pki.oids.data).getBytes()
            ),
            // content
            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.OCTETSTRING,
                false,
                asn1.toDer(certSafeContents).getBytes()
              )
            ])
          ])
        );
        contents.push(certCI);
      }
      var keyBag = null;
      if (key2 !== null) {
        var pkAsn1 = pki.wrapRsaPrivateKey(pki.privateKeyToAsn1(key2));
        if (password === null) {
          keyBag = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            // bagId
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(pki.oids.keyBag).getBytes()
            ),
            // bagValue
            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
              // PrivateKeyInfo
              pkAsn1
            ]),
            // bagAttributes (OPTIONAL)
            bagAttrs
          ]);
        } else {
          keyBag = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            // bagId
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(pki.oids.pkcs8ShroudedKeyBag).getBytes()
            ),
            // bagValue
            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
              // EncryptedPrivateKeyInfo
              pki.encryptPrivateKeyInfo(pkAsn1, password, options)
            ]),
            // bagAttributes (OPTIONAL)
            bagAttrs
          ]);
        }
        var keySafeContents = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [keyBag]);
        var keyCI = (
          // PKCS#7 ContentInfo
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            // contentType
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              // OID for the content type is 'data'
              asn1.oidToDer(pki.oids.data).getBytes()
            ),
            // content
            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.OCTETSTRING,
                false,
                asn1.toDer(keySafeContents).getBytes()
              )
            ])
          ])
        );
        contents.push(keyCI);
      }
      var safe = asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.SEQUENCE,
        true,
        contents
      );
      var macData;
      if (options.useMac) {
        var sha14 = forge2.md.sha1.create();
        var macSalt = new forge2.util.ByteBuffer(
          forge2.random.getBytes(options.saltSize)
        );
        var count = options.count;
        var key2 = p12.generateKey(password, macSalt, 3, count, 20);
        var mac = forge2.hmac.create();
        mac.start(sha14, key2);
        mac.update(asn1.toDer(safe).getBytes());
        var macValue = mac.getMac();
        macData = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // mac DigestInfo
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            // digestAlgorithm
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              // algorithm = SHA-1
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.OID,
                false,
                asn1.oidToDer(pki.oids.sha1).getBytes()
              ),
              // parameters = Null
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
            ]),
            // digest
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OCTETSTRING,
              false,
              macValue.getBytes()
            )
          ]),
          // macSalt OCTET STRING
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OCTETSTRING,
            false,
            macSalt.getBytes()
          ),
          // iterations INTEGER (XXX: Only support count < 65536)
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.INTEGER,
            false,
            asn1.integerToDer(count).getBytes()
          )
        ]);
      }
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // version (3)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          asn1.integerToDer(3).getBytes()
        ),
        // PKCS#7 ContentInfo
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // contentType
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            // OID for the content type is 'data'
            asn1.oidToDer(pki.oids.data).getBytes()
          ),
          // content
          asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OCTETSTRING,
              false,
              asn1.toDer(safe).getBytes()
            )
          ])
        ]),
        macData
      ]);
    };
    p12.generateKey = forge2.pbe.generatePkcs12Key;
  }
});

// node_modules/@selfxyz/common/node_modules/node-forge/lib/pki.js
var require_pki = __commonJS({
  "node_modules/@selfxyz/common/node_modules/node-forge/lib/pki.js"(exports2, module2) {
    var forge2 = require_forge();
    require_asn1();
    require_oids();
    require_pbe();
    require_pem();
    require_pbkdf2();
    require_pkcs12();
    require_pss();
    require_rsa();
    require_util();
    require_x509();
    var asn1 = forge2.asn1;
    var pki = module2.exports = forge2.pki = forge2.pki || {};
    pki.pemToDer = function(pem) {
      var msg = forge2.pem.decode(pem)[0];
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        throw new Error("Could not convert PEM to DER; PEM is encrypted.");
      }
      return forge2.util.createBuffer(msg.body);
    };
    pki.privateKeyFromPem = function(pem) {
      var msg = forge2.pem.decode(pem)[0];
      if (msg.type !== "PRIVATE KEY" && msg.type !== "RSA PRIVATE KEY") {
        var error = new Error('Could not convert private key from PEM; PEM header type is not "PRIVATE KEY" or "RSA PRIVATE KEY".');
        error.headerType = msg.type;
        throw error;
      }
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        throw new Error("Could not convert private key from PEM; PEM is encrypted.");
      }
      var obj = asn1.fromDer(msg.body);
      return pki.privateKeyFromAsn1(obj);
    };
    pki.privateKeyToPem = function(key2, maxline) {
      var msg = {
        type: "RSA PRIVATE KEY",
        body: asn1.toDer(pki.privateKeyToAsn1(key2)).getBytes()
      };
      return forge2.pem.encode(msg, { maxline });
    };
    pki.privateKeyInfoToPem = function(pki2, maxline) {
      var msg = {
        type: "PRIVATE KEY",
        body: asn1.toDer(pki2).getBytes()
      };
      return forge2.pem.encode(msg, { maxline });
    };
  }
});

// node_modules/@selfxyz/common/node_modules/node-forge/lib/tls.js
var require_tls = __commonJS({
  "node_modules/@selfxyz/common/node_modules/node-forge/lib/tls.js"(exports2, module2) {
    var forge2 = require_forge();
    require_asn1();
    require_hmac();
    require_md5();
    require_pem();
    require_pki();
    require_random();
    require_sha12();
    require_util();
    var prf_TLS1 = function(secret, label, seed, length2) {
      var rval = forge2.util.createBuffer();
      var idx = secret.length >> 1;
      var slen = idx + (secret.length & 1);
      var s1 = secret.substr(0, slen);
      var s2 = secret.substr(idx, slen);
      var ai = forge2.util.createBuffer();
      var hmac = forge2.hmac.create();
      seed = label + seed;
      var md5itr = Math.ceil(length2 / 16);
      var sha1itr = Math.ceil(length2 / 20);
      hmac.start("MD5", s1);
      var md5bytes = forge2.util.createBuffer();
      ai.putBytes(seed);
      for (var i = 0; i < md5itr; ++i) {
        hmac.start(null, null);
        hmac.update(ai.getBytes());
        ai.putBuffer(hmac.digest());
        hmac.start(null, null);
        hmac.update(ai.bytes() + seed);
        md5bytes.putBuffer(hmac.digest());
      }
      hmac.start("SHA1", s2);
      var sha1bytes = forge2.util.createBuffer();
      ai.clear();
      ai.putBytes(seed);
      for (var i = 0; i < sha1itr; ++i) {
        hmac.start(null, null);
        hmac.update(ai.getBytes());
        ai.putBuffer(hmac.digest());
        hmac.start(null, null);
        hmac.update(ai.bytes() + seed);
        sha1bytes.putBuffer(hmac.digest());
      }
      rval.putBytes(forge2.util.xorBytes(
        md5bytes.getBytes(),
        sha1bytes.getBytes(),
        length2
      ));
      return rval;
    };
    var hmac_sha1 = function(key3, seqNum, record) {
      var hmac = forge2.hmac.create();
      hmac.start("SHA1", key3);
      var b = forge2.util.createBuffer();
      b.putInt32(seqNum[0]);
      b.putInt32(seqNum[1]);
      b.putByte(record.type);
      b.putByte(record.version.major);
      b.putByte(record.version.minor);
      b.putInt16(record.length);
      b.putBytes(record.fragment.bytes());
      hmac.update(b.getBytes());
      return hmac.digest().getBytes();
    };
    var deflate = function(c, record, s) {
      var rval = false;
      try {
        var bytes = c.deflate(record.fragment.getBytes());
        record.fragment = forge2.util.createBuffer(bytes);
        record.length = bytes.length;
        rval = true;
      } catch (ex) {
      }
      return rval;
    };
    var inflate = function(c, record, s) {
      var rval = false;
      try {
        var bytes = c.inflate(record.fragment.getBytes());
        record.fragment = forge2.util.createBuffer(bytes);
        record.length = bytes.length;
        rval = true;
      } catch (ex) {
      }
      return rval;
    };
    var readVector = function(b, lenBytes) {
      var len = 0;
      switch (lenBytes) {
        case 1:
          len = b.getByte();
          break;
        case 2:
          len = b.getInt16();
          break;
        case 3:
          len = b.getInt24();
          break;
        case 4:
          len = b.getInt32();
          break;
      }
      return forge2.util.createBuffer(b.getBytes(len));
    };
    var writeVector = function(b, lenBytes, v) {
      b.putInt(v.length(), lenBytes << 3);
      b.putBuffer(v);
    };
    var tls = {};
    tls.Versions = {
      TLS_1_0: { major: 3, minor: 1 },
      TLS_1_1: { major: 3, minor: 2 },
      TLS_1_2: { major: 3, minor: 3 }
    };
    tls.SupportedVersions = [
      tls.Versions.TLS_1_1,
      tls.Versions.TLS_1_0
    ];
    tls.Version = tls.SupportedVersions[0];
    tls.MaxFragment = 16384 - 1024;
    tls.ConnectionEnd = {
      server: 0,
      client: 1
    };
    tls.PRFAlgorithm = {
      tls_prf_sha256: 0
    };
    tls.BulkCipherAlgorithm = {
      none: null,
      rc4: 0,
      des3: 1,
      aes: 2
    };
    tls.CipherType = {
      stream: 0,
      block: 1,
      aead: 2
    };
    tls.MACAlgorithm = {
      none: null,
      hmac_md5: 0,
      hmac_sha1: 1,
      hmac_sha256: 2,
      hmac_sha384: 3,
      hmac_sha512: 4
    };
    tls.CompressionMethod = {
      none: 0,
      deflate: 1
    };
    tls.ContentType = {
      change_cipher_spec: 20,
      alert: 21,
      handshake: 22,
      application_data: 23,
      heartbeat: 24
    };
    tls.HandshakeType = {
      hello_request: 0,
      client_hello: 1,
      server_hello: 2,
      certificate: 11,
      server_key_exchange: 12,
      certificate_request: 13,
      server_hello_done: 14,
      certificate_verify: 15,
      client_key_exchange: 16,
      finished: 20
    };
    tls.Alert = {};
    tls.Alert.Level = {
      warning: 1,
      fatal: 2
    };
    tls.Alert.Description = {
      close_notify: 0,
      unexpected_message: 10,
      bad_record_mac: 20,
      decryption_failed: 21,
      record_overflow: 22,
      decompression_failure: 30,
      handshake_failure: 40,
      bad_certificate: 42,
      unsupported_certificate: 43,
      certificate_revoked: 44,
      certificate_expired: 45,
      certificate_unknown: 46,
      illegal_parameter: 47,
      unknown_ca: 48,
      access_denied: 49,
      decode_error: 50,
      decrypt_error: 51,
      export_restriction: 60,
      protocol_version: 70,
      insufficient_security: 71,
      internal_error: 80,
      user_canceled: 90,
      no_renegotiation: 100
    };
    tls.HeartbeatMessageType = {
      heartbeat_request: 1,
      heartbeat_response: 2
    };
    tls.CipherSuites = {};
    tls.getCipherSuite = function(twoBytes) {
      var rval = null;
      for (var key3 in tls.CipherSuites) {
        var cs = tls.CipherSuites[key3];
        if (cs.id[0] === twoBytes.charCodeAt(0) && cs.id[1] === twoBytes.charCodeAt(1)) {
          rval = cs;
          break;
        }
      }
      return rval;
    };
    tls.handleUnexpected = function(c, record) {
      var ignore = !c.open && c.entity === tls.ConnectionEnd.client;
      if (!ignore) {
        c.error(c, {
          message: "Unexpected message. Received TLS record out of order.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.unexpected_message
          }
        });
      }
    };
    tls.handleHelloRequest = function(c, record, length2) {
      if (!c.handshaking && c.handshakes > 0) {
        tls.queue(c, tls.createAlert(c, {
          level: tls.Alert.Level.warning,
          description: tls.Alert.Description.no_renegotiation
        }));
        tls.flush(c);
      }
      c.process();
    };
    tls.parseHelloMessage = function(c, record, length2) {
      var msg = null;
      var client = c.entity === tls.ConnectionEnd.client;
      if (length2 < 38) {
        c.error(c, {
          message: client ? "Invalid ServerHello message. Message too short." : "Invalid ClientHello message. Message too short.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.illegal_parameter
          }
        });
      } else {
        var b = record.fragment;
        var remaining = b.length();
        msg = {
          version: {
            major: b.getByte(),
            minor: b.getByte()
          },
          random: forge2.util.createBuffer(b.getBytes(32)),
          session_id: readVector(b, 1),
          extensions: []
        };
        if (client) {
          msg.cipher_suite = b.getBytes(2);
          msg.compression_method = b.getByte();
        } else {
          msg.cipher_suites = readVector(b, 2);
          msg.compression_methods = readVector(b, 1);
        }
        remaining = length2 - (remaining - b.length());
        if (remaining > 0) {
          var exts = readVector(b, 2);
          while (exts.length() > 0) {
            msg.extensions.push({
              type: [exts.getByte(), exts.getByte()],
              data: readVector(exts, 2)
            });
          }
          if (!client) {
            for (var i = 0; i < msg.extensions.length; ++i) {
              var ext = msg.extensions[i];
              if (ext.type[0] === 0 && ext.type[1] === 0) {
                var snl = readVector(ext.data, 2);
                while (snl.length() > 0) {
                  var snType = snl.getByte();
                  if (snType !== 0) {
                    break;
                  }
                  c.session.extensions.server_name.serverNameList.push(
                    readVector(snl, 2).getBytes()
                  );
                }
              }
            }
          }
        }
        if (c.session.version) {
          if (msg.version.major !== c.session.version.major || msg.version.minor !== c.session.version.minor) {
            return c.error(c, {
              message: "TLS version change is disallowed during renegotiation.",
              send: true,
              alert: {
                level: tls.Alert.Level.fatal,
                description: tls.Alert.Description.protocol_version
              }
            });
          }
        }
        if (client) {
          c.session.cipherSuite = tls.getCipherSuite(msg.cipher_suite);
        } else {
          var tmp = forge2.util.createBuffer(msg.cipher_suites.bytes());
          while (tmp.length() > 0) {
            c.session.cipherSuite = tls.getCipherSuite(tmp.getBytes(2));
            if (c.session.cipherSuite !== null) {
              break;
            }
          }
        }
        if (c.session.cipherSuite === null) {
          return c.error(c, {
            message: "No cipher suites in common.",
            send: true,
            alert: {
              level: tls.Alert.Level.fatal,
              description: tls.Alert.Description.handshake_failure
            },
            cipherSuite: forge2.util.bytesToHex(msg.cipher_suite)
          });
        }
        if (client) {
          c.session.compressionMethod = msg.compression_method;
        } else {
          c.session.compressionMethod = tls.CompressionMethod.none;
        }
      }
      return msg;
    };
    tls.createSecurityParameters = function(c, msg) {
      var client = c.entity === tls.ConnectionEnd.client;
      var msgRandom = msg.random.bytes();
      var cRandom = client ? c.session.sp.client_random : msgRandom;
      var sRandom = client ? msgRandom : tls.createRandom().getBytes();
      c.session.sp = {
        entity: c.entity,
        prf_algorithm: tls.PRFAlgorithm.tls_prf_sha256,
        bulk_cipher_algorithm: null,
        cipher_type: null,
        enc_key_length: null,
        block_length: null,
        fixed_iv_length: null,
        record_iv_length: null,
        mac_algorithm: null,
        mac_length: null,
        mac_key_length: null,
        compression_algorithm: c.session.compressionMethod,
        pre_master_secret: null,
        master_secret: null,
        client_random: cRandom,
        server_random: sRandom
      };
    };
    tls.handleServerHello = function(c, record, length2) {
      var msg = tls.parseHelloMessage(c, record, length2);
      if (c.fail) {
        return;
      }
      if (msg.version.minor <= c.version.minor) {
        c.version.minor = msg.version.minor;
      } else {
        return c.error(c, {
          message: "Incompatible TLS version.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.protocol_version
          }
        });
      }
      c.session.version = c.version;
      var sessionId = msg.session_id.bytes();
      if (sessionId.length > 0 && sessionId === c.session.id) {
        c.expect = SCC;
        c.session.resuming = true;
        c.session.sp.server_random = msg.random.bytes();
      } else {
        c.expect = SCE;
        c.session.resuming = false;
        tls.createSecurityParameters(c, msg);
      }
      c.session.id = sessionId;
      c.process();
    };
    tls.handleClientHello = function(c, record, length2) {
      var msg = tls.parseHelloMessage(c, record, length2);
      if (c.fail) {
        return;
      }
      var sessionId = msg.session_id.bytes();
      var session = null;
      if (c.sessionCache) {
        session = c.sessionCache.getSession(sessionId);
        if (session === null) {
          sessionId = "";
        } else if (session.version.major !== msg.version.major || session.version.minor > msg.version.minor) {
          session = null;
          sessionId = "";
        }
      }
      if (sessionId.length === 0) {
        sessionId = forge2.random.getBytes(32);
      }
      c.session.id = sessionId;
      c.session.clientHelloVersion = msg.version;
      c.session.sp = {};
      if (session) {
        c.version = c.session.version = session.version;
        c.session.sp = session.sp;
      } else {
        var version;
        for (var i = 1; i < tls.SupportedVersions.length; ++i) {
          version = tls.SupportedVersions[i];
          if (version.minor <= msg.version.minor) {
            break;
          }
        }
        c.version = { major: version.major, minor: version.minor };
        c.session.version = c.version;
      }
      if (session !== null) {
        c.expect = CCC;
        c.session.resuming = true;
        c.session.sp.client_random = msg.random.bytes();
      } else {
        c.expect = c.verifyClient !== false ? CCE : CKE;
        c.session.resuming = false;
        tls.createSecurityParameters(c, msg);
      }
      c.open = true;
      tls.queue(c, tls.createRecord(c, {
        type: tls.ContentType.handshake,
        data: tls.createServerHello(c)
      }));
      if (c.session.resuming) {
        tls.queue(c, tls.createRecord(c, {
          type: tls.ContentType.change_cipher_spec,
          data: tls.createChangeCipherSpec()
        }));
        c.state.pending = tls.createConnectionState(c);
        c.state.current.write = c.state.pending.write;
        tls.queue(c, tls.createRecord(c, {
          type: tls.ContentType.handshake,
          data: tls.createFinished(c)
        }));
      } else {
        tls.queue(c, tls.createRecord(c, {
          type: tls.ContentType.handshake,
          data: tls.createCertificate(c)
        }));
        if (!c.fail) {
          tls.queue(c, tls.createRecord(c, {
            type: tls.ContentType.handshake,
            data: tls.createServerKeyExchange(c)
          }));
          if (c.verifyClient !== false) {
            tls.queue(c, tls.createRecord(c, {
              type: tls.ContentType.handshake,
              data: tls.createCertificateRequest(c)
            }));
          }
          tls.queue(c, tls.createRecord(c, {
            type: tls.ContentType.handshake,
            data: tls.createServerHelloDone(c)
          }));
        }
      }
      tls.flush(c);
      c.process();
    };
    tls.handleCertificate = function(c, record, length2) {
      if (length2 < 3) {
        return c.error(c, {
          message: "Invalid Certificate message. Message too short.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.illegal_parameter
          }
        });
      }
      var b = record.fragment;
      var msg = {
        certificate_list: readVector(b, 3)
      };
      var cert, asn1;
      var certs = [];
      try {
        while (msg.certificate_list.length() > 0) {
          cert = readVector(msg.certificate_list, 3);
          asn1 = forge2.asn1.fromDer(cert);
          cert = forge2.pki.certificateFromAsn1(asn1, true);
          certs.push(cert);
        }
      } catch (ex) {
        return c.error(c, {
          message: "Could not parse certificate list.",
          cause: ex,
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.bad_certificate
          }
        });
      }
      var client = c.entity === tls.ConnectionEnd.client;
      if ((client || c.verifyClient === true) && certs.length === 0) {
        c.error(c, {
          message: client ? "No server certificate provided." : "No client certificate provided.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.illegal_parameter
          }
        });
      } else if (certs.length === 0) {
        c.expect = client ? SKE : CKE;
      } else {
        if (client) {
          c.session.serverCertificate = certs[0];
        } else {
          c.session.clientCertificate = certs[0];
        }
        if (tls.verifyCertificateChain(c, certs)) {
          c.expect = client ? SKE : CKE;
        }
      }
      c.process();
    };
    tls.handleServerKeyExchange = function(c, record, length2) {
      if (length2 > 0) {
        return c.error(c, {
          message: "Invalid key parameters. Only RSA is supported.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.unsupported_certificate
          }
        });
      }
      c.expect = SCR;
      c.process();
    };
    tls.handleClientKeyExchange = function(c, record, length2) {
      if (length2 < 48) {
        return c.error(c, {
          message: "Invalid key parameters. Only RSA is supported.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.unsupported_certificate
          }
        });
      }
      var b = record.fragment;
      var msg = {
        enc_pre_master_secret: readVector(b, 2).getBytes()
      };
      var privateKey = null;
      if (c.getPrivateKey) {
        try {
          privateKey = c.getPrivateKey(c, c.session.serverCertificate);
          privateKey = forge2.pki.privateKeyFromPem(privateKey);
        } catch (ex) {
          c.error(c, {
            message: "Could not get private key.",
            cause: ex,
            send: true,
            alert: {
              level: tls.Alert.Level.fatal,
              description: tls.Alert.Description.internal_error
            }
          });
        }
      }
      if (privateKey === null) {
        return c.error(c, {
          message: "No private key set.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.internal_error
          }
        });
      }
      try {
        var sp = c.session.sp;
        sp.pre_master_secret = privateKey.decrypt(msg.enc_pre_master_secret);
        var version = c.session.clientHelloVersion;
        if (version.major !== sp.pre_master_secret.charCodeAt(0) || version.minor !== sp.pre_master_secret.charCodeAt(1)) {
          throw new Error("TLS version rollback attack detected.");
        }
      } catch (ex) {
        sp.pre_master_secret = forge2.random.getBytes(48);
      }
      c.expect = CCC;
      if (c.session.clientCertificate !== null) {
        c.expect = CCV;
      }
      c.process();
    };
    tls.handleCertificateRequest = function(c, record, length2) {
      if (length2 < 3) {
        return c.error(c, {
          message: "Invalid CertificateRequest. Message too short.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.illegal_parameter
          }
        });
      }
      var b = record.fragment;
      var msg = {
        certificate_types: readVector(b, 1),
        certificate_authorities: readVector(b, 2)
      };
      c.session.certificateRequest = msg;
      c.expect = SHD;
      c.process();
    };
    tls.handleCertificateVerify = function(c, record, length2) {
      if (length2 < 2) {
        return c.error(c, {
          message: "Invalid CertificateVerify. Message too short.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.illegal_parameter
          }
        });
      }
      var b = record.fragment;
      b.read -= 4;
      var msgBytes = b.bytes();
      b.read += 4;
      var msg = {
        signature: readVector(b, 2).getBytes()
      };
      var verify = forge2.util.createBuffer();
      verify.putBuffer(c.session.md5.digest());
      verify.putBuffer(c.session.sha1.digest());
      verify = verify.getBytes();
      try {
        var cert = c.session.clientCertificate;
        if (!cert.publicKey.verify(verify, msg.signature, "NONE")) {
          throw new Error("CertificateVerify signature does not match.");
        }
        c.session.md5.update(msgBytes);
        c.session.sha1.update(msgBytes);
      } catch (ex) {
        return c.error(c, {
          message: "Bad signature in CertificateVerify.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.handshake_failure
          }
        });
      }
      c.expect = CCC;
      c.process();
    };
    tls.handleServerHelloDone = function(c, record, length2) {
      if (length2 > 0) {
        return c.error(c, {
          message: "Invalid ServerHelloDone message. Invalid length.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.record_overflow
          }
        });
      }
      if (c.serverCertificate === null) {
        var error = {
          message: "No server certificate provided. Not enough security.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.insufficient_security
          }
        };
        var depth = 0;
        var ret = c.verify(c, error.alert.description, depth, []);
        if (ret !== true) {
          if (ret || ret === 0) {
            if (typeof ret === "object" && !forge2.util.isArray(ret)) {
              if (ret.message) {
                error.message = ret.message;
              }
              if (ret.alert) {
                error.alert.description = ret.alert;
              }
            } else if (typeof ret === "number") {
              error.alert.description = ret;
            }
          }
          return c.error(c, error);
        }
      }
      if (c.session.certificateRequest !== null) {
        record = tls.createRecord(c, {
          type: tls.ContentType.handshake,
          data: tls.createCertificate(c)
        });
        tls.queue(c, record);
      }
      record = tls.createRecord(c, {
        type: tls.ContentType.handshake,
        data: tls.createClientKeyExchange(c)
      });
      tls.queue(c, record);
      c.expect = SER;
      var callback = function(c2, signature) {
        if (c2.session.certificateRequest !== null && c2.session.clientCertificate !== null) {
          tls.queue(c2, tls.createRecord(c2, {
            type: tls.ContentType.handshake,
            data: tls.createCertificateVerify(c2, signature)
          }));
        }
        tls.queue(c2, tls.createRecord(c2, {
          type: tls.ContentType.change_cipher_spec,
          data: tls.createChangeCipherSpec()
        }));
        c2.state.pending = tls.createConnectionState(c2);
        c2.state.current.write = c2.state.pending.write;
        tls.queue(c2, tls.createRecord(c2, {
          type: tls.ContentType.handshake,
          data: tls.createFinished(c2)
        }));
        c2.expect = SCC;
        tls.flush(c2);
        c2.process();
      };
      if (c.session.certificateRequest === null || c.session.clientCertificate === null) {
        return callback(c, null);
      }
      tls.getClientSignature(c, callback);
    };
    tls.handleChangeCipherSpec = function(c, record) {
      if (record.fragment.getByte() !== 1) {
        return c.error(c, {
          message: "Invalid ChangeCipherSpec message received.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.illegal_parameter
          }
        });
      }
      var client = c.entity === tls.ConnectionEnd.client;
      if (c.session.resuming && client || !c.session.resuming && !client) {
        c.state.pending = tls.createConnectionState(c);
      }
      c.state.current.read = c.state.pending.read;
      if (!c.session.resuming && client || c.session.resuming && !client) {
        c.state.pending = null;
      }
      c.expect = client ? SFI : CFI;
      c.process();
    };
    tls.handleFinished = function(c, record, length2) {
      var b = record.fragment;
      b.read -= 4;
      var msgBytes = b.bytes();
      b.read += 4;
      var vd = record.fragment.getBytes();
      b = forge2.util.createBuffer();
      b.putBuffer(c.session.md5.digest());
      b.putBuffer(c.session.sha1.digest());
      var client = c.entity === tls.ConnectionEnd.client;
      var label = client ? "server finished" : "client finished";
      var sp = c.session.sp;
      var vdl = 12;
      var prf = prf_TLS1;
      b = prf(sp.master_secret, label, b.getBytes(), vdl);
      if (b.getBytes() !== vd) {
        return c.error(c, {
          message: "Invalid verify_data in Finished message.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.decrypt_error
          }
        });
      }
      c.session.md5.update(msgBytes);
      c.session.sha1.update(msgBytes);
      if (c.session.resuming && client || !c.session.resuming && !client) {
        tls.queue(c, tls.createRecord(c, {
          type: tls.ContentType.change_cipher_spec,
          data: tls.createChangeCipherSpec()
        }));
        c.state.current.write = c.state.pending.write;
        c.state.pending = null;
        tls.queue(c, tls.createRecord(c, {
          type: tls.ContentType.handshake,
          data: tls.createFinished(c)
        }));
      }
      c.expect = client ? SAD : CAD;
      c.handshaking = false;
      ++c.handshakes;
      c.peerCertificate = client ? c.session.serverCertificate : c.session.clientCertificate;
      tls.flush(c);
      c.isConnected = true;
      c.connected(c);
      c.process();
    };
    tls.handleAlert = function(c, record) {
      var b = record.fragment;
      var alert = {
        level: b.getByte(),
        description: b.getByte()
      };
      var msg;
      switch (alert.description) {
        case tls.Alert.Description.close_notify:
          msg = "Connection closed.";
          break;
        case tls.Alert.Description.unexpected_message:
          msg = "Unexpected message.";
          break;
        case tls.Alert.Description.bad_record_mac:
          msg = "Bad record MAC.";
          break;
        case tls.Alert.Description.decryption_failed:
          msg = "Decryption failed.";
          break;
        case tls.Alert.Description.record_overflow:
          msg = "Record overflow.";
          break;
        case tls.Alert.Description.decompression_failure:
          msg = "Decompression failed.";
          break;
        case tls.Alert.Description.handshake_failure:
          msg = "Handshake failure.";
          break;
        case tls.Alert.Description.bad_certificate:
          msg = "Bad certificate.";
          break;
        case tls.Alert.Description.unsupported_certificate:
          msg = "Unsupported certificate.";
          break;
        case tls.Alert.Description.certificate_revoked:
          msg = "Certificate revoked.";
          break;
        case tls.Alert.Description.certificate_expired:
          msg = "Certificate expired.";
          break;
        case tls.Alert.Description.certificate_unknown:
          msg = "Certificate unknown.";
          break;
        case tls.Alert.Description.illegal_parameter:
          msg = "Illegal parameter.";
          break;
        case tls.Alert.Description.unknown_ca:
          msg = "Unknown certificate authority.";
          break;
        case tls.Alert.Description.access_denied:
          msg = "Access denied.";
          break;
        case tls.Alert.Description.decode_error:
          msg = "Decode error.";
          break;
        case tls.Alert.Description.decrypt_error:
          msg = "Decrypt error.";
          break;
        case tls.Alert.Description.export_restriction:
          msg = "Export restriction.";
          break;
        case tls.Alert.Description.protocol_version:
          msg = "Unsupported protocol version.";
          break;
        case tls.Alert.Description.insufficient_security:
          msg = "Insufficient security.";
          break;
        case tls.Alert.Description.internal_error:
          msg = "Internal error.";
          break;
        case tls.Alert.Description.user_canceled:
          msg = "User canceled.";
          break;
        case tls.Alert.Description.no_renegotiation:
          msg = "Renegotiation not supported.";
          break;
        default:
          msg = "Unknown error.";
          break;
      }
      if (alert.description === tls.Alert.Description.close_notify) {
        return c.close();
      }
      c.error(c, {
        message: msg,
        send: false,
        // origin is the opposite end
        origin: c.entity === tls.ConnectionEnd.client ? "server" : "client",
        alert
      });
      c.process();
    };
    tls.handleHandshake = function(c, record) {
      var b = record.fragment;
      var type = b.getByte();
      var length2 = b.getInt24();
      if (length2 > b.length()) {
        c.fragmented = record;
        record.fragment = forge2.util.createBuffer();
        b.read -= 4;
        return c.process();
      }
      c.fragmented = null;
      b.read -= 4;
      var bytes = b.bytes(length2 + 4);
      b.read += 4;
      if (type in hsTable[c.entity][c.expect]) {
        if (c.entity === tls.ConnectionEnd.server && !c.open && !c.fail) {
          c.handshaking = true;
          c.session = {
            version: null,
            extensions: {
              server_name: {
                serverNameList: []
              }
            },
            cipherSuite: null,
            compressionMethod: null,
            serverCertificate: null,
            clientCertificate: null,
            md5: forge2.md.md5.create(),
            sha1: forge2.md.sha1.create()
          };
        }
        if (type !== tls.HandshakeType.hello_request && type !== tls.HandshakeType.certificate_verify && type !== tls.HandshakeType.finished) {
          c.session.md5.update(bytes);
          c.session.sha1.update(bytes);
        }
        hsTable[c.entity][c.expect][type](c, record, length2);
      } else {
        tls.handleUnexpected(c, record);
      }
    };
    tls.handleApplicationData = function(c, record) {
      c.data.putBuffer(record.fragment);
      c.dataReady(c);
      c.process();
    };
    tls.handleHeartbeat = function(c, record) {
      var b = record.fragment;
      var type = b.getByte();
      var length2 = b.getInt16();
      var payload = b.getBytes(length2);
      if (type === tls.HeartbeatMessageType.heartbeat_request) {
        if (c.handshaking || length2 > payload.length) {
          return c.process();
        }
        tls.queue(c, tls.createRecord(c, {
          type: tls.ContentType.heartbeat,
          data: tls.createHeartbeat(
            tls.HeartbeatMessageType.heartbeat_response,
            payload
          )
        }));
        tls.flush(c);
      } else if (type === tls.HeartbeatMessageType.heartbeat_response) {
        if (payload !== c.expectedHeartbeatPayload) {
          return c.process();
        }
        if (c.heartbeatReceived) {
          c.heartbeatReceived(c, forge2.util.createBuffer(payload));
        }
      }
      c.process();
    };
    var SHE = 0;
    var SCE = 1;
    var SKE = 2;
    var SCR = 3;
    var SHD = 4;
    var SCC = 5;
    var SFI = 6;
    var SAD = 7;
    var SER = 8;
    var CHE = 0;
    var CCE = 1;
    var CKE = 2;
    var CCV = 3;
    var CCC = 4;
    var CFI = 5;
    var CAD = 6;
    var __ = tls.handleUnexpected;
    var R0 = tls.handleChangeCipherSpec;
    var R1 = tls.handleAlert;
    var R2 = tls.handleHandshake;
    var R3 = tls.handleApplicationData;
    var R4 = tls.handleHeartbeat;
    var ctTable = [];
    ctTable[tls.ConnectionEnd.client] = [
      //      CC,AL,HS,AD,HB
      /*SHE*/
      [__, R1, R2, __, R4],
      /*SCE*/
      [__, R1, R2, __, R4],
      /*SKE*/
      [__, R1, R2, __, R4],
      /*SCR*/
      [__, R1, R2, __, R4],
      /*SHD*/
      [__, R1, R2, __, R4],
      /*SCC*/
      [R0, R1, __, __, R4],
      /*SFI*/
      [__, R1, R2, __, R4],
      /*SAD*/
      [__, R1, R2, R3, R4],
      /*SER*/
      [__, R1, R2, __, R4]
    ];
    ctTable[tls.ConnectionEnd.server] = [
      //      CC,AL,HS,AD
      /*CHE*/
      [__, R1, R2, __, R4],
      /*CCE*/
      [__, R1, R2, __, R4],
      /*CKE*/
      [__, R1, R2, __, R4],
      /*CCV*/
      [__, R1, R2, __, R4],
      /*CCC*/
      [R0, R1, __, __, R4],
      /*CFI*/
      [__, R1, R2, __, R4],
      /*CAD*/
      [__, R1, R2, R3, R4],
      /*CER*/
      [__, R1, R2, __, R4]
    ];
    var H0 = tls.handleHelloRequest;
    var H1 = tls.handleServerHello;
    var H2 = tls.handleCertificate;
    var H3 = tls.handleServerKeyExchange;
    var H4 = tls.handleCertificateRequest;
    var H5 = tls.handleServerHelloDone;
    var H6 = tls.handleFinished;
    var hsTable = [];
    hsTable[tls.ConnectionEnd.client] = [
      //      HR,01,SH,03,04,05,06,07,08,09,10,SC,SK,CR,HD,15,CK,17,18,19,FI
      /*SHE*/
      [__, __, H1, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __],
      /*SCE*/
      [H0, __, __, __, __, __, __, __, __, __, __, H2, H3, H4, H5, __, __, __, __, __, __],
      /*SKE*/
      [H0, __, __, __, __, __, __, __, __, __, __, __, H3, H4, H5, __, __, __, __, __, __],
      /*SCR*/
      [H0, __, __, __, __, __, __, __, __, __, __, __, __, H4, H5, __, __, __, __, __, __],
      /*SHD*/
      [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, H5, __, __, __, __, __, __],
      /*SCC*/
      [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __],
      /*SFI*/
      [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, H6],
      /*SAD*/
      [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __],
      /*SER*/
      [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __]
    ];
    var H7 = tls.handleClientHello;
    var H8 = tls.handleClientKeyExchange;
    var H9 = tls.handleCertificateVerify;
    hsTable[tls.ConnectionEnd.server] = [
      //      01,CH,02,03,04,05,06,07,08,09,10,CC,12,13,14,CV,CK,17,18,19,FI
      /*CHE*/
      [__, H7, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __],
      /*CCE*/
      [__, __, __, __, __, __, __, __, __, __, __, H2, __, __, __, __, __, __, __, __, __],
      /*CKE*/
      [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, H8, __, __, __, __],
      /*CCV*/
      [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, H9, __, __, __, __, __],
      /*CCC*/
      [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __],
      /*CFI*/
      [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, H6],
      /*CAD*/
      [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __],
      /*CER*/
      [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __]
    ];
    tls.generateKeys = function(c, sp) {
      var prf = prf_TLS1;
      var random2 = sp.client_random + sp.server_random;
      if (!c.session.resuming) {
        sp.master_secret = prf(
          sp.pre_master_secret,
          "master secret",
          random2,
          48
        ).bytes();
        sp.pre_master_secret = null;
      }
      random2 = sp.server_random + sp.client_random;
      var length2 = 2 * sp.mac_key_length + 2 * sp.enc_key_length;
      var tls10 = c.version.major === tls.Versions.TLS_1_0.major && c.version.minor === tls.Versions.TLS_1_0.minor;
      if (tls10) {
        length2 += 2 * sp.fixed_iv_length;
      }
      var km = prf(sp.master_secret, "key expansion", random2, length2);
      var rval = {
        client_write_MAC_key: km.getBytes(sp.mac_key_length),
        server_write_MAC_key: km.getBytes(sp.mac_key_length),
        client_write_key: km.getBytes(sp.enc_key_length),
        server_write_key: km.getBytes(sp.enc_key_length)
      };
      if (tls10) {
        rval.client_write_IV = km.getBytes(sp.fixed_iv_length);
        rval.server_write_IV = km.getBytes(sp.fixed_iv_length);
      }
      return rval;
    };
    tls.createConnectionState = function(c) {
      var client = c.entity === tls.ConnectionEnd.client;
      var createMode = function() {
        var mode = {
          // two 32-bit numbers, first is most significant
          sequenceNumber: [0, 0],
          macKey: null,
          macLength: 0,
          macFunction: null,
          cipherState: null,
          cipherFunction: function(record) {
            return true;
          },
          compressionState: null,
          compressFunction: function(record) {
            return true;
          },
          updateSequenceNumber: function() {
            if (mode.sequenceNumber[1] === 4294967295) {
              mode.sequenceNumber[1] = 0;
              ++mode.sequenceNumber[0];
            } else {
              ++mode.sequenceNumber[1];
            }
          }
        };
        return mode;
      };
      var state = {
        read: createMode(),
        write: createMode()
      };
      state.read.update = function(c2, record) {
        if (!state.read.cipherFunction(record, state.read)) {
          c2.error(c2, {
            message: "Could not decrypt record or bad MAC.",
            send: true,
            alert: {
              level: tls.Alert.Level.fatal,
              // doesn't matter if decryption failed or MAC was
              // invalid, return the same error so as not to reveal
              // which one occurred
              description: tls.Alert.Description.bad_record_mac
            }
          });
        } else if (!state.read.compressFunction(c2, record, state.read)) {
          c2.error(c2, {
            message: "Could not decompress record.",
            send: true,
            alert: {
              level: tls.Alert.Level.fatal,
              description: tls.Alert.Description.decompression_failure
            }
          });
        }
        return !c2.fail;
      };
      state.write.update = function(c2, record) {
        if (!state.write.compressFunction(c2, record, state.write)) {
          c2.error(c2, {
            message: "Could not compress record.",
            send: false,
            alert: {
              level: tls.Alert.Level.fatal,
              description: tls.Alert.Description.internal_error
            }
          });
        } else if (!state.write.cipherFunction(record, state.write)) {
          c2.error(c2, {
            message: "Could not encrypt record.",
            send: false,
            alert: {
              level: tls.Alert.Level.fatal,
              description: tls.Alert.Description.internal_error
            }
          });
        }
        return !c2.fail;
      };
      if (c.session) {
        var sp = c.session.sp;
        c.session.cipherSuite.initSecurityParameters(sp);
        sp.keys = tls.generateKeys(c, sp);
        state.read.macKey = client ? sp.keys.server_write_MAC_key : sp.keys.client_write_MAC_key;
        state.write.macKey = client ? sp.keys.client_write_MAC_key : sp.keys.server_write_MAC_key;
        c.session.cipherSuite.initConnectionState(state, c, sp);
        switch (sp.compression_algorithm) {
          case tls.CompressionMethod.none:
            break;
          case tls.CompressionMethod.deflate:
            state.read.compressFunction = inflate;
            state.write.compressFunction = deflate;
            break;
          default:
            throw new Error("Unsupported compression algorithm.");
        }
      }
      return state;
    };
    tls.createRandom = function() {
      var d = /* @__PURE__ */ new Date();
      var utc = +d + d.getTimezoneOffset() * 6e4;
      var rval = forge2.util.createBuffer();
      rval.putInt32(utc);
      rval.putBytes(forge2.random.getBytes(28));
      return rval;
    };
    tls.createRecord = function(c, options) {
      if (!options.data) {
        return null;
      }
      var record = {
        type: options.type,
        version: {
          major: c.version.major,
          minor: c.version.minor
        },
        length: options.data.length(),
        fragment: options.data
      };
      return record;
    };
    tls.createAlert = function(c, alert) {
      var b = forge2.util.createBuffer();
      b.putByte(alert.level);
      b.putByte(alert.description);
      return tls.createRecord(c, {
        type: tls.ContentType.alert,
        data: b
      });
    };
    tls.createClientHello = function(c) {
      c.session.clientHelloVersion = {
        major: c.version.major,
        minor: c.version.minor
      };
      var cipherSuites = forge2.util.createBuffer();
      for (var i = 0; i < c.cipherSuites.length; ++i) {
        var cs = c.cipherSuites[i];
        cipherSuites.putByte(cs.id[0]);
        cipherSuites.putByte(cs.id[1]);
      }
      var cSuites = cipherSuites.length();
      var compressionMethods = forge2.util.createBuffer();
      compressionMethods.putByte(tls.CompressionMethod.none);
      var cMethods = compressionMethods.length();
      var extensions = forge2.util.createBuffer();
      if (c.virtualHost) {
        var ext = forge2.util.createBuffer();
        ext.putByte(0);
        ext.putByte(0);
        var serverName = forge2.util.createBuffer();
        serverName.putByte(0);
        writeVector(serverName, 2, forge2.util.createBuffer(c.virtualHost));
        var snList = forge2.util.createBuffer();
        writeVector(snList, 2, serverName);
        writeVector(ext, 2, snList);
        extensions.putBuffer(ext);
      }
      var extLength = extensions.length();
      if (extLength > 0) {
        extLength += 2;
      }
      var sessionId = c.session.id;
      var length2 = sessionId.length + 1 + // session ID vector
      2 + // version (major + minor)
      4 + 28 + // random time and random bytes
      2 + cSuites + // cipher suites vector
      1 + cMethods + // compression methods vector
      extLength;
      var rval = forge2.util.createBuffer();
      rval.putByte(tls.HandshakeType.client_hello);
      rval.putInt24(length2);
      rval.putByte(c.version.major);
      rval.putByte(c.version.minor);
      rval.putBytes(c.session.sp.client_random);
      writeVector(rval, 1, forge2.util.createBuffer(sessionId));
      writeVector(rval, 2, cipherSuites);
      writeVector(rval, 1, compressionMethods);
      if (extLength > 0) {
        writeVector(rval, 2, extensions);
      }
      return rval;
    };
    tls.createServerHello = function(c) {
      var sessionId = c.session.id;
      var length2 = sessionId.length + 1 + // session ID vector
      2 + // version (major + minor)
      4 + 28 + // random time and random bytes
      2 + // chosen cipher suite
      1;
      var rval = forge2.util.createBuffer();
      rval.putByte(tls.HandshakeType.server_hello);
      rval.putInt24(length2);
      rval.putByte(c.version.major);
      rval.putByte(c.version.minor);
      rval.putBytes(c.session.sp.server_random);
      writeVector(rval, 1, forge2.util.createBuffer(sessionId));
      rval.putByte(c.session.cipherSuite.id[0]);
      rval.putByte(c.session.cipherSuite.id[1]);
      rval.putByte(c.session.compressionMethod);
      return rval;
    };
    tls.createCertificate = function(c) {
      var client = c.entity === tls.ConnectionEnd.client;
      var cert = null;
      if (c.getCertificate) {
        var hint;
        if (client) {
          hint = c.session.certificateRequest;
        } else {
          hint = c.session.extensions.server_name.serverNameList;
        }
        cert = c.getCertificate(c, hint);
      }
      var certList = forge2.util.createBuffer();
      if (cert !== null) {
        try {
          if (!forge2.util.isArray(cert)) {
            cert = [cert];
          }
          var asn1 = null;
          for (var i = 0; i < cert.length; ++i) {
            var msg = forge2.pem.decode(cert[i])[0];
            if (msg.type !== "CERTIFICATE" && msg.type !== "X509 CERTIFICATE" && msg.type !== "TRUSTED CERTIFICATE") {
              var error = new Error('Could not convert certificate from PEM; PEM header type is not "CERTIFICATE", "X509 CERTIFICATE", or "TRUSTED CERTIFICATE".');
              error.headerType = msg.type;
              throw error;
            }
            if (msg.procType && msg.procType.type === "ENCRYPTED") {
              throw new Error("Could not convert certificate from PEM; PEM is encrypted.");
            }
            var der = forge2.util.createBuffer(msg.body);
            if (asn1 === null) {
              asn1 = forge2.asn1.fromDer(der.bytes(), false);
            }
            var certBuffer = forge2.util.createBuffer();
            writeVector(certBuffer, 3, der);
            certList.putBuffer(certBuffer);
          }
          cert = forge2.pki.certificateFromAsn1(asn1);
          if (client) {
            c.session.clientCertificate = cert;
          } else {
            c.session.serverCertificate = cert;
          }
        } catch (ex) {
          return c.error(c, {
            message: "Could not send certificate list.",
            cause: ex,
            send: true,
            alert: {
              level: tls.Alert.Level.fatal,
              description: tls.Alert.Description.bad_certificate
            }
          });
        }
      }
      var length2 = 3 + certList.length();
      var rval = forge2.util.createBuffer();
      rval.putByte(tls.HandshakeType.certificate);
      rval.putInt24(length2);
      writeVector(rval, 3, certList);
      return rval;
    };
    tls.createClientKeyExchange = function(c) {
      var b = forge2.util.createBuffer();
      b.putByte(c.session.clientHelloVersion.major);
      b.putByte(c.session.clientHelloVersion.minor);
      b.putBytes(forge2.random.getBytes(46));
      var sp = c.session.sp;
      sp.pre_master_secret = b.getBytes();
      var key3 = c.session.serverCertificate.publicKey;
      b = key3.encrypt(sp.pre_master_secret);
      var length2 = b.length + 2;
      var rval = forge2.util.createBuffer();
      rval.putByte(tls.HandshakeType.client_key_exchange);
      rval.putInt24(length2);
      rval.putInt16(b.length);
      rval.putBytes(b);
      return rval;
    };
    tls.createServerKeyExchange = function(c) {
      var length2 = 0;
      var rval = forge2.util.createBuffer();
      if (length2 > 0) {
        rval.putByte(tls.HandshakeType.server_key_exchange);
        rval.putInt24(length2);
      }
      return rval;
    };
    tls.getClientSignature = function(c, callback) {
      var b = forge2.util.createBuffer();
      b.putBuffer(c.session.md5.digest());
      b.putBuffer(c.session.sha1.digest());
      b = b.getBytes();
      c.getSignature = c.getSignature || function(c2, b2, callback2) {
        var privateKey = null;
        if (c2.getPrivateKey) {
          try {
            privateKey = c2.getPrivateKey(c2, c2.session.clientCertificate);
            privateKey = forge2.pki.privateKeyFromPem(privateKey);
          } catch (ex) {
            c2.error(c2, {
              message: "Could not get private key.",
              cause: ex,
              send: true,
              alert: {
                level: tls.Alert.Level.fatal,
                description: tls.Alert.Description.internal_error
              }
            });
          }
        }
        if (privateKey === null) {
          c2.error(c2, {
            message: "No private key set.",
            send: true,
            alert: {
              level: tls.Alert.Level.fatal,
              description: tls.Alert.Description.internal_error
            }
          });
        } else {
          b2 = privateKey.sign(b2, null);
        }
        callback2(c2, b2);
      };
      c.getSignature(c, b, callback);
    };
    tls.createCertificateVerify = function(c, signature) {
      var length2 = signature.length + 2;
      var rval = forge2.util.createBuffer();
      rval.putByte(tls.HandshakeType.certificate_verify);
      rval.putInt24(length2);
      rval.putInt16(signature.length);
      rval.putBytes(signature);
      return rval;
    };
    tls.createCertificateRequest = function(c) {
      var certTypes = forge2.util.createBuffer();
      certTypes.putByte(1);
      var cAs = forge2.util.createBuffer();
      for (var key3 in c.caStore.certs) {
        var cert = c.caStore.certs[key3];
        var dn = forge2.pki.distinguishedNameToAsn1(cert.subject);
        var byteBuffer = forge2.asn1.toDer(dn);
        cAs.putInt16(byteBuffer.length());
        cAs.putBuffer(byteBuffer);
      }
      var length2 = 1 + certTypes.length() + 2 + cAs.length();
      var rval = forge2.util.createBuffer();
      rval.putByte(tls.HandshakeType.certificate_request);
      rval.putInt24(length2);
      writeVector(rval, 1, certTypes);
      writeVector(rval, 2, cAs);
      return rval;
    };
    tls.createServerHelloDone = function(c) {
      var rval = forge2.util.createBuffer();
      rval.putByte(tls.HandshakeType.server_hello_done);
      rval.putInt24(0);
      return rval;
    };
    tls.createChangeCipherSpec = function() {
      var rval = forge2.util.createBuffer();
      rval.putByte(1);
      return rval;
    };
    tls.createFinished = function(c) {
      var b = forge2.util.createBuffer();
      b.putBuffer(c.session.md5.digest());
      b.putBuffer(c.session.sha1.digest());
      var client = c.entity === tls.ConnectionEnd.client;
      var sp = c.session.sp;
      var vdl = 12;
      var prf = prf_TLS1;
      var label = client ? "client finished" : "server finished";
      b = prf(sp.master_secret, label, b.getBytes(), vdl);
      var rval = forge2.util.createBuffer();
      rval.putByte(tls.HandshakeType.finished);
      rval.putInt24(b.length());
      rval.putBuffer(b);
      return rval;
    };
    tls.createHeartbeat = function(type, payload, payloadLength) {
      if (typeof payloadLength === "undefined") {
        payloadLength = payload.length;
      }
      var rval = forge2.util.createBuffer();
      rval.putByte(type);
      rval.putInt16(payloadLength);
      rval.putBytes(payload);
      var plaintextLength = rval.length();
      var paddingLength = Math.max(16, plaintextLength - payloadLength - 3);
      rval.putBytes(forge2.random.getBytes(paddingLength));
      return rval;
    };
    tls.queue = function(c, record) {
      if (!record) {
        return;
      }
      if (record.fragment.length() === 0) {
        if (record.type === tls.ContentType.handshake || record.type === tls.ContentType.alert || record.type === tls.ContentType.change_cipher_spec) {
          return;
        }
      }
      if (record.type === tls.ContentType.handshake) {
        var bytes = record.fragment.bytes();
        c.session.md5.update(bytes);
        c.session.sha1.update(bytes);
        bytes = null;
      }
      var records;
      if (record.fragment.length() <= tls.MaxFragment) {
        records = [record];
      } else {
        records = [];
        var data2 = record.fragment.bytes();
        while (data2.length > tls.MaxFragment) {
          records.push(tls.createRecord(c, {
            type: record.type,
            data: forge2.util.createBuffer(data2.slice(0, tls.MaxFragment))
          }));
          data2 = data2.slice(tls.MaxFragment);
        }
        if (data2.length > 0) {
          records.push(tls.createRecord(c, {
            type: record.type,
            data: forge2.util.createBuffer(data2)
          }));
        }
      }
      for (var i = 0; i < records.length && !c.fail; ++i) {
        var rec = records[i];
        var s = c.state.current.write;
        if (s.update(c, rec)) {
          c.records.push(rec);
        }
      }
    };
    tls.flush = function(c) {
      for (var i = 0; i < c.records.length; ++i) {
        var record = c.records[i];
        c.tlsData.putByte(record.type);
        c.tlsData.putByte(record.version.major);
        c.tlsData.putByte(record.version.minor);
        c.tlsData.putInt16(record.fragment.length());
        c.tlsData.putBuffer(c.records[i].fragment);
      }
      c.records = [];
      return c.tlsDataReady(c);
    };
    var _certErrorToAlertDesc = function(error) {
      switch (error) {
        case true:
          return true;
        case forge2.pki.certificateError.bad_certificate:
          return tls.Alert.Description.bad_certificate;
        case forge2.pki.certificateError.unsupported_certificate:
          return tls.Alert.Description.unsupported_certificate;
        case forge2.pki.certificateError.certificate_revoked:
          return tls.Alert.Description.certificate_revoked;
        case forge2.pki.certificateError.certificate_expired:
          return tls.Alert.Description.certificate_expired;
        case forge2.pki.certificateError.certificate_unknown:
          return tls.Alert.Description.certificate_unknown;
        case forge2.pki.certificateError.unknown_ca:
          return tls.Alert.Description.unknown_ca;
        default:
          return tls.Alert.Description.bad_certificate;
      }
    };
    var _alertDescToCertError = function(desc) {
      switch (desc) {
        case true:
          return true;
        case tls.Alert.Description.bad_certificate:
          return forge2.pki.certificateError.bad_certificate;
        case tls.Alert.Description.unsupported_certificate:
          return forge2.pki.certificateError.unsupported_certificate;
        case tls.Alert.Description.certificate_revoked:
          return forge2.pki.certificateError.certificate_revoked;
        case tls.Alert.Description.certificate_expired:
          return forge2.pki.certificateError.certificate_expired;
        case tls.Alert.Description.certificate_unknown:
          return forge2.pki.certificateError.certificate_unknown;
        case tls.Alert.Description.unknown_ca:
          return forge2.pki.certificateError.unknown_ca;
        default:
          return forge2.pki.certificateError.bad_certificate;
      }
    };
    tls.verifyCertificateChain = function(c, chain) {
      try {
        var options = {};
        for (var key3 in c.verifyOptions) {
          options[key3] = c.verifyOptions[key3];
        }
        options.verify = function(vfd, depth, chain2) {
          var desc = _certErrorToAlertDesc(vfd);
          var ret = c.verify(c, vfd, depth, chain2);
          if (ret !== true) {
            if (typeof ret === "object" && !forge2.util.isArray(ret)) {
              var error = new Error("The application rejected the certificate.");
              error.send = true;
              error.alert = {
                level: tls.Alert.Level.fatal,
                description: tls.Alert.Description.bad_certificate
              };
              if (ret.message) {
                error.message = ret.message;
              }
              if (ret.alert) {
                error.alert.description = ret.alert;
              }
              throw error;
            }
            if (ret !== vfd) {
              ret = _alertDescToCertError(ret);
            }
          }
          return ret;
        };
        forge2.pki.verifyCertificateChain(c.caStore, chain, options);
      } catch (ex) {
        var err = ex;
        if (typeof err !== "object" || forge2.util.isArray(err)) {
          err = {
            send: true,
            alert: {
              level: tls.Alert.Level.fatal,
              description: _certErrorToAlertDesc(ex)
            }
          };
        }
        if (!("send" in err)) {
          err.send = true;
        }
        if (!("alert" in err)) {
          err.alert = {
            level: tls.Alert.Level.fatal,
            description: _certErrorToAlertDesc(err.error)
          };
        }
        c.error(c, err);
      }
      return !c.fail;
    };
    tls.createSessionCache = function(cache2, capacity) {
      var rval = null;
      if (cache2 && cache2.getSession && cache2.setSession && cache2.order) {
        rval = cache2;
      } else {
        rval = {};
        rval.cache = cache2 || {};
        rval.capacity = Math.max(capacity || 100, 1);
        rval.order = [];
        for (var key3 in cache2) {
          if (rval.order.length <= capacity) {
            rval.order.push(key3);
          } else {
            delete cache2[key3];
          }
        }
        rval.getSession = function(sessionId) {
          var session = null;
          var key4 = null;
          if (sessionId) {
            key4 = forge2.util.bytesToHex(sessionId);
          } else if (rval.order.length > 0) {
            key4 = rval.order[0];
          }
          if (key4 !== null && key4 in rval.cache) {
            session = rval.cache[key4];
            delete rval.cache[key4];
            for (var i in rval.order) {
              if (rval.order[i] === key4) {
                rval.order.splice(i, 1);
                break;
              }
            }
          }
          return session;
        };
        rval.setSession = function(sessionId, session) {
          if (rval.order.length === rval.capacity) {
            var key4 = rval.order.shift();
            delete rval.cache[key4];
          }
          var key4 = forge2.util.bytesToHex(sessionId);
          rval.order.push(key4);
          rval.cache[key4] = session;
        };
      }
      return rval;
    };
    tls.createConnection = function(options) {
      var caStore = null;
      if (options.caStore) {
        if (forge2.util.isArray(options.caStore)) {
          caStore = forge2.pki.createCaStore(options.caStore);
        } else {
          caStore = options.caStore;
        }
      } else {
        caStore = forge2.pki.createCaStore();
      }
      var cipherSuites = options.cipherSuites || null;
      if (cipherSuites === null) {
        cipherSuites = [];
        for (var key3 in tls.CipherSuites) {
          cipherSuites.push(tls.CipherSuites[key3]);
        }
      }
      var entity = options.server || false ? tls.ConnectionEnd.server : tls.ConnectionEnd.client;
      var sessionCache = options.sessionCache ? tls.createSessionCache(options.sessionCache) : null;
      var c = {
        version: { major: tls.Version.major, minor: tls.Version.minor },
        entity,
        sessionId: options.sessionId,
        caStore,
        sessionCache,
        cipherSuites,
        connected: options.connected,
        virtualHost: options.virtualHost || null,
        verifyClient: options.verifyClient || false,
        verify: options.verify || function(cn, vfd, dpth, cts) {
          return vfd;
        },
        verifyOptions: options.verifyOptions || {},
        getCertificate: options.getCertificate || null,
        getPrivateKey: options.getPrivateKey || null,
        getSignature: options.getSignature || null,
        input: forge2.util.createBuffer(),
        tlsData: forge2.util.createBuffer(),
        data: forge2.util.createBuffer(),
        tlsDataReady: options.tlsDataReady,
        dataReady: options.dataReady,
        heartbeatReceived: options.heartbeatReceived,
        closed: options.closed,
        error: function(c2, ex) {
          ex.origin = ex.origin || (c2.entity === tls.ConnectionEnd.client ? "client" : "server");
          if (ex.send) {
            tls.queue(c2, tls.createAlert(c2, ex.alert));
            tls.flush(c2);
          }
          var fatal = ex.fatal !== false;
          if (fatal) {
            c2.fail = true;
          }
          options.error(c2, ex);
          if (fatal) {
            c2.close(false);
          }
        },
        deflate: options.deflate || null,
        inflate: options.inflate || null
      };
      c.reset = function(clearFail) {
        c.version = { major: tls.Version.major, minor: tls.Version.minor };
        c.record = null;
        c.session = null;
        c.peerCertificate = null;
        c.state = {
          pending: null,
          current: null
        };
        c.expect = c.entity === tls.ConnectionEnd.client ? SHE : CHE;
        c.fragmented = null;
        c.records = [];
        c.open = false;
        c.handshakes = 0;
        c.handshaking = false;
        c.isConnected = false;
        c.fail = !(clearFail || typeof clearFail === "undefined");
        c.input.clear();
        c.tlsData.clear();
        c.data.clear();
        c.state.current = tls.createConnectionState(c);
      };
      c.reset();
      var _update = function(c2, record) {
        var aligned = record.type - tls.ContentType.change_cipher_spec;
        var handlers = ctTable[c2.entity][c2.expect];
        if (aligned in handlers) {
          handlers[aligned](c2, record);
        } else {
          tls.handleUnexpected(c2, record);
        }
      };
      var _readRecordHeader = function(c2) {
        var rval = 0;
        var b = c2.input;
        var len = b.length();
        if (len < 5) {
          rval = 5 - len;
        } else {
          c2.record = {
            type: b.getByte(),
            version: {
              major: b.getByte(),
              minor: b.getByte()
            },
            length: b.getInt16(),
            fragment: forge2.util.createBuffer(),
            ready: false
          };
          var compatibleVersion = c2.record.version.major === c2.version.major;
          if (compatibleVersion && c2.session && c2.session.version) {
            compatibleVersion = c2.record.version.minor === c2.version.minor;
          }
          if (!compatibleVersion) {
            c2.error(c2, {
              message: "Incompatible TLS version.",
              send: true,
              alert: {
                level: tls.Alert.Level.fatal,
                description: tls.Alert.Description.protocol_version
              }
            });
          }
        }
        return rval;
      };
      var _readRecord = function(c2) {
        var rval = 0;
        var b = c2.input;
        var len = b.length();
        if (len < c2.record.length) {
          rval = c2.record.length - len;
        } else {
          c2.record.fragment.putBytes(b.getBytes(c2.record.length));
          b.compact();
          var s = c2.state.current.read;
          if (s.update(c2, c2.record)) {
            if (c2.fragmented !== null) {
              if (c2.fragmented.type === c2.record.type) {
                c2.fragmented.fragment.putBuffer(c2.record.fragment);
                c2.record = c2.fragmented;
              } else {
                c2.error(c2, {
                  message: "Invalid fragmented record.",
                  send: true,
                  alert: {
                    level: tls.Alert.Level.fatal,
                    description: tls.Alert.Description.unexpected_message
                  }
                });
              }
            }
            c2.record.ready = true;
          }
        }
        return rval;
      };
      c.handshake = function(sessionId) {
        if (c.entity !== tls.ConnectionEnd.client) {
          c.error(c, {
            message: "Cannot initiate handshake as a server.",
            fatal: false
          });
        } else if (c.handshaking) {
          c.error(c, {
            message: "Handshake already in progress.",
            fatal: false
          });
        } else {
          if (c.fail && !c.open && c.handshakes === 0) {
            c.fail = false;
          }
          c.handshaking = true;
          sessionId = sessionId || "";
          var session = null;
          if (sessionId.length > 0) {
            if (c.sessionCache) {
              session = c.sessionCache.getSession(sessionId);
            }
            if (session === null) {
              sessionId = "";
            }
          }
          if (sessionId.length === 0 && c.sessionCache) {
            session = c.sessionCache.getSession();
            if (session !== null) {
              sessionId = session.id;
            }
          }
          c.session = {
            id: sessionId,
            version: null,
            cipherSuite: null,
            compressionMethod: null,
            serverCertificate: null,
            certificateRequest: null,
            clientCertificate: null,
            sp: {},
            md5: forge2.md.md5.create(),
            sha1: forge2.md.sha1.create()
          };
          if (session) {
            c.version = session.version;
            c.session.sp = session.sp;
          }
          c.session.sp.client_random = tls.createRandom().getBytes();
          c.open = true;
          tls.queue(c, tls.createRecord(c, {
            type: tls.ContentType.handshake,
            data: tls.createClientHello(c)
          }));
          tls.flush(c);
        }
      };
      c.process = function(data2) {
        var rval = 0;
        if (data2) {
          c.input.putBytes(data2);
        }
        if (!c.fail) {
          if (c.record !== null && c.record.ready && c.record.fragment.isEmpty()) {
            c.record = null;
          }
          if (c.record === null) {
            rval = _readRecordHeader(c);
          }
          if (!c.fail && c.record !== null && !c.record.ready) {
            rval = _readRecord(c);
          }
          if (!c.fail && c.record !== null && c.record.ready) {
            _update(c, c.record);
          }
        }
        return rval;
      };
      c.prepare = function(data2) {
        tls.queue(c, tls.createRecord(c, {
          type: tls.ContentType.application_data,
          data: forge2.util.createBuffer(data2)
        }));
        return tls.flush(c);
      };
      c.prepareHeartbeatRequest = function(payload, payloadLength) {
        if (payload instanceof forge2.util.ByteBuffer) {
          payload = payload.bytes();
        }
        if (typeof payloadLength === "undefined") {
          payloadLength = payload.length;
        }
        c.expectedHeartbeatPayload = payload;
        tls.queue(c, tls.createRecord(c, {
          type: tls.ContentType.heartbeat,
          data: tls.createHeartbeat(
            tls.HeartbeatMessageType.heartbeat_request,
            payload,
            payloadLength
          )
        }));
        return tls.flush(c);
      };
      c.close = function(clearFail) {
        if (!c.fail && c.sessionCache && c.session) {
          var session = {
            id: c.session.id,
            version: c.session.version,
            sp: c.session.sp
          };
          session.sp.keys = null;
          c.sessionCache.setSession(session.id, session);
        }
        if (c.open) {
          c.open = false;
          c.input.clear();
          if (c.isConnected || c.handshaking) {
            c.isConnected = c.handshaking = false;
            tls.queue(c, tls.createAlert(c, {
              level: tls.Alert.Level.warning,
              description: tls.Alert.Description.close_notify
            }));
            tls.flush(c);
          }
          c.closed(c);
        }
        c.reset(clearFail);
      };
      return c;
    };
    module2.exports = forge2.tls = forge2.tls || {};
    for (key2 in tls) {
      if (typeof tls[key2] !== "function") {
        forge2.tls[key2] = tls[key2];
      }
    }
    var key2;
    forge2.tls.prf_tls1 = prf_TLS1;
    forge2.tls.hmac_sha1 = hmac_sha1;
    forge2.tls.createSessionCache = tls.createSessionCache;
    forge2.tls.createConnection = tls.createConnection;
  }
});

// node_modules/@selfxyz/common/node_modules/node-forge/lib/aesCipherSuites.js
var require_aesCipherSuites = __commonJS({
  "node_modules/@selfxyz/common/node_modules/node-forge/lib/aesCipherSuites.js"(exports2, module2) {
    var forge2 = require_forge();
    require_aes();
    require_tls();
    var tls = module2.exports = forge2.tls;
    tls.CipherSuites["TLS_RSA_WITH_AES_128_CBC_SHA"] = {
      id: [0, 47],
      name: "TLS_RSA_WITH_AES_128_CBC_SHA",
      initSecurityParameters: function(sp) {
        sp.bulk_cipher_algorithm = tls.BulkCipherAlgorithm.aes;
        sp.cipher_type = tls.CipherType.block;
        sp.enc_key_length = 16;
        sp.block_length = 16;
        sp.fixed_iv_length = 16;
        sp.record_iv_length = 16;
        sp.mac_algorithm = tls.MACAlgorithm.hmac_sha1;
        sp.mac_length = 20;
        sp.mac_key_length = 20;
      },
      initConnectionState
    };
    tls.CipherSuites["TLS_RSA_WITH_AES_256_CBC_SHA"] = {
      id: [0, 53],
      name: "TLS_RSA_WITH_AES_256_CBC_SHA",
      initSecurityParameters: function(sp) {
        sp.bulk_cipher_algorithm = tls.BulkCipherAlgorithm.aes;
        sp.cipher_type = tls.CipherType.block;
        sp.enc_key_length = 32;
        sp.block_length = 16;
        sp.fixed_iv_length = 16;
        sp.record_iv_length = 16;
        sp.mac_algorithm = tls.MACAlgorithm.hmac_sha1;
        sp.mac_length = 20;
        sp.mac_key_length = 20;
      },
      initConnectionState
    };
    function initConnectionState(state, c, sp) {
      var client = c.entity === forge2.tls.ConnectionEnd.client;
      state.read.cipherState = {
        init: false,
        cipher: forge2.cipher.createDecipher("AES-CBC", client ? sp.keys.server_write_key : sp.keys.client_write_key),
        iv: client ? sp.keys.server_write_IV : sp.keys.client_write_IV
      };
      state.write.cipherState = {
        init: false,
        cipher: forge2.cipher.createCipher("AES-CBC", client ? sp.keys.client_write_key : sp.keys.server_write_key),
        iv: client ? sp.keys.client_write_IV : sp.keys.server_write_IV
      };
      state.read.cipherFunction = decrypt_aes_cbc_sha1;
      state.write.cipherFunction = encrypt_aes_cbc_sha1;
      state.read.macLength = state.write.macLength = sp.mac_length;
      state.read.macFunction = state.write.macFunction = tls.hmac_sha1;
    }
    function encrypt_aes_cbc_sha1(record, s) {
      var rval = false;
      var mac = s.macFunction(s.macKey, s.sequenceNumber, record);
      record.fragment.putBytes(mac);
      s.updateSequenceNumber();
      var iv;
      if (record.version.minor === tls.Versions.TLS_1_0.minor) {
        iv = s.cipherState.init ? null : s.cipherState.iv;
      } else {
        iv = forge2.random.getBytesSync(16);
      }
      s.cipherState.init = true;
      var cipher = s.cipherState.cipher;
      cipher.start({ iv });
      if (record.version.minor >= tls.Versions.TLS_1_1.minor) {
        cipher.output.putBytes(iv);
      }
      cipher.update(record.fragment);
      if (cipher.finish(encrypt_aes_cbc_sha1_padding)) {
        record.fragment = cipher.output;
        record.length = record.fragment.length();
        rval = true;
      }
      return rval;
    }
    function encrypt_aes_cbc_sha1_padding(blockSize, input, decrypt) {
      if (!decrypt) {
        var padding = blockSize - input.length() % blockSize;
        input.fillWithByte(padding - 1, padding);
      }
      return true;
    }
    function decrypt_aes_cbc_sha1_padding(blockSize, output, decrypt) {
      var rval = true;
      if (decrypt) {
        var len = output.length();
        var paddingLength = output.last();
        for (var i = len - 1 - paddingLength; i < len - 1; ++i) {
          rval = rval && output.at(i) == paddingLength;
        }
        if (rval) {
          output.truncate(paddingLength + 1);
        }
      }
      return rval;
    }
    function decrypt_aes_cbc_sha1(record, s) {
      var rval = false;
      var iv;
      if (record.version.minor === tls.Versions.TLS_1_0.minor) {
        iv = s.cipherState.init ? null : s.cipherState.iv;
      } else {
        iv = record.fragment.getBytes(16);
      }
      s.cipherState.init = true;
      var cipher = s.cipherState.cipher;
      cipher.start({ iv });
      cipher.update(record.fragment);
      rval = cipher.finish(decrypt_aes_cbc_sha1_padding);
      var macLen = s.macLength;
      var mac = forge2.random.getBytesSync(macLen);
      var len = cipher.output.length();
      if (len >= macLen) {
        record.fragment = cipher.output.getBytes(len - macLen);
        mac = cipher.output.getBytes(macLen);
      } else {
        record.fragment = cipher.output.getBytes();
      }
      record.fragment = forge2.util.createBuffer(record.fragment);
      record.length = record.fragment.length();
      var mac2 = s.macFunction(s.macKey, s.sequenceNumber, record);
      s.updateSequenceNumber();
      rval = compareMacs(s.macKey, mac, mac2) && rval;
      return rval;
    }
    function compareMacs(key2, mac1, mac2) {
      var hmac = forge2.hmac.create();
      hmac.start("SHA1", key2);
      hmac.update(mac1);
      mac1 = hmac.digest().getBytes();
      hmac.start(null, null);
      hmac.update(mac2);
      mac2 = hmac.digest().getBytes();
      return mac1 === mac2;
    }
  }
});

// node_modules/@selfxyz/common/node_modules/node-forge/lib/sha512.js
var require_sha5122 = __commonJS({
  "node_modules/@selfxyz/common/node_modules/node-forge/lib/sha512.js"(exports2, module2) {
    var forge2 = require_forge();
    require_md();
    require_util();
    var sha5122 = module2.exports = forge2.sha512 = forge2.sha512 || {};
    forge2.md.sha512 = forge2.md.algorithms.sha512 = sha5122;
    var sha3842 = forge2.sha384 = forge2.sha512.sha384 = forge2.sha512.sha384 || {};
    sha3842.create = function() {
      return sha5122.create("SHA-384");
    };
    forge2.md.sha384 = forge2.md.algorithms.sha384 = sha3842;
    forge2.sha512.sha256 = forge2.sha512.sha256 || {
      create: function() {
        return sha5122.create("SHA-512/256");
      }
    };
    forge2.md["sha512/256"] = forge2.md.algorithms["sha512/256"] = forge2.sha512.sha256;
    forge2.sha512.sha224 = forge2.sha512.sha224 || {
      create: function() {
        return sha5122.create("SHA-512/224");
      }
    };
    forge2.md["sha512/224"] = forge2.md.algorithms["sha512/224"] = forge2.sha512.sha224;
    sha5122.create = function(algorithm) {
      if (!_initialized) {
        _init();
      }
      if (typeof algorithm === "undefined") {
        algorithm = "SHA-512";
      }
      if (!(algorithm in _states)) {
        throw new Error("Invalid SHA-512 algorithm: " + algorithm);
      }
      var _state = _states[algorithm];
      var _h = null;
      var _input = forge2.util.createBuffer();
      var _w = new Array(80);
      for (var wi = 0; wi < 80; ++wi) {
        _w[wi] = new Array(2);
      }
      var digestLength = 64;
      switch (algorithm) {
        case "SHA-384":
          digestLength = 48;
          break;
        case "SHA-512/256":
          digestLength = 32;
          break;
        case "SHA-512/224":
          digestLength = 28;
          break;
      }
      var md = {
        // SHA-512 => sha512
        algorithm: algorithm.replace("-", "").toLowerCase(),
        blockLength: 128,
        digestLength,
        // 56-bit length of message so far (does not including padding)
        messageLength: 0,
        // true message length
        fullMessageLength: null,
        // size of message length in bytes
        messageLengthSize: 16
      };
      md.start = function() {
        md.messageLength = 0;
        md.fullMessageLength = md.messageLength128 = [];
        var int32s = md.messageLengthSize / 4;
        for (var i = 0; i < int32s; ++i) {
          md.fullMessageLength.push(0);
        }
        _input = forge2.util.createBuffer();
        _h = new Array(_state.length);
        for (var i = 0; i < _state.length; ++i) {
          _h[i] = _state[i].slice(0);
        }
        return md;
      };
      md.start();
      md.update = function(msg, encoding) {
        if (encoding === "utf8") {
          msg = forge2.util.encodeUtf8(msg);
        }
        var len = msg.length;
        md.messageLength += len;
        len = [len / 4294967296 >>> 0, len >>> 0];
        for (var i = md.fullMessageLength.length - 1; i >= 0; --i) {
          md.fullMessageLength[i] += len[1];
          len[1] = len[0] + (md.fullMessageLength[i] / 4294967296 >>> 0);
          md.fullMessageLength[i] = md.fullMessageLength[i] >>> 0;
          len[0] = len[1] / 4294967296 >>> 0;
        }
        _input.putBytes(msg);
        _update(_h, _w, _input);
        if (_input.read > 2048 || _input.length() === 0) {
          _input.compact();
        }
        return md;
      };
      md.digest = function() {
        var finalBlock = forge2.util.createBuffer();
        finalBlock.putBytes(_input.bytes());
        var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize;
        var overflow = remaining & md.blockLength - 1;
        finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));
        var next, carry;
        var bits = md.fullMessageLength[0] * 8;
        for (var i = 0; i < md.fullMessageLength.length - 1; ++i) {
          next = md.fullMessageLength[i + 1] * 8;
          carry = next / 4294967296 >>> 0;
          bits += carry;
          finalBlock.putInt32(bits >>> 0);
          bits = next >>> 0;
        }
        finalBlock.putInt32(bits);
        var h = new Array(_h.length);
        for (var i = 0; i < _h.length; ++i) {
          h[i] = _h[i].slice(0);
        }
        _update(h, _w, finalBlock);
        var rval = forge2.util.createBuffer();
        var hlen;
        if (algorithm === "SHA-512") {
          hlen = h.length;
        } else if (algorithm === "SHA-384") {
          hlen = h.length - 2;
        } else {
          hlen = h.length - 4;
        }
        for (var i = 0; i < hlen; ++i) {
          rval.putInt32(h[i][0]);
          if (i !== hlen - 1 || algorithm !== "SHA-512/224") {
            rval.putInt32(h[i][1]);
          }
        }
        return rval;
      };
      return md;
    };
    var _padding = null;
    var _initialized = false;
    var _k = null;
    var _states = null;
    function _init() {
      _padding = String.fromCharCode(128);
      _padding += forge2.util.fillString(String.fromCharCode(0), 128);
      _k = [
        [1116352408, 3609767458],
        [1899447441, 602891725],
        [3049323471, 3964484399],
        [3921009573, 2173295548],
        [961987163, 4081628472],
        [1508970993, 3053834265],
        [2453635748, 2937671579],
        [2870763221, 3664609560],
        [3624381080, 2734883394],
        [310598401, 1164996542],
        [607225278, 1323610764],
        [1426881987, 3590304994],
        [1925078388, 4068182383],
        [2162078206, 991336113],
        [2614888103, 633803317],
        [3248222580, 3479774868],
        [3835390401, 2666613458],
        [4022224774, 944711139],
        [264347078, 2341262773],
        [604807628, 2007800933],
        [770255983, 1495990901],
        [1249150122, 1856431235],
        [1555081692, 3175218132],
        [1996064986, 2198950837],
        [2554220882, 3999719339],
        [2821834349, 766784016],
        [2952996808, 2566594879],
        [3210313671, 3203337956],
        [3336571891, 1034457026],
        [3584528711, 2466948901],
        [113926993, 3758326383],
        [338241895, 168717936],
        [666307205, 1188179964],
        [773529912, 1546045734],
        [1294757372, 1522805485],
        [1396182291, 2643833823],
        [1695183700, 2343527390],
        [1986661051, 1014477480],
        [2177026350, 1206759142],
        [2456956037, 344077627],
        [2730485921, 1290863460],
        [2820302411, 3158454273],
        [3259730800, 3505952657],
        [3345764771, 106217008],
        [3516065817, 3606008344],
        [3600352804, 1432725776],
        [4094571909, 1467031594],
        [275423344, 851169720],
        [430227734, 3100823752],
        [506948616, 1363258195],
        [659060556, 3750685593],
        [883997877, 3785050280],
        [958139571, 3318307427],
        [1322822218, 3812723403],
        [1537002063, 2003034995],
        [1747873779, 3602036899],
        [1955562222, 1575990012],
        [2024104815, 1125592928],
        [2227730452, 2716904306],
        [2361852424, 442776044],
        [2428436474, 593698344],
        [2756734187, 3733110249],
        [3204031479, 2999351573],
        [3329325298, 3815920427],
        [3391569614, 3928383900],
        [3515267271, 566280711],
        [3940187606, 3454069534],
        [4118630271, 4000239992],
        [116418474, 1914138554],
        [174292421, 2731055270],
        [289380356, 3203993006],
        [460393269, 320620315],
        [685471733, 587496836],
        [852142971, 1086792851],
        [1017036298, 365543100],
        [1126000580, 2618297676],
        [1288033470, 3409855158],
        [1501505948, 4234509866],
        [1607167915, 987167468],
        [1816402316, 1246189591]
      ];
      _states = {};
      _states["SHA-512"] = [
        [1779033703, 4089235720],
        [3144134277, 2227873595],
        [1013904242, 4271175723],
        [2773480762, 1595750129],
        [1359893119, 2917565137],
        [2600822924, 725511199],
        [528734635, 4215389547],
        [1541459225, 327033209]
      ];
      _states["SHA-384"] = [
        [3418070365, 3238371032],
        [1654270250, 914150663],
        [2438529370, 812702999],
        [355462360, 4144912697],
        [1731405415, 4290775857],
        [2394180231, 1750603025],
        [3675008525, 1694076839],
        [1203062813, 3204075428]
      ];
      _states["SHA-512/256"] = [
        [573645204, 4230739756],
        [2673172387, 3360449730],
        [596883563, 1867755857],
        [2520282905, 1497426621],
        [2519219938, 2827943907],
        [3193839141, 1401305490],
        [721525244, 746961066],
        [246885852, 2177182882]
      ];
      _states["SHA-512/224"] = [
        [2352822216, 424955298],
        [1944164710, 2312950998],
        [502970286, 855612546],
        [1738396948, 1479516111],
        [258812777, 2077511080],
        [2011393907, 79989058],
        [1067287976, 1780299464],
        [286451373, 2446758561]
      ];
      _initialized = true;
    }
    function _update(s, w, bytes) {
      var t1_hi, t1_lo;
      var t2_hi, t2_lo;
      var s0_hi, s0_lo;
      var s1_hi, s1_lo;
      var ch_hi, ch_lo;
      var maj_hi, maj_lo;
      var a_hi, a_lo;
      var b_hi, b_lo;
      var c_hi, c_lo;
      var d_hi, d_lo;
      var e_hi, e_lo;
      var f_hi, f_lo;
      var g_hi, g_lo;
      var h_hi, h_lo;
      var i, hi, lo, w2, w7, w15, w16;
      var len = bytes.length();
      while (len >= 128) {
        for (i = 0; i < 16; ++i) {
          w[i][0] = bytes.getInt32() >>> 0;
          w[i][1] = bytes.getInt32() >>> 0;
        }
        for (; i < 80; ++i) {
          w2 = w[i - 2];
          hi = w2[0];
          lo = w2[1];
          t1_hi = ((hi >>> 19 | lo << 13) ^ // ROTR 19
          (lo >>> 29 | hi << 3) ^ // ROTR 61/(swap + ROTR 29)
          hi >>> 6) >>> 0;
          t1_lo = ((hi << 13 | lo >>> 19) ^ // ROTR 19
          (lo << 3 | hi >>> 29) ^ // ROTR 61/(swap + ROTR 29)
          (hi << 26 | lo >>> 6)) >>> 0;
          w15 = w[i - 15];
          hi = w15[0];
          lo = w15[1];
          t2_hi = ((hi >>> 1 | lo << 31) ^ // ROTR 1
          (hi >>> 8 | lo << 24) ^ // ROTR 8
          hi >>> 7) >>> 0;
          t2_lo = ((hi << 31 | lo >>> 1) ^ // ROTR 1
          (hi << 24 | lo >>> 8) ^ // ROTR 8
          (hi << 25 | lo >>> 7)) >>> 0;
          w7 = w[i - 7];
          w16 = w[i - 16];
          lo = t1_lo + w7[1] + t2_lo + w16[1];
          w[i][0] = t1_hi + w7[0] + t2_hi + w16[0] + (lo / 4294967296 >>> 0) >>> 0;
          w[i][1] = lo >>> 0;
        }
        a_hi = s[0][0];
        a_lo = s[0][1];
        b_hi = s[1][0];
        b_lo = s[1][1];
        c_hi = s[2][0];
        c_lo = s[2][1];
        d_hi = s[3][0];
        d_lo = s[3][1];
        e_hi = s[4][0];
        e_lo = s[4][1];
        f_hi = s[5][0];
        f_lo = s[5][1];
        g_hi = s[6][0];
        g_lo = s[6][1];
        h_hi = s[7][0];
        h_lo = s[7][1];
        for (i = 0; i < 80; ++i) {
          s1_hi = ((e_hi >>> 14 | e_lo << 18) ^ // ROTR 14
          (e_hi >>> 18 | e_lo << 14) ^ // ROTR 18
          (e_lo >>> 9 | e_hi << 23)) >>> 0;
          s1_lo = ((e_hi << 18 | e_lo >>> 14) ^ // ROTR 14
          (e_hi << 14 | e_lo >>> 18) ^ // ROTR 18
          (e_lo << 23 | e_hi >>> 9)) >>> 0;
          ch_hi = (g_hi ^ e_hi & (f_hi ^ g_hi)) >>> 0;
          ch_lo = (g_lo ^ e_lo & (f_lo ^ g_lo)) >>> 0;
          s0_hi = ((a_hi >>> 28 | a_lo << 4) ^ // ROTR 28
          (a_lo >>> 2 | a_hi << 30) ^ // ROTR 34/(swap + ROTR 2)
          (a_lo >>> 7 | a_hi << 25)) >>> 0;
          s0_lo = ((a_hi << 4 | a_lo >>> 28) ^ // ROTR 28
          (a_lo << 30 | a_hi >>> 2) ^ // ROTR 34/(swap + ROTR 2)
          (a_lo << 25 | a_hi >>> 7)) >>> 0;
          maj_hi = (a_hi & b_hi | c_hi & (a_hi ^ b_hi)) >>> 0;
          maj_lo = (a_lo & b_lo | c_lo & (a_lo ^ b_lo)) >>> 0;
          lo = h_lo + s1_lo + ch_lo + _k[i][1] + w[i][1];
          t1_hi = h_hi + s1_hi + ch_hi + _k[i][0] + w[i][0] + (lo / 4294967296 >>> 0) >>> 0;
          t1_lo = lo >>> 0;
          lo = s0_lo + maj_lo;
          t2_hi = s0_hi + maj_hi + (lo / 4294967296 >>> 0) >>> 0;
          t2_lo = lo >>> 0;
          h_hi = g_hi;
          h_lo = g_lo;
          g_hi = f_hi;
          g_lo = f_lo;
          f_hi = e_hi;
          f_lo = e_lo;
          lo = d_lo + t1_lo;
          e_hi = d_hi + t1_hi + (lo / 4294967296 >>> 0) >>> 0;
          e_lo = lo >>> 0;
          d_hi = c_hi;
          d_lo = c_lo;
          c_hi = b_hi;
          c_lo = b_lo;
          b_hi = a_hi;
          b_lo = a_lo;
          lo = t1_lo + t2_lo;
          a_hi = t1_hi + t2_hi + (lo / 4294967296 >>> 0) >>> 0;
          a_lo = lo >>> 0;
        }
        lo = s[0][1] + a_lo;
        s[0][0] = s[0][0] + a_hi + (lo / 4294967296 >>> 0) >>> 0;
        s[0][1] = lo >>> 0;
        lo = s[1][1] + b_lo;
        s[1][0] = s[1][0] + b_hi + (lo / 4294967296 >>> 0) >>> 0;
        s[1][1] = lo >>> 0;
        lo = s[2][1] + c_lo;
        s[2][0] = s[2][0] + c_hi + (lo / 4294967296 >>> 0) >>> 0;
        s[2][1] = lo >>> 0;
        lo = s[3][1] + d_lo;
        s[3][0] = s[3][0] + d_hi + (lo / 4294967296 >>> 0) >>> 0;
        s[3][1] = lo >>> 0;
        lo = s[4][1] + e_lo;
        s[4][0] = s[4][0] + e_hi + (lo / 4294967296 >>> 0) >>> 0;
        s[4][1] = lo >>> 0;
        lo = s[5][1] + f_lo;
        s[5][0] = s[5][0] + f_hi + (lo / 4294967296 >>> 0) >>> 0;
        s[5][1] = lo >>> 0;
        lo = s[6][1] + g_lo;
        s[6][0] = s[6][0] + g_hi + (lo / 4294967296 >>> 0) >>> 0;
        s[6][1] = lo >>> 0;
        lo = s[7][1] + h_lo;
        s[7][0] = s[7][0] + h_hi + (lo / 4294967296 >>> 0) >>> 0;
        s[7][1] = lo >>> 0;
        len -= 128;
      }
    }
  }
});

// node_modules/@selfxyz/common/node_modules/node-forge/lib/asn1-validator.js
var require_asn1_validator = __commonJS({
  "node_modules/@selfxyz/common/node_modules/node-forge/lib/asn1-validator.js"(exports2) {
    var forge2 = require_forge();
    require_asn1();
    var asn1 = forge2.asn1;
    exports2.privateKeyValidator = {
      // PrivateKeyInfo
      name: "PrivateKeyInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        // Version (INTEGER)
        name: "PrivateKeyInfo.version",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyVersion"
      }, {
        // privateKeyAlgorithm
        name: "PrivateKeyInfo.privateKeyAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "AlgorithmIdentifier.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "privateKeyOid"
        }]
      }, {
        // PrivateKey
        name: "PrivateKeyInfo",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: false,
        capture: "privateKey"
      }]
    };
    exports2.publicKeyValidator = {
      name: "SubjectPublicKeyInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      captureAsn1: "subjectPublicKeyInfo",
      value: [
        {
          name: "SubjectPublicKeyInfo.AlgorithmIdentifier",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "AlgorithmIdentifier.algorithm",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OID,
            constructed: false,
            capture: "publicKeyOid"
          }]
        },
        // capture group for ed25519PublicKey
        {
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.BITSTRING,
          constructed: false,
          composed: true,
          captureBitStringValue: "ed25519PublicKey"
        }
        // FIXME: this is capture group for rsaPublicKey, use it in this API or
        // discard?
        /* {
          // subjectPublicKey
          name: 'SubjectPublicKeyInfo.subjectPublicKey',
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.BITSTRING,
          constructed: false,
          value: [{
            // RSAPublicKey
            name: 'SubjectPublicKeyInfo.subjectPublicKey.RSAPublicKey',
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            optional: true,
            captureAsn1: 'rsaPublicKey'
          }]
        } */
      ]
    };
  }
});

// node_modules/@selfxyz/common/node_modules/node-forge/lib/ed25519.js
var require_ed25519 = __commonJS({
  "node_modules/@selfxyz/common/node_modules/node-forge/lib/ed25519.js"(exports2, module2) {
    var forge2 = require_forge();
    require_jsbn();
    require_random();
    require_sha5122();
    require_util();
    var asn1Validator = require_asn1_validator();
    var publicKeyValidator = asn1Validator.publicKeyValidator;
    var privateKeyValidator = asn1Validator.privateKeyValidator;
    if (typeof BigInteger === "undefined") {
      BigInteger = forge2.jsbn.BigInteger;
    }
    var BigInteger;
    var ByteBuffer = forge2.util.ByteBuffer;
    var NativeBuffer = typeof Buffer === "undefined" ? Uint8Array : Buffer;
    forge2.pki = forge2.pki || {};
    module2.exports = forge2.pki.ed25519 = forge2.ed25519 = forge2.ed25519 || {};
    var ed25519 = forge2.ed25519;
    ed25519.constants = {};
    ed25519.constants.PUBLIC_KEY_BYTE_LENGTH = 32;
    ed25519.constants.PRIVATE_KEY_BYTE_LENGTH = 64;
    ed25519.constants.SEED_BYTE_LENGTH = 32;
    ed25519.constants.SIGN_BYTE_LENGTH = 64;
    ed25519.constants.HASH_BYTE_LENGTH = 64;
    ed25519.generateKeyPair = function(options) {
      options = options || {};
      var seed = options.seed;
      if (seed === void 0) {
        seed = forge2.random.getBytesSync(ed25519.constants.SEED_BYTE_LENGTH);
      } else if (typeof seed === "string") {
        if (seed.length !== ed25519.constants.SEED_BYTE_LENGTH) {
          throw new TypeError(
            '"seed" must be ' + ed25519.constants.SEED_BYTE_LENGTH + " bytes in length."
          );
        }
      } else if (!(seed instanceof Uint8Array)) {
        throw new TypeError(
          '"seed" must be a node.js Buffer, Uint8Array, or a binary string.'
        );
      }
      seed = messageToNativeBuffer({ message: seed, encoding: "binary" });
      var pk = new NativeBuffer(ed25519.constants.PUBLIC_KEY_BYTE_LENGTH);
      var sk = new NativeBuffer(ed25519.constants.PRIVATE_KEY_BYTE_LENGTH);
      for (var i = 0; i < 32; ++i) {
        sk[i] = seed[i];
      }
      crypto_sign_keypair(pk, sk);
      return { publicKey: pk, privateKey: sk };
    };
    ed25519.privateKeyFromAsn1 = function(obj) {
      var capture = {};
      var errors = [];
      var valid = forge2.asn1.validate(obj, privateKeyValidator, capture, errors);
      if (!valid) {
        var error = new Error("Invalid Key.");
        error.errors = errors;
        throw error;
      }
      var oid = forge2.asn1.derToOid(capture.privateKeyOid);
      var ed25519Oid = forge2.oids.EdDSA25519;
      if (oid !== ed25519Oid) {
        throw new Error('Invalid OID "' + oid + '"; OID must be "' + ed25519Oid + '".');
      }
      var privateKey = capture.privateKey;
      var privateKeyBytes = messageToNativeBuffer({
        message: forge2.asn1.fromDer(privateKey).value,
        encoding: "binary"
      });
      return { privateKeyBytes };
    };
    ed25519.publicKeyFromAsn1 = function(obj) {
      var capture = {};
      var errors = [];
      var valid = forge2.asn1.validate(obj, publicKeyValidator, capture, errors);
      if (!valid) {
        var error = new Error("Invalid Key.");
        error.errors = errors;
        throw error;
      }
      var oid = forge2.asn1.derToOid(capture.publicKeyOid);
      var ed25519Oid = forge2.oids.EdDSA25519;
      if (oid !== ed25519Oid) {
        throw new Error('Invalid OID "' + oid + '"; OID must be "' + ed25519Oid + '".');
      }
      var publicKeyBytes = capture.ed25519PublicKey;
      if (publicKeyBytes.length !== ed25519.constants.PUBLIC_KEY_BYTE_LENGTH) {
        throw new Error("Key length is invalid.");
      }
      return messageToNativeBuffer({
        message: publicKeyBytes,
        encoding: "binary"
      });
    };
    ed25519.publicKeyFromPrivateKey = function(options) {
      options = options || {};
      var privateKey = messageToNativeBuffer({
        message: options.privateKey,
        encoding: "binary"
      });
      if (privateKey.length !== ed25519.constants.PRIVATE_KEY_BYTE_LENGTH) {
        throw new TypeError(
          '"options.privateKey" must have a byte length of ' + ed25519.constants.PRIVATE_KEY_BYTE_LENGTH
        );
      }
      var pk = new NativeBuffer(ed25519.constants.PUBLIC_KEY_BYTE_LENGTH);
      for (var i = 0; i < pk.length; ++i) {
        pk[i] = privateKey[32 + i];
      }
      return pk;
    };
    ed25519.sign = function(options) {
      options = options || {};
      var msg = messageToNativeBuffer(options);
      var privateKey = messageToNativeBuffer({
        message: options.privateKey,
        encoding: "binary"
      });
      if (privateKey.length === ed25519.constants.SEED_BYTE_LENGTH) {
        var keyPair = ed25519.generateKeyPair({ seed: privateKey });
        privateKey = keyPair.privateKey;
      } else if (privateKey.length !== ed25519.constants.PRIVATE_KEY_BYTE_LENGTH) {
        throw new TypeError(
          '"options.privateKey" must have a byte length of ' + ed25519.constants.SEED_BYTE_LENGTH + " or " + ed25519.constants.PRIVATE_KEY_BYTE_LENGTH
        );
      }
      var signedMsg = new NativeBuffer(
        ed25519.constants.SIGN_BYTE_LENGTH + msg.length
      );
      crypto_sign(signedMsg, msg, msg.length, privateKey);
      var sig = new NativeBuffer(ed25519.constants.SIGN_BYTE_LENGTH);
      for (var i = 0; i < sig.length; ++i) {
        sig[i] = signedMsg[i];
      }
      return sig;
    };
    ed25519.verify = function(options) {
      options = options || {};
      var msg = messageToNativeBuffer(options);
      if (options.signature === void 0) {
        throw new TypeError(
          '"options.signature" must be a node.js Buffer, a Uint8Array, a forge ByteBuffer, or a binary string.'
        );
      }
      var sig = messageToNativeBuffer({
        message: options.signature,
        encoding: "binary"
      });
      if (sig.length !== ed25519.constants.SIGN_BYTE_LENGTH) {
        throw new TypeError(
          '"options.signature" must have a byte length of ' + ed25519.constants.SIGN_BYTE_LENGTH
        );
      }
      var publicKey = messageToNativeBuffer({
        message: options.publicKey,
        encoding: "binary"
      });
      if (publicKey.length !== ed25519.constants.PUBLIC_KEY_BYTE_LENGTH) {
        throw new TypeError(
          '"options.publicKey" must have a byte length of ' + ed25519.constants.PUBLIC_KEY_BYTE_LENGTH
        );
      }
      var sm = new NativeBuffer(ed25519.constants.SIGN_BYTE_LENGTH + msg.length);
      var m = new NativeBuffer(ed25519.constants.SIGN_BYTE_LENGTH + msg.length);
      var i;
      for (i = 0; i < ed25519.constants.SIGN_BYTE_LENGTH; ++i) {
        sm[i] = sig[i];
      }
      for (i = 0; i < msg.length; ++i) {
        sm[i + ed25519.constants.SIGN_BYTE_LENGTH] = msg[i];
      }
      return crypto_sign_open(m, sm, sm.length, publicKey) >= 0;
    };
    function messageToNativeBuffer(options) {
      var message = options.message;
      if (message instanceof Uint8Array || message instanceof NativeBuffer) {
        return message;
      }
      var encoding = options.encoding;
      if (message === void 0) {
        if (options.md) {
          message = options.md.digest().getBytes();
          encoding = "binary";
        } else {
          throw new TypeError('"options.message" or "options.md" not specified.');
        }
      }
      if (typeof message === "string" && !encoding) {
        throw new TypeError('"options.encoding" must be "binary" or "utf8".');
      }
      if (typeof message === "string") {
        if (typeof Buffer !== "undefined") {
          return Buffer.from(message, encoding);
        }
        message = new ByteBuffer(message, encoding);
      } else if (!(message instanceof ByteBuffer)) {
        throw new TypeError(
          '"options.message" must be a node.js Buffer, a Uint8Array, a forge ByteBuffer, or a string with "options.encoding" specifying its encoding.'
        );
      }
      var buffer = new NativeBuffer(message.length());
      for (var i = 0; i < buffer.length; ++i) {
        buffer[i] = message.at(i);
      }
      return buffer;
    }
    var gf0 = gf();
    var gf1 = gf([1]);
    var D = gf([
      30883,
      4953,
      19914,
      30187,
      55467,
      16705,
      2637,
      112,
      59544,
      30585,
      16505,
      36039,
      65139,
      11119,
      27886,
      20995
    ]);
    var D2 = gf([
      61785,
      9906,
      39828,
      60374,
      45398,
      33411,
      5274,
      224,
      53552,
      61171,
      33010,
      6542,
      64743,
      22239,
      55772,
      9222
    ]);
    var X = gf([
      54554,
      36645,
      11616,
      51542,
      42930,
      38181,
      51040,
      26924,
      56412,
      64982,
      57905,
      49316,
      21502,
      52590,
      14035,
      8553
    ]);
    var Y = gf([
      26200,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214
    ]);
    var L = new Float64Array([
      237,
      211,
      245,
      92,
      26,
      99,
      18,
      88,
      214,
      156,
      247,
      162,
      222,
      249,
      222,
      20,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      16
    ]);
    var I = gf([
      41136,
      18958,
      6951,
      50414,
      58488,
      44335,
      6150,
      12099,
      55207,
      15867,
      153,
      11085,
      57099,
      20417,
      9344,
      11139
    ]);
    function sha5122(msg, msgLen) {
      var md = forge2.md.sha512.create();
      var buffer = new ByteBuffer(msg);
      md.update(buffer.getBytes(msgLen), "binary");
      var hash = md.digest().getBytes();
      if (typeof Buffer !== "undefined") {
        return Buffer.from(hash, "binary");
      }
      var out = new NativeBuffer(ed25519.constants.HASH_BYTE_LENGTH);
      for (var i = 0; i < 64; ++i) {
        out[i] = hash.charCodeAt(i);
      }
      return out;
    }
    function crypto_sign_keypair(pk, sk) {
      var p = [gf(), gf(), gf(), gf()];
      var i;
      var d = sha5122(sk, 32);
      d[0] &= 248;
      d[31] &= 127;
      d[31] |= 64;
      scalarbase(p, d);
      pack(pk, p);
      for (i = 0; i < 32; ++i) {
        sk[i + 32] = pk[i];
      }
      return 0;
    }
    function crypto_sign(sm, m, n, sk) {
      var i, j, x = new Float64Array(64);
      var p = [gf(), gf(), gf(), gf()];
      var d = sha5122(sk, 32);
      d[0] &= 248;
      d[31] &= 127;
      d[31] |= 64;
      var smlen = n + 64;
      for (i = 0; i < n; ++i) {
        sm[64 + i] = m[i];
      }
      for (i = 0; i < 32; ++i) {
        sm[32 + i] = d[32 + i];
      }
      var r = sha5122(sm.subarray(32), n + 32);
      reduce(r);
      scalarbase(p, r);
      pack(sm, p);
      for (i = 32; i < 64; ++i) {
        sm[i] = sk[i];
      }
      var h = sha5122(sm, n + 64);
      reduce(h);
      for (i = 32; i < 64; ++i) {
        x[i] = 0;
      }
      for (i = 0; i < 32; ++i) {
        x[i] = r[i];
      }
      for (i = 0; i < 32; ++i) {
        for (j = 0; j < 32; j++) {
          x[i + j] += h[i] * d[j];
        }
      }
      modL(sm.subarray(32), x);
      return smlen;
    }
    function crypto_sign_open(m, sm, n, pk) {
      var i, mlen;
      var t = new NativeBuffer(32);
      var p = [gf(), gf(), gf(), gf()], q = [gf(), gf(), gf(), gf()];
      mlen = -1;
      if (n < 64) {
        return -1;
      }
      if (unpackneg(q, pk)) {
        return -1;
      }
      for (i = 0; i < n; ++i) {
        m[i] = sm[i];
      }
      for (i = 0; i < 32; ++i) {
        m[i + 32] = pk[i];
      }
      var h = sha5122(m, n);
      reduce(h);
      scalarmult(p, q, h);
      scalarbase(q, sm.subarray(32));
      add2(p, q);
      pack(t, p);
      n -= 64;
      if (crypto_verify_32(sm, 0, t, 0)) {
        for (i = 0; i < n; ++i) {
          m[i] = 0;
        }
        return -1;
      }
      for (i = 0; i < n; ++i) {
        m[i] = sm[i + 64];
      }
      mlen = n;
      return mlen;
    }
    function modL(r, x) {
      var carry, i, j, k;
      for (i = 63; i >= 32; --i) {
        carry = 0;
        for (j = i - 32, k = i - 12; j < k; ++j) {
          x[j] += carry - 16 * x[i] * L[j - (i - 32)];
          carry = x[j] + 128 >> 8;
          x[j] -= carry * 256;
        }
        x[j] += carry;
        x[i] = 0;
      }
      carry = 0;
      for (j = 0; j < 32; ++j) {
        x[j] += carry - (x[31] >> 4) * L[j];
        carry = x[j] >> 8;
        x[j] &= 255;
      }
      for (j = 0; j < 32; ++j) {
        x[j] -= carry * L[j];
      }
      for (i = 0; i < 32; ++i) {
        x[i + 1] += x[i] >> 8;
        r[i] = x[i] & 255;
      }
    }
    function reduce(r) {
      var x = new Float64Array(64);
      for (var i = 0; i < 64; ++i) {
        x[i] = r[i];
        r[i] = 0;
      }
      modL(r, x);
    }
    function add2(p, q) {
      var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f3 = gf(), g = gf(), h = gf(), t = gf();
      Z(a, p[1], p[0]);
      Z(t, q[1], q[0]);
      M(a, a, t);
      A(b, p[0], p[1]);
      A(t, q[0], q[1]);
      M(b, b, t);
      M(c, p[3], q[3]);
      M(c, c, D2);
      M(d, p[2], q[2]);
      A(d, d, d);
      Z(e, b, a);
      Z(f3, d, c);
      A(g, d, c);
      A(h, b, a);
      M(p[0], e, f3);
      M(p[1], h, g);
      M(p[2], g, f3);
      M(p[3], e, h);
    }
    function cswap(p, q, b) {
      for (var i = 0; i < 4; ++i) {
        sel25519(p[i], q[i], b);
      }
    }
    function pack(r, p) {
      var tx = gf(), ty = gf(), zi = gf();
      inv25519(zi, p[2]);
      M(tx, p[0], zi);
      M(ty, p[1], zi);
      pack25519(r, ty);
      r[31] ^= par25519(tx) << 7;
    }
    function pack25519(o, n) {
      var i, j, b;
      var m = gf(), t = gf();
      for (i = 0; i < 16; ++i) {
        t[i] = n[i];
      }
      car25519(t);
      car25519(t);
      car25519(t);
      for (j = 0; j < 2; ++j) {
        m[0] = t[0] - 65517;
        for (i = 1; i < 15; ++i) {
          m[i] = t[i] - 65535 - (m[i - 1] >> 16 & 1);
          m[i - 1] &= 65535;
        }
        m[15] = t[15] - 32767 - (m[14] >> 16 & 1);
        b = m[15] >> 16 & 1;
        m[14] &= 65535;
        sel25519(t, m, 1 - b);
      }
      for (i = 0; i < 16; i++) {
        o[2 * i] = t[i] & 255;
        o[2 * i + 1] = t[i] >> 8;
      }
    }
    function unpackneg(r, p) {
      var t = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
      set25519(r[2], gf1);
      unpack25519(r[1], p);
      S(num, r[1]);
      M(den, num, D);
      Z(num, num, r[2]);
      A(den, r[2], den);
      S(den2, den);
      S(den4, den2);
      M(den6, den4, den2);
      M(t, den6, num);
      M(t, t, den);
      pow2523(t, t);
      M(t, t, num);
      M(t, t, den);
      M(t, t, den);
      M(r[0], t, den);
      S(chk, r[0]);
      M(chk, chk, den);
      if (neq25519(chk, num)) {
        M(r[0], r[0], I);
      }
      S(chk, r[0]);
      M(chk, chk, den);
      if (neq25519(chk, num)) {
        return -1;
      }
      if (par25519(r[0]) === p[31] >> 7) {
        Z(r[0], gf0, r[0]);
      }
      M(r[3], r[0], r[1]);
      return 0;
    }
    function unpack25519(o, n) {
      var i;
      for (i = 0; i < 16; ++i) {
        o[i] = n[2 * i] + (n[2 * i + 1] << 8);
      }
      o[15] &= 32767;
    }
    function pow2523(o, i) {
      var c = gf();
      var a;
      for (a = 0; a < 16; ++a) {
        c[a] = i[a];
      }
      for (a = 250; a >= 0; --a) {
        S(c, c);
        if (a !== 1) {
          M(c, c, i);
        }
      }
      for (a = 0; a < 16; ++a) {
        o[a] = c[a];
      }
    }
    function neq25519(a, b) {
      var c = new NativeBuffer(32);
      var d = new NativeBuffer(32);
      pack25519(c, a);
      pack25519(d, b);
      return crypto_verify_32(c, 0, d, 0);
    }
    function crypto_verify_32(x, xi, y, yi) {
      return vn(x, xi, y, yi, 32);
    }
    function vn(x, xi, y, yi, n) {
      var i, d = 0;
      for (i = 0; i < n; ++i) {
        d |= x[xi + i] ^ y[yi + i];
      }
      return (1 & d - 1 >>> 8) - 1;
    }
    function par25519(a) {
      var d = new NativeBuffer(32);
      pack25519(d, a);
      return d[0] & 1;
    }
    function scalarmult(p, q, s) {
      var b, i;
      set25519(p[0], gf0);
      set25519(p[1], gf1);
      set25519(p[2], gf1);
      set25519(p[3], gf0);
      for (i = 255; i >= 0; --i) {
        b = s[i / 8 | 0] >> (i & 7) & 1;
        cswap(p, q, b);
        add2(q, p);
        add2(p, p);
        cswap(p, q, b);
      }
    }
    function scalarbase(p, s) {
      var q = [gf(), gf(), gf(), gf()];
      set25519(q[0], X);
      set25519(q[1], Y);
      set25519(q[2], gf1);
      M(q[3], X, Y);
      scalarmult(p, q, s);
    }
    function set25519(r, a) {
      var i;
      for (i = 0; i < 16; i++) {
        r[i] = a[i] | 0;
      }
    }
    function inv25519(o, i) {
      var c = gf();
      var a;
      for (a = 0; a < 16; ++a) {
        c[a] = i[a];
      }
      for (a = 253; a >= 0; --a) {
        S(c, c);
        if (a !== 2 && a !== 4) {
          M(c, c, i);
        }
      }
      for (a = 0; a < 16; ++a) {
        o[a] = c[a];
      }
    }
    function car25519(o) {
      var i, v, c = 1;
      for (i = 0; i < 16; ++i) {
        v = o[i] + c + 65535;
        c = Math.floor(v / 65536);
        o[i] = v - c * 65536;
      }
      o[0] += c - 1 + 37 * (c - 1);
    }
    function sel25519(p, q, b) {
      var t, c = ~(b - 1);
      for (var i = 0; i < 16; ++i) {
        t = c & (p[i] ^ q[i]);
        p[i] ^= t;
        q[i] ^= t;
      }
    }
    function gf(init) {
      var i, r = new Float64Array(16);
      if (init) {
        for (i = 0; i < init.length; ++i) {
          r[i] = init[i];
        }
      }
      return r;
    }
    function A(o, a, b) {
      for (var i = 0; i < 16; ++i) {
        o[i] = a[i] + b[i];
      }
    }
    function Z(o, a, b) {
      for (var i = 0; i < 16; ++i) {
        o[i] = a[i] - b[i];
      }
    }
    function S(o, a) {
      M(o, a, a);
    }
    function M(o, a, b) {
      var v, c, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11], b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
      v = a[0];
      t0 += v * b0;
      t1 += v * b1;
      t2 += v * b2;
      t3 += v * b3;
      t4 += v * b4;
      t5 += v * b5;
      t6 += v * b6;
      t7 += v * b7;
      t8 += v * b8;
      t9 += v * b9;
      t10 += v * b10;
      t11 += v * b11;
      t12 += v * b12;
      t13 += v * b13;
      t14 += v * b14;
      t15 += v * b15;
      v = a[1];
      t1 += v * b0;
      t2 += v * b1;
      t3 += v * b2;
      t4 += v * b3;
      t5 += v * b4;
      t6 += v * b5;
      t7 += v * b6;
      t8 += v * b7;
      t9 += v * b8;
      t10 += v * b9;
      t11 += v * b10;
      t12 += v * b11;
      t13 += v * b12;
      t14 += v * b13;
      t15 += v * b14;
      t16 += v * b15;
      v = a[2];
      t2 += v * b0;
      t3 += v * b1;
      t4 += v * b2;
      t5 += v * b3;
      t6 += v * b4;
      t7 += v * b5;
      t8 += v * b6;
      t9 += v * b7;
      t10 += v * b8;
      t11 += v * b9;
      t12 += v * b10;
      t13 += v * b11;
      t14 += v * b12;
      t15 += v * b13;
      t16 += v * b14;
      t17 += v * b15;
      v = a[3];
      t3 += v * b0;
      t4 += v * b1;
      t5 += v * b2;
      t6 += v * b3;
      t7 += v * b4;
      t8 += v * b5;
      t9 += v * b6;
      t10 += v * b7;
      t11 += v * b8;
      t12 += v * b9;
      t13 += v * b10;
      t14 += v * b11;
      t15 += v * b12;
      t16 += v * b13;
      t17 += v * b14;
      t18 += v * b15;
      v = a[4];
      t4 += v * b0;
      t5 += v * b1;
      t6 += v * b2;
      t7 += v * b3;
      t8 += v * b4;
      t9 += v * b5;
      t10 += v * b6;
      t11 += v * b7;
      t12 += v * b8;
      t13 += v * b9;
      t14 += v * b10;
      t15 += v * b11;
      t16 += v * b12;
      t17 += v * b13;
      t18 += v * b14;
      t19 += v * b15;
      v = a[5];
      t5 += v * b0;
      t6 += v * b1;
      t7 += v * b2;
      t8 += v * b3;
      t9 += v * b4;
      t10 += v * b5;
      t11 += v * b6;
      t12 += v * b7;
      t13 += v * b8;
      t14 += v * b9;
      t15 += v * b10;
      t16 += v * b11;
      t17 += v * b12;
      t18 += v * b13;
      t19 += v * b14;
      t20 += v * b15;
      v = a[6];
      t6 += v * b0;
      t7 += v * b1;
      t8 += v * b2;
      t9 += v * b3;
      t10 += v * b4;
      t11 += v * b5;
      t12 += v * b6;
      t13 += v * b7;
      t14 += v * b8;
      t15 += v * b9;
      t16 += v * b10;
      t17 += v * b11;
      t18 += v * b12;
      t19 += v * b13;
      t20 += v * b14;
      t21 += v * b15;
      v = a[7];
      t7 += v * b0;
      t8 += v * b1;
      t9 += v * b2;
      t10 += v * b3;
      t11 += v * b4;
      t12 += v * b5;
      t13 += v * b6;
      t14 += v * b7;
      t15 += v * b8;
      t16 += v * b9;
      t17 += v * b10;
      t18 += v * b11;
      t19 += v * b12;
      t20 += v * b13;
      t21 += v * b14;
      t22 += v * b15;
      v = a[8];
      t8 += v * b0;
      t9 += v * b1;
      t10 += v * b2;
      t11 += v * b3;
      t12 += v * b4;
      t13 += v * b5;
      t14 += v * b6;
      t15 += v * b7;
      t16 += v * b8;
      t17 += v * b9;
      t18 += v * b10;
      t19 += v * b11;
      t20 += v * b12;
      t21 += v * b13;
      t22 += v * b14;
      t23 += v * b15;
      v = a[9];
      t9 += v * b0;
      t10 += v * b1;
      t11 += v * b2;
      t12 += v * b3;
      t13 += v * b4;
      t14 += v * b5;
      t15 += v * b6;
      t16 += v * b7;
      t17 += v * b8;
      t18 += v * b9;
      t19 += v * b10;
      t20 += v * b11;
      t21 += v * b12;
      t22 += v * b13;
      t23 += v * b14;
      t24 += v * b15;
      v = a[10];
      t10 += v * b0;
      t11 += v * b1;
      t12 += v * b2;
      t13 += v * b3;
      t14 += v * b4;
      t15 += v * b5;
      t16 += v * b6;
      t17 += v * b7;
      t18 += v * b8;
      t19 += v * b9;
      t20 += v * b10;
      t21 += v * b11;
      t22 += v * b12;
      t23 += v * b13;
      t24 += v * b14;
      t25 += v * b15;
      v = a[11];
      t11 += v * b0;
      t12 += v * b1;
      t13 += v * b2;
      t14 += v * b3;
      t15 += v * b4;
      t16 += v * b5;
      t17 += v * b6;
      t18 += v * b7;
      t19 += v * b8;
      t20 += v * b9;
      t21 += v * b10;
      t22 += v * b11;
      t23 += v * b12;
      t24 += v * b13;
      t25 += v * b14;
      t26 += v * b15;
      v = a[12];
      t12 += v * b0;
      t13 += v * b1;
      t14 += v * b2;
      t15 += v * b3;
      t16 += v * b4;
      t17 += v * b5;
      t18 += v * b6;
      t19 += v * b7;
      t20 += v * b8;
      t21 += v * b9;
      t22 += v * b10;
      t23 += v * b11;
      t24 += v * b12;
      t25 += v * b13;
      t26 += v * b14;
      t27 += v * b15;
      v = a[13];
      t13 += v * b0;
      t14 += v * b1;
      t15 += v * b2;
      t16 += v * b3;
      t17 += v * b4;
      t18 += v * b5;
      t19 += v * b6;
      t20 += v * b7;
      t21 += v * b8;
      t22 += v * b9;
      t23 += v * b10;
      t24 += v * b11;
      t25 += v * b12;
      t26 += v * b13;
      t27 += v * b14;
      t28 += v * b15;
      v = a[14];
      t14 += v * b0;
      t15 += v * b1;
      t16 += v * b2;
      t17 += v * b3;
      t18 += v * b4;
      t19 += v * b5;
      t20 += v * b6;
      t21 += v * b7;
      t22 += v * b8;
      t23 += v * b9;
      t24 += v * b10;
      t25 += v * b11;
      t26 += v * b12;
      t27 += v * b13;
      t28 += v * b14;
      t29 += v * b15;
      v = a[15];
      t15 += v * b0;
      t16 += v * b1;
      t17 += v * b2;
      t18 += v * b3;
      t19 += v * b4;
      t20 += v * b5;
      t21 += v * b6;
      t22 += v * b7;
      t23 += v * b8;
      t24 += v * b9;
      t25 += v * b10;
      t26 += v * b11;
      t27 += v * b12;
      t28 += v * b13;
      t29 += v * b14;
      t30 += v * b15;
      t0 += 38 * t16;
      t1 += 38 * t17;
      t2 += 38 * t18;
      t3 += 38 * t19;
      t4 += 38 * t20;
      t5 += 38 * t21;
      t6 += 38 * t22;
      t7 += 38 * t23;
      t8 += 38 * t24;
      t9 += 38 * t25;
      t10 += 38 * t26;
      t11 += 38 * t27;
      t12 += 38 * t28;
      t13 += 38 * t29;
      t14 += 38 * t30;
      c = 1;
      v = t0 + c + 65535;
      c = Math.floor(v / 65536);
      t0 = v - c * 65536;
      v = t1 + c + 65535;
      c = Math.floor(v / 65536);
      t1 = v - c * 65536;
      v = t2 + c + 65535;
      c = Math.floor(v / 65536);
      t2 = v - c * 65536;
      v = t3 + c + 65535;
      c = Math.floor(v / 65536);
      t3 = v - c * 65536;
      v = t4 + c + 65535;
      c = Math.floor(v / 65536);
      t4 = v - c * 65536;
      v = t5 + c + 65535;
      c = Math.floor(v / 65536);
      t5 = v - c * 65536;
      v = t6 + c + 65535;
      c = Math.floor(v / 65536);
      t6 = v - c * 65536;
      v = t7 + c + 65535;
      c = Math.floor(v / 65536);
      t7 = v - c * 65536;
      v = t8 + c + 65535;
      c = Math.floor(v / 65536);
      t8 = v - c * 65536;
      v = t9 + c + 65535;
      c = Math.floor(v / 65536);
      t9 = v - c * 65536;
      v = t10 + c + 65535;
      c = Math.floor(v / 65536);
      t10 = v - c * 65536;
      v = t11 + c + 65535;
      c = Math.floor(v / 65536);
      t11 = v - c * 65536;
      v = t12 + c + 65535;
      c = Math.floor(v / 65536);
      t12 = v - c * 65536;
      v = t13 + c + 65535;
      c = Math.floor(v / 65536);
      t13 = v - c * 65536;
      v = t14 + c + 65535;
      c = Math.floor(v / 65536);
      t14 = v - c * 65536;
      v = t15 + c + 65535;
      c = Math.floor(v / 65536);
      t15 = v - c * 65536;
      t0 += c - 1 + 37 * (c - 1);
      c = 1;
      v = t0 + c + 65535;
      c = Math.floor(v / 65536);
      t0 = v - c * 65536;
      v = t1 + c + 65535;
      c = Math.floor(v / 65536);
      t1 = v - c * 65536;
      v = t2 + c + 65535;
      c = Math.floor(v / 65536);
      t2 = v - c * 65536;
      v = t3 + c + 65535;
      c = Math.floor(v / 65536);
      t3 = v - c * 65536;
      v = t4 + c + 65535;
      c = Math.floor(v / 65536);
      t4 = v - c * 65536;
      v = t5 + c + 65535;
      c = Math.floor(v / 65536);
      t5 = v - c * 65536;
      v = t6 + c + 65535;
      c = Math.floor(v / 65536);
      t6 = v - c * 65536;
      v = t7 + c + 65535;
      c = Math.floor(v / 65536);
      t7 = v - c * 65536;
      v = t8 + c + 65535;
      c = Math.floor(v / 65536);
      t8 = v - c * 65536;
      v = t9 + c + 65535;
      c = Math.floor(v / 65536);
      t9 = v - c * 65536;
      v = t10 + c + 65535;
      c = Math.floor(v / 65536);
      t10 = v - c * 65536;
      v = t11 + c + 65535;
      c = Math.floor(v / 65536);
      t11 = v - c * 65536;
      v = t12 + c + 65535;
      c = Math.floor(v / 65536);
      t12 = v - c * 65536;
      v = t13 + c + 65535;
      c = Math.floor(v / 65536);
      t13 = v - c * 65536;
      v = t14 + c + 65535;
      c = Math.floor(v / 65536);
      t14 = v - c * 65536;
      v = t15 + c + 65535;
      c = Math.floor(v / 65536);
      t15 = v - c * 65536;
      t0 += c - 1 + 37 * (c - 1);
      o[0] = t0;
      o[1] = t1;
      o[2] = t2;
      o[3] = t3;
      o[4] = t4;
      o[5] = t5;
      o[6] = t6;
      o[7] = t7;
      o[8] = t8;
      o[9] = t9;
      o[10] = t10;
      o[11] = t11;
      o[12] = t12;
      o[13] = t13;
      o[14] = t14;
      o[15] = t15;
    }
  }
});

// node_modules/@selfxyz/common/node_modules/node-forge/lib/kem.js
var require_kem = __commonJS({
  "node_modules/@selfxyz/common/node_modules/node-forge/lib/kem.js"(exports2, module2) {
    var forge2 = require_forge();
    require_util();
    require_random();
    require_jsbn();
    module2.exports = forge2.kem = forge2.kem || {};
    var BigInteger = forge2.jsbn.BigInteger;
    forge2.kem.rsa = {};
    forge2.kem.rsa.create = function(kdf, options) {
      options = options || {};
      var prng = options.prng || forge2.random;
      var kem = {};
      kem.encrypt = function(publicKey, keyLength) {
        var byteLength2 = Math.ceil(publicKey.n.bitLength() / 8);
        var r;
        do {
          r = new BigInteger(
            forge2.util.bytesToHex(prng.getBytesSync(byteLength2)),
            16
          ).mod(publicKey.n);
        } while (r.compareTo(BigInteger.ONE) <= 0);
        r = forge2.util.hexToBytes(r.toString(16));
        var zeros = byteLength2 - r.length;
        if (zeros > 0) {
          r = forge2.util.fillString(String.fromCharCode(0), zeros) + r;
        }
        var encapsulation = publicKey.encrypt(r, "NONE");
        var key2 = kdf.generate(r, keyLength);
        return { encapsulation, key: key2 };
      };
      kem.decrypt = function(privateKey, encapsulation, keyLength) {
        var r = privateKey.decrypt(encapsulation, "NONE");
        return kdf.generate(r, keyLength);
      };
      return kem;
    };
    forge2.kem.kdf1 = function(md, digestLength) {
      _createKDF(this, md, 0, digestLength || md.digestLength);
    };
    forge2.kem.kdf2 = function(md, digestLength) {
      _createKDF(this, md, 1, digestLength || md.digestLength);
    };
    function _createKDF(kdf, md, counterStart, digestLength) {
      kdf.generate = function(x, length2) {
        var key2 = new forge2.util.ByteBuffer();
        var k = Math.ceil(length2 / digestLength) + counterStart;
        var c = new forge2.util.ByteBuffer();
        for (var i = counterStart; i < k; ++i) {
          c.putInt32(i);
          md.start();
          md.update(x + c.getBytes());
          var hash = md.digest();
          key2.putBytes(hash.getBytes(digestLength));
        }
        key2.truncate(key2.length() - length2);
        return key2.getBytes();
      };
    }
  }
});

// node_modules/@selfxyz/common/node_modules/node-forge/lib/log.js
var require_log = __commonJS({
  "node_modules/@selfxyz/common/node_modules/node-forge/lib/log.js"(exports2, module2) {
    var forge2 = require_forge();
    require_util();
    module2.exports = forge2.log = forge2.log || {};
    forge2.log.levels = [
      "none",
      "error",
      "warning",
      "info",
      "debug",
      "verbose",
      "max"
    ];
    var sLevelInfo = {};
    var sLoggers = [];
    var sConsoleLogger = null;
    forge2.log.LEVEL_LOCKED = 1 << 1;
    forge2.log.NO_LEVEL_CHECK = 1 << 2;
    forge2.log.INTERPOLATE = 1 << 3;
    for (i = 0; i < forge2.log.levels.length; ++i) {
      level = forge2.log.levels[i];
      sLevelInfo[level] = {
        index: i,
        name: level.toUpperCase()
      };
    }
    var level;
    var i;
    forge2.log.logMessage = function(message) {
      var messageLevelIndex = sLevelInfo[message.level].index;
      for (var i2 = 0; i2 < sLoggers.length; ++i2) {
        var logger2 = sLoggers[i2];
        if (logger2.flags & forge2.log.NO_LEVEL_CHECK) {
          logger2.f(message);
        } else {
          var loggerLevelIndex = sLevelInfo[logger2.level].index;
          if (messageLevelIndex <= loggerLevelIndex) {
            logger2.f(logger2, message);
          }
        }
      }
    };
    forge2.log.prepareStandard = function(message) {
      if (!("standard" in message)) {
        message.standard = sLevelInfo[message.level].name + //' ' + +message.timestamp +
        " [" + message.category + "] " + message.message;
      }
    };
    forge2.log.prepareFull = function(message) {
      if (!("full" in message)) {
        var args = [message.message];
        args = args.concat([]);
        message.full = forge2.util.format.apply(this, args);
      }
    };
    forge2.log.prepareStandardFull = function(message) {
      if (!("standardFull" in message)) {
        forge2.log.prepareStandard(message);
        message.standardFull = message.standard;
      }
    };
    if (true) {
      levels = ["error", "warning", "info", "debug", "verbose"];
      for (i = 0; i < levels.length; ++i) {
        (function(level2) {
          forge2.log[level2] = function(category, message) {
            var args = Array.prototype.slice.call(arguments).slice(2);
            var msg = {
              timestamp: /* @__PURE__ */ new Date(),
              level: level2,
              category,
              message,
              "arguments": args
              /*standard*/
              /*full*/
              /*fullMessage*/
            };
            forge2.log.logMessage(msg);
          };
        })(levels[i]);
      }
    }
    var levels;
    var i;
    forge2.log.makeLogger = function(logFunction) {
      var logger2 = {
        flags: 0,
        f: logFunction
      };
      forge2.log.setLevel(logger2, "none");
      return logger2;
    };
    forge2.log.setLevel = function(logger2, level2) {
      var rval = false;
      if (logger2 && !(logger2.flags & forge2.log.LEVEL_LOCKED)) {
        for (var i2 = 0; i2 < forge2.log.levels.length; ++i2) {
          var aValidLevel = forge2.log.levels[i2];
          if (level2 == aValidLevel) {
            logger2.level = level2;
            rval = true;
            break;
          }
        }
      }
      return rval;
    };
    forge2.log.lock = function(logger2, lock2) {
      if (typeof lock2 === "undefined" || lock2) {
        logger2.flags |= forge2.log.LEVEL_LOCKED;
      } else {
        logger2.flags &= ~forge2.log.LEVEL_LOCKED;
      }
    };
    forge2.log.addLogger = function(logger2) {
      sLoggers.push(logger2);
    };
    if (typeof console !== "undefined" && "log" in console) {
      if (console.error && console.warn && console.info && console.debug) {
        levelHandlers = {
          error: console.error,
          warning: console.warn,
          info: console.info,
          debug: console.debug,
          verbose: console.debug
        };
        f3 = function(logger2, message) {
          forge2.log.prepareStandard(message);
          var handler = levelHandlers[message.level];
          var args = [message.standard];
          args = args.concat(message["arguments"].slice());
          handler.apply(console, args);
        };
        logger = forge2.log.makeLogger(f3);
      } else {
        f3 = function(logger2, message) {
          forge2.log.prepareStandardFull(message);
          console.log(message.standardFull);
        };
        logger = forge2.log.makeLogger(f3);
      }
      forge2.log.setLevel(logger, "debug");
      forge2.log.addLogger(logger);
      sConsoleLogger = logger;
    } else {
      console = {
        log: function() {
        }
      };
    }
    var logger;
    var levelHandlers;
    var f3;
    if (sConsoleLogger !== null && typeof window !== "undefined" && window.location) {
      query = new URL(window.location.href).searchParams;
      if (query.has("console.level")) {
        forge2.log.setLevel(
          sConsoleLogger,
          query.get("console.level").slice(-1)[0]
        );
      }
      if (query.has("console.lock")) {
        lock = query.get("console.lock").slice(-1)[0];
        if (lock == "true") {
          forge2.log.lock(sConsoleLogger);
        }
      }
    }
    var query;
    var lock;
    forge2.log.consoleLogger = sConsoleLogger;
  }
});

// node_modules/@selfxyz/common/node_modules/node-forge/lib/md.all.js
var require_md_all = __commonJS({
  "node_modules/@selfxyz/common/node_modules/node-forge/lib/md.all.js"(exports2, module2) {
    module2.exports = require_md();
    require_md5();
    require_sha12();
    require_sha2562();
    require_sha5122();
  }
});

// node_modules/@selfxyz/common/node_modules/node-forge/lib/pkcs7.js
var require_pkcs7 = __commonJS({
  "node_modules/@selfxyz/common/node_modules/node-forge/lib/pkcs7.js"(exports2, module2) {
    var forge2 = require_forge();
    require_aes();
    require_asn1();
    require_des();
    require_oids();
    require_pem();
    require_pkcs7asn1();
    require_random();
    require_util();
    require_x509();
    var asn1 = forge2.asn1;
    var p7 = module2.exports = forge2.pkcs7 = forge2.pkcs7 || {};
    p7.messageFromPem = function(pem) {
      var msg = forge2.pem.decode(pem)[0];
      if (msg.type !== "PKCS7") {
        var error = new Error('Could not convert PKCS#7 message from PEM; PEM header type is not "PKCS#7".');
        error.headerType = msg.type;
        throw error;
      }
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        throw new Error("Could not convert PKCS#7 message from PEM; PEM is encrypted.");
      }
      var obj = asn1.fromDer(msg.body);
      return p7.messageFromAsn1(obj);
    };
    p7.messageToPem = function(msg, maxline) {
      var pemObj = {
        type: "PKCS7",
        body: asn1.toDer(msg.toAsn1()).getBytes()
      };
      return forge2.pem.encode(pemObj, { maxline });
    };
    p7.messageFromAsn1 = function(obj) {
      var capture = {};
      var errors = [];
      if (!asn1.validate(obj, p7.asn1.contentInfoValidator, capture, errors)) {
        var error = new Error("Cannot read PKCS#7 message. ASN.1 object is not an PKCS#7 ContentInfo.");
        error.errors = errors;
        throw error;
      }
      var contentType = asn1.derToOid(capture.contentType);
      var msg;
      switch (contentType) {
        case forge2.pki.oids.envelopedData:
          msg = p7.createEnvelopedData();
          break;
        case forge2.pki.oids.encryptedData:
          msg = p7.createEncryptedData();
          break;
        case forge2.pki.oids.signedData:
          msg = p7.createSignedData();
          break;
        default:
          throw new Error("Cannot read PKCS#7 message. ContentType with OID " + contentType + " is not (yet) supported.");
      }
      msg.fromAsn1(capture.content.value[0]);
      return msg;
    };
    p7.createSignedData = function() {
      var msg = null;
      msg = {
        type: forge2.pki.oids.signedData,
        version: 1,
        certificates: [],
        crls: [],
        // TODO: add json-formatted signer stuff here?
        signers: [],
        // populated during sign()
        digestAlgorithmIdentifiers: [],
        contentInfo: null,
        signerInfos: [],
        fromAsn1: function(obj) {
          _fromAsn1(msg, obj, p7.asn1.signedDataValidator);
          msg.certificates = [];
          msg.crls = [];
          msg.digestAlgorithmIdentifiers = [];
          msg.contentInfo = null;
          msg.signerInfos = [];
          if (msg.rawCapture.certificates) {
            var certs = msg.rawCapture.certificates.value;
            for (var i = 0; i < certs.length; ++i) {
              msg.certificates.push(forge2.pki.certificateFromAsn1(certs[i]));
            }
          }
        },
        toAsn1: function() {
          if (!msg.contentInfo) {
            msg.sign();
          }
          var certs = [];
          for (var i = 0; i < msg.certificates.length; ++i) {
            certs.push(forge2.pki.certificateToAsn1(msg.certificates[i]));
          }
          var crls = [];
          var signedData = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              // Version
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.INTEGER,
                false,
                asn1.integerToDer(msg.version).getBytes()
              ),
              // DigestAlgorithmIdentifiers
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.SET,
                true,
                msg.digestAlgorithmIdentifiers
              ),
              // ContentInfo
              msg.contentInfo
            ])
          ]);
          if (certs.length > 0) {
            signedData.value[0].value.push(
              asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, certs)
            );
          }
          if (crls.length > 0) {
            signedData.value[0].value.push(
              asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, crls)
            );
          }
          signedData.value[0].value.push(
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.SET,
              true,
              msg.signerInfos
            )
          );
          return asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.SEQUENCE,
            true,
            [
              // ContentType
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.OID,
                false,
                asn1.oidToDer(msg.type).getBytes()
              ),
              // [0] SignedData
              signedData
            ]
          );
        },
        /**
         * Add (another) entity to list of signers.
         *
         * Note: If authenticatedAttributes are provided, then, per RFC 2315,
         * they must include at least two attributes: content type and
         * message digest. The message digest attribute value will be
         * auto-calculated during signing and will be ignored if provided.
         *
         * Here's an example of providing these two attributes:
         *
         * forge.pkcs7.createSignedData();
         * p7.addSigner({
         *   issuer: cert.issuer.attributes,
         *   serialNumber: cert.serialNumber,
         *   key: privateKey,
         *   digestAlgorithm: forge.pki.oids.sha1,
         *   authenticatedAttributes: [{
         *     type: forge.pki.oids.contentType,
         *     value: forge.pki.oids.data
         *   }, {
         *     type: forge.pki.oids.messageDigest
         *   }]
         * });
         *
         * TODO: Support [subjectKeyIdentifier] as signer's ID.
         *
         * @param signer the signer information:
         *          key the signer's private key.
         *          [certificate] a certificate containing the public key
         *            associated with the signer's private key; use this option as
         *            an alternative to specifying signer.issuer and
         *            signer.serialNumber.
         *          [issuer] the issuer attributes (eg: cert.issuer.attributes).
         *          [serialNumber] the signer's certificate's serial number in
         *           hexadecimal (eg: cert.serialNumber).
         *          [digestAlgorithm] the message digest OID, as a string, to use
         *            (eg: forge.pki.oids.sha1).
         *          [authenticatedAttributes] an optional array of attributes
         *            to also sign along with the content.
         */
        addSigner: function(signer) {
          var issuer = signer.issuer;
          var serialNumber = signer.serialNumber;
          if (signer.certificate) {
            var cert = signer.certificate;
            if (typeof cert === "string") {
              cert = forge2.pki.certificateFromPem(cert);
            }
            issuer = cert.issuer.attributes;
            serialNumber = cert.serialNumber;
          }
          var key2 = signer.key;
          if (!key2) {
            throw new Error(
              "Could not add PKCS#7 signer; no private key specified."
            );
          }
          if (typeof key2 === "string") {
            key2 = forge2.pki.privateKeyFromPem(key2);
          }
          var digestAlgorithm = signer.digestAlgorithm || forge2.pki.oids.sha1;
          switch (digestAlgorithm) {
            case forge2.pki.oids.sha1:
            case forge2.pki.oids.sha256:
            case forge2.pki.oids.sha384:
            case forge2.pki.oids.sha512:
            case forge2.pki.oids.md5:
              break;
            default:
              throw new Error(
                "Could not add PKCS#7 signer; unknown message digest algorithm: " + digestAlgorithm
              );
          }
          var authenticatedAttributes = signer.authenticatedAttributes || [];
          if (authenticatedAttributes.length > 0) {
            var contentType = false;
            var messageDigest = false;
            for (var i = 0; i < authenticatedAttributes.length; ++i) {
              var attr = authenticatedAttributes[i];
              if (!contentType && attr.type === forge2.pki.oids.contentType) {
                contentType = true;
                if (messageDigest) {
                  break;
                }
                continue;
              }
              if (!messageDigest && attr.type === forge2.pki.oids.messageDigest) {
                messageDigest = true;
                if (contentType) {
                  break;
                }
                continue;
              }
            }
            if (!contentType || !messageDigest) {
              throw new Error("Invalid signer.authenticatedAttributes. If signer.authenticatedAttributes is specified, then it must contain at least two attributes, PKCS #9 content-type and PKCS #9 message-digest.");
            }
          }
          msg.signers.push({
            key: key2,
            version: 1,
            issuer,
            serialNumber,
            digestAlgorithm,
            signatureAlgorithm: forge2.pki.oids.rsaEncryption,
            signature: null,
            authenticatedAttributes,
            unauthenticatedAttributes: []
          });
        },
        /**
         * Signs the content.
         * @param options Options to apply when signing:
         *    [detached] boolean. If signing should be done in detached mode. Defaults to false.
         */
        sign: function(options) {
          options = options || {};
          if (typeof msg.content !== "object" || msg.contentInfo === null) {
            msg.contentInfo = asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.SEQUENCE,
              true,
              [
                // ContentType
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.OID,
                  false,
                  asn1.oidToDer(forge2.pki.oids.data).getBytes()
                )
              ]
            );
            if ("content" in msg) {
              var content2;
              if (msg.content instanceof forge2.util.ByteBuffer) {
                content2 = msg.content.bytes();
              } else if (typeof msg.content === "string") {
                content2 = forge2.util.encodeUtf8(msg.content);
              }
              if (options.detached) {
                msg.detachedContent = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, content2);
              } else {
                msg.contentInfo.value.push(
                  // [0] EXPLICIT content
                  asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
                    asn1.create(
                      asn1.Class.UNIVERSAL,
                      asn1.Type.OCTETSTRING,
                      false,
                      content2
                    )
                  ])
                );
              }
            }
          }
          if (msg.signers.length === 0) {
            return;
          }
          var mds = addDigestAlgorithmIds();
          addSignerInfos(mds);
        },
        verify: function() {
          throw new Error("PKCS#7 signature verification not yet implemented.");
        },
        /**
         * Add a certificate.
         *
         * @param cert the certificate to add.
         */
        addCertificate: function(cert) {
          if (typeof cert === "string") {
            cert = forge2.pki.certificateFromPem(cert);
          }
          msg.certificates.push(cert);
        },
        /**
         * Add a certificate revokation list.
         *
         * @param crl the certificate revokation list to add.
         */
        addCertificateRevokationList: function(crl) {
          throw new Error("PKCS#7 CRL support not yet implemented.");
        }
      };
      return msg;
      function addDigestAlgorithmIds() {
        var mds = {};
        for (var i = 0; i < msg.signers.length; ++i) {
          var signer = msg.signers[i];
          var oid = signer.digestAlgorithm;
          if (!(oid in mds)) {
            mds[oid] = forge2.md[forge2.pki.oids[oid]].create();
          }
          if (signer.authenticatedAttributes.length === 0) {
            signer.md = mds[oid];
          } else {
            signer.md = forge2.md[forge2.pki.oids[oid]].create();
          }
        }
        msg.digestAlgorithmIdentifiers = [];
        for (var oid in mds) {
          msg.digestAlgorithmIdentifiers.push(
            // AlgorithmIdentifier
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              // algorithm
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.OID,
                false,
                asn1.oidToDer(oid).getBytes()
              ),
              // parameters (null)
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
            ])
          );
        }
        return mds;
      }
      function addSignerInfos(mds) {
        var content2;
        if (msg.detachedContent) {
          content2 = msg.detachedContent;
        } else {
          content2 = msg.contentInfo.value[1];
          content2 = content2.value[0];
        }
        if (!content2) {
          throw new Error(
            "Could not sign PKCS#7 message; there is no content to sign."
          );
        }
        var contentType = asn1.derToOid(msg.contentInfo.value[0].value);
        var bytes = asn1.toDer(content2);
        bytes.getByte();
        asn1.getBerValueLength(bytes);
        bytes = bytes.getBytes();
        for (var oid in mds) {
          mds[oid].start().update(bytes);
        }
        var signingTime = /* @__PURE__ */ new Date();
        for (var i = 0; i < msg.signers.length; ++i) {
          var signer = msg.signers[i];
          if (signer.authenticatedAttributes.length === 0) {
            if (contentType !== forge2.pki.oids.data) {
              throw new Error(
                "Invalid signer; authenticatedAttributes must be present when the ContentInfo content type is not PKCS#7 Data."
              );
            }
          } else {
            signer.authenticatedAttributesAsn1 = asn1.create(
              asn1.Class.CONTEXT_SPECIFIC,
              0,
              true,
              []
            );
            var attrsAsn1 = asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.SET,
              true,
              []
            );
            for (var ai = 0; ai < signer.authenticatedAttributes.length; ++ai) {
              var attr = signer.authenticatedAttributes[ai];
              if (attr.type === forge2.pki.oids.messageDigest) {
                attr.value = mds[signer.digestAlgorithm].digest();
              } else if (attr.type === forge2.pki.oids.signingTime) {
                if (!attr.value) {
                  attr.value = signingTime;
                }
              }
              attrsAsn1.value.push(_attributeToAsn1(attr));
              signer.authenticatedAttributesAsn1.value.push(_attributeToAsn1(attr));
            }
            bytes = asn1.toDer(attrsAsn1).getBytes();
            signer.md.start().update(bytes);
          }
          signer.signature = signer.key.sign(signer.md, "RSASSA-PKCS1-V1_5");
        }
        msg.signerInfos = _signersToAsn1(msg.signers);
      }
    };
    p7.createEncryptedData = function() {
      var msg = null;
      msg = {
        type: forge2.pki.oids.encryptedData,
        version: 0,
        encryptedContent: {
          algorithm: forge2.pki.oids["aes256-CBC"]
        },
        /**
         * Reads an EncryptedData content block (in ASN.1 format)
         *
         * @param obj The ASN.1 representation of the EncryptedData content block
         */
        fromAsn1: function(obj) {
          _fromAsn1(msg, obj, p7.asn1.encryptedDataValidator);
        },
        /**
         * Decrypt encrypted content
         *
         * @param key The (symmetric) key as a byte buffer
         */
        decrypt: function(key2) {
          if (key2 !== void 0) {
            msg.encryptedContent.key = key2;
          }
          _decryptContent(msg);
        }
      };
      return msg;
    };
    p7.createEnvelopedData = function() {
      var msg = null;
      msg = {
        type: forge2.pki.oids.envelopedData,
        version: 0,
        recipients: [],
        encryptedContent: {
          algorithm: forge2.pki.oids["aes256-CBC"]
        },
        /**
         * Reads an EnvelopedData content block (in ASN.1 format)
         *
         * @param obj the ASN.1 representation of the EnvelopedData content block.
         */
        fromAsn1: function(obj) {
          var capture = _fromAsn1(msg, obj, p7.asn1.envelopedDataValidator);
          msg.recipients = _recipientsFromAsn1(capture.recipientInfos.value);
        },
        toAsn1: function() {
          return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            // ContentType
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(msg.type).getBytes()
            ),
            // [0] EnvelopedData
            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                // Version
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.INTEGER,
                  false,
                  asn1.integerToDer(msg.version).getBytes()
                ),
                // RecipientInfos
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.SET,
                  true,
                  _recipientsToAsn1(msg.recipients)
                ),
                // EncryptedContentInfo
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.SEQUENCE,
                  true,
                  _encryptedContentToAsn1(msg.encryptedContent)
                )
              ])
            ])
          ]);
        },
        /**
         * Find recipient by X.509 certificate's issuer.
         *
         * @param cert the certificate with the issuer to look for.
         *
         * @return the recipient object.
         */
        findRecipient: function(cert) {
          var sAttr = cert.issuer.attributes;
          for (var i = 0; i < msg.recipients.length; ++i) {
            var r = msg.recipients[i];
            var rAttr = r.issuer;
            if (r.serialNumber !== cert.serialNumber) {
              continue;
            }
            if (rAttr.length !== sAttr.length) {
              continue;
            }
            var match = true;
            for (var j = 0; j < sAttr.length; ++j) {
              if (rAttr[j].type !== sAttr[j].type || rAttr[j].value !== sAttr[j].value) {
                match = false;
                break;
              }
            }
            if (match) {
              return r;
            }
          }
          return null;
        },
        /**
         * Decrypt enveloped content
         *
         * @param recipient The recipient object related to the private key
         * @param privKey The (RSA) private key object
         */
        decrypt: function(recipient, privKey) {
          if (msg.encryptedContent.key === void 0 && recipient !== void 0 && privKey !== void 0) {
            switch (recipient.encryptedContent.algorithm) {
              case forge2.pki.oids.rsaEncryption:
              case forge2.pki.oids.desCBC:
                var key2 = privKey.decrypt(recipient.encryptedContent.content);
                msg.encryptedContent.key = forge2.util.createBuffer(key2);
                break;
              default:
                throw new Error("Unsupported asymmetric cipher, OID " + recipient.encryptedContent.algorithm);
            }
          }
          _decryptContent(msg);
        },
        /**
         * Add (another) entity to list of recipients.
         *
         * @param cert The certificate of the entity to add.
         */
        addRecipient: function(cert) {
          msg.recipients.push({
            version: 0,
            issuer: cert.issuer.attributes,
            serialNumber: cert.serialNumber,
            encryptedContent: {
              // We simply assume rsaEncryption here, since forge.pki only
              // supports RSA so far.  If the PKI module supports other
              // ciphers one day, we need to modify this one as well.
              algorithm: forge2.pki.oids.rsaEncryption,
              key: cert.publicKey
            }
          });
        },
        /**
         * Encrypt enveloped content.
         *
         * This function supports two optional arguments, cipher and key, which
         * can be used to influence symmetric encryption.  Unless cipher is
         * provided, the cipher specified in encryptedContent.algorithm is used
         * (defaults to AES-256-CBC).  If no key is provided, encryptedContent.key
         * is (re-)used.  If that one's not set, a random key will be generated
         * automatically.
         *
         * @param [key] The key to be used for symmetric encryption.
         * @param [cipher] The OID of the symmetric cipher to use.
         */
        encrypt: function(key2, cipher) {
          if (msg.encryptedContent.content === void 0) {
            cipher = cipher || msg.encryptedContent.algorithm;
            key2 = key2 || msg.encryptedContent.key;
            var keyLen, ivLen, ciphFn;
            switch (cipher) {
              case forge2.pki.oids["aes128-CBC"]:
                keyLen = 16;
                ivLen = 16;
                ciphFn = forge2.aes.createEncryptionCipher;
                break;
              case forge2.pki.oids["aes192-CBC"]:
                keyLen = 24;
                ivLen = 16;
                ciphFn = forge2.aes.createEncryptionCipher;
                break;
              case forge2.pki.oids["aes256-CBC"]:
                keyLen = 32;
                ivLen = 16;
                ciphFn = forge2.aes.createEncryptionCipher;
                break;
              case forge2.pki.oids["des-EDE3-CBC"]:
                keyLen = 24;
                ivLen = 8;
                ciphFn = forge2.des.createEncryptionCipher;
                break;
              default:
                throw new Error("Unsupported symmetric cipher, OID " + cipher);
            }
            if (key2 === void 0) {
              key2 = forge2.util.createBuffer(forge2.random.getBytes(keyLen));
            } else if (key2.length() != keyLen) {
              throw new Error("Symmetric key has wrong length; got " + key2.length() + " bytes, expected " + keyLen + ".");
            }
            msg.encryptedContent.algorithm = cipher;
            msg.encryptedContent.key = key2;
            msg.encryptedContent.parameter = forge2.util.createBuffer(
              forge2.random.getBytes(ivLen)
            );
            var ciph = ciphFn(key2);
            ciph.start(msg.encryptedContent.parameter.copy());
            ciph.update(msg.content);
            if (!ciph.finish()) {
              throw new Error("Symmetric encryption failed.");
            }
            msg.encryptedContent.content = ciph.output;
          }
          for (var i = 0; i < msg.recipients.length; ++i) {
            var recipient = msg.recipients[i];
            if (recipient.encryptedContent.content !== void 0) {
              continue;
            }
            switch (recipient.encryptedContent.algorithm) {
              case forge2.pki.oids.rsaEncryption:
                recipient.encryptedContent.content = recipient.encryptedContent.key.encrypt(
                  msg.encryptedContent.key.data
                );
                break;
              default:
                throw new Error("Unsupported asymmetric cipher, OID " + recipient.encryptedContent.algorithm);
            }
          }
        }
      };
      return msg;
    };
    function _recipientFromAsn1(obj) {
      var capture = {};
      var errors = [];
      if (!asn1.validate(obj, p7.asn1.recipientInfoValidator, capture, errors)) {
        var error = new Error("Cannot read PKCS#7 RecipientInfo. ASN.1 object is not an PKCS#7 RecipientInfo.");
        error.errors = errors;
        throw error;
      }
      return {
        version: capture.version.charCodeAt(0),
        issuer: forge2.pki.RDNAttributesAsArray(capture.issuer),
        serialNumber: forge2.util.createBuffer(capture.serial).toHex(),
        encryptedContent: {
          algorithm: asn1.derToOid(capture.encAlgorithm),
          parameter: capture.encParameter ? capture.encParameter.value : void 0,
          content: capture.encKey
        }
      };
    }
    function _recipientToAsn1(obj) {
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // Version
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          asn1.integerToDer(obj.version).getBytes()
        ),
        // IssuerAndSerialNumber
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // Name
          forge2.pki.distinguishedNameToAsn1({ attributes: obj.issuer }),
          // Serial
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.INTEGER,
            false,
            forge2.util.hexToBytes(obj.serialNumber)
          )
        ]),
        // KeyEncryptionAlgorithmIdentifier
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // Algorithm
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(obj.encryptedContent.algorithm).getBytes()
          ),
          // Parameter, force NULL, only RSA supported for now.
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
        ]),
        // EncryptedKey
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OCTETSTRING,
          false,
          obj.encryptedContent.content
        )
      ]);
    }
    function _recipientsFromAsn1(infos) {
      var ret = [];
      for (var i = 0; i < infos.length; ++i) {
        ret.push(_recipientFromAsn1(infos[i]));
      }
      return ret;
    }
    function _recipientsToAsn1(recipients) {
      var ret = [];
      for (var i = 0; i < recipients.length; ++i) {
        ret.push(_recipientToAsn1(recipients[i]));
      }
      return ret;
    }
    function _signerToAsn1(obj) {
      var rval = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // version
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          asn1.integerToDer(obj.version).getBytes()
        ),
        // issuerAndSerialNumber
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // name
          forge2.pki.distinguishedNameToAsn1({ attributes: obj.issuer }),
          // serial
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.INTEGER,
            false,
            forge2.util.hexToBytes(obj.serialNumber)
          )
        ]),
        // digestAlgorithm
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // algorithm
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(obj.digestAlgorithm).getBytes()
          ),
          // parameters (null)
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
        ])
      ]);
      if (obj.authenticatedAttributesAsn1) {
        rval.value.push(obj.authenticatedAttributesAsn1);
      }
      rval.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // algorithm
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OID,
          false,
          asn1.oidToDer(obj.signatureAlgorithm).getBytes()
        ),
        // parameters (null)
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
      ]));
      rval.value.push(asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.OCTETSTRING,
        false,
        obj.signature
      ));
      if (obj.unauthenticatedAttributes.length > 0) {
        var attrsAsn1 = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, []);
        for (var i = 0; i < obj.unauthenticatedAttributes.length; ++i) {
          var attr = obj.unauthenticatedAttributes[i];
          attrsAsn1.values.push(_attributeToAsn1(attr));
        }
        rval.value.push(attrsAsn1);
      }
      return rval;
    }
    function _signersToAsn1(signers) {
      var ret = [];
      for (var i = 0; i < signers.length; ++i) {
        ret.push(_signerToAsn1(signers[i]));
      }
      return ret;
    }
    function _attributeToAsn1(attr) {
      var value3;
      if (attr.type === forge2.pki.oids.contentType) {
        value3 = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OID,
          false,
          asn1.oidToDer(attr.value).getBytes()
        );
      } else if (attr.type === forge2.pki.oids.messageDigest) {
        value3 = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OCTETSTRING,
          false,
          attr.value.bytes()
        );
      } else if (attr.type === forge2.pki.oids.signingTime) {
        var jan_1_1950 = /* @__PURE__ */ new Date("1950-01-01T00:00:00Z");
        var jan_1_2050 = /* @__PURE__ */ new Date("2050-01-01T00:00:00Z");
        var date = attr.value;
        if (typeof date === "string") {
          var timestamp = Date.parse(date);
          if (!isNaN(timestamp)) {
            date = new Date(timestamp);
          } else if (date.length === 13) {
            date = asn1.utcTimeToDate(date);
          } else {
            date = asn1.generalizedTimeToDate(date);
          }
        }
        if (date >= jan_1_1950 && date < jan_1_2050) {
          value3 = asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.UTCTIME,
            false,
            asn1.dateToUtcTime(date)
          );
        } else {
          value3 = asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.GENERALIZEDTIME,
            false,
            asn1.dateToGeneralizedTime(date)
          );
        }
      }
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // AttributeType
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OID,
          false,
          asn1.oidToDer(attr.type).getBytes()
        ),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [
          // AttributeValue
          value3
        ])
      ]);
    }
    function _encryptedContentToAsn1(ec) {
      return [
        // ContentType, always Data for the moment
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OID,
          false,
          asn1.oidToDer(forge2.pki.oids.data).getBytes()
        ),
        // ContentEncryptionAlgorithmIdentifier
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // Algorithm
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(ec.algorithm).getBytes()
          ),
          // Parameters (IV)
          !ec.parameter ? void 0 : asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OCTETSTRING,
            false,
            ec.parameter.getBytes()
          )
        ]),
        // [0] EncryptedContent
        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OCTETSTRING,
            false,
            ec.content.getBytes()
          )
        ])
      ];
    }
    function _fromAsn1(msg, obj, validator) {
      var capture = {};
      var errors = [];
      if (!asn1.validate(obj, validator, capture, errors)) {
        var error = new Error("Cannot read PKCS#7 message. ASN.1 object is not a supported PKCS#7 message.");
        error.errors = error;
        throw error;
      }
      var contentType = asn1.derToOid(capture.contentType);
      if (contentType !== forge2.pki.oids.data) {
        throw new Error("Unsupported PKCS#7 message. Only wrapped ContentType Data supported.");
      }
      if (capture.encryptedContent) {
        var content2 = "";
        if (forge2.util.isArray(capture.encryptedContent)) {
          for (var i = 0; i < capture.encryptedContent.length; ++i) {
            if (capture.encryptedContent[i].type !== asn1.Type.OCTETSTRING) {
              throw new Error("Malformed PKCS#7 message, expecting encrypted content constructed of only OCTET STRING objects.");
            }
            content2 += capture.encryptedContent[i].value;
          }
        } else {
          content2 = capture.encryptedContent;
        }
        msg.encryptedContent = {
          algorithm: asn1.derToOid(capture.encAlgorithm),
          parameter: forge2.util.createBuffer(capture.encParameter.value),
          content: forge2.util.createBuffer(content2)
        };
      }
      if (capture.content) {
        var content2 = "";
        if (forge2.util.isArray(capture.content)) {
          for (var i = 0; i < capture.content.length; ++i) {
            if (capture.content[i].type !== asn1.Type.OCTETSTRING) {
              throw new Error("Malformed PKCS#7 message, expecting content constructed of only OCTET STRING objects.");
            }
            content2 += capture.content[i].value;
          }
        } else {
          content2 = capture.content;
        }
        msg.content = forge2.util.createBuffer(content2);
      }
      msg.version = capture.version.charCodeAt(0);
      msg.rawCapture = capture;
      return capture;
    }
    function _decryptContent(msg) {
      if (msg.encryptedContent.key === void 0) {
        throw new Error("Symmetric key not available.");
      }
      if (msg.content === void 0) {
        var ciph;
        switch (msg.encryptedContent.algorithm) {
          case forge2.pki.oids["aes128-CBC"]:
          case forge2.pki.oids["aes192-CBC"]:
          case forge2.pki.oids["aes256-CBC"]:
            ciph = forge2.aes.createDecryptionCipher(msg.encryptedContent.key);
            break;
          case forge2.pki.oids["desCBC"]:
          case forge2.pki.oids["des-EDE3-CBC"]:
            ciph = forge2.des.createDecryptionCipher(msg.encryptedContent.key);
            break;
          default:
            throw new Error("Unsupported symmetric cipher, OID " + msg.encryptedContent.algorithm);
        }
        ciph.start(msg.encryptedContent.parameter);
        ciph.update(msg.encryptedContent.content);
        if (!ciph.finish()) {
          throw new Error("Symmetric decryption failed.");
        }
        msg.content = ciph.output;
      }
    }
  }
});

// node_modules/@selfxyz/common/node_modules/node-forge/lib/ssh.js
var require_ssh = __commonJS({
  "node_modules/@selfxyz/common/node_modules/node-forge/lib/ssh.js"(exports2, module2) {
    var forge2 = require_forge();
    require_aes();
    require_hmac();
    require_md5();
    require_sha12();
    require_util();
    var ssh = module2.exports = forge2.ssh = forge2.ssh || {};
    ssh.privateKeyToPutty = function(privateKey, passphrase, comment) {
      comment = comment || "";
      passphrase = passphrase || "";
      var algorithm = "ssh-rsa";
      var encryptionAlgorithm = passphrase === "" ? "none" : "aes256-cbc";
      var ppk = "PuTTY-User-Key-File-2: " + algorithm + "\r\n";
      ppk += "Encryption: " + encryptionAlgorithm + "\r\n";
      ppk += "Comment: " + comment + "\r\n";
      var pubbuffer = forge2.util.createBuffer();
      _addStringToBuffer(pubbuffer, algorithm);
      _addBigIntegerToBuffer(pubbuffer, privateKey.e);
      _addBigIntegerToBuffer(pubbuffer, privateKey.n);
      var pub = forge2.util.encode64(pubbuffer.bytes(), 64);
      var length2 = Math.floor(pub.length / 66) + 1;
      ppk += "Public-Lines: " + length2 + "\r\n";
      ppk += pub;
      var privbuffer = forge2.util.createBuffer();
      _addBigIntegerToBuffer(privbuffer, privateKey.d);
      _addBigIntegerToBuffer(privbuffer, privateKey.p);
      _addBigIntegerToBuffer(privbuffer, privateKey.q);
      _addBigIntegerToBuffer(privbuffer, privateKey.qInv);
      var priv;
      if (!passphrase) {
        priv = forge2.util.encode64(privbuffer.bytes(), 64);
      } else {
        var encLen = privbuffer.length() + 16 - 1;
        encLen -= encLen % 16;
        var padding = _sha1(privbuffer.bytes());
        padding.truncate(padding.length() - encLen + privbuffer.length());
        privbuffer.putBuffer(padding);
        var aeskey = forge2.util.createBuffer();
        aeskey.putBuffer(_sha1("\0\0\0\0", passphrase));
        aeskey.putBuffer(_sha1("\0\0\0", passphrase));
        var cipher = forge2.aes.createEncryptionCipher(aeskey.truncate(8), "CBC");
        cipher.start(forge2.util.createBuffer().fillWithByte(0, 16));
        cipher.update(privbuffer.copy());
        cipher.finish();
        var encrypted = cipher.output;
        encrypted.truncate(16);
        priv = forge2.util.encode64(encrypted.bytes(), 64);
      }
      length2 = Math.floor(priv.length / 66) + 1;
      ppk += "\r\nPrivate-Lines: " + length2 + "\r\n";
      ppk += priv;
      var mackey = _sha1("putty-private-key-file-mac-key", passphrase);
      var macbuffer = forge2.util.createBuffer();
      _addStringToBuffer(macbuffer, algorithm);
      _addStringToBuffer(macbuffer, encryptionAlgorithm);
      _addStringToBuffer(macbuffer, comment);
      macbuffer.putInt32(pubbuffer.length());
      macbuffer.putBuffer(pubbuffer);
      macbuffer.putInt32(privbuffer.length());
      macbuffer.putBuffer(privbuffer);
      var hmac = forge2.hmac.create();
      hmac.start("sha1", mackey);
      hmac.update(macbuffer.bytes());
      ppk += "\r\nPrivate-MAC: " + hmac.digest().toHex() + "\r\n";
      return ppk;
    };
    ssh.publicKeyToOpenSSH = function(key2, comment) {
      var type = "ssh-rsa";
      comment = comment || "";
      var buffer = forge2.util.createBuffer();
      _addStringToBuffer(buffer, type);
      _addBigIntegerToBuffer(buffer, key2.e);
      _addBigIntegerToBuffer(buffer, key2.n);
      return type + " " + forge2.util.encode64(buffer.bytes()) + " " + comment;
    };
    ssh.privateKeyToOpenSSH = function(privateKey, passphrase) {
      if (!passphrase) {
        return forge2.pki.privateKeyToPem(privateKey);
      }
      return forge2.pki.encryptRsaPrivateKey(
        privateKey,
        passphrase,
        { legacy: true, algorithm: "aes128" }
      );
    };
    ssh.getPublicKeyFingerprint = function(key2, options) {
      options = options || {};
      var md = options.md || forge2.md.md5.create();
      var type = "ssh-rsa";
      var buffer = forge2.util.createBuffer();
      _addStringToBuffer(buffer, type);
      _addBigIntegerToBuffer(buffer, key2.e);
      _addBigIntegerToBuffer(buffer, key2.n);
      md.start();
      md.update(buffer.getBytes());
      var digest = md.digest();
      if (options.encoding === "hex") {
        var hex = digest.toHex();
        if (options.delimiter) {
          return hex.match(/.{2}/g).join(options.delimiter);
        }
        return hex;
      } else if (options.encoding === "binary") {
        return digest.getBytes();
      } else if (options.encoding) {
        throw new Error('Unknown encoding "' + options.encoding + '".');
      }
      return digest;
    };
    function _addBigIntegerToBuffer(buffer, val2) {
      var hexVal = val2.toString(16);
      if (hexVal[0] >= "8") {
        hexVal = "00" + hexVal;
      }
      var bytes = forge2.util.hexToBytes(hexVal);
      buffer.putInt32(bytes.length);
      buffer.putBytes(bytes);
    }
    function _addStringToBuffer(buffer, val2) {
      buffer.putInt32(val2.length);
      buffer.putString(val2);
    }
    function _sha1() {
      var sha = forge2.md.sha1.create();
      var num = arguments.length;
      for (var i = 0; i < num; ++i) {
        sha.update(arguments[i]);
      }
      return sha.digest();
    }
  }
});

// node_modules/@selfxyz/common/node_modules/node-forge/lib/index.js
var require_lib = __commonJS({
  "node_modules/@selfxyz/common/node_modules/node-forge/lib/index.js"(exports2, module2) {
    module2.exports = require_forge();
    require_aes();
    require_aesCipherSuites();
    require_asn1();
    require_cipher();
    require_des();
    require_ed25519();
    require_hmac();
    require_kem();
    require_log();
    require_md_all();
    require_mgf1();
    require_pbkdf2();
    require_pem();
    require_pkcs1();
    require_pkcs12();
    require_pkcs7();
    require_pki();
    require_prime();
    require_prng();
    require_pss();
    require_random();
    require_rc2();
    require_ssh();
    require_tls();
    require_util();
  }
});

// node_modules/@selfxyz/qrcode/dist/chunk-S3YCKNTC.js
var QRcodeSteps = {
  DISCONNECTED: 0,
  WAITING_FOR_MOBILE: 1,
  MOBILE_CONNECTED: 2,
  PROOF_GENERATION_STARTED: 3,
  PROOF_GENERATION_FAILED: 4,
  PROOF_GENERATED: 5,
  PROOF_VERIFIED: 6
};

// node_modules/@selfxyz/qrcode/dist/chunk-CXII3ZQQ.js
var import_react = __toESM(require_react(), 1);
var green = "#31F040";
var blue = "#424AD8";
var gray = "#95a5a6";
var LED = ({
  size = 8,
  connectionStatus = QRcodeSteps.DISCONNECTED
}) => {
  const getColor = () => {
    if (connectionStatus >= QRcodeSteps.MOBILE_CONNECTED) {
      return green;
    } else if (connectionStatus >= QRcodeSteps.WAITING_FOR_MOBILE) {
      return blue;
    } else {
      return gray;
    }
  };
  return import_react.default.createElement(
    "div",
    {
      style: {
        width: `${size}px`,
        height: `${size}px`,
        borderRadius: "50%",
        backgroundColor: getColor(),
        boxShadow: `0 0 ${size * 1.5}px ${getColor()}`,
        transition: "all 0.3s ease",
        marginBottom: "8px"
      }
    }
  );
};
var LED_default = LED;

// node_modules/@selfxyz/qrcode/dist/chunk-OWXV7T5Z.js
var containerStyle = {
  display: "flex",
  flexDirection: "column",
  alignItems: "center",
  width: "100%"
};
var ledContainerStyle = {
  marginBottom: "4px"
};
var qrContainerStyle = (size) => ({
  width: `${size}px`,
  height: `${size}px`,
  display: "flex",
  alignItems: "center",
  justifyContent: "center"
});

// node_modules/engine.io-parser/build/esm/commons.js
var PACKET_TYPES = /* @__PURE__ */ Object.create(null);
PACKET_TYPES["open"] = "0";
PACKET_TYPES["close"] = "1";
PACKET_TYPES["ping"] = "2";
PACKET_TYPES["pong"] = "3";
PACKET_TYPES["message"] = "4";
PACKET_TYPES["upgrade"] = "5";
PACKET_TYPES["noop"] = "6";
var PACKET_TYPES_REVERSE = /* @__PURE__ */ Object.create(null);
Object.keys(PACKET_TYPES).forEach((key2) => {
  PACKET_TYPES_REVERSE[PACKET_TYPES[key2]] = key2;
});
var ERROR_PACKET = { type: "error", data: "parser error" };

// node_modules/engine.io-parser/build/esm/encodePacket.browser.js
var withNativeBlob = typeof Blob === "function" || typeof Blob !== "undefined" && Object.prototype.toString.call(Blob) === "[object BlobConstructor]";
var withNativeArrayBuffer = typeof ArrayBuffer === "function";
var isView = (obj) => {
  return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj && obj.buffer instanceof ArrayBuffer;
};
var encodePacket = ({ type, data: data2 }, supportsBinary, callback) => {
  if (withNativeBlob && data2 instanceof Blob) {
    if (supportsBinary) {
      return callback(data2);
    } else {
      return encodeBlobAsBase64(data2, callback);
    }
  } else if (withNativeArrayBuffer && (data2 instanceof ArrayBuffer || isView(data2))) {
    if (supportsBinary) {
      return callback(data2);
    } else {
      return encodeBlobAsBase64(new Blob([data2]), callback);
    }
  }
  return callback(PACKET_TYPES[type] + (data2 || ""));
};
var encodeBlobAsBase64 = (data2, callback) => {
  const fileReader = new FileReader();
  fileReader.onload = function() {
    const content2 = fileReader.result.split(",")[1];
    callback("b" + (content2 || ""));
  };
  return fileReader.readAsDataURL(data2);
};
function toArray(data2) {
  if (data2 instanceof Uint8Array) {
    return data2;
  } else if (data2 instanceof ArrayBuffer) {
    return new Uint8Array(data2);
  } else {
    return new Uint8Array(data2.buffer, data2.byteOffset, data2.byteLength);
  }
}
var TEXT_ENCODER;
function encodePacketToBinary(packet, callback) {
  if (withNativeBlob && packet.data instanceof Blob) {
    return packet.data.arrayBuffer().then(toArray).then(callback);
  } else if (withNativeArrayBuffer && (packet.data instanceof ArrayBuffer || isView(packet.data))) {
    return callback(toArray(packet.data));
  }
  encodePacket(packet, false, (encoded) => {
    if (!TEXT_ENCODER) {
      TEXT_ENCODER = new TextEncoder();
    }
    callback(TEXT_ENCODER.encode(encoded));
  });
}

// node_modules/engine.io-parser/build/esm/contrib/base64-arraybuffer.js
var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var lookup = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
for (let i = 0; i < chars.length; i++) {
  lookup[chars.charCodeAt(i)] = i;
}
var decode = (base64) => {
  let bufferLength = base64.length * 0.75, len = base64.length, i, p = 0, encoded1, encoded2, encoded3, encoded4;
  if (base64[base64.length - 1] === "=") {
    bufferLength--;
    if (base64[base64.length - 2] === "=") {
      bufferLength--;
    }
  }
  const arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);
  for (i = 0; i < len; i += 4) {
    encoded1 = lookup[base64.charCodeAt(i)];
    encoded2 = lookup[base64.charCodeAt(i + 1)];
    encoded3 = lookup[base64.charCodeAt(i + 2)];
    encoded4 = lookup[base64.charCodeAt(i + 3)];
    bytes[p++] = encoded1 << 2 | encoded2 >> 4;
    bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
    bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
  }
  return arraybuffer;
};

// node_modules/engine.io-parser/build/esm/decodePacket.browser.js
var withNativeArrayBuffer2 = typeof ArrayBuffer === "function";
var decodePacket = (encodedPacket, binaryType) => {
  if (typeof encodedPacket !== "string") {
    return {
      type: "message",
      data: mapBinary(encodedPacket, binaryType)
    };
  }
  const type = encodedPacket.charAt(0);
  if (type === "b") {
    return {
      type: "message",
      data: decodeBase64Packet(encodedPacket.substring(1), binaryType)
    };
  }
  const packetType = PACKET_TYPES_REVERSE[type];
  if (!packetType) {
    return ERROR_PACKET;
  }
  return encodedPacket.length > 1 ? {
    type: PACKET_TYPES_REVERSE[type],
    data: encodedPacket.substring(1)
  } : {
    type: PACKET_TYPES_REVERSE[type]
  };
};
var decodeBase64Packet = (data2, binaryType) => {
  if (withNativeArrayBuffer2) {
    const decoded = decode(data2);
    return mapBinary(decoded, binaryType);
  } else {
    return { base64: true, data: data2 };
  }
};
var mapBinary = (data2, binaryType) => {
  switch (binaryType) {
    case "blob":
      if (data2 instanceof Blob) {
        return data2;
      } else {
        return new Blob([data2]);
      }
    case "arraybuffer":
    default:
      if (data2 instanceof ArrayBuffer) {
        return data2;
      } else {
        return data2.buffer;
      }
  }
};

// node_modules/engine.io-parser/build/esm/index.js
var SEPARATOR = String.fromCharCode(30);
var encodePayload = (packets, callback) => {
  const length2 = packets.length;
  const encodedPackets = new Array(length2);
  let count = 0;
  packets.forEach((packet, i) => {
    encodePacket(packet, false, (encodedPacket) => {
      encodedPackets[i] = encodedPacket;
      if (++count === length2) {
        callback(encodedPackets.join(SEPARATOR));
      }
    });
  });
};
var decodePayload = (encodedPayload, binaryType) => {
  const encodedPackets = encodedPayload.split(SEPARATOR);
  const packets = [];
  for (let i = 0; i < encodedPackets.length; i++) {
    const decodedPacket = decodePacket(encodedPackets[i], binaryType);
    packets.push(decodedPacket);
    if (decodedPacket.type === "error") {
      break;
    }
  }
  return packets;
};
function createPacketEncoderStream() {
  return new TransformStream({
    transform(packet, controller) {
      encodePacketToBinary(packet, (encodedPacket) => {
        const payloadLength = encodedPacket.length;
        let header;
        if (payloadLength < 126) {
          header = new Uint8Array(1);
          new DataView(header.buffer).setUint8(0, payloadLength);
        } else if (payloadLength < 65536) {
          header = new Uint8Array(3);
          const view = new DataView(header.buffer);
          view.setUint8(0, 126);
          view.setUint16(1, payloadLength);
        } else {
          header = new Uint8Array(9);
          const view = new DataView(header.buffer);
          view.setUint8(0, 127);
          view.setBigUint64(1, BigInt(payloadLength));
        }
        if (packet.data && typeof packet.data !== "string") {
          header[0] |= 128;
        }
        controller.enqueue(header);
        controller.enqueue(encodedPacket);
      });
    }
  });
}
var TEXT_DECODER;
function totalLength(chunks) {
  return chunks.reduce((acc, chunk) => acc + chunk.length, 0);
}
function concatChunks(chunks, size) {
  if (chunks[0].length === size) {
    return chunks.shift();
  }
  const buffer = new Uint8Array(size);
  let j = 0;
  for (let i = 0; i < size; i++) {
    buffer[i] = chunks[0][j++];
    if (j === chunks[0].length) {
      chunks.shift();
      j = 0;
    }
  }
  if (chunks.length && j < chunks[0].length) {
    chunks[0] = chunks[0].slice(j);
  }
  return buffer;
}
function createPacketDecoderStream(maxPayload, binaryType) {
  if (!TEXT_DECODER) {
    TEXT_DECODER = new TextDecoder();
  }
  const chunks = [];
  let state = 0;
  let expectedLength = -1;
  let isBinary2 = false;
  return new TransformStream({
    transform(chunk, controller) {
      chunks.push(chunk);
      while (true) {
        if (state === 0) {
          if (totalLength(chunks) < 1) {
            break;
          }
          const header = concatChunks(chunks, 1);
          isBinary2 = (header[0] & 128) === 128;
          expectedLength = header[0] & 127;
          if (expectedLength < 126) {
            state = 3;
          } else if (expectedLength === 126) {
            state = 1;
          } else {
            state = 2;
          }
        } else if (state === 1) {
          if (totalLength(chunks) < 2) {
            break;
          }
          const headerArray = concatChunks(chunks, 2);
          expectedLength = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length).getUint16(0);
          state = 3;
        } else if (state === 2) {
          if (totalLength(chunks) < 8) {
            break;
          }
          const headerArray = concatChunks(chunks, 8);
          const view = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length);
          const n = view.getUint32(0);
          if (n > Math.pow(2, 53 - 32) - 1) {
            controller.enqueue(ERROR_PACKET);
            break;
          }
          expectedLength = n * Math.pow(2, 32) + view.getUint32(4);
          state = 3;
        } else {
          if (totalLength(chunks) < expectedLength) {
            break;
          }
          const data2 = concatChunks(chunks, expectedLength);
          controller.enqueue(decodePacket(isBinary2 ? data2 : TEXT_DECODER.decode(data2), binaryType));
          state = 0;
        }
        if (expectedLength === 0 || expectedLength > maxPayload) {
          controller.enqueue(ERROR_PACKET);
          break;
        }
      }
    }
  });
}
var protocol = 4;

// node_modules/@socket.io/component-emitter/lib/esm/index.js
function Emitter(obj) {
  if (obj) return mixin(obj);
}
function mixin(obj) {
  for (var key2 in Emitter.prototype) {
    obj[key2] = Emitter.prototype[key2];
  }
  return obj;
}
Emitter.prototype.on = Emitter.prototype.addEventListener = function(event, fn) {
  this._callbacks = this._callbacks || {};
  (this._callbacks["$" + event] = this._callbacks["$" + event] || []).push(fn);
  return this;
};
Emitter.prototype.once = function(event, fn) {
  function on2() {
    this.off(event, on2);
    fn.apply(this, arguments);
  }
  on2.fn = fn;
  this.on(event, on2);
  return this;
};
Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function(event, fn) {
  this._callbacks = this._callbacks || {};
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }
  var callbacks = this._callbacks["$" + event];
  if (!callbacks) return this;
  if (1 == arguments.length) {
    delete this._callbacks["$" + event];
    return this;
  }
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  if (callbacks.length === 0) {
    delete this._callbacks["$" + event];
  }
  return this;
};
Emitter.prototype.emit = function(event) {
  this._callbacks = this._callbacks || {};
  var args = new Array(arguments.length - 1), callbacks = this._callbacks["$" + event];
  for (var i = 1; i < arguments.length; i++) {
    args[i - 1] = arguments[i];
  }
  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }
  return this;
};
Emitter.prototype.emitReserved = Emitter.prototype.emit;
Emitter.prototype.listeners = function(event) {
  this._callbacks = this._callbacks || {};
  return this._callbacks["$" + event] || [];
};
Emitter.prototype.hasListeners = function(event) {
  return !!this.listeners(event).length;
};

// node_modules/engine.io-client/build/esm/globals.js
var nextTick = (() => {
  const isPromiseAvailable = typeof Promise === "function" && typeof Promise.resolve === "function";
  if (isPromiseAvailable) {
    return (cb) => Promise.resolve().then(cb);
  } else {
    return (cb, setTimeoutFn) => setTimeoutFn(cb, 0);
  }
})();
var globalThisShim = (() => {
  if (typeof self !== "undefined") {
    return self;
  } else if (typeof window !== "undefined") {
    return window;
  } else {
    return Function("return this")();
  }
})();
var defaultBinaryType = "arraybuffer";
function createCookieJar() {
}

// node_modules/engine.io-client/build/esm/util.js
function pick(obj, ...attr) {
  return attr.reduce((acc, k) => {
    if (obj.hasOwnProperty(k)) {
      acc[k] = obj[k];
    }
    return acc;
  }, {});
}
var NATIVE_SET_TIMEOUT = globalThisShim.setTimeout;
var NATIVE_CLEAR_TIMEOUT = globalThisShim.clearTimeout;
function installTimerFunctions(obj, opts) {
  if (opts.useNativeTimers) {
    obj.setTimeoutFn = NATIVE_SET_TIMEOUT.bind(globalThisShim);
    obj.clearTimeoutFn = NATIVE_CLEAR_TIMEOUT.bind(globalThisShim);
  } else {
    obj.setTimeoutFn = globalThisShim.setTimeout.bind(globalThisShim);
    obj.clearTimeoutFn = globalThisShim.clearTimeout.bind(globalThisShim);
  }
}
var BASE64_OVERHEAD = 1.33;
function byteLength(obj) {
  if (typeof obj === "string") {
    return utf8Length(obj);
  }
  return Math.ceil((obj.byteLength || obj.size) * BASE64_OVERHEAD);
}
function utf8Length(str) {
  let c = 0, length2 = 0;
  for (let i = 0, l = str.length; i < l; i++) {
    c = str.charCodeAt(i);
    if (c < 128) {
      length2 += 1;
    } else if (c < 2048) {
      length2 += 2;
    } else if (c < 55296 || c >= 57344) {
      length2 += 3;
    } else {
      i++;
      length2 += 4;
    }
  }
  return length2;
}
function randomString() {
  return Date.now().toString(36).substring(3) + Math.random().toString(36).substring(2, 5);
}

// node_modules/engine.io-client/build/esm/contrib/parseqs.js
function encode(obj) {
  let str = "";
  for (let i in obj) {
    if (obj.hasOwnProperty(i)) {
      if (str.length)
        str += "&";
      str += encodeURIComponent(i) + "=" + encodeURIComponent(obj[i]);
    }
  }
  return str;
}
function decode2(qs) {
  let qry = {};
  let pairs = qs.split("&");
  for (let i = 0, l = pairs.length; i < l; i++) {
    let pair = pairs[i].split("=");
    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
  }
  return qry;
}

// node_modules/engine.io-client/build/esm/transport.js
var TransportError = class extends Error {
  constructor(reason, description, context) {
    super(reason);
    this.description = description;
    this.context = context;
    this.type = "TransportError";
  }
};
var Transport = class extends Emitter {
  /**
   * Transport abstract constructor.
   *
   * @param {Object} opts - options
   * @protected
   */
  constructor(opts) {
    super();
    this.writable = false;
    installTimerFunctions(this, opts);
    this.opts = opts;
    this.query = opts.query;
    this.socket = opts.socket;
    this.supportsBinary = !opts.forceBase64;
  }
  /**
   * Emits an error.
   *
   * @param {String} reason
   * @param description
   * @param context - the error context
   * @return {Transport} for chaining
   * @protected
   */
  onError(reason, description, context) {
    super.emitReserved("error", new TransportError(reason, description, context));
    return this;
  }
  /**
   * Opens the transport.
   */
  open() {
    this.readyState = "opening";
    this.doOpen();
    return this;
  }
  /**
   * Closes the transport.
   */
  close() {
    if (this.readyState === "opening" || this.readyState === "open") {
      this.doClose();
      this.onClose();
    }
    return this;
  }
  /**
   * Sends multiple packets.
   *
   * @param {Array} packets
   */
  send(packets) {
    if (this.readyState === "open") {
      this.write(packets);
    } else {
    }
  }
  /**
   * Called upon open
   *
   * @protected
   */
  onOpen() {
    this.readyState = "open";
    this.writable = true;
    super.emitReserved("open");
  }
  /**
   * Called with data.
   *
   * @param {String} data
   * @protected
   */
  onData(data2) {
    const packet = decodePacket(data2, this.socket.binaryType);
    this.onPacket(packet);
  }
  /**
   * Called with a decoded packet.
   *
   * @protected
   */
  onPacket(packet) {
    super.emitReserved("packet", packet);
  }
  /**
   * Called upon close.
   *
   * @protected
   */
  onClose(details) {
    this.readyState = "closed";
    super.emitReserved("close", details);
  }
  /**
   * Pauses the transport, in order not to lose packets during an upgrade.
   *
   * @param onPause
   */
  pause(onPause) {
  }
  createUri(schema, query = {}) {
    return schema + "://" + this._hostname() + this._port() + this.opts.path + this._query(query);
  }
  _hostname() {
    const hostname = this.opts.hostname;
    return hostname.indexOf(":") === -1 ? hostname : "[" + hostname + "]";
  }
  _port() {
    if (this.opts.port && (this.opts.secure && Number(this.opts.port !== 443) || !this.opts.secure && Number(this.opts.port) !== 80)) {
      return ":" + this.opts.port;
    } else {
      return "";
    }
  }
  _query(query) {
    const encodedQuery = encode(query);
    return encodedQuery.length ? "?" + encodedQuery : "";
  }
};

// node_modules/engine.io-client/build/esm/transports/polling.js
var Polling = class extends Transport {
  constructor() {
    super(...arguments);
    this._polling = false;
  }
  get name() {
    return "polling";
  }
  /**
   * Opens the socket (triggers polling). We write a PING message to determine
   * when the transport is open.
   *
   * @protected
   */
  doOpen() {
    this._poll();
  }
  /**
   * Pauses polling.
   *
   * @param {Function} onPause - callback upon buffers are flushed and transport is paused
   * @package
   */
  pause(onPause) {
    this.readyState = "pausing";
    const pause = () => {
      this.readyState = "paused";
      onPause();
    };
    if (this._polling || !this.writable) {
      let total = 0;
      if (this._polling) {
        total++;
        this.once("pollComplete", function() {
          --total || pause();
        });
      }
      if (!this.writable) {
        total++;
        this.once("drain", function() {
          --total || pause();
        });
      }
    } else {
      pause();
    }
  }
  /**
   * Starts polling cycle.
   *
   * @private
   */
  _poll() {
    this._polling = true;
    this.doPoll();
    this.emitReserved("poll");
  }
  /**
   * Overloads onData to detect payloads.
   *
   * @protected
   */
  onData(data2) {
    const callback = (packet) => {
      if ("opening" === this.readyState && packet.type === "open") {
        this.onOpen();
      }
      if ("close" === packet.type) {
        this.onClose({ description: "transport closed by the server" });
        return false;
      }
      this.onPacket(packet);
    };
    decodePayload(data2, this.socket.binaryType).forEach(callback);
    if ("closed" !== this.readyState) {
      this._polling = false;
      this.emitReserved("pollComplete");
      if ("open" === this.readyState) {
        this._poll();
      } else {
      }
    }
  }
  /**
   * For polling, send a close packet.
   *
   * @protected
   */
  doClose() {
    const close = () => {
      this.write([{ type: "close" }]);
    };
    if ("open" === this.readyState) {
      close();
    } else {
      this.once("open", close);
    }
  }
  /**
   * Writes a packets payload.
   *
   * @param {Array} packets - data packets
   * @protected
   */
  write(packets) {
    this.writable = false;
    encodePayload(packets, (data2) => {
      this.doWrite(data2, () => {
        this.writable = true;
        this.emitReserved("drain");
      });
    });
  }
  /**
   * Generates uri for connection.
   *
   * @private
   */
  uri() {
    const schema = this.opts.secure ? "https" : "http";
    const query = this.query || {};
    if (false !== this.opts.timestampRequests) {
      query[this.opts.timestampParam] = randomString();
    }
    if (!this.supportsBinary && !query.sid) {
      query.b64 = 1;
    }
    return this.createUri(schema, query);
  }
};

// node_modules/engine.io-client/build/esm/contrib/has-cors.js
var value2 = false;
try {
  value2 = typeof XMLHttpRequest !== "undefined" && "withCredentials" in new XMLHttpRequest();
} catch (err) {
}
var hasCORS = value2;

// node_modules/engine.io-client/build/esm/transports/polling-xhr.js
function empty() {
}
var BaseXHR = class extends Polling {
  /**
   * XHR Polling constructor.
   *
   * @param {Object} opts
   * @package
   */
  constructor(opts) {
    super(opts);
    if (typeof location !== "undefined") {
      const isSSL = "https:" === location.protocol;
      let port = location.port;
      if (!port) {
        port = isSSL ? "443" : "80";
      }
      this.xd = typeof location !== "undefined" && opts.hostname !== location.hostname || port !== opts.port;
    }
  }
  /**
   * Sends data.
   *
   * @param {String} data to send.
   * @param {Function} called upon flush.
   * @private
   */
  doWrite(data2, fn) {
    const req = this.request({
      method: "POST",
      data: data2
    });
    req.on("success", fn);
    req.on("error", (xhrStatus, context) => {
      this.onError("xhr post error", xhrStatus, context);
    });
  }
  /**
   * Starts a poll cycle.
   *
   * @private
   */
  doPoll() {
    const req = this.request();
    req.on("data", this.onData.bind(this));
    req.on("error", (xhrStatus, context) => {
      this.onError("xhr poll error", xhrStatus, context);
    });
    this.pollXhr = req;
  }
};
var Request = class _Request extends Emitter {
  /**
   * Request constructor
   *
   * @param {Object} options
   * @package
   */
  constructor(createRequest, uri, opts) {
    super();
    this.createRequest = createRequest;
    installTimerFunctions(this, opts);
    this._opts = opts;
    this._method = opts.method || "GET";
    this._uri = uri;
    this._data = void 0 !== opts.data ? opts.data : null;
    this._create();
  }
  /**
   * Creates the XHR object and sends the request.
   *
   * @private
   */
  _create() {
    var _a;
    const opts = pick(this._opts, "agent", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref");
    opts.xdomain = !!this._opts.xd;
    const xhr = this._xhr = this.createRequest(opts);
    try {
      xhr.open(this._method, this._uri, true);
      try {
        if (this._opts.extraHeaders) {
          xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);
          for (let i in this._opts.extraHeaders) {
            if (this._opts.extraHeaders.hasOwnProperty(i)) {
              xhr.setRequestHeader(i, this._opts.extraHeaders[i]);
            }
          }
        }
      } catch (e) {
      }
      if ("POST" === this._method) {
        try {
          xhr.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
        } catch (e) {
        }
      }
      try {
        xhr.setRequestHeader("Accept", "*/*");
      } catch (e) {
      }
      (_a = this._opts.cookieJar) === null || _a === void 0 ? void 0 : _a.addCookies(xhr);
      if ("withCredentials" in xhr) {
        xhr.withCredentials = this._opts.withCredentials;
      }
      if (this._opts.requestTimeout) {
        xhr.timeout = this._opts.requestTimeout;
      }
      xhr.onreadystatechange = () => {
        var _a2;
        if (xhr.readyState === 3) {
          (_a2 = this._opts.cookieJar) === null || _a2 === void 0 ? void 0 : _a2.parseCookies(
            // @ts-ignore
            xhr.getResponseHeader("set-cookie")
          );
        }
        if (4 !== xhr.readyState)
          return;
        if (200 === xhr.status || 1223 === xhr.status) {
          this._onLoad();
        } else {
          this.setTimeoutFn(() => {
            this._onError(typeof xhr.status === "number" ? xhr.status : 0);
          }, 0);
        }
      };
      xhr.send(this._data);
    } catch (e) {
      this.setTimeoutFn(() => {
        this._onError(e);
      }, 0);
      return;
    }
    if (typeof document !== "undefined") {
      this._index = _Request.requestsCount++;
      _Request.requests[this._index] = this;
    }
  }
  /**
   * Called upon error.
   *
   * @private
   */
  _onError(err) {
    this.emitReserved("error", err, this._xhr);
    this._cleanup(true);
  }
  /**
   * Cleans up house.
   *
   * @private
   */
  _cleanup(fromError) {
    if ("undefined" === typeof this._xhr || null === this._xhr) {
      return;
    }
    this._xhr.onreadystatechange = empty;
    if (fromError) {
      try {
        this._xhr.abort();
      } catch (e) {
      }
    }
    if (typeof document !== "undefined") {
      delete _Request.requests[this._index];
    }
    this._xhr = null;
  }
  /**
   * Called upon load.
   *
   * @private
   */
  _onLoad() {
    const data2 = this._xhr.responseText;
    if (data2 !== null) {
      this.emitReserved("data", data2);
      this.emitReserved("success");
      this._cleanup();
    }
  }
  /**
   * Aborts the request.
   *
   * @package
   */
  abort() {
    this._cleanup();
  }
};
Request.requestsCount = 0;
Request.requests = {};
if (typeof document !== "undefined") {
  if (typeof attachEvent === "function") {
    attachEvent("onunload", unloadHandler);
  } else if (typeof addEventListener === "function") {
    const terminationEvent = "onpagehide" in globalThisShim ? "pagehide" : "unload";
    addEventListener(terminationEvent, unloadHandler, false);
  }
}
function unloadHandler() {
  for (let i in Request.requests) {
    if (Request.requests.hasOwnProperty(i)) {
      Request.requests[i].abort();
    }
  }
}
var hasXHR2 = function() {
  const xhr = newRequest({
    xdomain: false
  });
  return xhr && xhr.responseType !== null;
}();
var XHR = class extends BaseXHR {
  constructor(opts) {
    super(opts);
    const forceBase64 = opts && opts.forceBase64;
    this.supportsBinary = hasXHR2 && !forceBase64;
  }
  request(opts = {}) {
    Object.assign(opts, { xd: this.xd }, this.opts);
    return new Request(newRequest, this.uri(), opts);
  }
};
function newRequest(opts) {
  const xdomain = opts.xdomain;
  try {
    if ("undefined" !== typeof XMLHttpRequest && (!xdomain || hasCORS)) {
      return new XMLHttpRequest();
    }
  } catch (e) {
  }
  if (!xdomain) {
    try {
      return new globalThisShim[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP");
    } catch (e) {
    }
  }
}

// node_modules/engine.io-client/build/esm/transports/websocket.js
var isReactNative = typeof navigator !== "undefined" && typeof navigator.product === "string" && navigator.product.toLowerCase() === "reactnative";
var BaseWS = class extends Transport {
  get name() {
    return "websocket";
  }
  doOpen() {
    const uri = this.uri();
    const protocols = this.opts.protocols;
    const opts = isReactNative ? {} : pick(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity");
    if (this.opts.extraHeaders) {
      opts.headers = this.opts.extraHeaders;
    }
    try {
      this.ws = this.createSocket(uri, protocols, opts);
    } catch (err) {
      return this.emitReserved("error", err);
    }
    this.ws.binaryType = this.socket.binaryType;
    this.addEventListeners();
  }
  /**
   * Adds event listeners to the socket
   *
   * @private
   */
  addEventListeners() {
    this.ws.onopen = () => {
      if (this.opts.autoUnref) {
        this.ws._socket.unref();
      }
      this.onOpen();
    };
    this.ws.onclose = (closeEvent) => this.onClose({
      description: "websocket connection closed",
      context: closeEvent
    });
    this.ws.onmessage = (ev) => this.onData(ev.data);
    this.ws.onerror = (e) => this.onError("websocket error", e);
  }
  write(packets) {
    this.writable = false;
    for (let i = 0; i < packets.length; i++) {
      const packet = packets[i];
      const lastPacket = i === packets.length - 1;
      encodePacket(packet, this.supportsBinary, (data2) => {
        try {
          this.doWrite(packet, data2);
        } catch (e) {
        }
        if (lastPacket) {
          nextTick(() => {
            this.writable = true;
            this.emitReserved("drain");
          }, this.setTimeoutFn);
        }
      });
    }
  }
  doClose() {
    if (typeof this.ws !== "undefined") {
      this.ws.onerror = () => {
      };
      this.ws.close();
      this.ws = null;
    }
  }
  /**
   * Generates uri for connection.
   *
   * @private
   */
  uri() {
    const schema = this.opts.secure ? "wss" : "ws";
    const query = this.query || {};
    if (this.opts.timestampRequests) {
      query[this.opts.timestampParam] = randomString();
    }
    if (!this.supportsBinary) {
      query.b64 = 1;
    }
    return this.createUri(schema, query);
  }
};
var WebSocketCtor = globalThisShim.WebSocket || globalThisShim.MozWebSocket;
var WS = class extends BaseWS {
  createSocket(uri, protocols, opts) {
    return !isReactNative ? protocols ? new WebSocketCtor(uri, protocols) : new WebSocketCtor(uri) : new WebSocketCtor(uri, protocols, opts);
  }
  doWrite(_packet, data2) {
    this.ws.send(data2);
  }
};

// node_modules/engine.io-client/build/esm/transports/webtransport.js
var WT = class extends Transport {
  get name() {
    return "webtransport";
  }
  doOpen() {
    try {
      this._transport = new WebTransport(this.createUri("https"), this.opts.transportOptions[this.name]);
    } catch (err) {
      return this.emitReserved("error", err);
    }
    this._transport.closed.then(() => {
      this.onClose();
    }).catch((err) => {
      this.onError("webtransport error", err);
    });
    this._transport.ready.then(() => {
      this._transport.createBidirectionalStream().then((stream) => {
        const decoderStream = createPacketDecoderStream(Number.MAX_SAFE_INTEGER, this.socket.binaryType);
        const reader = stream.readable.pipeThrough(decoderStream).getReader();
        const encoderStream = createPacketEncoderStream();
        encoderStream.readable.pipeTo(stream.writable);
        this._writer = encoderStream.writable.getWriter();
        const read = () => {
          reader.read().then(({ done, value: value3 }) => {
            if (done) {
              return;
            }
            this.onPacket(value3);
            read();
          }).catch((err) => {
          });
        };
        read();
        const packet = { type: "open" };
        if (this.query.sid) {
          packet.data = `{"sid":"${this.query.sid}"}`;
        }
        this._writer.write(packet).then(() => this.onOpen());
      });
    });
  }
  write(packets) {
    this.writable = false;
    for (let i = 0; i < packets.length; i++) {
      const packet = packets[i];
      const lastPacket = i === packets.length - 1;
      this._writer.write(packet).then(() => {
        if (lastPacket) {
          nextTick(() => {
            this.writable = true;
            this.emitReserved("drain");
          }, this.setTimeoutFn);
        }
      });
    }
  }
  doClose() {
    var _a;
    (_a = this._transport) === null || _a === void 0 ? void 0 : _a.close();
  }
};

// node_modules/engine.io-client/build/esm/transports/index.js
var transports = {
  websocket: WS,
  webtransport: WT,
  polling: XHR
};

// node_modules/engine.io-client/build/esm/contrib/parseuri.js
var re = /^(?:(?![^:@\/?#]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@\/?#]*)(?::([^:@\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;
var parts = [
  "source",
  "protocol",
  "authority",
  "userInfo",
  "user",
  "password",
  "host",
  "port",
  "relative",
  "path",
  "directory",
  "file",
  "query",
  "anchor"
];
function parse(str) {
  if (str.length > 8e3) {
    throw "URI too long";
  }
  const src = str, b = str.indexOf("["), e = str.indexOf("]");
  if (b != -1 && e != -1) {
    str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ";") + str.substring(e, str.length);
  }
  let m = re.exec(str || ""), uri = {}, i = 14;
  while (i--) {
    uri[parts[i]] = m[i] || "";
  }
  if (b != -1 && e != -1) {
    uri.source = src;
    uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ":");
    uri.authority = uri.authority.replace("[", "").replace("]", "").replace(/;/g, ":");
    uri.ipv6uri = true;
  }
  uri.pathNames = pathNames(uri, uri["path"]);
  uri.queryKey = queryKey(uri, uri["query"]);
  return uri;
}
function pathNames(obj, path) {
  const regx = /\/{2,9}/g, names = path.replace(regx, "/").split("/");
  if (path.slice(0, 1) == "/" || path.length === 0) {
    names.splice(0, 1);
  }
  if (path.slice(-1) == "/") {
    names.splice(names.length - 1, 1);
  }
  return names;
}
function queryKey(uri, query) {
  const data2 = {};
  query.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function($0, $1, $2) {
    if ($1) {
      data2[$1] = $2;
    }
  });
  return data2;
}

// node_modules/engine.io-client/build/esm/socket.js
var withEventListeners = typeof addEventListener === "function" && typeof removeEventListener === "function";
var OFFLINE_EVENT_LISTENERS = [];
if (withEventListeners) {
  addEventListener("offline", () => {
    OFFLINE_EVENT_LISTENERS.forEach((listener) => listener());
  }, false);
}
var SocketWithoutUpgrade = class _SocketWithoutUpgrade extends Emitter {
  /**
   * Socket constructor.
   *
   * @param {String|Object} uri - uri or options
   * @param {Object} opts - options
   */
  constructor(uri, opts) {
    super();
    this.binaryType = defaultBinaryType;
    this.writeBuffer = [];
    this._prevBufferLen = 0;
    this._pingInterval = -1;
    this._pingTimeout = -1;
    this._maxPayload = -1;
    this._pingTimeoutTime = Infinity;
    if (uri && "object" === typeof uri) {
      opts = uri;
      uri = null;
    }
    if (uri) {
      const parsedUri = parse(uri);
      opts.hostname = parsedUri.host;
      opts.secure = parsedUri.protocol === "https" || parsedUri.protocol === "wss";
      opts.port = parsedUri.port;
      if (parsedUri.query)
        opts.query = parsedUri.query;
    } else if (opts.host) {
      opts.hostname = parse(opts.host).host;
    }
    installTimerFunctions(this, opts);
    this.secure = null != opts.secure ? opts.secure : typeof location !== "undefined" && "https:" === location.protocol;
    if (opts.hostname && !opts.port) {
      opts.port = this.secure ? "443" : "80";
    }
    this.hostname = opts.hostname || (typeof location !== "undefined" ? location.hostname : "localhost");
    this.port = opts.port || (typeof location !== "undefined" && location.port ? location.port : this.secure ? "443" : "80");
    this.transports = [];
    this._transportsByName = {};
    opts.transports.forEach((t) => {
      const transportName = t.prototype.name;
      this.transports.push(transportName);
      this._transportsByName[transportName] = t;
    });
    this.opts = Object.assign({
      path: "/engine.io",
      agent: false,
      withCredentials: false,
      upgrade: true,
      timestampParam: "t",
      rememberUpgrade: false,
      addTrailingSlash: true,
      rejectUnauthorized: true,
      perMessageDeflate: {
        threshold: 1024
      },
      transportOptions: {},
      closeOnBeforeunload: false
    }, opts);
    this.opts.path = this.opts.path.replace(/\/$/, "") + (this.opts.addTrailingSlash ? "/" : "");
    if (typeof this.opts.query === "string") {
      this.opts.query = decode2(this.opts.query);
    }
    if (withEventListeners) {
      if (this.opts.closeOnBeforeunload) {
        this._beforeunloadEventListener = () => {
          if (this.transport) {
            this.transport.removeAllListeners();
            this.transport.close();
          }
        };
        addEventListener("beforeunload", this._beforeunloadEventListener, false);
      }
      if (this.hostname !== "localhost") {
        this._offlineEventListener = () => {
          this._onClose("transport close", {
            description: "network connection lost"
          });
        };
        OFFLINE_EVENT_LISTENERS.push(this._offlineEventListener);
      }
    }
    if (this.opts.withCredentials) {
      this._cookieJar = createCookieJar();
    }
    this._open();
  }
  /**
   * Creates transport of the given type.
   *
   * @param {String} name - transport name
   * @return {Transport}
   * @private
   */
  createTransport(name2) {
    const query = Object.assign({}, this.opts.query);
    query.EIO = protocol;
    query.transport = name2;
    if (this.id)
      query.sid = this.id;
    const opts = Object.assign({}, this.opts, {
      query,
      socket: this,
      hostname: this.hostname,
      secure: this.secure,
      port: this.port
    }, this.opts.transportOptions[name2]);
    return new this._transportsByName[name2](opts);
  }
  /**
   * Initializes transport to use and starts probe.
   *
   * @private
   */
  _open() {
    if (this.transports.length === 0) {
      this.setTimeoutFn(() => {
        this.emitReserved("error", "No transports available");
      }, 0);
      return;
    }
    const transportName = this.opts.rememberUpgrade && _SocketWithoutUpgrade.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1 ? "websocket" : this.transports[0];
    this.readyState = "opening";
    const transport = this.createTransport(transportName);
    transport.open();
    this.setTransport(transport);
  }
  /**
   * Sets the current transport. Disables the existing one (if any).
   *
   * @private
   */
  setTransport(transport) {
    if (this.transport) {
      this.transport.removeAllListeners();
    }
    this.transport = transport;
    transport.on("drain", this._onDrain.bind(this)).on("packet", this._onPacket.bind(this)).on("error", this._onError.bind(this)).on("close", (reason) => this._onClose("transport close", reason));
  }
  /**
   * Called when connection is deemed open.
   *
   * @private
   */
  onOpen() {
    this.readyState = "open";
    _SocketWithoutUpgrade.priorWebsocketSuccess = "websocket" === this.transport.name;
    this.emitReserved("open");
    this.flush();
  }
  /**
   * Handles a packet.
   *
   * @private
   */
  _onPacket(packet) {
    if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) {
      this.emitReserved("packet", packet);
      this.emitReserved("heartbeat");
      switch (packet.type) {
        case "open":
          this.onHandshake(JSON.parse(packet.data));
          break;
        case "ping":
          this._sendPacket("pong");
          this.emitReserved("ping");
          this.emitReserved("pong");
          this._resetPingTimeout();
          break;
        case "error":
          const err = new Error("server error");
          err.code = packet.data;
          this._onError(err);
          break;
        case "message":
          this.emitReserved("data", packet.data);
          this.emitReserved("message", packet.data);
          break;
      }
    } else {
    }
  }
  /**
   * Called upon handshake completion.
   *
   * @param {Object} data - handshake obj
   * @private
   */
  onHandshake(data2) {
    this.emitReserved("handshake", data2);
    this.id = data2.sid;
    this.transport.query.sid = data2.sid;
    this._pingInterval = data2.pingInterval;
    this._pingTimeout = data2.pingTimeout;
    this._maxPayload = data2.maxPayload;
    this.onOpen();
    if ("closed" === this.readyState)
      return;
    this._resetPingTimeout();
  }
  /**
   * Sets and resets ping timeout timer based on server pings.
   *
   * @private
   */
  _resetPingTimeout() {
    this.clearTimeoutFn(this._pingTimeoutTimer);
    const delay = this._pingInterval + this._pingTimeout;
    this._pingTimeoutTime = Date.now() + delay;
    this._pingTimeoutTimer = this.setTimeoutFn(() => {
      this._onClose("ping timeout");
    }, delay);
    if (this.opts.autoUnref) {
      this._pingTimeoutTimer.unref();
    }
  }
  /**
   * Called on `drain` event
   *
   * @private
   */
  _onDrain() {
    this.writeBuffer.splice(0, this._prevBufferLen);
    this._prevBufferLen = 0;
    if (0 === this.writeBuffer.length) {
      this.emitReserved("drain");
    } else {
      this.flush();
    }
  }
  /**
   * Flush write buffers.
   *
   * @private
   */
  flush() {
    if ("closed" !== this.readyState && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
      const packets = this._getWritablePackets();
      this.transport.send(packets);
      this._prevBufferLen = packets.length;
      this.emitReserved("flush");
    }
  }
  /**
   * Ensure the encoded size of the writeBuffer is below the maxPayload value sent by the server (only for HTTP
   * long-polling)
   *
   * @private
   */
  _getWritablePackets() {
    const shouldCheckPayloadSize = this._maxPayload && this.transport.name === "polling" && this.writeBuffer.length > 1;
    if (!shouldCheckPayloadSize) {
      return this.writeBuffer;
    }
    let payloadSize = 1;
    for (let i = 0; i < this.writeBuffer.length; i++) {
      const data2 = this.writeBuffer[i].data;
      if (data2) {
        payloadSize += byteLength(data2);
      }
      if (i > 0 && payloadSize > this._maxPayload) {
        return this.writeBuffer.slice(0, i);
      }
      payloadSize += 2;
    }
    return this.writeBuffer;
  }
  /**
   * Checks whether the heartbeat timer has expired but the socket has not yet been notified.
   *
   * Note: this method is private for now because it does not really fit the WebSocket API, but if we put it in the
   * `write()` method then the message would not be buffered by the Socket.IO client.
   *
   * @return {boolean}
   * @private
   */
  /* private */
  _hasPingExpired() {
    if (!this._pingTimeoutTime)
      return true;
    const hasExpired = Date.now() > this._pingTimeoutTime;
    if (hasExpired) {
      this._pingTimeoutTime = 0;
      nextTick(() => {
        this._onClose("ping timeout");
      }, this.setTimeoutFn);
    }
    return hasExpired;
  }
  /**
   * Sends a message.
   *
   * @param {String} msg - message.
   * @param {Object} options.
   * @param {Function} fn - callback function.
   * @return {Socket} for chaining.
   */
  write(msg, options, fn) {
    this._sendPacket("message", msg, options, fn);
    return this;
  }
  /**
   * Sends a message. Alias of {@link Socket#write}.
   *
   * @param {String} msg - message.
   * @param {Object} options.
   * @param {Function} fn - callback function.
   * @return {Socket} for chaining.
   */
  send(msg, options, fn) {
    this._sendPacket("message", msg, options, fn);
    return this;
  }
  /**
   * Sends a packet.
   *
   * @param {String} type: packet type.
   * @param {String} data.
   * @param {Object} options.
   * @param {Function} fn - callback function.
   * @private
   */
  _sendPacket(type, data2, options, fn) {
    if ("function" === typeof data2) {
      fn = data2;
      data2 = void 0;
    }
    if ("function" === typeof options) {
      fn = options;
      options = null;
    }
    if ("closing" === this.readyState || "closed" === this.readyState) {
      return;
    }
    options = options || {};
    options.compress = false !== options.compress;
    const packet = {
      type,
      data: data2,
      options
    };
    this.emitReserved("packetCreate", packet);
    this.writeBuffer.push(packet);
    if (fn)
      this.once("flush", fn);
    this.flush();
  }
  /**
   * Closes the connection.
   */
  close() {
    const close = () => {
      this._onClose("forced close");
      this.transport.close();
    };
    const cleanupAndClose = () => {
      this.off("upgrade", cleanupAndClose);
      this.off("upgradeError", cleanupAndClose);
      close();
    };
    const waitForUpgrade = () => {
      this.once("upgrade", cleanupAndClose);
      this.once("upgradeError", cleanupAndClose);
    };
    if ("opening" === this.readyState || "open" === this.readyState) {
      this.readyState = "closing";
      if (this.writeBuffer.length) {
        this.once("drain", () => {
          if (this.upgrading) {
            waitForUpgrade();
          } else {
            close();
          }
        });
      } else if (this.upgrading) {
        waitForUpgrade();
      } else {
        close();
      }
    }
    return this;
  }
  /**
   * Called upon transport error
   *
   * @private
   */
  _onError(err) {
    _SocketWithoutUpgrade.priorWebsocketSuccess = false;
    if (this.opts.tryAllTransports && this.transports.length > 1 && this.readyState === "opening") {
      this.transports.shift();
      return this._open();
    }
    this.emitReserved("error", err);
    this._onClose("transport error", err);
  }
  /**
   * Called upon transport close.
   *
   * @private
   */
  _onClose(reason, description) {
    if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) {
      this.clearTimeoutFn(this._pingTimeoutTimer);
      this.transport.removeAllListeners("close");
      this.transport.close();
      this.transport.removeAllListeners();
      if (withEventListeners) {
        if (this._beforeunloadEventListener) {
          removeEventListener("beforeunload", this._beforeunloadEventListener, false);
        }
        if (this._offlineEventListener) {
          const i = OFFLINE_EVENT_LISTENERS.indexOf(this._offlineEventListener);
          if (i !== -1) {
            OFFLINE_EVENT_LISTENERS.splice(i, 1);
          }
        }
      }
      this.readyState = "closed";
      this.id = null;
      this.emitReserved("close", reason, description);
      this.writeBuffer = [];
      this._prevBufferLen = 0;
    }
  }
};
SocketWithoutUpgrade.protocol = protocol;
var SocketWithUpgrade = class extends SocketWithoutUpgrade {
  constructor() {
    super(...arguments);
    this._upgrades = [];
  }
  onOpen() {
    super.onOpen();
    if ("open" === this.readyState && this.opts.upgrade) {
      for (let i = 0; i < this._upgrades.length; i++) {
        this._probe(this._upgrades[i]);
      }
    }
  }
  /**
   * Probes a transport.
   *
   * @param {String} name - transport name
   * @private
   */
  _probe(name2) {
    let transport = this.createTransport(name2);
    let failed = false;
    SocketWithoutUpgrade.priorWebsocketSuccess = false;
    const onTransportOpen = () => {
      if (failed)
        return;
      transport.send([{ type: "ping", data: "probe" }]);
      transport.once("packet", (msg) => {
        if (failed)
          return;
        if ("pong" === msg.type && "probe" === msg.data) {
          this.upgrading = true;
          this.emitReserved("upgrading", transport);
          if (!transport)
            return;
          SocketWithoutUpgrade.priorWebsocketSuccess = "websocket" === transport.name;
          this.transport.pause(() => {
            if (failed)
              return;
            if ("closed" === this.readyState)
              return;
            cleanup();
            this.setTransport(transport);
            transport.send([{ type: "upgrade" }]);
            this.emitReserved("upgrade", transport);
            transport = null;
            this.upgrading = false;
            this.flush();
          });
        } else {
          const err = new Error("probe error");
          err.transport = transport.name;
          this.emitReserved("upgradeError", err);
        }
      });
    };
    function freezeTransport() {
      if (failed)
        return;
      failed = true;
      cleanup();
      transport.close();
      transport = null;
    }
    const onerror = (err) => {
      const error = new Error("probe error: " + err);
      error.transport = transport.name;
      freezeTransport();
      this.emitReserved("upgradeError", error);
    };
    function onTransportClose() {
      onerror("transport closed");
    }
    function onclose() {
      onerror("socket closed");
    }
    function onupgrade(to) {
      if (transport && to.name !== transport.name) {
        freezeTransport();
      }
    }
    const cleanup = () => {
      transport.removeListener("open", onTransportOpen);
      transport.removeListener("error", onerror);
      transport.removeListener("close", onTransportClose);
      this.off("close", onclose);
      this.off("upgrading", onupgrade);
    };
    transport.once("open", onTransportOpen);
    transport.once("error", onerror);
    transport.once("close", onTransportClose);
    this.once("close", onclose);
    this.once("upgrading", onupgrade);
    if (this._upgrades.indexOf("webtransport") !== -1 && name2 !== "webtransport") {
      this.setTimeoutFn(() => {
        if (!failed) {
          transport.open();
        }
      }, 200);
    } else {
      transport.open();
    }
  }
  onHandshake(data2) {
    this._upgrades = this._filterUpgrades(data2.upgrades);
    super.onHandshake(data2);
  }
  /**
   * Filters upgrades, returning only those matching client transports.
   *
   * @param {Array} upgrades - server upgrades
   * @private
   */
  _filterUpgrades(upgrades) {
    const filteredUpgrades = [];
    for (let i = 0; i < upgrades.length; i++) {
      if (~this.transports.indexOf(upgrades[i]))
        filteredUpgrades.push(upgrades[i]);
    }
    return filteredUpgrades;
  }
};
var Socket = class extends SocketWithUpgrade {
  constructor(uri, opts = {}) {
    const o = typeof uri === "object" ? uri : opts;
    if (!o.transports || o.transports && typeof o.transports[0] === "string") {
      o.transports = (o.transports || ["polling", "websocket", "webtransport"]).map((transportName) => transports[transportName]).filter((t) => !!t);
    }
    super(uri, o);
  }
};

// node_modules/engine.io-client/build/esm/index.js
var protocol2 = Socket.protocol;

// node_modules/socket.io-client/build/esm/url.js
function url(uri, path = "", loc) {
  let obj = uri;
  loc = loc || typeof location !== "undefined" && location;
  if (null == uri)
    uri = loc.protocol + "//" + loc.host;
  if (typeof uri === "string") {
    if ("/" === uri.charAt(0)) {
      if ("/" === uri.charAt(1)) {
        uri = loc.protocol + uri;
      } else {
        uri = loc.host + uri;
      }
    }
    if (!/^(https?|wss?):\/\//.test(uri)) {
      if ("undefined" !== typeof loc) {
        uri = loc.protocol + "//" + uri;
      } else {
        uri = "https://" + uri;
      }
    }
    obj = parse(uri);
  }
  if (!obj.port) {
    if (/^(http|ws)$/.test(obj.protocol)) {
      obj.port = "80";
    } else if (/^(http|ws)s$/.test(obj.protocol)) {
      obj.port = "443";
    }
  }
  obj.path = obj.path || "/";
  const ipv6 = obj.host.indexOf(":") !== -1;
  const host = ipv6 ? "[" + obj.host + "]" : obj.host;
  obj.id = obj.protocol + "://" + host + ":" + obj.port + path;
  obj.href = obj.protocol + "://" + host + (loc && loc.port === obj.port ? "" : ":" + obj.port);
  return obj;
}

// node_modules/socket.io-parser/build/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  Decoder: () => Decoder,
  Encoder: () => Encoder,
  PacketType: () => PacketType,
  protocol: () => protocol3
});

// node_modules/socket.io-parser/build/esm/is-binary.js
var withNativeArrayBuffer3 = typeof ArrayBuffer === "function";
var isView2 = (obj) => {
  return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj.buffer instanceof ArrayBuffer;
};
var toString = Object.prototype.toString;
var withNativeBlob2 = typeof Blob === "function" || typeof Blob !== "undefined" && toString.call(Blob) === "[object BlobConstructor]";
var withNativeFile = typeof File === "function" || typeof File !== "undefined" && toString.call(File) === "[object FileConstructor]";
function isBinary(obj) {
  return withNativeArrayBuffer3 && (obj instanceof ArrayBuffer || isView2(obj)) || withNativeBlob2 && obj instanceof Blob || withNativeFile && obj instanceof File;
}
function hasBinary(obj, toJSON) {
  if (!obj || typeof obj !== "object") {
    return false;
  }
  if (Array.isArray(obj)) {
    for (let i = 0, l = obj.length; i < l; i++) {
      if (hasBinary(obj[i])) {
        return true;
      }
    }
    return false;
  }
  if (isBinary(obj)) {
    return true;
  }
  if (obj.toJSON && typeof obj.toJSON === "function" && arguments.length === 1) {
    return hasBinary(obj.toJSON(), true);
  }
  for (const key2 in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key2) && hasBinary(obj[key2])) {
      return true;
    }
  }
  return false;
}

// node_modules/socket.io-parser/build/esm/binary.js
function deconstructPacket(packet) {
  const buffers = [];
  const packetData = packet.data;
  const pack = packet;
  pack.data = _deconstructPacket(packetData, buffers);
  pack.attachments = buffers.length;
  return { packet: pack, buffers };
}
function _deconstructPacket(data2, buffers) {
  if (!data2)
    return data2;
  if (isBinary(data2)) {
    const placeholder = { _placeholder: true, num: buffers.length };
    buffers.push(data2);
    return placeholder;
  } else if (Array.isArray(data2)) {
    const newData = new Array(data2.length);
    for (let i = 0; i < data2.length; i++) {
      newData[i] = _deconstructPacket(data2[i], buffers);
    }
    return newData;
  } else if (typeof data2 === "object" && !(data2 instanceof Date)) {
    const newData = {};
    for (const key2 in data2) {
      if (Object.prototype.hasOwnProperty.call(data2, key2)) {
        newData[key2] = _deconstructPacket(data2[key2], buffers);
      }
    }
    return newData;
  }
  return data2;
}
function reconstructPacket(packet, buffers) {
  packet.data = _reconstructPacket(packet.data, buffers);
  delete packet.attachments;
  return packet;
}
function _reconstructPacket(data2, buffers) {
  if (!data2)
    return data2;
  if (data2 && data2._placeholder === true) {
    const isIndexValid = typeof data2.num === "number" && data2.num >= 0 && data2.num < buffers.length;
    if (isIndexValid) {
      return buffers[data2.num];
    } else {
      throw new Error("illegal attachments");
    }
  } else if (Array.isArray(data2)) {
    for (let i = 0; i < data2.length; i++) {
      data2[i] = _reconstructPacket(data2[i], buffers);
    }
  } else if (typeof data2 === "object") {
    for (const key2 in data2) {
      if (Object.prototype.hasOwnProperty.call(data2, key2)) {
        data2[key2] = _reconstructPacket(data2[key2], buffers);
      }
    }
  }
  return data2;
}

// node_modules/socket.io-parser/build/esm/index.js
var RESERVED_EVENTS = [
  "connect",
  "connect_error",
  "disconnect",
  "disconnecting",
  "newListener",
  "removeListener"
  // used by the Node.js EventEmitter
];
var protocol3 = 5;
var PacketType;
(function(PacketType2) {
  PacketType2[PacketType2["CONNECT"] = 0] = "CONNECT";
  PacketType2[PacketType2["DISCONNECT"] = 1] = "DISCONNECT";
  PacketType2[PacketType2["EVENT"] = 2] = "EVENT";
  PacketType2[PacketType2["ACK"] = 3] = "ACK";
  PacketType2[PacketType2["CONNECT_ERROR"] = 4] = "CONNECT_ERROR";
  PacketType2[PacketType2["BINARY_EVENT"] = 5] = "BINARY_EVENT";
  PacketType2[PacketType2["BINARY_ACK"] = 6] = "BINARY_ACK";
})(PacketType || (PacketType = {}));
var Encoder = class {
  /**
   * Encoder constructor
   *
   * @param {function} replacer - custom replacer to pass down to JSON.parse
   */
  constructor(replacer) {
    this.replacer = replacer;
  }
  /**
   * Encode a packet as a single string if non-binary, or as a
   * buffer sequence, depending on packet type.
   *
   * @param {Object} obj - packet object
   */
  encode(obj) {
    if (obj.type === PacketType.EVENT || obj.type === PacketType.ACK) {
      if (hasBinary(obj)) {
        return this.encodeAsBinary({
          type: obj.type === PacketType.EVENT ? PacketType.BINARY_EVENT : PacketType.BINARY_ACK,
          nsp: obj.nsp,
          data: obj.data,
          id: obj.id
        });
      }
    }
    return [this.encodeAsString(obj)];
  }
  /**
   * Encode packet as string.
   */
  encodeAsString(obj) {
    let str = "" + obj.type;
    if (obj.type === PacketType.BINARY_EVENT || obj.type === PacketType.BINARY_ACK) {
      str += obj.attachments + "-";
    }
    if (obj.nsp && "/" !== obj.nsp) {
      str += obj.nsp + ",";
    }
    if (null != obj.id) {
      str += obj.id;
    }
    if (null != obj.data) {
      str += JSON.stringify(obj.data, this.replacer);
    }
    return str;
  }
  /**
   * Encode packet as 'buffer sequence' by removing blobs, and
   * deconstructing packet into object with placeholders and
   * a list of buffers.
   */
  encodeAsBinary(obj) {
    const deconstruction = deconstructPacket(obj);
    const pack = this.encodeAsString(deconstruction.packet);
    const buffers = deconstruction.buffers;
    buffers.unshift(pack);
    return buffers;
  }
};
function isObject(value3) {
  return Object.prototype.toString.call(value3) === "[object Object]";
}
var Decoder = class _Decoder extends Emitter {
  /**
   * Decoder constructor
   *
   * @param {function} reviver - custom reviver to pass down to JSON.stringify
   */
  constructor(reviver) {
    super();
    this.reviver = reviver;
  }
  /**
   * Decodes an encoded packet string into packet JSON.
   *
   * @param {String} obj - encoded packet
   */
  add(obj) {
    let packet;
    if (typeof obj === "string") {
      if (this.reconstructor) {
        throw new Error("got plaintext data when reconstructing a packet");
      }
      packet = this.decodeString(obj);
      const isBinaryEvent = packet.type === PacketType.BINARY_EVENT;
      if (isBinaryEvent || packet.type === PacketType.BINARY_ACK) {
        packet.type = isBinaryEvent ? PacketType.EVENT : PacketType.ACK;
        this.reconstructor = new BinaryReconstructor(packet);
        if (packet.attachments === 0) {
          super.emitReserved("decoded", packet);
        }
      } else {
        super.emitReserved("decoded", packet);
      }
    } else if (isBinary(obj) || obj.base64) {
      if (!this.reconstructor) {
        throw new Error("got binary data when not reconstructing a packet");
      } else {
        packet = this.reconstructor.takeBinaryData(obj);
        if (packet) {
          this.reconstructor = null;
          super.emitReserved("decoded", packet);
        }
      }
    } else {
      throw new Error("Unknown type: " + obj);
    }
  }
  /**
   * Decode a packet String (JSON data)
   *
   * @param {String} str
   * @return {Object} packet
   */
  decodeString(str) {
    let i = 0;
    const p = {
      type: Number(str.charAt(0))
    };
    if (PacketType[p.type] === void 0) {
      throw new Error("unknown packet type " + p.type);
    }
    if (p.type === PacketType.BINARY_EVENT || p.type === PacketType.BINARY_ACK) {
      const start = i + 1;
      while (str.charAt(++i) !== "-" && i != str.length) {
      }
      const buf = str.substring(start, i);
      if (buf != Number(buf) || str.charAt(i) !== "-") {
        throw new Error("Illegal attachments");
      }
      p.attachments = Number(buf);
    }
    if ("/" === str.charAt(i + 1)) {
      const start = i + 1;
      while (++i) {
        const c = str.charAt(i);
        if ("," === c)
          break;
        if (i === str.length)
          break;
      }
      p.nsp = str.substring(start, i);
    } else {
      p.nsp = "/";
    }
    const next = str.charAt(i + 1);
    if ("" !== next && Number(next) == next) {
      const start = i + 1;
      while (++i) {
        const c = str.charAt(i);
        if (null == c || Number(c) != c) {
          --i;
          break;
        }
        if (i === str.length)
          break;
      }
      p.id = Number(str.substring(start, i + 1));
    }
    if (str.charAt(++i)) {
      const payload = this.tryParse(str.substr(i));
      if (_Decoder.isPayloadValid(p.type, payload)) {
        p.data = payload;
      } else {
        throw new Error("invalid payload");
      }
    }
    return p;
  }
  tryParse(str) {
    try {
      return JSON.parse(str, this.reviver);
    } catch (e) {
      return false;
    }
  }
  static isPayloadValid(type, payload) {
    switch (type) {
      case PacketType.CONNECT:
        return isObject(payload);
      case PacketType.DISCONNECT:
        return payload === void 0;
      case PacketType.CONNECT_ERROR:
        return typeof payload === "string" || isObject(payload);
      case PacketType.EVENT:
      case PacketType.BINARY_EVENT:
        return Array.isArray(payload) && (typeof payload[0] === "number" || typeof payload[0] === "string" && RESERVED_EVENTS.indexOf(payload[0]) === -1);
      case PacketType.ACK:
      case PacketType.BINARY_ACK:
        return Array.isArray(payload);
    }
  }
  /**
   * Deallocates a parser's resources
   */
  destroy() {
    if (this.reconstructor) {
      this.reconstructor.finishedReconstruction();
      this.reconstructor = null;
    }
  }
};
var BinaryReconstructor = class {
  constructor(packet) {
    this.packet = packet;
    this.buffers = [];
    this.reconPack = packet;
  }
  /**
   * Method to be called when binary data received from connection
   * after a BINARY_EVENT packet.
   *
   * @param {Buffer | ArrayBuffer} binData - the raw binary data received
   * @return {null | Object} returns null if more binary data is expected or
   *   a reconstructed packet object if all buffers have been received.
   */
  takeBinaryData(binData) {
    this.buffers.push(binData);
    if (this.buffers.length === this.reconPack.attachments) {
      const packet = reconstructPacket(this.reconPack, this.buffers);
      this.finishedReconstruction();
      return packet;
    }
    return null;
  }
  /**
   * Cleans up binary packet reconstruction variables.
   */
  finishedReconstruction() {
    this.reconPack = null;
    this.buffers = [];
  }
};

// node_modules/socket.io-client/build/esm/on.js
function on(obj, ev, fn) {
  obj.on(ev, fn);
  return function subDestroy() {
    obj.off(ev, fn);
  };
}

// node_modules/socket.io-client/build/esm/socket.js
var RESERVED_EVENTS2 = Object.freeze({
  connect: 1,
  connect_error: 1,
  disconnect: 1,
  disconnecting: 1,
  // EventEmitter reserved events: https://nodejs.org/api/events.html#events_event_newlistener
  newListener: 1,
  removeListener: 1
});
var Socket2 = class extends Emitter {
  /**
   * `Socket` constructor.
   */
  constructor(io, nsp, opts) {
    super();
    this.connected = false;
    this.recovered = false;
    this.receiveBuffer = [];
    this.sendBuffer = [];
    this._queue = [];
    this._queueSeq = 0;
    this.ids = 0;
    this.acks = {};
    this.flags = {};
    this.io = io;
    this.nsp = nsp;
    if (opts && opts.auth) {
      this.auth = opts.auth;
    }
    this._opts = Object.assign({}, opts);
    if (this.io._autoConnect)
      this.open();
  }
  /**
   * Whether the socket is currently disconnected
   *
   * @example
   * const socket = io();
   *
   * socket.on("connect", () => {
   *   console.log(socket.disconnected); // false
   * });
   *
   * socket.on("disconnect", () => {
   *   console.log(socket.disconnected); // true
   * });
   */
  get disconnected() {
    return !this.connected;
  }
  /**
   * Subscribe to open, close and packet events
   *
   * @private
   */
  subEvents() {
    if (this.subs)
      return;
    const io = this.io;
    this.subs = [
      on(io, "open", this.onopen.bind(this)),
      on(io, "packet", this.onpacket.bind(this)),
      on(io, "error", this.onerror.bind(this)),
      on(io, "close", this.onclose.bind(this))
    ];
  }
  /**
   * Whether the Socket will try to reconnect when its Manager connects or reconnects.
   *
   * @example
   * const socket = io();
   *
   * console.log(socket.active); // true
   *
   * socket.on("disconnect", (reason) => {
   *   if (reason === "io server disconnect") {
   *     // the disconnection was initiated by the server, you need to manually reconnect
   *     console.log(socket.active); // false
   *   }
   *   // else the socket will automatically try to reconnect
   *   console.log(socket.active); // true
   * });
   */
  get active() {
    return !!this.subs;
  }
  /**
   * "Opens" the socket.
   *
   * @example
   * const socket = io({
   *   autoConnect: false
   * });
   *
   * socket.connect();
   */
  connect() {
    if (this.connected)
      return this;
    this.subEvents();
    if (!this.io["_reconnecting"])
      this.io.open();
    if ("open" === this.io._readyState)
      this.onopen();
    return this;
  }
  /**
   * Alias for {@link connect()}.
   */
  open() {
    return this.connect();
  }
  /**
   * Sends a `message` event.
   *
   * This method mimics the WebSocket.send() method.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send
   *
   * @example
   * socket.send("hello");
   *
   * // this is equivalent to
   * socket.emit("message", "hello");
   *
   * @return self
   */
  send(...args) {
    args.unshift("message");
    this.emit.apply(this, args);
    return this;
  }
  /**
   * Override `emit`.
   * If the event is in `events`, it's emitted normally.
   *
   * @example
   * socket.emit("hello", "world");
   *
   * // all serializable datastructures are supported (no need to call JSON.stringify)
   * socket.emit("hello", 1, "2", { 3: ["4"], 5: Uint8Array.from([6]) });
   *
   * // with an acknowledgement from the server
   * socket.emit("hello", "world", (val) => {
   *   // ...
   * });
   *
   * @return self
   */
  emit(ev, ...args) {
    var _a, _b, _c;
    if (RESERVED_EVENTS2.hasOwnProperty(ev)) {
      throw new Error('"' + ev.toString() + '" is a reserved event name');
    }
    args.unshift(ev);
    if (this._opts.retries && !this.flags.fromQueue && !this.flags.volatile) {
      this._addToQueue(args);
      return this;
    }
    const packet = {
      type: PacketType.EVENT,
      data: args
    };
    packet.options = {};
    packet.options.compress = this.flags.compress !== false;
    if ("function" === typeof args[args.length - 1]) {
      const id = this.ids++;
      const ack = args.pop();
      this._registerAckCallback(id, ack);
      packet.id = id;
    }
    const isTransportWritable = (_b = (_a = this.io.engine) === null || _a === void 0 ? void 0 : _a.transport) === null || _b === void 0 ? void 0 : _b.writable;
    const isConnected = this.connected && !((_c = this.io.engine) === null || _c === void 0 ? void 0 : _c._hasPingExpired());
    const discardPacket = this.flags.volatile && !isTransportWritable;
    if (discardPacket) {
    } else if (isConnected) {
      this.notifyOutgoingListeners(packet);
      this.packet(packet);
    } else {
      this.sendBuffer.push(packet);
    }
    this.flags = {};
    return this;
  }
  /**
   * @private
   */
  _registerAckCallback(id, ack) {
    var _a;
    const timeout = (_a = this.flags.timeout) !== null && _a !== void 0 ? _a : this._opts.ackTimeout;
    if (timeout === void 0) {
      this.acks[id] = ack;
      return;
    }
    const timer = this.io.setTimeoutFn(() => {
      delete this.acks[id];
      for (let i = 0; i < this.sendBuffer.length; i++) {
        if (this.sendBuffer[i].id === id) {
          this.sendBuffer.splice(i, 1);
        }
      }
      ack.call(this, new Error("operation has timed out"));
    }, timeout);
    const fn = (...args) => {
      this.io.clearTimeoutFn(timer);
      ack.apply(this, args);
    };
    fn.withError = true;
    this.acks[id] = fn;
  }
  /**
   * Emits an event and waits for an acknowledgement
   *
   * @example
   * // without timeout
   * const response = await socket.emitWithAck("hello", "world");
   *
   * // with a specific timeout
   * try {
   *   const response = await socket.timeout(1000).emitWithAck("hello", "world");
   * } catch (err) {
   *   // the server did not acknowledge the event in the given delay
   * }
   *
   * @return a Promise that will be fulfilled when the server acknowledges the event
   */
  emitWithAck(ev, ...args) {
    return new Promise((resolve, reject) => {
      const fn = (arg1, arg2) => {
        return arg1 ? reject(arg1) : resolve(arg2);
      };
      fn.withError = true;
      args.push(fn);
      this.emit(ev, ...args);
    });
  }
  /**
   * Add the packet to the queue.
   * @param args
   * @private
   */
  _addToQueue(args) {
    let ack;
    if (typeof args[args.length - 1] === "function") {
      ack = args.pop();
    }
    const packet = {
      id: this._queueSeq++,
      tryCount: 0,
      pending: false,
      args,
      flags: Object.assign({ fromQueue: true }, this.flags)
    };
    args.push((err, ...responseArgs) => {
      if (packet !== this._queue[0]) {
        return;
      }
      const hasError = err !== null;
      if (hasError) {
        if (packet.tryCount > this._opts.retries) {
          this._queue.shift();
          if (ack) {
            ack(err);
          }
        }
      } else {
        this._queue.shift();
        if (ack) {
          ack(null, ...responseArgs);
        }
      }
      packet.pending = false;
      return this._drainQueue();
    });
    this._queue.push(packet);
    this._drainQueue();
  }
  /**
   * Send the first packet of the queue, and wait for an acknowledgement from the server.
   * @param force - whether to resend a packet that has not been acknowledged yet
   *
   * @private
   */
  _drainQueue(force = false) {
    if (!this.connected || this._queue.length === 0) {
      return;
    }
    const packet = this._queue[0];
    if (packet.pending && !force) {
      return;
    }
    packet.pending = true;
    packet.tryCount++;
    this.flags = packet.flags;
    this.emit.apply(this, packet.args);
  }
  /**
   * Sends a packet.
   *
   * @param packet
   * @private
   */
  packet(packet) {
    packet.nsp = this.nsp;
    this.io._packet(packet);
  }
  /**
   * Called upon engine `open`.
   *
   * @private
   */
  onopen() {
    if (typeof this.auth == "function") {
      this.auth((data2) => {
        this._sendConnectPacket(data2);
      });
    } else {
      this._sendConnectPacket(this.auth);
    }
  }
  /**
   * Sends a CONNECT packet to initiate the Socket.IO session.
   *
   * @param data
   * @private
   */
  _sendConnectPacket(data2) {
    this.packet({
      type: PacketType.CONNECT,
      data: this._pid ? Object.assign({ pid: this._pid, offset: this._lastOffset }, data2) : data2
    });
  }
  /**
   * Called upon engine or manager `error`.
   *
   * @param err
   * @private
   */
  onerror(err) {
    if (!this.connected) {
      this.emitReserved("connect_error", err);
    }
  }
  /**
   * Called upon engine `close`.
   *
   * @param reason
   * @param description
   * @private
   */
  onclose(reason, description) {
    this.connected = false;
    delete this.id;
    this.emitReserved("disconnect", reason, description);
    this._clearAcks();
  }
  /**
   * Clears the acknowledgement handlers upon disconnection, since the client will never receive an acknowledgement from
   * the server.
   *
   * @private
   */
  _clearAcks() {
    Object.keys(this.acks).forEach((id) => {
      const isBuffered = this.sendBuffer.some((packet) => String(packet.id) === id);
      if (!isBuffered) {
        const ack = this.acks[id];
        delete this.acks[id];
        if (ack.withError) {
          ack.call(this, new Error("socket has been disconnected"));
        }
      }
    });
  }
  /**
   * Called with socket packet.
   *
   * @param packet
   * @private
   */
  onpacket(packet) {
    const sameNamespace = packet.nsp === this.nsp;
    if (!sameNamespace)
      return;
    switch (packet.type) {
      case PacketType.CONNECT:
        if (packet.data && packet.data.sid) {
          this.onconnect(packet.data.sid, packet.data.pid);
        } else {
          this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
        }
        break;
      case PacketType.EVENT:
      case PacketType.BINARY_EVENT:
        this.onevent(packet);
        break;
      case PacketType.ACK:
      case PacketType.BINARY_ACK:
        this.onack(packet);
        break;
      case PacketType.DISCONNECT:
        this.ondisconnect();
        break;
      case PacketType.CONNECT_ERROR:
        this.destroy();
        const err = new Error(packet.data.message);
        err.data = packet.data.data;
        this.emitReserved("connect_error", err);
        break;
    }
  }
  /**
   * Called upon a server event.
   *
   * @param packet
   * @private
   */
  onevent(packet) {
    const args = packet.data || [];
    if (null != packet.id) {
      args.push(this.ack(packet.id));
    }
    if (this.connected) {
      this.emitEvent(args);
    } else {
      this.receiveBuffer.push(Object.freeze(args));
    }
  }
  emitEvent(args) {
    if (this._anyListeners && this._anyListeners.length) {
      const listeners = this._anyListeners.slice();
      for (const listener of listeners) {
        listener.apply(this, args);
      }
    }
    super.emit.apply(this, args);
    if (this._pid && args.length && typeof args[args.length - 1] === "string") {
      this._lastOffset = args[args.length - 1];
    }
  }
  /**
   * Produces an ack callback to emit with an event.
   *
   * @private
   */
  ack(id) {
    const self2 = this;
    let sent = false;
    return function(...args) {
      if (sent)
        return;
      sent = true;
      self2.packet({
        type: PacketType.ACK,
        id,
        data: args
      });
    };
  }
  /**
   * Called upon a server acknowledgement.
   *
   * @param packet
   * @private
   */
  onack(packet) {
    const ack = this.acks[packet.id];
    if (typeof ack !== "function") {
      return;
    }
    delete this.acks[packet.id];
    if (ack.withError) {
      packet.data.unshift(null);
    }
    ack.apply(this, packet.data);
  }
  /**
   * Called upon server connect.
   *
   * @private
   */
  onconnect(id, pid) {
    this.id = id;
    this.recovered = pid && this._pid === pid;
    this._pid = pid;
    this.connected = true;
    this.emitBuffered();
    this.emitReserved("connect");
    this._drainQueue(true);
  }
  /**
   * Emit buffered events (received and emitted).
   *
   * @private
   */
  emitBuffered() {
    this.receiveBuffer.forEach((args) => this.emitEvent(args));
    this.receiveBuffer = [];
    this.sendBuffer.forEach((packet) => {
      this.notifyOutgoingListeners(packet);
      this.packet(packet);
    });
    this.sendBuffer = [];
  }
  /**
   * Called upon server disconnect.
   *
   * @private
   */
  ondisconnect() {
    this.destroy();
    this.onclose("io server disconnect");
  }
  /**
   * Called upon forced client/server side disconnections,
   * this method ensures the manager stops tracking us and
   * that reconnections don't get triggered for this.
   *
   * @private
   */
  destroy() {
    if (this.subs) {
      this.subs.forEach((subDestroy) => subDestroy());
      this.subs = void 0;
    }
    this.io["_destroy"](this);
  }
  /**
   * Disconnects the socket manually. In that case, the socket will not try to reconnect.
   *
   * If this is the last active Socket instance of the {@link Manager}, the low-level connection will be closed.
   *
   * @example
   * const socket = io();
   *
   * socket.on("disconnect", (reason) => {
   *   // console.log(reason); prints "io client disconnect"
   * });
   *
   * socket.disconnect();
   *
   * @return self
   */
  disconnect() {
    if (this.connected) {
      this.packet({ type: PacketType.DISCONNECT });
    }
    this.destroy();
    if (this.connected) {
      this.onclose("io client disconnect");
    }
    return this;
  }
  /**
   * Alias for {@link disconnect()}.
   *
   * @return self
   */
  close() {
    return this.disconnect();
  }
  /**
   * Sets the compress flag.
   *
   * @example
   * socket.compress(false).emit("hello");
   *
   * @param compress - if `true`, compresses the sending data
   * @return self
   */
  compress(compress) {
    this.flags.compress = compress;
    return this;
  }
  /**
   * Sets a modifier for a subsequent event emission that the event message will be dropped when this socket is not
   * ready to send messages.
   *
   * @example
   * socket.volatile.emit("hello"); // the server may or may not receive it
   *
   * @returns self
   */
  get volatile() {
    this.flags.volatile = true;
    return this;
  }
  /**
   * Sets a modifier for a subsequent event emission that the callback will be called with an error when the
   * given number of milliseconds have elapsed without an acknowledgement from the server:
   *
   * @example
   * socket.timeout(5000).emit("my-event", (err) => {
   *   if (err) {
   *     // the server did not acknowledge the event in the given delay
   *   }
   * });
   *
   * @returns self
   */
  timeout(timeout) {
    this.flags.timeout = timeout;
    return this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback.
   *
   * @example
   * socket.onAny((event, ...args) => {
   *   console.log(`got ${event}`);
   * });
   *
   * @param listener
   */
  onAny(listener) {
    this._anyListeners = this._anyListeners || [];
    this._anyListeners.push(listener);
    return this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback. The listener is added to the beginning of the listeners array.
   *
   * @example
   * socket.prependAny((event, ...args) => {
   *   console.log(`got event ${event}`);
   * });
   *
   * @param listener
   */
  prependAny(listener) {
    this._anyListeners = this._anyListeners || [];
    this._anyListeners.unshift(listener);
    return this;
  }
  /**
   * Removes the listener that will be fired when any event is emitted.
   *
   * @example
   * const catchAllListener = (event, ...args) => {
   *   console.log(`got event ${event}`);
   * }
   *
   * socket.onAny(catchAllListener);
   *
   * // remove a specific listener
   * socket.offAny(catchAllListener);
   *
   * // or remove all listeners
   * socket.offAny();
   *
   * @param listener
   */
  offAny(listener) {
    if (!this._anyListeners) {
      return this;
    }
    if (listener) {
      const listeners = this._anyListeners;
      for (let i = 0; i < listeners.length; i++) {
        if (listener === listeners[i]) {
          listeners.splice(i, 1);
          return this;
        }
      }
    } else {
      this._anyListeners = [];
    }
    return this;
  }
  /**
   * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
   * e.g. to remove listeners.
   */
  listenersAny() {
    return this._anyListeners || [];
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback.
   *
   * Note: acknowledgements sent to the server are not included.
   *
   * @example
   * socket.onAnyOutgoing((event, ...args) => {
   *   console.log(`sent event ${event}`);
   * });
   *
   * @param listener
   */
  onAnyOutgoing(listener) {
    this._anyOutgoingListeners = this._anyOutgoingListeners || [];
    this._anyOutgoingListeners.push(listener);
    return this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback. The listener is added to the beginning of the listeners array.
   *
   * Note: acknowledgements sent to the server are not included.
   *
   * @example
   * socket.prependAnyOutgoing((event, ...args) => {
   *   console.log(`sent event ${event}`);
   * });
   *
   * @param listener
   */
  prependAnyOutgoing(listener) {
    this._anyOutgoingListeners = this._anyOutgoingListeners || [];
    this._anyOutgoingListeners.unshift(listener);
    return this;
  }
  /**
   * Removes the listener that will be fired when any event is emitted.
   *
   * @example
   * const catchAllListener = (event, ...args) => {
   *   console.log(`sent event ${event}`);
   * }
   *
   * socket.onAnyOutgoing(catchAllListener);
   *
   * // remove a specific listener
   * socket.offAnyOutgoing(catchAllListener);
   *
   * // or remove all listeners
   * socket.offAnyOutgoing();
   *
   * @param [listener] - the catch-all listener (optional)
   */
  offAnyOutgoing(listener) {
    if (!this._anyOutgoingListeners) {
      return this;
    }
    if (listener) {
      const listeners = this._anyOutgoingListeners;
      for (let i = 0; i < listeners.length; i++) {
        if (listener === listeners[i]) {
          listeners.splice(i, 1);
          return this;
        }
      }
    } else {
      this._anyOutgoingListeners = [];
    }
    return this;
  }
  /**
   * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
   * e.g. to remove listeners.
   */
  listenersAnyOutgoing() {
    return this._anyOutgoingListeners || [];
  }
  /**
   * Notify the listeners for each packet sent
   *
   * @param packet
   *
   * @private
   */
  notifyOutgoingListeners(packet) {
    if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {
      const listeners = this._anyOutgoingListeners.slice();
      for (const listener of listeners) {
        listener.apply(this, packet.data);
      }
    }
  }
};

// node_modules/socket.io-client/build/esm/contrib/backo2.js
function Backoff(opts) {
  opts = opts || {};
  this.ms = opts.min || 100;
  this.max = opts.max || 1e4;
  this.factor = opts.factor || 2;
  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
  this.attempts = 0;
}
Backoff.prototype.duration = function() {
  var ms = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var rand = Math.random();
    var deviation = Math.floor(rand * this.jitter * ms);
    ms = (Math.floor(rand * 10) & 1) == 0 ? ms - deviation : ms + deviation;
  }
  return Math.min(ms, this.max) | 0;
};
Backoff.prototype.reset = function() {
  this.attempts = 0;
};
Backoff.prototype.setMin = function(min) {
  this.ms = min;
};
Backoff.prototype.setMax = function(max) {
  this.max = max;
};
Backoff.prototype.setJitter = function(jitter) {
  this.jitter = jitter;
};

// node_modules/socket.io-client/build/esm/manager.js
var Manager = class extends Emitter {
  constructor(uri, opts) {
    var _a;
    super();
    this.nsps = {};
    this.subs = [];
    if (uri && "object" === typeof uri) {
      opts = uri;
      uri = void 0;
    }
    opts = opts || {};
    opts.path = opts.path || "/socket.io";
    this.opts = opts;
    installTimerFunctions(this, opts);
    this.reconnection(opts.reconnection !== false);
    this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
    this.reconnectionDelay(opts.reconnectionDelay || 1e3);
    this.reconnectionDelayMax(opts.reconnectionDelayMax || 5e3);
    this.randomizationFactor((_a = opts.randomizationFactor) !== null && _a !== void 0 ? _a : 0.5);
    this.backoff = new Backoff({
      min: this.reconnectionDelay(),
      max: this.reconnectionDelayMax(),
      jitter: this.randomizationFactor()
    });
    this.timeout(null == opts.timeout ? 2e4 : opts.timeout);
    this._readyState = "closed";
    this.uri = uri;
    const _parser = opts.parser || esm_exports;
    this.encoder = new _parser.Encoder();
    this.decoder = new _parser.Decoder();
    this._autoConnect = opts.autoConnect !== false;
    if (this._autoConnect)
      this.open();
  }
  reconnection(v) {
    if (!arguments.length)
      return this._reconnection;
    this._reconnection = !!v;
    if (!v) {
      this.skipReconnect = true;
    }
    return this;
  }
  reconnectionAttempts(v) {
    if (v === void 0)
      return this._reconnectionAttempts;
    this._reconnectionAttempts = v;
    return this;
  }
  reconnectionDelay(v) {
    var _a;
    if (v === void 0)
      return this._reconnectionDelay;
    this._reconnectionDelay = v;
    (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMin(v);
    return this;
  }
  randomizationFactor(v) {
    var _a;
    if (v === void 0)
      return this._randomizationFactor;
    this._randomizationFactor = v;
    (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setJitter(v);
    return this;
  }
  reconnectionDelayMax(v) {
    var _a;
    if (v === void 0)
      return this._reconnectionDelayMax;
    this._reconnectionDelayMax = v;
    (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMax(v);
    return this;
  }
  timeout(v) {
    if (!arguments.length)
      return this._timeout;
    this._timeout = v;
    return this;
  }
  /**
   * Starts trying to reconnect if reconnection is enabled and we have not
   * started reconnecting yet
   *
   * @private
   */
  maybeReconnectOnOpen() {
    if (!this._reconnecting && this._reconnection && this.backoff.attempts === 0) {
      this.reconnect();
    }
  }
  /**
   * Sets the current transport `socket`.
   *
   * @param {Function} fn - optional, callback
   * @return self
   * @public
   */
  open(fn) {
    if (~this._readyState.indexOf("open"))
      return this;
    this.engine = new Socket(this.uri, this.opts);
    const socket = this.engine;
    const self2 = this;
    this._readyState = "opening";
    this.skipReconnect = false;
    const openSubDestroy = on(socket, "open", function() {
      self2.onopen();
      fn && fn();
    });
    const onError = (err) => {
      this.cleanup();
      this._readyState = "closed";
      this.emitReserved("error", err);
      if (fn) {
        fn(err);
      } else {
        this.maybeReconnectOnOpen();
      }
    };
    const errorSub = on(socket, "error", onError);
    if (false !== this._timeout) {
      const timeout = this._timeout;
      const timer = this.setTimeoutFn(() => {
        openSubDestroy();
        onError(new Error("timeout"));
        socket.close();
      }, timeout);
      if (this.opts.autoUnref) {
        timer.unref();
      }
      this.subs.push(() => {
        this.clearTimeoutFn(timer);
      });
    }
    this.subs.push(openSubDestroy);
    this.subs.push(errorSub);
    return this;
  }
  /**
   * Alias for open()
   *
   * @return self
   * @public
   */
  connect(fn) {
    return this.open(fn);
  }
  /**
   * Called upon transport open.
   *
   * @private
   */
  onopen() {
    this.cleanup();
    this._readyState = "open";
    this.emitReserved("open");
    const socket = this.engine;
    this.subs.push(
      on(socket, "ping", this.onping.bind(this)),
      on(socket, "data", this.ondata.bind(this)),
      on(socket, "error", this.onerror.bind(this)),
      on(socket, "close", this.onclose.bind(this)),
      // @ts-ignore
      on(this.decoder, "decoded", this.ondecoded.bind(this))
    );
  }
  /**
   * Called upon a ping.
   *
   * @private
   */
  onping() {
    this.emitReserved("ping");
  }
  /**
   * Called with data.
   *
   * @private
   */
  ondata(data2) {
    try {
      this.decoder.add(data2);
    } catch (e) {
      this.onclose("parse error", e);
    }
  }
  /**
   * Called when parser fully decodes a packet.
   *
   * @private
   */
  ondecoded(packet) {
    nextTick(() => {
      this.emitReserved("packet", packet);
    }, this.setTimeoutFn);
  }
  /**
   * Called upon socket error.
   *
   * @private
   */
  onerror(err) {
    this.emitReserved("error", err);
  }
  /**
   * Creates a new socket for the given `nsp`.
   *
   * @return {Socket}
   * @public
   */
  socket(nsp, opts) {
    let socket = this.nsps[nsp];
    if (!socket) {
      socket = new Socket2(this, nsp, opts);
      this.nsps[nsp] = socket;
    } else if (this._autoConnect && !socket.active) {
      socket.connect();
    }
    return socket;
  }
  /**
   * Called upon a socket close.
   *
   * @param socket
   * @private
   */
  _destroy(socket) {
    const nsps = Object.keys(this.nsps);
    for (const nsp of nsps) {
      const socket2 = this.nsps[nsp];
      if (socket2.active) {
        return;
      }
    }
    this._close();
  }
  /**
   * Writes a packet.
   *
   * @param packet
   * @private
   */
  _packet(packet) {
    const encodedPackets = this.encoder.encode(packet);
    for (let i = 0; i < encodedPackets.length; i++) {
      this.engine.write(encodedPackets[i], packet.options);
    }
  }
  /**
   * Clean up transport subscriptions and packet buffer.
   *
   * @private
   */
  cleanup() {
    this.subs.forEach((subDestroy) => subDestroy());
    this.subs.length = 0;
    this.decoder.destroy();
  }
  /**
   * Close the current socket.
   *
   * @private
   */
  _close() {
    this.skipReconnect = true;
    this._reconnecting = false;
    this.onclose("forced close");
  }
  /**
   * Alias for close()
   *
   * @private
   */
  disconnect() {
    return this._close();
  }
  /**
   * Called when:
   *
   * - the low-level engine is closed
   * - the parser encountered a badly formatted packet
   * - all sockets are disconnected
   *
   * @private
   */
  onclose(reason, description) {
    var _a;
    this.cleanup();
    (_a = this.engine) === null || _a === void 0 ? void 0 : _a.close();
    this.backoff.reset();
    this._readyState = "closed";
    this.emitReserved("close", reason, description);
    if (this._reconnection && !this.skipReconnect) {
      this.reconnect();
    }
  }
  /**
   * Attempt a reconnection.
   *
   * @private
   */
  reconnect() {
    if (this._reconnecting || this.skipReconnect)
      return this;
    const self2 = this;
    if (this.backoff.attempts >= this._reconnectionAttempts) {
      this.backoff.reset();
      this.emitReserved("reconnect_failed");
      this._reconnecting = false;
    } else {
      const delay = this.backoff.duration();
      this._reconnecting = true;
      const timer = this.setTimeoutFn(() => {
        if (self2.skipReconnect)
          return;
        this.emitReserved("reconnect_attempt", self2.backoff.attempts);
        if (self2.skipReconnect)
          return;
        self2.open((err) => {
          if (err) {
            self2._reconnecting = false;
            self2.reconnect();
            this.emitReserved("reconnect_error", err);
          } else {
            self2.onreconnect();
          }
        });
      }, delay);
      if (this.opts.autoUnref) {
        timer.unref();
      }
      this.subs.push(() => {
        this.clearTimeoutFn(timer);
      });
    }
  }
  /**
   * Called upon successful reconnect.
   *
   * @private
   */
  onreconnect() {
    const attempt = this.backoff.attempts;
    this._reconnecting = false;
    this.backoff.reset();
    this.emitReserved("reconnect", attempt);
  }
};

// node_modules/socket.io-client/build/esm/index.js
var cache = {};
function lookup2(uri, opts) {
  if (typeof uri === "object") {
    opts = uri;
    uri = void 0;
  }
  opts = opts || {};
  const parsed = url(uri, opts.path || "/socket.io");
  const source = parsed.source;
  const id = parsed.id;
  const path = parsed.path;
  const sameNamespace = cache[id] && path in cache[id]["nsps"];
  const newConnection = opts.forceNew || opts["force new connection"] || false === opts.multiplex || sameNamespace;
  let io;
  if (newConnection) {
    io = new Manager(source, opts);
  } else {
    if (!cache[id]) {
      cache[id] = new Manager(source, opts);
    }
    io = cache[id];
  }
  if (parsed.query && !opts.query) {
    opts.query = parsed.queryKey;
  }
  return io.socket(parsed.path, opts);
}
Object.assign(lookup2, {
  Manager,
  Socket: Socket2,
  io: lookup2,
  connect: lookup2
});

// node_modules/@selfxyz/qrcode/dist/chunk-JIBTBBJU.js
console.log("[WebSocket] Initializing websocket module.");
var validateWebSocketUrl = (websocketUrl) => {
  if (websocketUrl.includes("localhost") || websocketUrl.includes("127.0.0.1")) {
    throw new Error("localhost websocket URLs are not allowed");
  }
};
var newSocket = (websocketUrl, sessionId) => {
  const fullUrl = `${websocketUrl}/websocket`;
  console.log(
    `[WebSocket] Creating new socket. URL: ${fullUrl}, sessionId: ${sessionId}`
  );
  return lookup2(fullUrl, {
    path: "/",
    query: { sessionId, clientType: "web" },
    transports: ["websocket"]
  });
};
var handleWebSocketMessage = (socket, sessionId, selfApp, type, setProofStep, onSuccess, onError) => async (data2) => {
  console.log(
    "[WebSocket] Received mobile status:",
    data2.status,
    "for session:",
    sessionId
  );
  switch (data2.status) {
    case "mobile_connected":
      console.log(
        "[WebSocket] Mobile device connected. Emitting self_app event with payload:",
        selfApp
      );
      setProofStep(QRcodeSteps.MOBILE_CONNECTED);
      if (type === "websocket") {
        socket.emit("self_app", { ...selfApp, sessionId });
      }
      break;
    case "mobile_disconnected":
      console.log("[WebSocket] Mobile device disconnected.");
      setProofStep(QRcodeSteps.WAITING_FOR_MOBILE);
      break;
    case "proof_generation_started":
      console.log("[WebSocket] Proof generation started.");
      setProofStep(QRcodeSteps.PROOF_GENERATION_STARTED);
      break;
    case "proof_generated":
      console.log("[WebSocket] Proof generated.");
      setProofStep(QRcodeSteps.PROOF_GENERATED);
      break;
    case "proof_generation_failed":
      console.log("[WebSocket] Proof generation failed.");
      setProofStep(QRcodeSteps.PROOF_GENERATION_FAILED);
      onError(data2);
      break;
    case "proof_verified":
      console.log("[WebSocket] Proof verified.");
      console.log("ws data", data2);
      setProofStep(QRcodeSteps.PROOF_VERIFIED);
      onSuccess();
      break;
    default:
      console.log("[WebSocket] Unhandled mobile status:", data2.status);
      break;
  }
};
function initWebSocket(websocketUrl, selfApp, type, setProofStep, onSuccess, onError) {
  validateWebSocketUrl(websocketUrl);
  const sessionId = selfApp.sessionId;
  console.log(
    `[WebSocket] Initializing WebSocket connection for sessionId: ${sessionId}`
  );
  const socket = newSocket(websocketUrl, sessionId);
  socket.on("connect", () => {
    console.log(
      `[WebSocket] Connected with id: ${socket.id}, transport: ${socket.io.engine.transport.name}`
    );
  });
  socket.on("connect_error", (error) => {
    console.error("[WebSocket] Connection error:", error);
  });
  socket.on("mobile_status", (data2) => {
    console.log("[WebSocket] Raw mobile_status event received:", data2);
    handleWebSocketMessage(
      socket,
      sessionId,
      selfApp,
      type,
      setProofStep,
      onSuccess,
      onError
    )(data2);
  });
  socket.on("disconnect", (reason) => {
    console.log(
      `[WebSocket] Disconnected. Reason: ${reason}, Last transport: ${socket.io.engine.transport?.name}`
    );
  });
  return () => {
    console.log(
      `[WebSocket] Cleaning up connection for sessionId: ${sessionId}`
    );
    if (socket) {
      socket.disconnect();
    }
  };
}

// node_modules/@selfxyz/qrcode/dist/chunk-YLXJTR7N.js
var import_react4 = __toESM(require_react(), 1);

// node_modules/react-spinners/esm/BarLoader.js
var React2 = __toESM(require_react());

// node_modules/react-spinners/esm/helpers/unitConverter.js
var cssUnit = {
  cm: true,
  mm: true,
  in: true,
  px: true,
  pt: true,
  pc: true,
  em: true,
  ex: true,
  ch: true,
  rem: true,
  vw: true,
  vh: true,
  vmin: true,
  vmax: true,
  "%": true
};
function parseLengthAndUnit(size) {
  if (typeof size === "number") {
    return {
      value: size,
      unit: "px"
    };
  }
  var value3;
  var valueString = (size.match(/^[0-9.]*/) || "").toString();
  if (valueString.includes(".")) {
    value3 = parseFloat(valueString);
  } else {
    value3 = parseInt(valueString, 10);
  }
  var unit = (size.match(/[^0-9]*$/) || "").toString();
  if (cssUnit[unit]) {
    return {
      value: value3,
      unit
    };
  }
  console.warn("React Spinners: ".concat(size, " is not a valid css value. Defaulting to ").concat(value3, "px."));
  return {
    value: value3,
    unit: "px"
  };
}
function cssValue(value3) {
  var lengthWithunit = parseLengthAndUnit(value3);
  return "".concat(lengthWithunit.value).concat(lengthWithunit.unit);
}

// node_modules/react-spinners/esm/helpers/animation.js
var createAnimation = function(loaderName, frames2, suffix) {
  var animationName = "react-spinners-".concat(loaderName, "-").concat(suffix);
  if (typeof window == "undefined" || !window.document) {
    return animationName;
  }
  var styleEl = document.createElement("style");
  document.head.appendChild(styleEl);
  var styleSheet = styleEl.sheet;
  var keyFrames = "\n    @keyframes ".concat(animationName, " {\n      ").concat(frames2, "\n    }\n  ");
  if (styleSheet) {
    styleSheet.insertRule(keyFrames, 0);
  }
  return animationName;
};

// node_modules/react-spinners/esm/helpers/colors.js
var BasicColors;
(function(BasicColors2) {
  BasicColors2["maroon"] = "#800000";
  BasicColors2["red"] = "#FF0000";
  BasicColors2["orange"] = "#FFA500";
  BasicColors2["yellow"] = "#FFFF00";
  BasicColors2["olive"] = "#808000";
  BasicColors2["green"] = "#008000";
  BasicColors2["purple"] = "#800080";
  BasicColors2["fuchsia"] = "#FF00FF";
  BasicColors2["lime"] = "#00FF00";
  BasicColors2["teal"] = "#008080";
  BasicColors2["aqua"] = "#00FFFF";
  BasicColors2["blue"] = "#0000FF";
  BasicColors2["navy"] = "#000080";
  BasicColors2["black"] = "#000000";
  BasicColors2["gray"] = "#808080";
  BasicColors2["silver"] = "#C0C0C0";
  BasicColors2["white"] = "#FFFFFF";
})(BasicColors || (BasicColors = {}));

// node_modules/react-spinners/esm/BarLoader.js
var long = createAnimation("BarLoader", "0% {left: -35%;right: 100%} 60% {left: 100%;right: -90%} 100% {left: 100%;right: -90%}", "long");
var short = createAnimation("BarLoader", "0% {left: -200%;right: 100%} 60% {left: 107%;right: -8%} 100% {left: 107%;right: -8%}", "short");

// node_modules/react-spinners/esm/BeatLoader.js
var React3 = __toESM(require_react());
var beat = createAnimation("BeatLoader", "50% {transform: scale(0.75);opacity: 0.2} 100% {transform: scale(1);opacity: 1}", "beat");

// node_modules/react-spinners/esm/BounceLoader.js
var React4 = __toESM(require_react());
var __assign = function() {
  __assign = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
var __rest = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var bounce = createAnimation("BounceLoader", "0% {transform: scale(0)} 50% {transform: scale(1.0)} 100% {transform: scale(0)}", "bounce");
function BounceLoader(_a) {
  var _b = _a.loading, loading = _b === void 0 ? true : _b, _c = _a.color, color = _c === void 0 ? "#000000" : _c, _d = _a.speedMultiplier, speedMultiplier = _d === void 0 ? 1 : _d, _e = _a.cssOverride, cssOverride = _e === void 0 ? {} : _e, _f = _a.size, size = _f === void 0 ? 60 : _f, additionalprops = __rest(_a, ["loading", "color", "speedMultiplier", "cssOverride", "size"]);
  var style = function(i) {
    var animationTiming = i === 1 ? "".concat(1 / speedMultiplier, "s") : "0s";
    return {
      position: "absolute",
      height: cssValue(size),
      width: cssValue(size),
      backgroundColor: color,
      borderRadius: "100%",
      opacity: 0.6,
      top: 0,
      left: 0,
      animationFillMode: "both",
      animation: "".concat(bounce, " ").concat(2.1 / speedMultiplier, "s ").concat(animationTiming, " infinite ease-in-out")
    };
  };
  var wrapper = __assign({ display: "inherit", position: "relative", width: cssValue(size), height: cssValue(size) }, cssOverride);
  if (!loading) {
    return null;
  }
  return React4.createElement(
    "span",
    __assign({ style: wrapper }, additionalprops),
    React4.createElement("span", { style: style(1) }),
    React4.createElement("span", { style: style(2) })
  );
}
var BounceLoader_default = BounceLoader;

// node_modules/react-spinners/esm/CircleLoader.js
var React5 = __toESM(require_react());
var circle = createAnimation("CircleLoader", "0% {transform: rotate(0deg)} 50% {transform: rotate(180deg)} 100% {transform: rotate(360deg)}", "circle");

// node_modules/react-spinners/esm/ClimbingBoxLoader.js
var React6 = __toESM(require_react());
var climbingBox = createAnimation("ClimbingBoxLoader", "0% {transform:translate(0, -1em) rotate(-45deg)}\n  5% {transform:translate(0, -1em) rotate(-50deg)}\n  20% {transform:translate(1em, -2em) rotate(47deg)}\n  25% {transform:translate(1em, -2em) rotate(45deg)}\n  30% {transform:translate(1em, -2em) rotate(40deg)}\n  45% {transform:translate(2em, -3em) rotate(137deg)}\n  50% {transform:translate(2em, -3em) rotate(135deg)}\n  55% {transform:translate(2em, -3em) rotate(130deg)}\n  70% {transform:translate(3em, -4em) rotate(217deg)}\n  75% {transform:translate(3em, -4em) rotate(220deg)}\n  100% {transform:translate(0, -1em) rotate(-225deg)}", "climbingBox");

// node_modules/react-spinners/esm/ClipLoader.js
var React7 = __toESM(require_react());
var clip = createAnimation("ClipLoader", "0% {transform: rotate(0deg) scale(1)} 50% {transform: rotate(180deg) scale(0.8)} 100% {transform: rotate(360deg) scale(1)}", "clip");

// node_modules/react-spinners/esm/ClockLoader.js
var React8 = __toESM(require_react());
var rotate = createAnimation("ClockLoader", "100% { transform: rotate(360deg) }", "rotate");

// node_modules/react-spinners/esm/DotLoader.js
var React9 = __toESM(require_react());
var rotate2 = createAnimation("DotLoader", "100% {transform: rotate(360deg)}", "rotate");
var bounce2 = createAnimation("DotLoader", "0%, 100% {transform: scale(0)} 50% {transform: scale(1.0)}", "bounce");

// node_modules/react-spinners/esm/FadeLoader.js
var React10 = __toESM(require_react());
var fade = createAnimation("FadeLoader", "50% {opacity: 0.3} 100% {opacity: 1}", "fade");

// node_modules/react-spinners/esm/GridLoader.js
var React11 = __toESM(require_react());
var grid = createAnimation("GridLoader", "0% {transform: scale(1)} 50% {transform: scale(0.5); opacity: 0.7} 100% {transform: scale(1); opacity: 1}", "grid");

// node_modules/react-spinners/esm/HashLoader.js
var React12 = __toESM(require_react());

// node_modules/react-spinners/esm/MoonLoader.js
var React13 = __toESM(require_react());
var moon = createAnimation("MoonLoader", "100% {transform: rotate(360deg)}", "moon");

// node_modules/react-spinners/esm/PacmanLoader.js
var React14 = __toESM(require_react());
var pacman = [
  createAnimation("PacmanLoader", "0% {transform: rotate(0deg)} 50% {transform: rotate(-44deg)}", "pacman-1"),
  createAnimation("PacmanLoader", "0% {transform: rotate(0deg)} 50% {transform: rotate(44deg)}", "pacman-2")
];

// node_modules/react-spinners/esm/PropagateLoader.js
var React15 = __toESM(require_react());
var distance = [1, 3, 5];
var propagate = [
  createAnimation("PropagateLoader", "25% {transform: translateX(-".concat(distance[0], "rem) scale(0.75)}\n    50% {transform: translateX(-").concat(distance[1], "rem) scale(0.6)}\n    75% {transform: translateX(-").concat(distance[2], "rem) scale(0.5)}\n    95% {transform: translateX(0rem) scale(1)}"), "propogate-0"),
  createAnimation("PropagateLoader", "25% {transform: translateX(-".concat(distance[0], "rem) scale(0.75)}\n    50% {transform: translateX(-").concat(distance[1], "rem) scale(0.6)}\n    75% {transform: translateX(-").concat(distance[1], "rem) scale(0.6)}\n    95% {transform: translateX(0rem) scale(1)}"), "propogate-1"),
  createAnimation("PropagateLoader", "25% {transform: translateX(-".concat(distance[0], "rem) scale(0.75)}\n    75% {transform: translateX(-").concat(distance[0], "rem) scale(0.75)}\n    95% {transform: translateX(0rem) scale(1)}"), "propogate-2"),
  createAnimation("PropagateLoader", "25% {transform: translateX(".concat(distance[0], "rem) scale(0.75)}\n    75% {transform: translateX(").concat(distance[0], "rem) scale(0.75)}\n    95% {transform: translateX(0rem) scale(1)}"), "propogate-3"),
  createAnimation("PropagateLoader", "25% {transform: translateX(".concat(distance[0], "rem) scale(0.75)}\n    50% {transform: translateX(").concat(distance[1], "rem) scale(0.6)}\n    75% {transform: translateX(").concat(distance[1], "rem) scale(0.6)}\n    95% {transform: translateX(0rem) scale(1)}"), "propogate-4"),
  createAnimation("PropagateLoader", "25% {transform: translateX(".concat(distance[0], "rem) scale(0.75)}\n    50% {transform: translateX(").concat(distance[1], "rem) scale(0.6)}\n    75% {transform: translateX(").concat(distance[2], "rem) scale(0.5)}\n    95% {transform: translateX(0rem) scale(1)}"), "propogate-5")
];

// node_modules/react-spinners/esm/PulseLoader.js
var React16 = __toESM(require_react());
var pulse = createAnimation("PulseLoader", "0% {transform: scale(1); opacity: 1} 45% {transform: scale(0.1); opacity: 0.7} 80% {transform: scale(1); opacity: 1}", "pulse");

// node_modules/react-spinners/esm/PuffLoader.js
var React17 = __toESM(require_react());
var puff = [
  createAnimation("PuffLoader", "0% {transform: scale(0)} 100% {transform: scale(1.0)}", "puff-1"),
  createAnimation("PuffLoader", "0% {opacity: 1} 100% {opacity: 0}", "puff-2")
];

// node_modules/react-spinners/esm/RingLoader.js
var React18 = __toESM(require_react());
var right = createAnimation("RingLoader", "0% {transform: rotateX(0deg) rotateY(0deg) rotateZ(0deg)} 100% {transform: rotateX(180deg) rotateY(360deg) rotateZ(360deg)}", "right");
var left = createAnimation("RingLoader", "0% {transform: rotateX(0deg) rotateY(0deg) rotateZ(0deg)} 100% {transform: rotateX(360deg) rotateY(180deg) rotateZ(360deg)}", "left");

// node_modules/react-spinners/esm/RiseLoader.js
var React19 = __toESM(require_react());

// node_modules/react-spinners/esm/RotateLoader.js
var React20 = __toESM(require_react());
var rotate3 = createAnimation("RotateLoader", "0% {transform: rotate(0deg)} 50% {transform: rotate(180deg)} 100% {transform: rotate(360deg)}", "rotate");

// node_modules/react-spinners/esm/ScaleLoader.js
var React21 = __toESM(require_react());
var scale2 = createAnimation("ScaleLoader", "0% {transform: scaley(1.0)} 50% {transform: scaley(0.4)} 100% {transform: scaley(1.0)}", "scale");

// node_modules/react-spinners/esm/SkewLoader.js
var React22 = __toESM(require_react());
var skew = createAnimation("SkewLoader", "25% {transform: perspective(100px) rotateX(180deg) rotateY(0)} 50% {transform: perspective(100px) rotateX(180deg) rotateY(180deg)} 75% {transform: perspective(100px) rotateX(0) rotateY(180deg)} 100% {transform: perspective(100px) rotateX(0) rotateY(0)}", "skew");

// node_modules/react-spinners/esm/SquareLoader.js
var React23 = __toESM(require_react());
var square = createAnimation("SquareLoader", "25% {transform: rotateX(180deg) rotateY(0)}\n  50% {transform: rotateX(180deg) rotateY(180deg)} \n  75% {transform: rotateX(0) rotateY(180deg)} \n  100% {transform: rotateX(0) rotateY(0)}", "square");

// node_modules/react-spinners/esm/SyncLoader.js
var React24 = __toESM(require_react());
var sync = createAnimation("SyncLoader", "33% {transform: translateY(10px)}\n  66% {transform: translateY(-10px)}\n  100% {transform: translateY(0)}", "sync");

// node_modules/lottie-react/build/index.es.js
var import_lottie_web = __toESM(require_lottie());
var import_lottie_web2 = __toESM(require_lottie());
var import_react2 = __toESM(require_react());
function _arrayLikeToArray(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
function _arrayWithHoles(r) {
  if (Array.isArray(r)) return r;
}
function _defineProperty(e, r, t) {
  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
    value: t,
    enumerable: true,
    configurable: true,
    writable: true
  }) : e[r] = t, e;
}
function _iterableToArrayLimit(r, l) {
  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t) {
    var e, n, i, u, a = [], f3 = true, o = false;
    try {
      if (i = (t = t.call(r)).next, 0 === l) {
        if (Object(t) !== t) return;
        f3 = false;
      } else for (; !(f3 = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f3 = true) ;
    } catch (r2) {
      o = true, n = r2;
    } finally {
      try {
        if (!f3 && null != t.return && (u = t.return(), Object(u) !== u)) return;
      } finally {
        if (o) throw n;
      }
    }
    return a;
  }
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function ownKeys(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread2(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
      _defineProperty(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _objectWithoutProperties(e, t) {
  if (null == e) return {};
  var o, r, i = _objectWithoutPropertiesLoose(e, t);
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(e);
    for (r = 0; r < s.length; r++) o = s[r], t.includes(o) || {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
  }
  return i;
}
function _objectWithoutPropertiesLoose(r, e) {
  if (null == r) return {};
  var t = {};
  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (e.includes(n)) continue;
    t[n] = r[n];
  }
  return t;
}
function _slicedToArray(r, e) {
  return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();
}
function _toPrimitive(t, r) {
  if ("object" != typeof t || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function _toPropertyKey(t) {
  var i = _toPrimitive(t, "string");
  return "symbol" == typeof i ? i : i + "";
}
function _unsupportedIterableToArray(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
  }
}
var _excluded$1 = ["animationData", "loop", "autoplay", "initialSegment", "onComplete", "onLoopComplete", "onEnterFrame", "onSegmentStart", "onConfigReady", "onDataReady", "onDataFailed", "onLoadedImages", "onDOMLoaded", "onDestroy", "lottieRef", "renderer", "name", "assetsPath", "rendererSettings"];
var useLottie = function useLottie2(props, style) {
  var animationData2 = props.animationData, loop = props.loop, autoplay = props.autoplay, initialSegment = props.initialSegment, onComplete = props.onComplete, onLoopComplete = props.onLoopComplete, onEnterFrame = props.onEnterFrame, onSegmentStart = props.onSegmentStart, onConfigReady = props.onConfigReady, onDataReady = props.onDataReady, onDataFailed = props.onDataFailed, onLoadedImages = props.onLoadedImages, onDOMLoaded = props.onDOMLoaded, onDestroy = props.onDestroy;
  props.lottieRef;
  props.renderer;
  props.name;
  props.assetsPath;
  props.rendererSettings;
  var rest = _objectWithoutProperties(props, _excluded$1);
  var _useState = (0, import_react2.useState)(false), _useState2 = _slicedToArray(_useState, 2), animationLoaded = _useState2[0], setAnimationLoaded = _useState2[1];
  var animationInstanceRef = (0, import_react2.useRef)();
  var animationContainer = (0, import_react2.useRef)(null);
  var play = function play2() {
    var _a;
    (_a = animationInstanceRef.current) === null || _a === void 0 ? void 0 : _a.play();
  };
  var stop = function stop2() {
    var _a;
    (_a = animationInstanceRef.current) === null || _a === void 0 ? void 0 : _a.stop();
  };
  var pause = function pause2() {
    var _a;
    (_a = animationInstanceRef.current) === null || _a === void 0 ? void 0 : _a.pause();
  };
  var setSpeed = function setSpeed2(speed) {
    var _a;
    (_a = animationInstanceRef.current) === null || _a === void 0 ? void 0 : _a.setSpeed(speed);
  };
  var goToAndPlay = function goToAndPlay2(value3, isFrame) {
    var _a;
    (_a = animationInstanceRef.current) === null || _a === void 0 ? void 0 : _a.goToAndPlay(value3, isFrame);
  };
  var goToAndStop = function goToAndStop2(value3, isFrame) {
    var _a;
    (_a = animationInstanceRef.current) === null || _a === void 0 ? void 0 : _a.goToAndStop(value3, isFrame);
  };
  var setDirection = function setDirection2(direction) {
    var _a;
    (_a = animationInstanceRef.current) === null || _a === void 0 ? void 0 : _a.setDirection(direction);
  };
  var playSegments = function playSegments2(segments, forceFlag) {
    var _a;
    (_a = animationInstanceRef.current) === null || _a === void 0 ? void 0 : _a.playSegments(segments, forceFlag);
  };
  var setSubframe = function setSubframe2(useSubFrames) {
    var _a;
    (_a = animationInstanceRef.current) === null || _a === void 0 ? void 0 : _a.setSubframe(useSubFrames);
  };
  var getDuration = function getDuration2(inFrames) {
    var _a;
    return (_a = animationInstanceRef.current) === null || _a === void 0 ? void 0 : _a.getDuration(inFrames);
  };
  var destroy = function destroy2() {
    var _a;
    (_a = animationInstanceRef.current) === null || _a === void 0 ? void 0 : _a.destroy();
    animationInstanceRef.current = void 0;
  };
  var loadAnimation2 = function loadAnimation3() {
    var forcedConfigs = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var _a;
    if (!animationContainer.current) {
      return;
    }
    (_a = animationInstanceRef.current) === null || _a === void 0 ? void 0 : _a.destroy();
    var config = _objectSpread2(_objectSpread2(_objectSpread2({}, props), forcedConfigs), {}, {
      container: animationContainer.current
    });
    animationInstanceRef.current = import_lottie_web.default.loadAnimation(config);
    setAnimationLoaded(!!animationInstanceRef.current);
    return function() {
      var _a2;
      (_a2 = animationInstanceRef.current) === null || _a2 === void 0 ? void 0 : _a2.destroy();
      animationInstanceRef.current = void 0;
    };
  };
  (0, import_react2.useEffect)(function() {
    var onUnmount = loadAnimation2();
    return function() {
      return onUnmount === null || onUnmount === void 0 ? void 0 : onUnmount();
    };
  }, [animationData2, loop]);
  (0, import_react2.useEffect)(function() {
    if (!animationInstanceRef.current) {
      return;
    }
    animationInstanceRef.current.autoplay = !!autoplay;
  }, [autoplay]);
  (0, import_react2.useEffect)(function() {
    if (!animationInstanceRef.current) {
      return;
    }
    if (!initialSegment) {
      animationInstanceRef.current.resetSegments(true);
      return;
    }
    if (!Array.isArray(initialSegment) || !initialSegment.length) {
      return;
    }
    if (animationInstanceRef.current.currentRawFrame < initialSegment[0] || animationInstanceRef.current.currentRawFrame > initialSegment[1]) {
      animationInstanceRef.current.currentRawFrame = initialSegment[0];
    }
    animationInstanceRef.current.setSegment(initialSegment[0], initialSegment[1]);
  }, [initialSegment]);
  (0, import_react2.useEffect)(function() {
    var partialListeners = [{
      name: "complete",
      handler: onComplete
    }, {
      name: "loopComplete",
      handler: onLoopComplete
    }, {
      name: "enterFrame",
      handler: onEnterFrame
    }, {
      name: "segmentStart",
      handler: onSegmentStart
    }, {
      name: "config_ready",
      handler: onConfigReady
    }, {
      name: "data_ready",
      handler: onDataReady
    }, {
      name: "data_failed",
      handler: onDataFailed
    }, {
      name: "loaded_images",
      handler: onLoadedImages
    }, {
      name: "DOMLoaded",
      handler: onDOMLoaded
    }, {
      name: "destroy",
      handler: onDestroy
    }];
    var listeners = partialListeners.filter(function(listener) {
      return listener.handler != null;
    });
    if (!listeners.length) {
      return;
    }
    var deregisterList = listeners.map(
      /**
       * Handle the process of adding an event listener
       * @param {Listener} listener
       * @return {Function} Function that deregister the listener
       */
      function(listener) {
        var _a;
        (_a = animationInstanceRef.current) === null || _a === void 0 ? void 0 : _a.addEventListener(listener.name, listener.handler);
        return function() {
          var _a2;
          (_a2 = animationInstanceRef.current) === null || _a2 === void 0 ? void 0 : _a2.removeEventListener(listener.name, listener.handler);
        };
      }
    );
    return function() {
      deregisterList.forEach(function(deregister) {
        return deregister();
      });
    };
  }, [onComplete, onLoopComplete, onEnterFrame, onSegmentStart, onConfigReady, onDataReady, onDataFailed, onLoadedImages, onDOMLoaded, onDestroy]);
  var View = import_react2.default.createElement("div", _objectSpread2({
    style,
    ref: animationContainer
  }, rest));
  return {
    View,
    play,
    stop,
    pause,
    setSpeed,
    goToAndStop,
    goToAndPlay,
    setDirection,
    playSegments,
    setSubframe,
    getDuration,
    destroy,
    animationContainerRef: animationContainer,
    animationLoaded,
    animationItem: animationInstanceRef.current
  };
};
function getContainerVisibility(container) {
  var _container$getBoundin = container.getBoundingClientRect(), top = _container$getBoundin.top, height2 = _container$getBoundin.height;
  var current = window.innerHeight - top;
  var max = window.innerHeight + height2;
  return current / max;
}
function getContainerCursorPosition(container, cursorX, cursorY) {
  var _container$getBoundin2 = container.getBoundingClientRect(), top = _container$getBoundin2.top, left2 = _container$getBoundin2.left, width2 = _container$getBoundin2.width, height2 = _container$getBoundin2.height;
  var x = (cursorX - left2) / width2;
  var y = (cursorY - top) / height2;
  return {
    x,
    y
  };
}
var useInitInteractivity = function useInitInteractivity2(_ref) {
  var wrapperRef = _ref.wrapperRef, animationItem = _ref.animationItem, mode = _ref.mode, actions = _ref.actions;
  (0, import_react2.useEffect)(function() {
    var wrapper = wrapperRef.current;
    if (!wrapper || !animationItem || !actions.length) {
      return;
    }
    animationItem.stop();
    var scrollModeHandler = function scrollModeHandler2() {
      var assignedSegment = null;
      var scrollHandler = function scrollHandler2() {
        var currentPercent = getContainerVisibility(wrapper);
        var action = actions.find(function(_ref2) {
          var visibility = _ref2.visibility;
          return visibility && currentPercent >= visibility[0] && currentPercent <= visibility[1];
        });
        if (!action) {
          return;
        }
        if (action.type === "seek" && action.visibility && action.frames.length === 2) {
          var frameToGo = action.frames[0] + Math.ceil((currentPercent - action.visibility[0]) / (action.visibility[1] - action.visibility[0]) * action.frames[1]);
          animationItem.goToAndStop(frameToGo - animationItem.firstFrame - 1, true);
        }
        if (action.type === "loop") {
          if (assignedSegment === null) {
            animationItem.playSegments(action.frames, true);
            assignedSegment = action.frames;
          } else {
            if (assignedSegment !== action.frames) {
              animationItem.playSegments(action.frames, true);
              assignedSegment = action.frames;
            } else if (animationItem.isPaused) {
              animationItem.playSegments(action.frames, true);
              assignedSegment = action.frames;
            }
          }
        }
        if (action.type === "play" && animationItem.isPaused) {
          animationItem.resetSegments(true);
          animationItem.play();
        }
        if (action.type === "stop") {
          animationItem.goToAndStop(action.frames[0] - animationItem.firstFrame - 1, true);
        }
      };
      document.addEventListener("scroll", scrollHandler);
      return function() {
        document.removeEventListener("scroll", scrollHandler);
      };
    };
    var cursorModeHandler = function cursorModeHandler2() {
      var handleCursor = function handleCursor2(_x, _y) {
        var x = _x;
        var y = _y;
        if (x !== -1 && y !== -1) {
          var pos = getContainerCursorPosition(wrapper, x, y);
          x = pos.x;
          y = pos.y;
        }
        var action = actions.find(function(_ref3) {
          var position2 = _ref3.position;
          if (position2 && Array.isArray(position2.x) && Array.isArray(position2.y)) {
            return x >= position2.x[0] && x <= position2.x[1] && y >= position2.y[0] && y <= position2.y[1];
          }
          if (position2 && !Number.isNaN(position2.x) && !Number.isNaN(position2.y)) {
            return x === position2.x && y === position2.y;
          }
          return false;
        });
        if (!action) {
          return;
        }
        if (action.type === "seek" && action.position && Array.isArray(action.position.x) && Array.isArray(action.position.y) && action.frames.length === 2) {
          var xPercent = (x - action.position.x[0]) / (action.position.x[1] - action.position.x[0]);
          var yPercent = (y - action.position.y[0]) / (action.position.y[1] - action.position.y[0]);
          animationItem.playSegments(action.frames, true);
          animationItem.goToAndStop(Math.ceil((xPercent + yPercent) / 2 * (action.frames[1] - action.frames[0])), true);
        }
        if (action.type === "loop") {
          animationItem.playSegments(action.frames, true);
        }
        if (action.type === "play") {
          if (animationItem.isPaused) {
            animationItem.resetSegments(false);
          }
          animationItem.playSegments(action.frames);
        }
        if (action.type === "stop") {
          animationItem.goToAndStop(action.frames[0], true);
        }
      };
      var mouseMoveHandler = function mouseMoveHandler2(ev) {
        handleCursor(ev.clientX, ev.clientY);
      };
      var mouseOutHandler = function mouseOutHandler2() {
        handleCursor(-1, -1);
      };
      wrapper.addEventListener("mousemove", mouseMoveHandler);
      wrapper.addEventListener("mouseout", mouseOutHandler);
      return function() {
        wrapper.removeEventListener("mousemove", mouseMoveHandler);
        wrapper.removeEventListener("mouseout", mouseOutHandler);
      };
    };
    switch (mode) {
      case "scroll":
        return scrollModeHandler();
      case "cursor":
        return cursorModeHandler();
    }
  }, [mode, animationItem]);
};
var useLottieInteractivity = function useLottieInteractivity2(_ref4) {
  var actions = _ref4.actions, mode = _ref4.mode, lottieObj = _ref4.lottieObj;
  var animationItem = lottieObj.animationItem, View = lottieObj.View, animationContainerRef = lottieObj.animationContainerRef;
  useInitInteractivity({
    actions,
    animationItem,
    mode,
    wrapperRef: animationContainerRef
  });
  return View;
};
var _excluded = ["style", "interactivity"];
var Lottie = function Lottie2(props) {
  var _a, _b, _c;
  var style = props.style, interactivity = props.interactivity, lottieProps = _objectWithoutProperties(props, _excluded);
  var _useLottie = useLottie(lottieProps, style), View = _useLottie.View, play = _useLottie.play, stop = _useLottie.stop, pause = _useLottie.pause, setSpeed = _useLottie.setSpeed, goToAndStop = _useLottie.goToAndStop, goToAndPlay = _useLottie.goToAndPlay, setDirection = _useLottie.setDirection, playSegments = _useLottie.playSegments, setSubframe = _useLottie.setSubframe, getDuration = _useLottie.getDuration, destroy = _useLottie.destroy, animationContainerRef = _useLottie.animationContainerRef, animationLoaded = _useLottie.animationLoaded, animationItem = _useLottie.animationItem;
  (0, import_react2.useEffect)(function() {
    if (props.lottieRef) {
      props.lottieRef.current = {
        play,
        stop,
        pause,
        setSpeed,
        goToAndPlay,
        goToAndStop,
        setDirection,
        playSegments,
        setSubframe,
        getDuration,
        destroy,
        animationContainerRef,
        animationLoaded,
        animationItem
      };
    }
  }, [(_a = props.lottieRef) === null || _a === void 0 ? void 0 : _a.current]);
  return useLottieInteractivity({
    lottieObj: {
      View,
      play,
      stop,
      pause,
      setSpeed,
      goToAndStop,
      goToAndPlay,
      setDirection,
      playSegments,
      setSubframe,
      getDuration,
      destroy,
      animationContainerRef,
      animationLoaded,
      animationItem
    },
    actions: (_b = interactivity === null || interactivity === void 0 ? void 0 : interactivity.actions) !== null && _b !== void 0 ? _b : [],
    mode: (_c = interactivity === null || interactivity === void 0 ? void 0 : interactivity.mode) !== null && _c !== void 0 ? _c : "scroll"
  });
};

// node_modules/@selfxyz/common/dist/esm/src/constants/constants.js
var REDIRECT_URL = "https://redirect.self.xyz";
var WS_DB_RELAYER = "wss://websocket.self.xyz";
var RegisterVerifierId;
(function(RegisterVerifierId2) {
  RegisterVerifierId2[RegisterVerifierId2["register_sha256_sha256_sha256_rsa_65537_4096"] = 0] = "register_sha256_sha256_sha256_rsa_65537_4096";
  RegisterVerifierId2[RegisterVerifierId2["register_sha256_sha256_sha256_ecdsa_brainpoolP384r1"] = 1] = "register_sha256_sha256_sha256_ecdsa_brainpoolP384r1";
  RegisterVerifierId2[RegisterVerifierId2["register_sha256_sha256_sha256_ecdsa_secp256r1"] = 2] = "register_sha256_sha256_sha256_ecdsa_secp256r1";
  RegisterVerifierId2[RegisterVerifierId2["register_sha256_sha256_sha256_ecdsa_secp384r1"] = 3] = "register_sha256_sha256_sha256_ecdsa_secp384r1";
  RegisterVerifierId2[RegisterVerifierId2["register_sha256_sha256_sha256_rsa_3_4096"] = 4] = "register_sha256_sha256_sha256_rsa_3_4096";
  RegisterVerifierId2[RegisterVerifierId2["register_sha256_sha256_sha256_rsapss_3_32_2048"] = 5] = "register_sha256_sha256_sha256_rsapss_3_32_2048";
  RegisterVerifierId2[RegisterVerifierId2["register_sha256_sha256_sha256_rsapss_65537_32_2048"] = 6] = "register_sha256_sha256_sha256_rsapss_65537_32_2048";
  RegisterVerifierId2[RegisterVerifierId2["register_sha256_sha256_sha256_rsapss_65537_32_3072"] = 7] = "register_sha256_sha256_sha256_rsapss_65537_32_3072";
  RegisterVerifierId2[RegisterVerifierId2["register_sha384_sha384_sha384_ecdsa_brainpoolP384r1"] = 8] = "register_sha384_sha384_sha384_ecdsa_brainpoolP384r1";
  RegisterVerifierId2[RegisterVerifierId2["register_sha384_sha384_sha384_ecdsa_brainpoolP512r1"] = 9] = "register_sha384_sha384_sha384_ecdsa_brainpoolP512r1";
  RegisterVerifierId2[RegisterVerifierId2["register_sha384_sha384_sha384_ecdsa_secp384r1"] = 10] = "register_sha384_sha384_sha384_ecdsa_secp384r1";
  RegisterVerifierId2[RegisterVerifierId2["register_sha512_sha512_sha512_ecdsa_brainpoolP512r1"] = 11] = "register_sha512_sha512_sha512_ecdsa_brainpoolP512r1";
  RegisterVerifierId2[RegisterVerifierId2["register_sha512_sha512_sha512_rsa_65537_4096"] = 12] = "register_sha512_sha512_sha512_rsa_65537_4096";
  RegisterVerifierId2[RegisterVerifierId2["register_sha512_sha512_sha512_rsapss_65537_64_2048"] = 13] = "register_sha512_sha512_sha512_rsapss_65537_64_2048";
  RegisterVerifierId2[RegisterVerifierId2["register_sha1_sha1_sha1_rsa_65537_4096"] = 14] = "register_sha1_sha1_sha1_rsa_65537_4096";
  RegisterVerifierId2[RegisterVerifierId2["register_sha1_sha256_sha256_rsa_65537_4096"] = 15] = "register_sha1_sha256_sha256_rsa_65537_4096";
  RegisterVerifierId2[RegisterVerifierId2["register_sha224_sha224_sha224_ecdsa_brainpoolP224r1"] = 16] = "register_sha224_sha224_sha224_ecdsa_brainpoolP224r1";
  RegisterVerifierId2[RegisterVerifierId2["register_sha256_sha224_sha224_ecdsa_secp224r1"] = 17] = "register_sha256_sha224_sha224_ecdsa_secp224r1";
  RegisterVerifierId2[RegisterVerifierId2["register_sha256_sha256_sha256_ecdsa_brainpoolP256r1"] = 18] = "register_sha256_sha256_sha256_ecdsa_brainpoolP256r1";
  RegisterVerifierId2[RegisterVerifierId2["register_sha1_sha1_sha1_ecdsa_brainpoolP224r1"] = 19] = "register_sha1_sha1_sha1_ecdsa_brainpoolP224r1";
  RegisterVerifierId2[RegisterVerifierId2["register_sha384_sha384_sha384_rsapss_65537_48_2048"] = 20] = "register_sha384_sha384_sha384_rsapss_65537_48_2048";
  RegisterVerifierId2[RegisterVerifierId2["register_sha1_sha1_sha1_ecdsa_secp256r1"] = 21] = "register_sha1_sha1_sha1_ecdsa_secp256r1";
  RegisterVerifierId2[RegisterVerifierId2["register_sha256_sha256_sha256_rsapss_65537_64_2048"] = 22] = "register_sha256_sha256_sha256_rsapss_65537_64_2048";
  RegisterVerifierId2[RegisterVerifierId2["register_sha512_sha512_sha256_rsa_65537_4096"] = 23] = "register_sha512_sha512_sha256_rsa_65537_4096";
  RegisterVerifierId2[RegisterVerifierId2["register_sha512_sha512_sha512_ecdsa_secp521r1"] = 24] = "register_sha512_sha512_sha512_ecdsa_secp521r1";
  RegisterVerifierId2[RegisterVerifierId2["register_id_sha256_sha256_sha256_rsa_65537_4096"] = 25] = "register_id_sha256_sha256_sha256_rsa_65537_4096";
  RegisterVerifierId2[RegisterVerifierId2["register_sha256_sha256_sha224_ecdsa_secp224r1"] = 26] = "register_sha256_sha256_sha224_ecdsa_secp224r1";
  RegisterVerifierId2[RegisterVerifierId2["register_id_sha1_sha1_sha1_ecdsa_brainpoolP224r1"] = 27] = "register_id_sha1_sha1_sha1_ecdsa_brainpoolP224r1";
  RegisterVerifierId2[RegisterVerifierId2["register_id_sha1_sha1_sha1_ecdsa_secp256r1"] = 28] = "register_id_sha1_sha1_sha1_ecdsa_secp256r1";
  RegisterVerifierId2[RegisterVerifierId2["register_id_sha1_sha1_sha1_rsa_65537_4096"] = 29] = "register_id_sha1_sha1_sha1_rsa_65537_4096";
  RegisterVerifierId2[RegisterVerifierId2["register_id_sha1_sha256_sha256_rsa_65537_4096"] = 30] = "register_id_sha1_sha256_sha256_rsa_65537_4096";
  RegisterVerifierId2[RegisterVerifierId2["register_id_sha224_sha224_sha224_ecdsa_brainpoolP224r1"] = 31] = "register_id_sha224_sha224_sha224_ecdsa_brainpoolP224r1";
  RegisterVerifierId2[RegisterVerifierId2["register_id_sha256_sha224_sha224_ecdsa_secp224r1"] = 32] = "register_id_sha256_sha224_sha224_ecdsa_secp224r1";
  RegisterVerifierId2[RegisterVerifierId2["register_id_sha256_sha256_sha224_ecdsa_secp224r1"] = 33] = "register_id_sha256_sha256_sha224_ecdsa_secp224r1";
  RegisterVerifierId2[RegisterVerifierId2["register_id_sha256_sha256_sha256_ecdsa_brainpoolP256r1"] = 34] = "register_id_sha256_sha256_sha256_ecdsa_brainpoolP256r1";
  RegisterVerifierId2[RegisterVerifierId2["register_id_sha256_sha256_sha256_ecdsa_brainpoolP384r1"] = 35] = "register_id_sha256_sha256_sha256_ecdsa_brainpoolP384r1";
  RegisterVerifierId2[RegisterVerifierId2["register_id_sha256_sha256_sha256_ecdsa_secp256r1"] = 36] = "register_id_sha256_sha256_sha256_ecdsa_secp256r1";
  RegisterVerifierId2[RegisterVerifierId2["register_id_sha256_sha256_sha256_ecdsa_secp384r1"] = 37] = "register_id_sha256_sha256_sha256_ecdsa_secp384r1";
  RegisterVerifierId2[RegisterVerifierId2["register_id_sha256_sha256_sha256_rsa_3_4096"] = 38] = "register_id_sha256_sha256_sha256_rsa_3_4096";
  RegisterVerifierId2[RegisterVerifierId2["register_id_sha256_sha256_sha256_rsapss_3_32_2048"] = 39] = "register_id_sha256_sha256_sha256_rsapss_3_32_2048";
  RegisterVerifierId2[RegisterVerifierId2["register_id_sha256_sha256_sha256_rsapss_65537_32_2048"] = 40] = "register_id_sha256_sha256_sha256_rsapss_65537_32_2048";
  RegisterVerifierId2[RegisterVerifierId2["register_id_sha256_sha256_sha256_rsapss_65537_32_3072"] = 41] = "register_id_sha256_sha256_sha256_rsapss_65537_32_3072";
  RegisterVerifierId2[RegisterVerifierId2["register_id_sha256_sha256_sha256_rsapss_65537_64_2048"] = 42] = "register_id_sha256_sha256_sha256_rsapss_65537_64_2048";
  RegisterVerifierId2[RegisterVerifierId2["register_id_sha384_sha384_sha384_ecdsa_brainpoolP384r1"] = 43] = "register_id_sha384_sha384_sha384_ecdsa_brainpoolP384r1";
  RegisterVerifierId2[RegisterVerifierId2["register_id_sha384_sha384_sha384_ecdsa_brainpoolP512r1"] = 44] = "register_id_sha384_sha384_sha384_ecdsa_brainpoolP512r1";
  RegisterVerifierId2[RegisterVerifierId2["register_id_sha384_sha384_sha384_ecdsa_secp384r1"] = 45] = "register_id_sha384_sha384_sha384_ecdsa_secp384r1";
  RegisterVerifierId2[RegisterVerifierId2["register_id_sha384_sha384_sha384_rsapss_65537_48_2048"] = 46] = "register_id_sha384_sha384_sha384_rsapss_65537_48_2048";
  RegisterVerifierId2[RegisterVerifierId2["register_id_sha512_sha512_sha256_rsa_65537_4096"] = 47] = "register_id_sha512_sha512_sha256_rsa_65537_4096";
  RegisterVerifierId2[RegisterVerifierId2["register_id_sha512_sha512_sha512_ecdsa_brainpoolP512r1"] = 48] = "register_id_sha512_sha512_sha512_ecdsa_brainpoolP512r1";
  RegisterVerifierId2[RegisterVerifierId2["register_id_sha512_sha512_sha512_ecdsa_secp521r1"] = 49] = "register_id_sha512_sha512_sha512_ecdsa_secp521r1";
  RegisterVerifierId2[RegisterVerifierId2["register_id_sha512_sha512_sha512_rsa_65537_4096"] = 50] = "register_id_sha512_sha512_sha512_rsa_65537_4096";
  RegisterVerifierId2[RegisterVerifierId2["register_id_sha512_sha512_sha512_rsapss_65537_64_2048"] = 51] = "register_id_sha512_sha512_sha512_rsapss_65537_64_2048";
})(RegisterVerifierId || (RegisterVerifierId = {}));
var DscVerifierId;
(function(DscVerifierId2) {
  DscVerifierId2[DscVerifierId2["dsc_sha1_ecdsa_brainpoolP256r1"] = 0] = "dsc_sha1_ecdsa_brainpoolP256r1";
  DscVerifierId2[DscVerifierId2["dsc_sha1_rsa_65537_4096"] = 1] = "dsc_sha1_rsa_65537_4096";
  DscVerifierId2[DscVerifierId2["dsc_sha256_ecdsa_brainpoolP256r1"] = 2] = "dsc_sha256_ecdsa_brainpoolP256r1";
  DscVerifierId2[DscVerifierId2["dsc_sha256_ecdsa_brainpoolP384r1"] = 3] = "dsc_sha256_ecdsa_brainpoolP384r1";
  DscVerifierId2[DscVerifierId2["dsc_sha256_ecdsa_secp256r1"] = 4] = "dsc_sha256_ecdsa_secp256r1";
  DscVerifierId2[DscVerifierId2["dsc_sha256_ecdsa_secp384r1"] = 5] = "dsc_sha256_ecdsa_secp384r1";
  DscVerifierId2[DscVerifierId2["dsc_sha256_ecdsa_secp521r1"] = 6] = "dsc_sha256_ecdsa_secp521r1";
  DscVerifierId2[DscVerifierId2["dsc_sha256_rsa_65537_4096"] = 7] = "dsc_sha256_rsa_65537_4096";
  DscVerifierId2[DscVerifierId2["dsc_sha256_rsapss_3_32_3072"] = 8] = "dsc_sha256_rsapss_3_32_3072";
  DscVerifierId2[DscVerifierId2["dsc_sha256_rsapss_65537_32_3072"] = 9] = "dsc_sha256_rsapss_65537_32_3072";
  DscVerifierId2[DscVerifierId2["dsc_sha256_rsapss_65537_32_4096"] = 10] = "dsc_sha256_rsapss_65537_32_4096";
  DscVerifierId2[DscVerifierId2["dsc_sha384_ecdsa_brainpoolP384r1"] = 11] = "dsc_sha384_ecdsa_brainpoolP384r1";
  DscVerifierId2[DscVerifierId2["dsc_sha384_ecdsa_brainpoolP512r1"] = 12] = "dsc_sha384_ecdsa_brainpoolP512r1";
  DscVerifierId2[DscVerifierId2["dsc_sha384_ecdsa_secp384r1"] = 13] = "dsc_sha384_ecdsa_secp384r1";
  DscVerifierId2[DscVerifierId2["dsc_sha512_ecdsa_brainpoolP512r1"] = 14] = "dsc_sha512_ecdsa_brainpoolP512r1";
  DscVerifierId2[DscVerifierId2["dsc_sha512_ecdsa_secp521r1"] = 15] = "dsc_sha512_ecdsa_secp521r1";
  DscVerifierId2[DscVerifierId2["dsc_sha512_rsa_65537_4096"] = 16] = "dsc_sha512_rsa_65537_4096";
  DscVerifierId2[DscVerifierId2["dsc_sha512_rsapss_65537_64_4096"] = 17] = "dsc_sha512_rsapss_65537_64_4096";
  DscVerifierId2[DscVerifierId2["dsc_sha256_rsapss_3_32_4096"] = 18] = "dsc_sha256_rsapss_3_32_4096";
  DscVerifierId2[DscVerifierId2["dsc_sha1_ecdsa_secp256r1"] = 19] = "dsc_sha1_ecdsa_secp256r1";
})(DscVerifierId || (DscVerifierId = {}));
var SignatureAlgorithmIndex;
(function(SignatureAlgorithmIndex2) {
  SignatureAlgorithmIndex2[SignatureAlgorithmIndex2["rsa_sha256_65537_2048"] = 1] = "rsa_sha256_65537_2048";
  SignatureAlgorithmIndex2[SignatureAlgorithmIndex2["rsa_sha1_65537_2048"] = 3] = "rsa_sha1_65537_2048";
  SignatureAlgorithmIndex2[SignatureAlgorithmIndex2["rsapss_sha256_65537_2048"] = 4] = "rsapss_sha256_65537_2048";
  SignatureAlgorithmIndex2[SignatureAlgorithmIndex2["ecdsa_sha1_secp256r1_256"] = 7] = "ecdsa_sha1_secp256r1_256";
  SignatureAlgorithmIndex2[SignatureAlgorithmIndex2["ecdsa_sha256_secp256r1_256"] = 8] = "ecdsa_sha256_secp256r1_256";
  SignatureAlgorithmIndex2[SignatureAlgorithmIndex2["ecdsa_sha384_secp384r1_384"] = 9] = "ecdsa_sha384_secp384r1_384";
  SignatureAlgorithmIndex2[SignatureAlgorithmIndex2["rsa_sha256_65537_4096"] = 10] = "rsa_sha256_65537_4096";
  SignatureAlgorithmIndex2[SignatureAlgorithmIndex2["rsa_sha1_65537_4096"] = 11] = "rsa_sha1_65537_4096";
  SignatureAlgorithmIndex2[SignatureAlgorithmIndex2["rsapss_sha256_65537_4096"] = 12] = "rsapss_sha256_65537_4096";
  SignatureAlgorithmIndex2[SignatureAlgorithmIndex2["rsa_sha256_3_2048"] = 13] = "rsa_sha256_3_2048";
  SignatureAlgorithmIndex2[SignatureAlgorithmIndex2["rsa_sha256_65537_3072"] = 14] = "rsa_sha256_65537_3072";
  SignatureAlgorithmIndex2[SignatureAlgorithmIndex2["rsa_sha512_65537_4096"] = 15] = "rsa_sha512_65537_4096";
  SignatureAlgorithmIndex2[SignatureAlgorithmIndex2["rsapss_sha256_3_3072"] = 16] = "rsapss_sha256_3_3072";
  SignatureAlgorithmIndex2[SignatureAlgorithmIndex2["rsapss_sha256_3_4096"] = 17] = "rsapss_sha256_3_4096";
  SignatureAlgorithmIndex2[SignatureAlgorithmIndex2["rsapss_sha384_65537_3072"] = 18] = "rsapss_sha384_65537_3072";
  SignatureAlgorithmIndex2[SignatureAlgorithmIndex2["rsapss_sha256_65537_3072"] = 19] = "rsapss_sha256_65537_3072";
  SignatureAlgorithmIndex2[SignatureAlgorithmIndex2["ecdsa_sha256_brainpoolP256r1_256"] = 21] = "ecdsa_sha256_brainpoolP256r1_256";
  SignatureAlgorithmIndex2[SignatureAlgorithmIndex2["ecdsa_sha384_brainpoolP384r1_384"] = 22] = "ecdsa_sha384_brainpoolP384r1_384";
  SignatureAlgorithmIndex2[SignatureAlgorithmIndex2["ecdsa_sha256_secp384r1_384"] = 23] = "ecdsa_sha256_secp384r1_384";
  SignatureAlgorithmIndex2[SignatureAlgorithmIndex2["ecdsa_sha384_brainpoolP256r1_256"] = 24] = "ecdsa_sha384_brainpoolP256r1_256";
  SignatureAlgorithmIndex2[SignatureAlgorithmIndex2["ecdsa_sha512_brainpoolP256r1_256"] = 25] = "ecdsa_sha512_brainpoolP256r1_256";
  SignatureAlgorithmIndex2[SignatureAlgorithmIndex2["ecdsa_sha512_brainpoolP384r1_384"] = 26] = "ecdsa_sha512_brainpoolP384r1_384";
  SignatureAlgorithmIndex2[SignatureAlgorithmIndex2["ecdsa_sha1_brainpoolP224r1_224"] = 27] = "ecdsa_sha1_brainpoolP224r1_224";
  SignatureAlgorithmIndex2[SignatureAlgorithmIndex2["ecdsa_sha256_brainpoolP224r1_224"] = 28] = "ecdsa_sha256_brainpoolP224r1_224";
  SignatureAlgorithmIndex2[SignatureAlgorithmIndex2["ecdsa_sha512_brainpoolP512r1_512"] = 29] = "ecdsa_sha512_brainpoolP512r1_512";
  SignatureAlgorithmIndex2[SignatureAlgorithmIndex2["ecdsa_sha224_brainpoolP224r1_224"] = 30] = "ecdsa_sha224_brainpoolP224r1_224";
  SignatureAlgorithmIndex2[SignatureAlgorithmIndex2["rsa_sha256_3_4096"] = 32] = "rsa_sha256_3_4096";
  SignatureAlgorithmIndex2[SignatureAlgorithmIndex2["rsa_sha1_3_4096"] = 33] = "rsa_sha1_3_4096";
  SignatureAlgorithmIndex2[SignatureAlgorithmIndex2["rsa_sha384_65537_4096"] = 34] = "rsa_sha384_65537_4096";
  SignatureAlgorithmIndex2[SignatureAlgorithmIndex2["rsapss_sha384_65537_4096"] = 35] = "rsapss_sha384_65537_4096";
  SignatureAlgorithmIndex2[SignatureAlgorithmIndex2["ecdsa_sha1_brainpoolP256r1_256"] = 36] = "ecdsa_sha1_brainpoolP256r1_256";
  SignatureAlgorithmIndex2[SignatureAlgorithmIndex2["ecdsa_sha512_secp521r1_521"] = 41] = "ecdsa_sha512_secp521r1_521";
})(SignatureAlgorithmIndex || (SignatureAlgorithmIndex = {}));

// node_modules/@selfxyz/qrcode/node_modules/uuid/dist/esm-browser/regex.js
var regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;

// node_modules/@selfxyz/qrcode/node_modules/uuid/dist/esm-browser/validate.js
function validate(uuid) {
  return typeof uuid === "string" && regex_default.test(uuid);
}
var validate_default = validate;

// node_modules/@selfxyz/qrcode/node_modules/uuid/dist/esm-browser/parse.js
function parse2(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError("Invalid UUID");
  }
  var v;
  var arr = new Uint8Array(16);
  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 255;
  arr[2] = v >>> 8 & 255;
  arr[3] = v & 255;
  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 255;
  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 255;
  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 255;
  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
  arr[11] = v / 4294967296 & 255;
  arr[12] = v >>> 24 & 255;
  arr[13] = v >>> 16 & 255;
  arr[14] = v >>> 8 & 255;
  arr[15] = v & 255;
  return arr;
}
var parse_default = parse2;

// node_modules/@selfxyz/qrcode/node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex = [];
for (i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).slice(1));
}
var i;
function unsafeStringify(arr, offset = 0) {
  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}

// node_modules/@selfxyz/qrcode/node_modules/uuid/dist/esm-browser/rng.js
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}

// node_modules/@selfxyz/qrcode/node_modules/uuid/dist/esm-browser/v35.js
function stringToBytes(str) {
  str = unescape(encodeURIComponent(str));
  var bytes = [];
  for (var i = 0; i < str.length; ++i) {
    bytes.push(str.charCodeAt(i));
  }
  return bytes;
}
var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
var URL2 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function v35(name2, version, hashfunc) {
  function generateUUID(value3, namespace, buf, offset) {
    var _namespace;
    if (typeof value3 === "string") {
      value3 = stringToBytes(value3);
    }
    if (typeof namespace === "string") {
      namespace = parse_default(namespace);
    }
    if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    }
    var bytes = new Uint8Array(16 + value3.length);
    bytes.set(namespace);
    bytes.set(value3, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 15 | version;
    bytes[8] = bytes[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (var i = 0; i < 16; ++i) {
        buf[offset + i] = bytes[i];
      }
      return buf;
    }
    return unsafeStringify(bytes);
  }
  try {
    generateUUID.name = name2;
  } catch (err) {
  }
  generateUUID.DNS = DNS;
  generateUUID.URL = URL2;
  return generateUUID;
}

// node_modules/@selfxyz/qrcode/node_modules/uuid/dist/esm-browser/md5.js
function md5(bytes) {
  if (typeof bytes === "string") {
    var msg = unescape(encodeURIComponent(bytes));
    bytes = new Uint8Array(msg.length);
    for (var i = 0; i < msg.length; ++i) {
      bytes[i] = msg.charCodeAt(i);
    }
  }
  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
}
function md5ToHexEncodedArray(input) {
  var output = [];
  var length32 = input.length * 32;
  var hexTab = "0123456789abcdef";
  for (var i = 0; i < length32; i += 8) {
    var x = input[i >> 5] >>> i % 32 & 255;
    var hex = parseInt(hexTab.charAt(x >>> 4 & 15) + hexTab.charAt(x & 15), 16);
    output.push(hex);
  }
  return output;
}
function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
function wordsToMd5(x, len) {
  x[len >> 5] |= 128 << len % 32;
  x[getOutputLength(len) - 1] = len;
  var a = 1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d = 271733878;
  for (var i = 0; i < x.length; i += 16) {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;
    a = md5ff(a, b, c, d, x[i], 7, -680876936);
    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
    b = md5gg(b, c, d, a, x[i], 20, -373897302);
    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
    d = md5hh(d, a, b, c, x[i], 11, -358537222);
    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
    a = md5ii(a, b, c, d, x[i], 6, -198630844);
    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
    a = safeAdd(a, olda);
    b = safeAdd(b, oldb);
    c = safeAdd(c, oldc);
    d = safeAdd(d, oldd);
  }
  return [a, b, c, d];
}
function bytesToWords(input) {
  if (input.length === 0) {
    return [];
  }
  var length8 = input.length * 8;
  var output = new Uint32Array(getOutputLength(length8));
  for (var i = 0; i < length8; i += 8) {
    output[i >> 5] |= (input[i / 8] & 255) << i % 32;
  }
  return output;
}
function safeAdd(x, y) {
  var lsw = (x & 65535) + (y & 65535);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 65535;
}
function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
function md5cmn(q, a, b, x, s, t) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
}
function md5ff(a, b, c, d, x, s, t) {
  return md5cmn(b & c | ~b & d, a, b, x, s, t);
}
function md5gg(a, b, c, d, x, s, t) {
  return md5cmn(b & d | c & ~d, a, b, x, s, t);
}
function md5hh(a, b, c, d, x, s, t) {
  return md5cmn(b ^ c ^ d, a, b, x, s, t);
}
function md5ii(a, b, c, d, x, s, t) {
  return md5cmn(c ^ (b | ~d), a, b, x, s, t);
}
var md5_default = md5;

// node_modules/@selfxyz/qrcode/node_modules/uuid/dist/esm-browser/v3.js
var v3 = v35("v3", 48, md5_default);

// node_modules/@selfxyz/qrcode/node_modules/uuid/dist/esm-browser/native.js
var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native_default = {
  randomUUID
};

// node_modules/@selfxyz/qrcode/node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset) {
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  var rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (var i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default = v4;

// node_modules/@selfxyz/qrcode/node_modules/uuid/dist/esm-browser/sha1.js
function f(s, x, y, z) {
  switch (s) {
    case 0:
      return x & y ^ ~x & z;
    case 1:
      return x ^ y ^ z;
    case 2:
      return x & y ^ x & z ^ y & z;
    case 3:
      return x ^ y ^ z;
  }
}
function ROTL(x, n) {
  return x << n | x >>> 32 - n;
}
function sha1(bytes) {
  var K = [1518500249, 1859775393, 2400959708, 3395469782];
  var H = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  if (typeof bytes === "string") {
    var msg = unescape(encodeURIComponent(bytes));
    bytes = [];
    for (var i = 0; i < msg.length; ++i) {
      bytes.push(msg.charCodeAt(i));
    }
  } else if (!Array.isArray(bytes)) {
    bytes = Array.prototype.slice.call(bytes);
  }
  bytes.push(128);
  var l = bytes.length / 4 + 2;
  var N = Math.ceil(l / 16);
  var M = new Array(N);
  for (var _i = 0; _i < N; ++_i) {
    var arr = new Uint32Array(16);
    for (var j = 0; j < 16; ++j) {
      arr[j] = bytes[_i * 64 + j * 4] << 24 | bytes[_i * 64 + j * 4 + 1] << 16 | bytes[_i * 64 + j * 4 + 2] << 8 | bytes[_i * 64 + j * 4 + 3];
    }
    M[_i] = arr;
  }
  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M[N - 1][14] = Math.floor(M[N - 1][14]);
  M[N - 1][15] = (bytes.length - 1) * 8 & 4294967295;
  for (var _i2 = 0; _i2 < N; ++_i2) {
    var W = new Uint32Array(80);
    for (var t = 0; t < 16; ++t) {
      W[t] = M[_i2][t];
    }
    for (var _t = 16; _t < 80; ++_t) {
      W[_t] = ROTL(W[_t - 3] ^ W[_t - 8] ^ W[_t - 14] ^ W[_t - 16], 1);
    }
    var a = H[0];
    var b = H[1];
    var c = H[2];
    var d = H[3];
    var e = H[4];
    for (var _t2 = 0; _t2 < 80; ++_t2) {
      var s = Math.floor(_t2 / 20);
      var T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[_t2] >>> 0;
      e = d;
      d = c;
      c = ROTL(b, 30) >>> 0;
      b = a;
      a = T;
    }
    H[0] = H[0] + a >>> 0;
    H[1] = H[1] + b >>> 0;
    H[2] = H[2] + c >>> 0;
    H[3] = H[3] + d >>> 0;
    H[4] = H[4] + e >>> 0;
  }
  return [H[0] >> 24 & 255, H[0] >> 16 & 255, H[0] >> 8 & 255, H[0] & 255, H[1] >> 24 & 255, H[1] >> 16 & 255, H[1] >> 8 & 255, H[1] & 255, H[2] >> 24 & 255, H[2] >> 16 & 255, H[2] >> 8 & 255, H[2] & 255, H[3] >> 24 & 255, H[3] >> 16 & 255, H[3] >> 8 & 255, H[3] & 255, H[4] >> 24 & 255, H[4] >> 16 & 255, H[4] >> 8 & 255, H[4] & 255];
}
var sha1_default = sha1;

// node_modules/@selfxyz/qrcode/node_modules/uuid/dist/esm-browser/v5.js
var v5 = v35("v5", 80, sha1_default);

// node_modules/qrcode.react/lib/esm/index.js
var import_react3 = __toESM(require_react());
var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key2, value3) => key2 in obj ? __defProp(obj, key2, { enumerable: true, configurable: true, writable: true, value: value3 }) : obj[key2] = value3;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var qrcodegen;
((qrcodegen2) => {
  const _QrCode = class _QrCode2 {
    /*-- Constructor (low level) and fields --*/
    // Creates a new QR Code with the given version number,
    // error correction level, data codeword bytes, and mask number.
    // This is a low-level API that most users should not use directly.
    // A mid-level API is the encodeSegments() function.
    constructor(version, errorCorrectionLevel, dataCodewords, msk) {
      this.version = version;
      this.errorCorrectionLevel = errorCorrectionLevel;
      this.modules = [];
      this.isFunction = [];
      if (version < _QrCode2.MIN_VERSION || version > _QrCode2.MAX_VERSION)
        throw new RangeError("Version value out of range");
      if (msk < -1 || msk > 7)
        throw new RangeError("Mask value out of range");
      this.size = version * 4 + 17;
      let row = [];
      for (let i = 0; i < this.size; i++)
        row.push(false);
      for (let i = 0; i < this.size; i++) {
        this.modules.push(row.slice());
        this.isFunction.push(row.slice());
      }
      this.drawFunctionPatterns();
      const allCodewords = this.addEccAndInterleave(dataCodewords);
      this.drawCodewords(allCodewords);
      if (msk == -1) {
        let minPenalty = 1e9;
        for (let i = 0; i < 8; i++) {
          this.applyMask(i);
          this.drawFormatBits(i);
          const penalty = this.getPenaltyScore();
          if (penalty < minPenalty) {
            msk = i;
            minPenalty = penalty;
          }
          this.applyMask(i);
        }
      }
      assert(0 <= msk && msk <= 7);
      this.mask = msk;
      this.applyMask(msk);
      this.drawFormatBits(msk);
      this.isFunction = [];
    }
    /*-- Static factory functions (high level) --*/
    // Returns a QR Code representing the given Unicode text string at the given error correction level.
    // As a conservative upper bound, this function is guaranteed to succeed for strings that have 738 or fewer
    // Unicode code points (not UTF-16 code units) if the low error correction level is used. The smallest possible
    // QR Code version is automatically chosen for the output. The ECC level of the result may be higher than the
    // ecl argument if it can be done without increasing the version.
    static encodeText(text2, ecl) {
      const segs = qrcodegen2.QrSegment.makeSegments(text2);
      return _QrCode2.encodeSegments(segs, ecl);
    }
    // Returns a QR Code representing the given binary data at the given error correction level.
    // This function always encodes using the binary segment mode, not any text mode. The maximum number of
    // bytes allowed is 2953. The smallest possible QR Code version is automatically chosen for the output.
    // The ECC level of the result may be higher than the ecl argument if it can be done without increasing the version.
    static encodeBinary(data2, ecl) {
      const seg = qrcodegen2.QrSegment.makeBytes(data2);
      return _QrCode2.encodeSegments([seg], ecl);
    }
    /*-- Static factory functions (mid level) --*/
    // Returns a QR Code representing the given segments with the given encoding parameters.
    // The smallest possible QR Code version within the given range is automatically
    // chosen for the output. Iff boostEcl is true, then the ECC level of the result
    // may be higher than the ecl argument if it can be done without increasing the
    // version. The mask number is either between 0 to 7 (inclusive) to force that
    // mask, or -1 to automatically choose an appropriate mask (which may be slow).
    // This function allows the user to create a custom sequence of segments that switches
    // between modes (such as alphanumeric and byte) to encode text in less space.
    // This is a mid-level API; the high-level API is encodeText() and encodeBinary().
    static encodeSegments(segs, ecl, minVersion = 1, maxVersion = 40, mask2 = -1, boostEcl = true) {
      if (!(_QrCode2.MIN_VERSION <= minVersion && minVersion <= maxVersion && maxVersion <= _QrCode2.MAX_VERSION) || mask2 < -1 || mask2 > 7)
        throw new RangeError("Invalid value");
      let version;
      let dataUsedBits;
      for (version = minVersion; ; version++) {
        const dataCapacityBits2 = _QrCode2.getNumDataCodewords(version, ecl) * 8;
        const usedBits = QrSegment.getTotalBits(segs, version);
        if (usedBits <= dataCapacityBits2) {
          dataUsedBits = usedBits;
          break;
        }
        if (version >= maxVersion)
          throw new RangeError("Data too long");
      }
      for (const newEcl of [_QrCode2.Ecc.MEDIUM, _QrCode2.Ecc.QUARTILE, _QrCode2.Ecc.HIGH]) {
        if (boostEcl && dataUsedBits <= _QrCode2.getNumDataCodewords(version, newEcl) * 8)
          ecl = newEcl;
      }
      let bb = [];
      for (const seg of segs) {
        appendBits(seg.mode.modeBits, 4, bb);
        appendBits(seg.numChars, seg.mode.numCharCountBits(version), bb);
        for (const b of seg.getData())
          bb.push(b);
      }
      assert(bb.length == dataUsedBits);
      const dataCapacityBits = _QrCode2.getNumDataCodewords(version, ecl) * 8;
      assert(bb.length <= dataCapacityBits);
      appendBits(0, Math.min(4, dataCapacityBits - bb.length), bb);
      appendBits(0, (8 - bb.length % 8) % 8, bb);
      assert(bb.length % 8 == 0);
      for (let padByte = 236; bb.length < dataCapacityBits; padByte ^= 236 ^ 17)
        appendBits(padByte, 8, bb);
      let dataCodewords = [];
      while (dataCodewords.length * 8 < bb.length)
        dataCodewords.push(0);
      bb.forEach((b, i) => dataCodewords[i >>> 3] |= b << 7 - (i & 7));
      return new _QrCode2(version, ecl, dataCodewords, mask2);
    }
    /*-- Accessor methods --*/
    // Returns the color of the module (pixel) at the given coordinates, which is false
    // for light or true for dark. The top left corner has the coordinates (x=0, y=0).
    // If the given coordinates are out of bounds, then false (light) is returned.
    getModule(x, y) {
      return 0 <= x && x < this.size && 0 <= y && y < this.size && this.modules[y][x];
    }
    // Modified to expose modules for easy access
    getModules() {
      return this.modules;
    }
    /*-- Private helper methods for constructor: Drawing function modules --*/
    // Reads this object's version field, and draws and marks all function modules.
    drawFunctionPatterns() {
      for (let i = 0; i < this.size; i++) {
        this.setFunctionModule(6, i, i % 2 == 0);
        this.setFunctionModule(i, 6, i % 2 == 0);
      }
      this.drawFinderPattern(3, 3);
      this.drawFinderPattern(this.size - 4, 3);
      this.drawFinderPattern(3, this.size - 4);
      const alignPatPos = this.getAlignmentPatternPositions();
      const numAlign = alignPatPos.length;
      for (let i = 0; i < numAlign; i++) {
        for (let j = 0; j < numAlign; j++) {
          if (!(i == 0 && j == 0 || i == 0 && j == numAlign - 1 || i == numAlign - 1 && j == 0))
            this.drawAlignmentPattern(alignPatPos[i], alignPatPos[j]);
        }
      }
      this.drawFormatBits(0);
      this.drawVersion();
    }
    // Draws two copies of the format bits (with its own error correction code)
    // based on the given mask and this object's error correction level field.
    drawFormatBits(mask2) {
      const data2 = this.errorCorrectionLevel.formatBits << 3 | mask2;
      let rem = data2;
      for (let i = 0; i < 10; i++)
        rem = rem << 1 ^ (rem >>> 9) * 1335;
      const bits = (data2 << 10 | rem) ^ 21522;
      assert(bits >>> 15 == 0);
      for (let i = 0; i <= 5; i++)
        this.setFunctionModule(8, i, getBit(bits, i));
      this.setFunctionModule(8, 7, getBit(bits, 6));
      this.setFunctionModule(8, 8, getBit(bits, 7));
      this.setFunctionModule(7, 8, getBit(bits, 8));
      for (let i = 9; i < 15; i++)
        this.setFunctionModule(14 - i, 8, getBit(bits, i));
      for (let i = 0; i < 8; i++)
        this.setFunctionModule(this.size - 1 - i, 8, getBit(bits, i));
      for (let i = 8; i < 15; i++)
        this.setFunctionModule(8, this.size - 15 + i, getBit(bits, i));
      this.setFunctionModule(8, this.size - 8, true);
    }
    // Draws two copies of the version bits (with its own error correction code),
    // based on this object's version field, iff 7 <= version <= 40.
    drawVersion() {
      if (this.version < 7)
        return;
      let rem = this.version;
      for (let i = 0; i < 12; i++)
        rem = rem << 1 ^ (rem >>> 11) * 7973;
      const bits = this.version << 12 | rem;
      assert(bits >>> 18 == 0);
      for (let i = 0; i < 18; i++) {
        const color = getBit(bits, i);
        const a = this.size - 11 + i % 3;
        const b = Math.floor(i / 3);
        this.setFunctionModule(a, b, color);
        this.setFunctionModule(b, a, color);
      }
    }
    // Draws a 9*9 finder pattern including the border separator,
    // with the center module at (x, y). Modules can be out of bounds.
    drawFinderPattern(x, y) {
      for (let dy = -4; dy <= 4; dy++) {
        for (let dx = -4; dx <= 4; dx++) {
          const dist = Math.max(Math.abs(dx), Math.abs(dy));
          const xx = x + dx;
          const yy = y + dy;
          if (0 <= xx && xx < this.size && 0 <= yy && yy < this.size)
            this.setFunctionModule(xx, yy, dist != 2 && dist != 4);
        }
      }
    }
    // Draws a 5*5 alignment pattern, with the center module
    // at (x, y). All modules must be in bounds.
    drawAlignmentPattern(x, y) {
      for (let dy = -2; dy <= 2; dy++) {
        for (let dx = -2; dx <= 2; dx++)
          this.setFunctionModule(x + dx, y + dy, Math.max(Math.abs(dx), Math.abs(dy)) != 1);
      }
    }
    // Sets the color of a module and marks it as a function module.
    // Only used by the constructor. Coordinates must be in bounds.
    setFunctionModule(x, y, isDark) {
      this.modules[y][x] = isDark;
      this.isFunction[y][x] = true;
    }
    /*-- Private helper methods for constructor: Codewords and masking --*/
    // Returns a new byte string representing the given data with the appropriate error correction
    // codewords appended to it, based on this object's version and error correction level.
    addEccAndInterleave(data2) {
      const ver = this.version;
      const ecl = this.errorCorrectionLevel;
      if (data2.length != _QrCode2.getNumDataCodewords(ver, ecl))
        throw new RangeError("Invalid argument");
      const numBlocks = _QrCode2.NUM_ERROR_CORRECTION_BLOCKS[ecl.ordinal][ver];
      const blockEccLen = _QrCode2.ECC_CODEWORDS_PER_BLOCK[ecl.ordinal][ver];
      const rawCodewords = Math.floor(_QrCode2.getNumRawDataModules(ver) / 8);
      const numShortBlocks = numBlocks - rawCodewords % numBlocks;
      const shortBlockLen = Math.floor(rawCodewords / numBlocks);
      let blocks = [];
      const rsDiv = _QrCode2.reedSolomonComputeDivisor(blockEccLen);
      for (let i = 0, k = 0; i < numBlocks; i++) {
        let dat = data2.slice(k, k + shortBlockLen - blockEccLen + (i < numShortBlocks ? 0 : 1));
        k += dat.length;
        const ecc = _QrCode2.reedSolomonComputeRemainder(dat, rsDiv);
        if (i < numShortBlocks)
          dat.push(0);
        blocks.push(dat.concat(ecc));
      }
      let result = [];
      for (let i = 0; i < blocks[0].length; i++) {
        blocks.forEach((block, j) => {
          if (i != shortBlockLen - blockEccLen || j >= numShortBlocks)
            result.push(block[i]);
        });
      }
      assert(result.length == rawCodewords);
      return result;
    }
    // Draws the given sequence of 8-bit codewords (data and error correction) onto the entire
    // data area of this QR Code. Function modules need to be marked off before this is called.
    drawCodewords(data2) {
      if (data2.length != Math.floor(_QrCode2.getNumRawDataModules(this.version) / 8))
        throw new RangeError("Invalid argument");
      let i = 0;
      for (let right2 = this.size - 1; right2 >= 1; right2 -= 2) {
        if (right2 == 6)
          right2 = 5;
        for (let vert = 0; vert < this.size; vert++) {
          for (let j = 0; j < 2; j++) {
            const x = right2 - j;
            const upward = (right2 + 1 & 2) == 0;
            const y = upward ? this.size - 1 - vert : vert;
            if (!this.isFunction[y][x] && i < data2.length * 8) {
              this.modules[y][x] = getBit(data2[i >>> 3], 7 - (i & 7));
              i++;
            }
          }
        }
      }
      assert(i == data2.length * 8);
    }
    // XORs the codeword modules in this QR Code with the given mask pattern.
    // The function modules must be marked and the codeword bits must be drawn
    // before masking. Due to the arithmetic of XOR, calling applyMask() with
    // the same mask value a second time will undo the mask. A final well-formed
    // QR Code needs exactly one (not zero, two, etc.) mask applied.
    applyMask(mask2) {
      if (mask2 < 0 || mask2 > 7)
        throw new RangeError("Mask value out of range");
      for (let y = 0; y < this.size; y++) {
        for (let x = 0; x < this.size; x++) {
          let invert;
          switch (mask2) {
            case 0:
              invert = (x + y) % 2 == 0;
              break;
            case 1:
              invert = y % 2 == 0;
              break;
            case 2:
              invert = x % 3 == 0;
              break;
            case 3:
              invert = (x + y) % 3 == 0;
              break;
            case 4:
              invert = (Math.floor(x / 3) + Math.floor(y / 2)) % 2 == 0;
              break;
            case 5:
              invert = x * y % 2 + x * y % 3 == 0;
              break;
            case 6:
              invert = (x * y % 2 + x * y % 3) % 2 == 0;
              break;
            case 7:
              invert = ((x + y) % 2 + x * y % 3) % 2 == 0;
              break;
            default:
              throw new Error("Unreachable");
          }
          if (!this.isFunction[y][x] && invert)
            this.modules[y][x] = !this.modules[y][x];
        }
      }
    }
    // Calculates and returns the penalty score based on state of this QR Code's current modules.
    // This is used by the automatic mask choice algorithm to find the mask pattern that yields the lowest score.
    getPenaltyScore() {
      let result = 0;
      for (let y = 0; y < this.size; y++) {
        let runColor = false;
        let runX = 0;
        let runHistory = [0, 0, 0, 0, 0, 0, 0];
        for (let x = 0; x < this.size; x++) {
          if (this.modules[y][x] == runColor) {
            runX++;
            if (runX == 5)
              result += _QrCode2.PENALTY_N1;
            else if (runX > 5)
              result++;
          } else {
            this.finderPenaltyAddHistory(runX, runHistory);
            if (!runColor)
              result += this.finderPenaltyCountPatterns(runHistory) * _QrCode2.PENALTY_N3;
            runColor = this.modules[y][x];
            runX = 1;
          }
        }
        result += this.finderPenaltyTerminateAndCount(runColor, runX, runHistory) * _QrCode2.PENALTY_N3;
      }
      for (let x = 0; x < this.size; x++) {
        let runColor = false;
        let runY = 0;
        let runHistory = [0, 0, 0, 0, 0, 0, 0];
        for (let y = 0; y < this.size; y++) {
          if (this.modules[y][x] == runColor) {
            runY++;
            if (runY == 5)
              result += _QrCode2.PENALTY_N1;
            else if (runY > 5)
              result++;
          } else {
            this.finderPenaltyAddHistory(runY, runHistory);
            if (!runColor)
              result += this.finderPenaltyCountPatterns(runHistory) * _QrCode2.PENALTY_N3;
            runColor = this.modules[y][x];
            runY = 1;
          }
        }
        result += this.finderPenaltyTerminateAndCount(runColor, runY, runHistory) * _QrCode2.PENALTY_N3;
      }
      for (let y = 0; y < this.size - 1; y++) {
        for (let x = 0; x < this.size - 1; x++) {
          const color = this.modules[y][x];
          if (color == this.modules[y][x + 1] && color == this.modules[y + 1][x] && color == this.modules[y + 1][x + 1])
            result += _QrCode2.PENALTY_N2;
        }
      }
      let dark = 0;
      for (const row of this.modules)
        dark = row.reduce((sum2, color) => sum2 + (color ? 1 : 0), dark);
      const total = this.size * this.size;
      const k = Math.ceil(Math.abs(dark * 20 - total * 10) / total) - 1;
      assert(0 <= k && k <= 9);
      result += k * _QrCode2.PENALTY_N4;
      assert(0 <= result && result <= 2568888);
      return result;
    }
    /*-- Private helper functions --*/
    // Returns an ascending list of positions of alignment patterns for this version number.
    // Each position is in the range [0,177), and are used on both the x and y axes.
    // This could be implemented as lookup table of 40 variable-length lists of integers.
    getAlignmentPatternPositions() {
      if (this.version == 1)
        return [];
      else {
        const numAlign = Math.floor(this.version / 7) + 2;
        const step = this.version == 32 ? 26 : Math.ceil((this.version * 4 + 4) / (numAlign * 2 - 2)) * 2;
        let result = [6];
        for (let pos = this.size - 7; result.length < numAlign; pos -= step)
          result.splice(1, 0, pos);
        return result;
      }
    }
    // Returns the number of data bits that can be stored in a QR Code of the given version number, after
    // all function modules are excluded. This includes remainder bits, so it might not be a multiple of 8.
    // The result is in the range [208, 29648]. This could be implemented as a 40-entry lookup table.
    static getNumRawDataModules(ver) {
      if (ver < _QrCode2.MIN_VERSION || ver > _QrCode2.MAX_VERSION)
        throw new RangeError("Version number out of range");
      let result = (16 * ver + 128) * ver + 64;
      if (ver >= 2) {
        const numAlign = Math.floor(ver / 7) + 2;
        result -= (25 * numAlign - 10) * numAlign - 55;
        if (ver >= 7)
          result -= 36;
      }
      assert(208 <= result && result <= 29648);
      return result;
    }
    // Returns the number of 8-bit data (i.e. not error correction) codewords contained in any
    // QR Code of the given version number and error correction level, with remainder bits discarded.
    // This stateless pure function could be implemented as a (40*4)-cell lookup table.
    static getNumDataCodewords(ver, ecl) {
      return Math.floor(_QrCode2.getNumRawDataModules(ver) / 8) - _QrCode2.ECC_CODEWORDS_PER_BLOCK[ecl.ordinal][ver] * _QrCode2.NUM_ERROR_CORRECTION_BLOCKS[ecl.ordinal][ver];
    }
    // Returns a Reed-Solomon ECC generator polynomial for the given degree. This could be
    // implemented as a lookup table over all possible parameter values, instead of as an algorithm.
    static reedSolomonComputeDivisor(degree) {
      if (degree < 1 || degree > 255)
        throw new RangeError("Degree out of range");
      let result = [];
      for (let i = 0; i < degree - 1; i++)
        result.push(0);
      result.push(1);
      let root = 1;
      for (let i = 0; i < degree; i++) {
        for (let j = 0; j < result.length; j++) {
          result[j] = _QrCode2.reedSolomonMultiply(result[j], root);
          if (j + 1 < result.length)
            result[j] ^= result[j + 1];
        }
        root = _QrCode2.reedSolomonMultiply(root, 2);
      }
      return result;
    }
    // Returns the Reed-Solomon error correction codeword for the given data and divisor polynomials.
    static reedSolomonComputeRemainder(data2, divisor) {
      let result = divisor.map((_) => 0);
      for (const b of data2) {
        const factor = b ^ result.shift();
        result.push(0);
        divisor.forEach((coef, i) => result[i] ^= _QrCode2.reedSolomonMultiply(coef, factor));
      }
      return result;
    }
    // Returns the product of the two given field elements modulo GF(2^8/0x11D). The arguments and result
    // are unsigned 8-bit integers. This could be implemented as a lookup table of 256*256 entries of uint8.
    static reedSolomonMultiply(x, y) {
      if (x >>> 8 != 0 || y >>> 8 != 0)
        throw new RangeError("Byte out of range");
      let z = 0;
      for (let i = 7; i >= 0; i--) {
        z = z << 1 ^ (z >>> 7) * 285;
        z ^= (y >>> i & 1) * x;
      }
      assert(z >>> 8 == 0);
      return z;
    }
    // Can only be called immediately after a light run is added, and
    // returns either 0, 1, or 2. A helper function for getPenaltyScore().
    finderPenaltyCountPatterns(runHistory) {
      const n = runHistory[1];
      assert(n <= this.size * 3);
      const core = n > 0 && runHistory[2] == n && runHistory[3] == n * 3 && runHistory[4] == n && runHistory[5] == n;
      return (core && runHistory[0] >= n * 4 && runHistory[6] >= n ? 1 : 0) + (core && runHistory[6] >= n * 4 && runHistory[0] >= n ? 1 : 0);
    }
    // Must be called at the end of a line (row or column) of modules. A helper function for getPenaltyScore().
    finderPenaltyTerminateAndCount(currentRunColor, currentRunLength, runHistory) {
      if (currentRunColor) {
        this.finderPenaltyAddHistory(currentRunLength, runHistory);
        currentRunLength = 0;
      }
      currentRunLength += this.size;
      this.finderPenaltyAddHistory(currentRunLength, runHistory);
      return this.finderPenaltyCountPatterns(runHistory);
    }
    // Pushes the given value to the front and drops the last value. A helper function for getPenaltyScore().
    finderPenaltyAddHistory(currentRunLength, runHistory) {
      if (runHistory[0] == 0)
        currentRunLength += this.size;
      runHistory.pop();
      runHistory.unshift(currentRunLength);
    }
  };
  _QrCode.MIN_VERSION = 1;
  _QrCode.MAX_VERSION = 40;
  _QrCode.PENALTY_N1 = 3;
  _QrCode.PENALTY_N2 = 3;
  _QrCode.PENALTY_N3 = 40;
  _QrCode.PENALTY_N4 = 10;
  _QrCode.ECC_CODEWORDS_PER_BLOCK = [
    // Version: (note that index 0 is for padding, and is set to an illegal value)
    //0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40    Error correction level
    [-1, 7, 10, 15, 20, 26, 18, 20, 24, 30, 18, 20, 24, 26, 30, 22, 24, 28, 30, 28, 28, 28, 28, 30, 30, 26, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30],
    // Low
    [-1, 10, 16, 26, 18, 24, 16, 18, 22, 22, 26, 30, 22, 22, 24, 24, 28, 28, 26, 26, 26, 26, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28],
    // Medium
    [-1, 13, 22, 18, 26, 18, 24, 18, 22, 20, 24, 28, 26, 24, 20, 30, 24, 28, 28, 26, 30, 28, 30, 30, 30, 30, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30],
    // Quartile
    [-1, 17, 28, 22, 16, 22, 28, 26, 26, 24, 28, 24, 28, 22, 24, 24, 30, 28, 28, 26, 28, 30, 24, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30]
    // High
  ];
  _QrCode.NUM_ERROR_CORRECTION_BLOCKS = [
    // Version: (note that index 0 is for padding, and is set to an illegal value)
    //0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40    Error correction level
    [-1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 4, 4, 4, 4, 4, 6, 6, 6, 6, 7, 8, 8, 9, 9, 10, 12, 12, 12, 13, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 24, 25],
    // Low
    [-1, 1, 1, 1, 2, 2, 4, 4, 4, 5, 5, 5, 8, 9, 9, 10, 10, 11, 13, 14, 16, 17, 17, 18, 20, 21, 23, 25, 26, 28, 29, 31, 33, 35, 37, 38, 40, 43, 45, 47, 49],
    // Medium
    [-1, 1, 1, 2, 2, 4, 4, 6, 6, 8, 8, 8, 10, 12, 16, 12, 17, 16, 18, 21, 20, 23, 23, 25, 27, 29, 34, 34, 35, 38, 40, 43, 45, 48, 51, 53, 56, 59, 62, 65, 68],
    // Quartile
    [-1, 1, 1, 2, 4, 4, 4, 5, 6, 8, 8, 11, 11, 16, 16, 18, 16, 19, 21, 25, 25, 25, 34, 30, 32, 35, 37, 40, 42, 45, 48, 51, 54, 57, 60, 63, 66, 70, 74, 77, 81]
    // High
  ];
  let QrCode = _QrCode;
  qrcodegen2.QrCode = _QrCode;
  function appendBits(val2, len, bb) {
    if (len < 0 || len > 31 || val2 >>> len != 0)
      throw new RangeError("Value out of range");
    for (let i = len - 1; i >= 0; i--)
      bb.push(val2 >>> i & 1);
  }
  function getBit(x, i) {
    return (x >>> i & 1) != 0;
  }
  function assert(cond) {
    if (!cond)
      throw new Error("Assertion error");
  }
  const _QrSegment = class _QrSegment2 {
    /*-- Constructor (low level) and fields --*/
    // Creates a new QR Code segment with the given attributes and data.
    // The character count (numChars) must agree with the mode and the bit buffer length,
    // but the constraint isn't checked. The given bit buffer is cloned and stored.
    constructor(mode, numChars, bitData) {
      this.mode = mode;
      this.numChars = numChars;
      this.bitData = bitData;
      if (numChars < 0)
        throw new RangeError("Invalid argument");
      this.bitData = bitData.slice();
    }
    /*-- Static factory functions (mid level) --*/
    // Returns a segment representing the given binary data encoded in
    // byte mode. All input byte arrays are acceptable. Any text string
    // can be converted to UTF-8 bytes and encoded as a byte mode segment.
    static makeBytes(data2) {
      let bb = [];
      for (const b of data2)
        appendBits(b, 8, bb);
      return new _QrSegment2(_QrSegment2.Mode.BYTE, data2.length, bb);
    }
    // Returns a segment representing the given string of decimal digits encoded in numeric mode.
    static makeNumeric(digits) {
      if (!_QrSegment2.isNumeric(digits))
        throw new RangeError("String contains non-numeric characters");
      let bb = [];
      for (let i = 0; i < digits.length; ) {
        const n = Math.min(digits.length - i, 3);
        appendBits(parseInt(digits.substring(i, i + n), 10), n * 3 + 1, bb);
        i += n;
      }
      return new _QrSegment2(_QrSegment2.Mode.NUMERIC, digits.length, bb);
    }
    // Returns a segment representing the given text string encoded in alphanumeric mode.
    // The characters allowed are: 0 to 9, A to Z (uppercase only), space,
    // dollar, percent, asterisk, plus, hyphen, period, slash, colon.
    static makeAlphanumeric(text2) {
      if (!_QrSegment2.isAlphanumeric(text2))
        throw new RangeError("String contains unencodable characters in alphanumeric mode");
      let bb = [];
      let i;
      for (i = 0; i + 2 <= text2.length; i += 2) {
        let temp = _QrSegment2.ALPHANUMERIC_CHARSET.indexOf(text2.charAt(i)) * 45;
        temp += _QrSegment2.ALPHANUMERIC_CHARSET.indexOf(text2.charAt(i + 1));
        appendBits(temp, 11, bb);
      }
      if (i < text2.length)
        appendBits(_QrSegment2.ALPHANUMERIC_CHARSET.indexOf(text2.charAt(i)), 6, bb);
      return new _QrSegment2(_QrSegment2.Mode.ALPHANUMERIC, text2.length, bb);
    }
    // Returns a new mutable list of zero or more segments to represent the given Unicode text string.
    // The result may use various segment modes and switch modes to optimize the length of the bit stream.
    static makeSegments(text2) {
      if (text2 == "")
        return [];
      else if (_QrSegment2.isNumeric(text2))
        return [_QrSegment2.makeNumeric(text2)];
      else if (_QrSegment2.isAlphanumeric(text2))
        return [_QrSegment2.makeAlphanumeric(text2)];
      else
        return [_QrSegment2.makeBytes(_QrSegment2.toUtf8ByteArray(text2))];
    }
    // Returns a segment representing an Extended Channel Interpretation
    // (ECI) designator with the given assignment value.
    static makeEci(assignVal) {
      let bb = [];
      if (assignVal < 0)
        throw new RangeError("ECI assignment value out of range");
      else if (assignVal < 1 << 7)
        appendBits(assignVal, 8, bb);
      else if (assignVal < 1 << 14) {
        appendBits(2, 2, bb);
        appendBits(assignVal, 14, bb);
      } else if (assignVal < 1e6) {
        appendBits(6, 3, bb);
        appendBits(assignVal, 21, bb);
      } else
        throw new RangeError("ECI assignment value out of range");
      return new _QrSegment2(_QrSegment2.Mode.ECI, 0, bb);
    }
    // Tests whether the given string can be encoded as a segment in numeric mode.
    // A string is encodable iff each character is in the range 0 to 9.
    static isNumeric(text2) {
      return _QrSegment2.NUMERIC_REGEX.test(text2);
    }
    // Tests whether the given string can be encoded as a segment in alphanumeric mode.
    // A string is encodable iff each character is in the following set: 0 to 9, A to Z
    // (uppercase only), space, dollar, percent, asterisk, plus, hyphen, period, slash, colon.
    static isAlphanumeric(text2) {
      return _QrSegment2.ALPHANUMERIC_REGEX.test(text2);
    }
    /*-- Methods --*/
    // Returns a new copy of the data bits of this segment.
    getData() {
      return this.bitData.slice();
    }
    // (Package-private) Calculates and returns the number of bits needed to encode the given segments at
    // the given version. The result is infinity if a segment has too many characters to fit its length field.
    static getTotalBits(segs, version) {
      let result = 0;
      for (const seg of segs) {
        const ccbits = seg.mode.numCharCountBits(version);
        if (seg.numChars >= 1 << ccbits)
          return Infinity;
        result += 4 + ccbits + seg.bitData.length;
      }
      return result;
    }
    // Returns a new array of bytes representing the given string encoded in UTF-8.
    static toUtf8ByteArray(str) {
      str = encodeURI(str);
      let result = [];
      for (let i = 0; i < str.length; i++) {
        if (str.charAt(i) != "%")
          result.push(str.charCodeAt(i));
        else {
          result.push(parseInt(str.substring(i + 1, i + 3), 16));
          i += 2;
        }
      }
      return result;
    }
  };
  _QrSegment.NUMERIC_REGEX = /^[0-9]*$/;
  _QrSegment.ALPHANUMERIC_REGEX = /^[A-Z0-9 $%*+.\/:-]*$/;
  _QrSegment.ALPHANUMERIC_CHARSET = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:";
  let QrSegment = _QrSegment;
  qrcodegen2.QrSegment = _QrSegment;
})(qrcodegen || (qrcodegen = {}));
((qrcodegen2) => {
  let QrCode;
  ((QrCode2) => {
    const _Ecc = class _Ecc {
      // The QR Code can tolerate about 30% erroneous codewords
      /*-- Constructor and fields --*/
      constructor(ordinal, formatBits) {
        this.ordinal = ordinal;
        this.formatBits = formatBits;
      }
    };
    _Ecc.LOW = new _Ecc(0, 1);
    _Ecc.MEDIUM = new _Ecc(1, 0);
    _Ecc.QUARTILE = new _Ecc(2, 3);
    _Ecc.HIGH = new _Ecc(3, 2);
    let Ecc = _Ecc;
    QrCode2.Ecc = _Ecc;
  })(QrCode = qrcodegen2.QrCode || (qrcodegen2.QrCode = {}));
})(qrcodegen || (qrcodegen = {}));
((qrcodegen2) => {
  let QrSegment;
  ((QrSegment2) => {
    const _Mode = class _Mode {
      /*-- Constructor and fields --*/
      constructor(modeBits, numBitsCharCount) {
        this.modeBits = modeBits;
        this.numBitsCharCount = numBitsCharCount;
      }
      /*-- Method --*/
      // (Package-private) Returns the bit width of the character count field for a segment in
      // this mode in a QR Code at the given version number. The result is in the range [0, 16].
      numCharCountBits(ver) {
        return this.numBitsCharCount[Math.floor((ver + 7) / 17)];
      }
    };
    _Mode.NUMERIC = new _Mode(1, [10, 12, 14]);
    _Mode.ALPHANUMERIC = new _Mode(2, [9, 11, 13]);
    _Mode.BYTE = new _Mode(4, [8, 16, 16]);
    _Mode.KANJI = new _Mode(8, [8, 10, 12]);
    _Mode.ECI = new _Mode(7, [0, 0, 0]);
    let Mode = _Mode;
    QrSegment2.Mode = _Mode;
  })(QrSegment = qrcodegen2.QrSegment || (qrcodegen2.QrSegment = {}));
})(qrcodegen || (qrcodegen = {}));
var qrcodegen_default = qrcodegen;
var ERROR_LEVEL_MAP = {
  L: qrcodegen_default.QrCode.Ecc.LOW,
  M: qrcodegen_default.QrCode.Ecc.MEDIUM,
  Q: qrcodegen_default.QrCode.Ecc.QUARTILE,
  H: qrcodegen_default.QrCode.Ecc.HIGH
};
var DEFAULT_SIZE = 128;
var DEFAULT_LEVEL = "L";
var DEFAULT_BGCOLOR = "#FFFFFF";
var DEFAULT_FGCOLOR = "#000000";
var DEFAULT_INCLUDEMARGIN = false;
var DEFAULT_MINVERSION = 1;
var SPEC_MARGIN_SIZE = 4;
var DEFAULT_MARGIN_SIZE = 0;
var DEFAULT_IMG_SCALE = 0.1;
function generatePath(modules, margin = 0) {
  const ops = [];
  modules.forEach(function(row, y) {
    let start = null;
    row.forEach(function(cell, x) {
      if (!cell && start !== null) {
        ops.push(
          `M${start + margin} ${y + margin}h${x - start}v1H${start + margin}z`
        );
        start = null;
        return;
      }
      if (x === row.length - 1) {
        if (!cell) {
          return;
        }
        if (start === null) {
          ops.push(`M${x + margin},${y + margin} h1v1H${x + margin}z`);
        } else {
          ops.push(
            `M${start + margin},${y + margin} h${x + 1 - start}v1H${start + margin}z`
          );
        }
        return;
      }
      if (cell && start === null) {
        start = x;
      }
    });
  });
  return ops.join("");
}
function excavateModules(modules, excavation) {
  return modules.slice().map((row, y) => {
    if (y < excavation.y || y >= excavation.y + excavation.h) {
      return row;
    }
    return row.map((cell, x) => {
      if (x < excavation.x || x >= excavation.x + excavation.w) {
        return cell;
      }
      return false;
    });
  });
}
function getImageSettings(cells, size, margin, imageSettings) {
  if (imageSettings == null) {
    return null;
  }
  const numCells = cells.length + margin * 2;
  const defaultSize = Math.floor(size * DEFAULT_IMG_SCALE);
  const scale3 = numCells / size;
  const w = (imageSettings.width || defaultSize) * scale3;
  const h = (imageSettings.height || defaultSize) * scale3;
  const x = imageSettings.x == null ? cells.length / 2 - w / 2 : imageSettings.x * scale3;
  const y = imageSettings.y == null ? cells.length / 2 - h / 2 : imageSettings.y * scale3;
  const opacity = imageSettings.opacity == null ? 1 : imageSettings.opacity;
  let excavation = null;
  if (imageSettings.excavate) {
    let floorX = Math.floor(x);
    let floorY = Math.floor(y);
    let ceilW = Math.ceil(w + x - floorX);
    let ceilH = Math.ceil(h + y - floorY);
    excavation = { x: floorX, y: floorY, w: ceilW, h: ceilH };
  }
  const crossOrigin = imageSettings.crossOrigin;
  return { x, y, h, w, excavation, opacity, crossOrigin };
}
function getMarginSize(includeMargin, marginSize) {
  if (marginSize != null) {
    return Math.max(Math.floor(marginSize), 0);
  }
  return includeMargin ? SPEC_MARGIN_SIZE : DEFAULT_MARGIN_SIZE;
}
function useQRCode({
  value: value3,
  level,
  minVersion,
  includeMargin,
  marginSize,
  imageSettings,
  size,
  boostLevel
}) {
  let qrcode = import_react3.default.useMemo(() => {
    const values = Array.isArray(value3) ? value3 : [value3];
    const segments = values.reduce((accum, v) => {
      accum.push(...qrcodegen_default.QrSegment.makeSegments(v));
      return accum;
    }, []);
    return qrcodegen_default.QrCode.encodeSegments(
      segments,
      ERROR_LEVEL_MAP[level],
      minVersion,
      void 0,
      void 0,
      boostLevel
    );
  }, [value3, level, minVersion, boostLevel]);
  const { cells, margin, numCells, calculatedImageSettings } = import_react3.default.useMemo(() => {
    let cells2 = qrcode.getModules();
    const margin2 = getMarginSize(includeMargin, marginSize);
    const numCells2 = cells2.length + margin2 * 2;
    const calculatedImageSettings2 = getImageSettings(
      cells2,
      size,
      margin2,
      imageSettings
    );
    return {
      cells: cells2,
      margin: margin2,
      numCells: numCells2,
      calculatedImageSettings: calculatedImageSettings2
    };
  }, [qrcode, size, imageSettings, includeMargin, marginSize]);
  return {
    qrcode,
    margin,
    cells,
    numCells,
    calculatedImageSettings
  };
}
var SUPPORTS_PATH2D = function() {
  try {
    new Path2D().addPath(new Path2D());
  } catch (e) {
    return false;
  }
  return true;
}();
var QRCodeCanvas = import_react3.default.forwardRef(
  function QRCodeCanvas2(props, forwardedRef) {
    const _a = props, {
      value: value3,
      size = DEFAULT_SIZE,
      level = DEFAULT_LEVEL,
      bgColor = DEFAULT_BGCOLOR,
      fgColor = DEFAULT_FGCOLOR,
      includeMargin = DEFAULT_INCLUDEMARGIN,
      minVersion = DEFAULT_MINVERSION,
      boostLevel,
      marginSize,
      imageSettings
    } = _a, extraProps = __objRest(_a, [
      "value",
      "size",
      "level",
      "bgColor",
      "fgColor",
      "includeMargin",
      "minVersion",
      "boostLevel",
      "marginSize",
      "imageSettings"
    ]);
    const _b = extraProps, { style } = _b, otherProps = __objRest(_b, ["style"]);
    const imgSrc = imageSettings == null ? void 0 : imageSettings.src;
    const _canvas = import_react3.default.useRef(null);
    const _image = import_react3.default.useRef(null);
    const setCanvasRef = import_react3.default.useCallback(
      (node) => {
        _canvas.current = node;
        if (typeof forwardedRef === "function") {
          forwardedRef(node);
        } else if (forwardedRef) {
          forwardedRef.current = node;
        }
      },
      [forwardedRef]
    );
    const [isImgLoaded, setIsImageLoaded] = import_react3.default.useState(false);
    const { margin, cells, numCells, calculatedImageSettings } = useQRCode({
      value: value3,
      level,
      minVersion,
      boostLevel,
      includeMargin,
      marginSize,
      imageSettings,
      size
    });
    import_react3.default.useEffect(() => {
      if (_canvas.current != null) {
        const canvas = _canvas.current;
        const ctx = canvas.getContext("2d");
        if (!ctx) {
          return;
        }
        let cellsToDraw = cells;
        const image = _image.current;
        const haveImageToRender = calculatedImageSettings != null && image !== null && image.complete && image.naturalHeight !== 0 && image.naturalWidth !== 0;
        if (haveImageToRender) {
          if (calculatedImageSettings.excavation != null) {
            cellsToDraw = excavateModules(
              cells,
              calculatedImageSettings.excavation
            );
          }
        }
        const pixelRatio = window.devicePixelRatio || 1;
        canvas.height = canvas.width = size * pixelRatio;
        const scale3 = size / numCells * pixelRatio;
        ctx.scale(scale3, scale3);
        ctx.fillStyle = bgColor;
        ctx.fillRect(0, 0, numCells, numCells);
        ctx.fillStyle = fgColor;
        if (SUPPORTS_PATH2D) {
          ctx.fill(new Path2D(generatePath(cellsToDraw, margin)));
        } else {
          cells.forEach(function(row, rdx) {
            row.forEach(function(cell, cdx) {
              if (cell) {
                ctx.fillRect(cdx + margin, rdx + margin, 1, 1);
              }
            });
          });
        }
        if (calculatedImageSettings) {
          ctx.globalAlpha = calculatedImageSettings.opacity;
        }
        if (haveImageToRender) {
          ctx.drawImage(
            image,
            calculatedImageSettings.x + margin,
            calculatedImageSettings.y + margin,
            calculatedImageSettings.w,
            calculatedImageSettings.h
          );
        }
      }
    });
    import_react3.default.useEffect(() => {
      setIsImageLoaded(false);
    }, [imgSrc]);
    const canvasStyle = __spreadValues({ height: size, width: size }, style);
    let img = null;
    if (imgSrc != null) {
      img = import_react3.default.createElement(
        "img",
        {
          src: imgSrc,
          key: imgSrc,
          style: { display: "none" },
          onLoad: () => {
            setIsImageLoaded(true);
          },
          ref: _image,
          crossOrigin: calculatedImageSettings == null ? void 0 : calculatedImageSettings.crossOrigin
        }
      );
    }
    return import_react3.default.createElement(import_react3.default.Fragment, null, import_react3.default.createElement(
      "canvas",
      __spreadValues({
        style: canvasStyle,
        height: size,
        width: size,
        ref: setCanvasRef,
        role: "img"
      }, otherProps)
    ), img);
  }
);
QRCodeCanvas.displayName = "QRCodeCanvas";
var QRCodeSVG = import_react3.default.forwardRef(
  function QRCodeSVG2(props, forwardedRef) {
    const _a = props, {
      value: value3,
      size = DEFAULT_SIZE,
      level = DEFAULT_LEVEL,
      bgColor = DEFAULT_BGCOLOR,
      fgColor = DEFAULT_FGCOLOR,
      includeMargin = DEFAULT_INCLUDEMARGIN,
      minVersion = DEFAULT_MINVERSION,
      boostLevel,
      title,
      marginSize,
      imageSettings
    } = _a, otherProps = __objRest(_a, [
      "value",
      "size",
      "level",
      "bgColor",
      "fgColor",
      "includeMargin",
      "minVersion",
      "boostLevel",
      "title",
      "marginSize",
      "imageSettings"
    ]);
    const { margin, cells, numCells, calculatedImageSettings } = useQRCode({
      value: value3,
      level,
      minVersion,
      boostLevel,
      includeMargin,
      marginSize,
      imageSettings,
      size
    });
    let cellsToDraw = cells;
    let image = null;
    if (imageSettings != null && calculatedImageSettings != null) {
      if (calculatedImageSettings.excavation != null) {
        cellsToDraw = excavateModules(
          cells,
          calculatedImageSettings.excavation
        );
      }
      image = import_react3.default.createElement(
        "image",
        {
          href: imageSettings.src,
          height: calculatedImageSettings.h,
          width: calculatedImageSettings.w,
          x: calculatedImageSettings.x + margin,
          y: calculatedImageSettings.y + margin,
          preserveAspectRatio: "none",
          opacity: calculatedImageSettings.opacity,
          crossOrigin: calculatedImageSettings.crossOrigin
        }
      );
    }
    const fgPath = generatePath(cellsToDraw, margin);
    return import_react3.default.createElement(
      "svg",
      __spreadValues({
        height: size,
        width: size,
        viewBox: `0 0 ${numCells} ${numCells}`,
        ref: forwardedRef,
        role: "img"
      }, otherProps),
      !!title && import_react3.default.createElement("title", null, title),
      import_react3.default.createElement(
        "path",
        {
          fill: bgColor,
          d: `M0,0 h${numCells}v${numCells}H0z`,
          shapeRendering: "crispEdges"
        }
      ),
      import_react3.default.createElement("path", { fill: fgColor, d: fgPath, shapeRendering: "crispEdges" }),
      image
    );
  }
);
QRCodeSVG.displayName = "QRCodeSVG";

// node_modules/@selfxyz/common/dist/esm/src/utils/circuits/uuid.js
function validateUserId(userId, type) {
  switch (type) {
    case "hex":
      return /^[0-9A-Fa-f]+$/.test(userId);
    case "uuid":
      return /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(userId);
    default:
      return false;
  }
}

// node_modules/uuid/dist/esm-browser/regex.js
var regex_default2 = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;

// node_modules/uuid/dist/esm-browser/validate.js
function validate2(uuid) {
  return typeof uuid === "string" && regex_default2.test(uuid);
}
var validate_default2 = validate2;

// node_modules/uuid/dist/esm-browser/parse.js
function parse3(uuid) {
  if (!validate_default2(uuid)) {
    throw TypeError("Invalid UUID");
  }
  let v;
  return Uint8Array.of((v = parseInt(uuid.slice(0, 8), 16)) >>> 24, v >>> 16 & 255, v >>> 8 & 255, v & 255, (v = parseInt(uuid.slice(9, 13), 16)) >>> 8, v & 255, (v = parseInt(uuid.slice(14, 18), 16)) >>> 8, v & 255, (v = parseInt(uuid.slice(19, 23), 16)) >>> 8, v & 255, (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255, v / 4294967296 & 255, v >>> 24 & 255, v >>> 16 & 255, v >>> 8 & 255, v & 255);
}
var parse_default2 = parse3;

// node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex2 = [];
for (let i = 0; i < 256; ++i) {
  byteToHex2.push((i + 256).toString(16).slice(1));
}
function unsafeStringify2(arr, offset = 0) {
  return (byteToHex2[arr[offset + 0]] + byteToHex2[arr[offset + 1]] + byteToHex2[arr[offset + 2]] + byteToHex2[arr[offset + 3]] + "-" + byteToHex2[arr[offset + 4]] + byteToHex2[arr[offset + 5]] + "-" + byteToHex2[arr[offset + 6]] + byteToHex2[arr[offset + 7]] + "-" + byteToHex2[arr[offset + 8]] + byteToHex2[arr[offset + 9]] + "-" + byteToHex2[arr[offset + 10]] + byteToHex2[arr[offset + 11]] + byteToHex2[arr[offset + 12]] + byteToHex2[arr[offset + 13]] + byteToHex2[arr[offset + 14]] + byteToHex2[arr[offset + 15]]).toLowerCase();
}

// node_modules/uuid/dist/esm-browser/rng.js
var getRandomValues2;
var rnds82 = new Uint8Array(16);
function rng2() {
  if (!getRandomValues2) {
    if (typeof crypto === "undefined" || !crypto.getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
    getRandomValues2 = crypto.getRandomValues.bind(crypto);
  }
  return getRandomValues2(rnds82);
}

// node_modules/uuid/dist/esm-browser/md5.js
function md52(bytes) {
  const words = uint8ToUint32(bytes);
  const md5Bytes = wordsToMd52(words, bytes.length * 8);
  return uint32ToUint8(md5Bytes);
}
function uint32ToUint8(input) {
  const bytes = new Uint8Array(input.length * 4);
  for (let i = 0; i < input.length * 4; i++) {
    bytes[i] = input[i >> 2] >>> i % 4 * 8 & 255;
  }
  return bytes;
}
function getOutputLength2(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
function wordsToMd52(x, len) {
  const xpad = new Uint32Array(getOutputLength2(len)).fill(0);
  xpad.set(x);
  xpad[len >> 5] |= 128 << len % 32;
  xpad[xpad.length - 1] = len;
  x = xpad;
  let a = 1732584193;
  let b = -271733879;
  let c = -1732584194;
  let d = 271733878;
  for (let i = 0; i < x.length; i += 16) {
    const olda = a;
    const oldb = b;
    const oldc = c;
    const oldd = d;
    a = md5ff2(a, b, c, d, x[i], 7, -680876936);
    d = md5ff2(d, a, b, c, x[i + 1], 12, -389564586);
    c = md5ff2(c, d, a, b, x[i + 2], 17, 606105819);
    b = md5ff2(b, c, d, a, x[i + 3], 22, -1044525330);
    a = md5ff2(a, b, c, d, x[i + 4], 7, -176418897);
    d = md5ff2(d, a, b, c, x[i + 5], 12, 1200080426);
    c = md5ff2(c, d, a, b, x[i + 6], 17, -1473231341);
    b = md5ff2(b, c, d, a, x[i + 7], 22, -45705983);
    a = md5ff2(a, b, c, d, x[i + 8], 7, 1770035416);
    d = md5ff2(d, a, b, c, x[i + 9], 12, -1958414417);
    c = md5ff2(c, d, a, b, x[i + 10], 17, -42063);
    b = md5ff2(b, c, d, a, x[i + 11], 22, -1990404162);
    a = md5ff2(a, b, c, d, x[i + 12], 7, 1804603682);
    d = md5ff2(d, a, b, c, x[i + 13], 12, -40341101);
    c = md5ff2(c, d, a, b, x[i + 14], 17, -1502002290);
    b = md5ff2(b, c, d, a, x[i + 15], 22, 1236535329);
    a = md5gg2(a, b, c, d, x[i + 1], 5, -165796510);
    d = md5gg2(d, a, b, c, x[i + 6], 9, -1069501632);
    c = md5gg2(c, d, a, b, x[i + 11], 14, 643717713);
    b = md5gg2(b, c, d, a, x[i], 20, -373897302);
    a = md5gg2(a, b, c, d, x[i + 5], 5, -701558691);
    d = md5gg2(d, a, b, c, x[i + 10], 9, 38016083);
    c = md5gg2(c, d, a, b, x[i + 15], 14, -660478335);
    b = md5gg2(b, c, d, a, x[i + 4], 20, -405537848);
    a = md5gg2(a, b, c, d, x[i + 9], 5, 568446438);
    d = md5gg2(d, a, b, c, x[i + 14], 9, -1019803690);
    c = md5gg2(c, d, a, b, x[i + 3], 14, -187363961);
    b = md5gg2(b, c, d, a, x[i + 8], 20, 1163531501);
    a = md5gg2(a, b, c, d, x[i + 13], 5, -1444681467);
    d = md5gg2(d, a, b, c, x[i + 2], 9, -51403784);
    c = md5gg2(c, d, a, b, x[i + 7], 14, 1735328473);
    b = md5gg2(b, c, d, a, x[i + 12], 20, -1926607734);
    a = md5hh2(a, b, c, d, x[i + 5], 4, -378558);
    d = md5hh2(d, a, b, c, x[i + 8], 11, -2022574463);
    c = md5hh2(c, d, a, b, x[i + 11], 16, 1839030562);
    b = md5hh2(b, c, d, a, x[i + 14], 23, -35309556);
    a = md5hh2(a, b, c, d, x[i + 1], 4, -1530992060);
    d = md5hh2(d, a, b, c, x[i + 4], 11, 1272893353);
    c = md5hh2(c, d, a, b, x[i + 7], 16, -155497632);
    b = md5hh2(b, c, d, a, x[i + 10], 23, -1094730640);
    a = md5hh2(a, b, c, d, x[i + 13], 4, 681279174);
    d = md5hh2(d, a, b, c, x[i], 11, -358537222);
    c = md5hh2(c, d, a, b, x[i + 3], 16, -722521979);
    b = md5hh2(b, c, d, a, x[i + 6], 23, 76029189);
    a = md5hh2(a, b, c, d, x[i + 9], 4, -640364487);
    d = md5hh2(d, a, b, c, x[i + 12], 11, -421815835);
    c = md5hh2(c, d, a, b, x[i + 15], 16, 530742520);
    b = md5hh2(b, c, d, a, x[i + 2], 23, -995338651);
    a = md5ii2(a, b, c, d, x[i], 6, -198630844);
    d = md5ii2(d, a, b, c, x[i + 7], 10, 1126891415);
    c = md5ii2(c, d, a, b, x[i + 14], 15, -1416354905);
    b = md5ii2(b, c, d, a, x[i + 5], 21, -57434055);
    a = md5ii2(a, b, c, d, x[i + 12], 6, 1700485571);
    d = md5ii2(d, a, b, c, x[i + 3], 10, -1894986606);
    c = md5ii2(c, d, a, b, x[i + 10], 15, -1051523);
    b = md5ii2(b, c, d, a, x[i + 1], 21, -2054922799);
    a = md5ii2(a, b, c, d, x[i + 8], 6, 1873313359);
    d = md5ii2(d, a, b, c, x[i + 15], 10, -30611744);
    c = md5ii2(c, d, a, b, x[i + 6], 15, -1560198380);
    b = md5ii2(b, c, d, a, x[i + 13], 21, 1309151649);
    a = md5ii2(a, b, c, d, x[i + 4], 6, -145523070);
    d = md5ii2(d, a, b, c, x[i + 11], 10, -1120210379);
    c = md5ii2(c, d, a, b, x[i + 2], 15, 718787259);
    b = md5ii2(b, c, d, a, x[i + 9], 21, -343485551);
    a = safeAdd2(a, olda);
    b = safeAdd2(b, oldb);
    c = safeAdd2(c, oldc);
    d = safeAdd2(d, oldd);
  }
  return Uint32Array.of(a, b, c, d);
}
function uint8ToUint32(input) {
  if (input.length === 0) {
    return new Uint32Array();
  }
  const output = new Uint32Array(getOutputLength2(input.length * 8)).fill(0);
  for (let i = 0; i < input.length; i++) {
    output[i >> 2] |= (input[i] & 255) << i % 4 * 8;
  }
  return output;
}
function safeAdd2(x, y) {
  const lsw = (x & 65535) + (y & 65535);
  const msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 65535;
}
function bitRotateLeft2(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
function md5cmn2(q, a, b, x, s, t) {
  return safeAdd2(bitRotateLeft2(safeAdd2(safeAdd2(a, q), safeAdd2(x, t)), s), b);
}
function md5ff2(a, b, c, d, x, s, t) {
  return md5cmn2(b & c | ~b & d, a, b, x, s, t);
}
function md5gg2(a, b, c, d, x, s, t) {
  return md5cmn2(b & d | c & ~d, a, b, x, s, t);
}
function md5hh2(a, b, c, d, x, s, t) {
  return md5cmn2(b ^ c ^ d, a, b, x, s, t);
}
function md5ii2(a, b, c, d, x, s, t) {
  return md5cmn2(c ^ (b | ~d), a, b, x, s, t);
}
var md5_default2 = md52;

// node_modules/uuid/dist/esm-browser/v35.js
function stringToBytes2(str) {
  str = unescape(encodeURIComponent(str));
  const bytes = new Uint8Array(str.length);
  for (let i = 0; i < str.length; ++i) {
    bytes[i] = str.charCodeAt(i);
  }
  return bytes;
}
var DNS2 = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
var URL3 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function v352(version, hash, value3, namespace, buf, offset) {
  const valueBytes = typeof value3 === "string" ? stringToBytes2(value3) : value3;
  const namespaceBytes = typeof namespace === "string" ? parse_default2(namespace) : namespace;
  if (typeof namespace === "string") {
    namespace = parse_default2(namespace);
  }
  if (namespace?.length !== 16) {
    throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
  }
  let bytes = new Uint8Array(16 + valueBytes.length);
  bytes.set(namespaceBytes);
  bytes.set(valueBytes, namespaceBytes.length);
  bytes = hash(bytes);
  bytes[6] = bytes[6] & 15 | version;
  bytes[8] = bytes[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = bytes[i];
    }
    return buf;
  }
  return unsafeStringify2(bytes);
}

// node_modules/uuid/dist/esm-browser/v3.js
function v32(value3, namespace, buf, offset) {
  return v352(48, md5_default2, value3, namespace, buf, offset);
}
v32.DNS = DNS2;
v32.URL = URL3;

// node_modules/uuid/dist/esm-browser/native.js
var randomUUID2 = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native_default2 = { randomUUID: randomUUID2 };

// node_modules/uuid/dist/esm-browser/v4.js
function v42(options, buf, offset) {
  if (native_default2.randomUUID && !buf && !options) {
    return native_default2.randomUUID();
  }
  options = options || {};
  const rnds = options.random ?? options.rng?.() ?? rng2();
  if (rnds.length < 16) {
    throw new Error("Random bytes length must be >= 16");
  }
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    if (offset < 0 || offset + 16 > buf.length) {
      throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);
    }
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return unsafeStringify2(rnds);
}
var v4_default2 = v42;

// node_modules/uuid/dist/esm-browser/sha1.js
function f2(s, x, y, z) {
  switch (s) {
    case 0:
      return x & y ^ ~x & z;
    case 1:
      return x ^ y ^ z;
    case 2:
      return x & y ^ x & z ^ y & z;
    case 3:
      return x ^ y ^ z;
  }
}
function ROTL2(x, n) {
  return x << n | x >>> 32 - n;
}
function sha12(bytes) {
  const K = [1518500249, 1859775393, 2400959708, 3395469782];
  const H = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  const newBytes = new Uint8Array(bytes.length + 1);
  newBytes.set(bytes);
  newBytes[bytes.length] = 128;
  bytes = newBytes;
  const l = bytes.length / 4 + 2;
  const N = Math.ceil(l / 16);
  const M = new Array(N);
  for (let i = 0; i < N; ++i) {
    const arr = new Uint32Array(16);
    for (let j = 0; j < 16; ++j) {
      arr[j] = bytes[i * 64 + j * 4] << 24 | bytes[i * 64 + j * 4 + 1] << 16 | bytes[i * 64 + j * 4 + 2] << 8 | bytes[i * 64 + j * 4 + 3];
    }
    M[i] = arr;
  }
  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M[N - 1][14] = Math.floor(M[N - 1][14]);
  M[N - 1][15] = (bytes.length - 1) * 8 & 4294967295;
  for (let i = 0; i < N; ++i) {
    const W = new Uint32Array(80);
    for (let t = 0; t < 16; ++t) {
      W[t] = M[i][t];
    }
    for (let t = 16; t < 80; ++t) {
      W[t] = ROTL2(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);
    }
    let a = H[0];
    let b = H[1];
    let c = H[2];
    let d = H[3];
    let e = H[4];
    for (let t = 0; t < 80; ++t) {
      const s = Math.floor(t / 20);
      const T = ROTL2(a, 5) + f2(s, b, c, d) + e + K[s] + W[t] >>> 0;
      e = d;
      d = c;
      c = ROTL2(b, 30) >>> 0;
      b = a;
      a = T;
    }
    H[0] = H[0] + a >>> 0;
    H[1] = H[1] + b >>> 0;
    H[2] = H[2] + c >>> 0;
    H[3] = H[3] + d >>> 0;
    H[4] = H[4] + e >>> 0;
  }
  return Uint8Array.of(H[0] >> 24, H[0] >> 16, H[0] >> 8, H[0], H[1] >> 24, H[1] >> 16, H[1] >> 8, H[1], H[2] >> 24, H[2] >> 16, H[2] >> 8, H[2], H[3] >> 24, H[3] >> 16, H[3] >> 8, H[3], H[4] >> 24, H[4] >> 16, H[4] >> 8, H[4]);
}
var sha1_default2 = sha12;

// node_modules/uuid/dist/esm-browser/v5.js
function v52(value3, namespace, buf, offset) {
  return v352(80, sha1_default2, value3, namespace, buf, offset);
}
v52.DNS = DNS2;
v52.URL = URL3;

// node_modules/@selfxyz/common/dist/esm/src/utils/scope.js
var import_poseidon_lite2 = __toESM(require_poseidon_lite(), 1);

// node_modules/@selfxyz/common/dist/esm/src/utils/hash.js
var import_poseidon_lite = __toESM(require_poseidon_lite(), 1);
var import_js_sha256 = __toESM(require_sha256(), 1);
var import_js_sha1 = __toESM(require_sha1(), 1);
var import_js_sha512 = __toESM(require_sha512(), 1);
var forge = __toESM(require_lib(), 1);

// node_modules/@selfxyz/common/dist/esm/src/utils/scope.js
function formatEndpoint(endpoint) {
  if (!endpoint)
    return "";
  return endpoint.replace(/^https?:\/\//, "").split("/")[0];
}

// node_modules/@selfxyz/common/dist/esm/src/utils/appType.js
var SelfAppBuilder = class {
  constructor(config) {
    if (!config.appName) {
      throw new Error("appName is required");
    }
    if (!config.scope) {
      throw new Error("scope is required");
    }
    if (!config.endpoint) {
      throw new Error("endpoint is required");
    }
    if (!/^[\x00-\x7F]*$/.test(config.scope)) {
      throw new Error("Scope must contain only ASCII characters (0-127)");
    }
    if (!/^[\x00-\x7F]*$/.test(config.endpoint)) {
      throw new Error("Endpoint must contain only ASCII characters (0-127)");
    }
    if (config.scope.length > 31) {
      throw new Error("Scope must be less than 31 characters");
    }
    const formattedEndpoint = formatEndpoint(config.endpoint);
    if (formattedEndpoint.length > 496) {
      throw new Error(`Endpoint must be less than 496 characters, current endpoint: ${formattedEndpoint}, length: ${formattedEndpoint.length}`);
    }
    if (!config.userId) {
      throw new Error("userId is required");
    }
    if (config.endpointType === "https" && !config.endpoint.startsWith("https://")) {
      throw new Error("endpoint must start with https://");
    }
    if (config.endpointType === "celo" && !config.endpoint.startsWith("0x")) {
      throw new Error("endpoint must be a valid address");
    }
    if (config.endpoint && (config.endpoint.includes("localhost") || config.endpoint.includes("127.0.0.1"))) {
      throw new Error("localhost endpoints are not allowed");
    }
    if (config.userIdType === "hex") {
      if (!config.userId.startsWith("0x")) {
        throw new Error("userId as hex must start with 0x");
      }
      config.userId = config.userId.slice(2);
    }
    if (!validateUserId(config.userId, config.userIdType ?? "uuid")) {
      throw new Error("userId must be a valid UUID or address");
    }
    this.config = {
      sessionId: v4_default2(),
      userIdType: "uuid",
      devMode: false,
      endpointType: "https",
      header: "",
      logoBase64: "",
      deeplinkCallback: "",
      disclosures: {},
      chainID: config.endpointType === "staging_celo" ? 44787 : 42220,
      version: config.version ?? 2,
      userDefinedData: "",
      ...config
    };
  }
  build() {
    return this.config;
  }
};
function getUniversalLink(selfApp) {
  return `${REDIRECT_URL}?selfApp=${encodeURIComponent(JSON.stringify(selfApp))}`;
}

// node_modules/@selfxyz/qrcode/dist/chunk-YLXJTR7N.js
var check_animation_default = {
  v: "5.7.12",
  fr: 24,
  ip: 0,
  op: 63,
  w: 520,
  h: 520,
  nm: "Checklist 2",
  ddd: 0,
  assets: [],
  layers: [
    {
      ddd: 0,
      ind: 1,
      ty: 4,
      nm: "Checklist",
      sr: 1,
      ks: {
        o: {
          a: 1,
          k: [
            {
              i: { x: [0.667], y: [1] },
              o: { x: [0.333], y: [0] },
              t: 50,
              s: [100]
            },
            { t: 62, s: [0] }
          ],
          ix: 11
        },
        r: { a: 0, k: 0, ix: 10 },
        p: { a: 0, k: [259.587, 260.119, 0], ix: 2, l: 2 },
        a: { a: 0, k: [297.587, 298.119, 0], ix: 1, l: 2 },
        s: { a: 0, k: [100, 100, 100], ix: 6, l: 2 }
      },
      ao: 0,
      shapes: [
        {
          ty: "gr",
          it: [
            {
              ind: 0,
              ty: "sh",
              ix: 1,
              ks: {
                a: 0,
                k: {
                  i: [
                    [0, 0],
                    [0, 0],
                    [0, 0]
                  ],
                  o: [
                    [0, 0],
                    [0, 0],
                    [0, 0]
                  ],
                  v: [
                    [54.754, -36.121],
                    [-17.487, 36.12],
                    [-54.754, -1.147]
                  ],
                  c: false
                },
                ix: 2
              },
              nm: "Path 1",
              mn: "ADBE Vector Shape - Group",
              hd: false
            },
            {
              ty: "st",
              c: { a: 0, k: [1, 1, 1, 1], ix: 3 },
              o: { a: 0, k: 100, ix: 4 },
              w: { a: 0, k: 23, ix: 5 },
              lc: 2,
              lj: 2,
              bm: 0,
              nm: "Stroke 1",
              mn: "ADBE Vector Graphic - Stroke",
              hd: false
            },
            {
              ty: "tr",
              p: { a: 0, k: [294.971, 298.679], ix: 2 },
              a: { a: 0, k: [0, 0], ix: 1 },
              s: { a: 0, k: [100, 100], ix: 3 },
              r: { a: 0, k: 0, ix: 6 },
              o: { a: 0, k: 100, ix: 7 },
              sk: { a: 0, k: 0, ix: 4 },
              sa: { a: 0, k: 0, ix: 5 },
              nm: "Transform"
            }
          ],
          nm: "Group 1",
          np: 2,
          cix: 2,
          bm: 0,
          ix: 1,
          mn: "ADBE Vector Group",
          hd: false
        },
        {
          ty: "tm",
          s: {
            a: 1,
            k: [
              { i: { x: [0], y: [1] }, o: { x: [0.333], y: [0] }, t: 24, s: [100] },
              { t: 36, s: [0] }
            ],
            ix: 1
          },
          e: { a: 0, k: 100, ix: 2 },
          o: { a: 0, k: 0, ix: 3 },
          m: 1,
          ix: 2,
          nm: "Trim Paths 1",
          mn: "ADBE Vector Filter - Trim",
          hd: false
        }
      ],
      ip: 0,
      op: 720,
      st: 0,
      bm: 0
    },
    {
      ddd: 0,
      ind: 2,
      ty: 4,
      nm: "Cricle",
      sr: 1,
      ks: {
        o: {
          a: 1,
          k: [
            {
              i: { x: [0.667], y: [1] },
              o: { x: [0.333], y: [0] },
              t: 50,
              s: [100]
            },
            { t: 62, s: [0] }
          ],
          ix: 11
        },
        r: { a: 0, k: 0, ix: 10 },
        p: { a: 0, k: [260, 260, 0], ix: 2, l: 2 },
        a: { a: 0, k: [-7.627, -7.691, 0], ix: 1, l: 2 },
        s: {
          a: 1,
          k: [
            {
              i: { x: [0.667, 0.667, 0.667], y: [1, 1, 1] },
              o: { x: [0.167, 0.167, 0.167], y: [0, 0, 0] },
              t: 18,
              s: [124.222, 124.222, 100]
            },
            {
              i: { x: [0.667, 0.667, 0.667], y: [1, 1, 1] },
              o: { x: [0.333, 0.333, 0.333], y: [0, 0, 0] },
              t: 20,
              s: [134.222, 134.222, 100]
            },
            {
              i: { x: [0.667, 0.667, 0.667], y: [1, 1, 1] },
              o: { x: [0.333, 0.333, 0.333], y: [0, 0, 0] },
              t: 22,
              s: [114.222, 114.222, 100]
            },
            { t: 24, s: [124.222, 124.222, 100] }
          ],
          ix: 6,
          l: 2
        }
      },
      ao: 0,
      shapes: [
        {
          ty: "gr",
          it: [
            {
              d: 1,
              ty: "el",
              s: { a: 0, k: [178.46, 178.46], ix: 2 },
              p: { a: 0, k: [0, 0], ix: 3 },
              nm: "Ellipse Path 1",
              mn: "ADBE Vector Shape - Ellipse",
              hd: false
            },
            {
              ty: "tm",
              s: { a: 0, k: 0, ix: 1 },
              e: {
                a: 1,
                k: [
                  {
                    i: { x: [0.239], y: [1] },
                    o: { x: [0.333], y: [0] },
                    t: 0,
                    s: [0]
                  },
                  { t: 24, s: [100] }
                ],
                ix: 2
              },
              o: { a: 0, k: 0, ix: 3 },
              m: 1,
              ix: 2,
              nm: "Trim Paths 1",
              mn: "ADBE Vector Filter - Trim",
              hd: false
            },
            {
              ty: "st",
              c: { a: 0, k: [0.3137, 0.7569, 0.3294, 1], ix: 3 },
              o: { a: 0, k: 100, ix: 4 },
              w: { a: 0, k: 10, ix: 5 },
              lc: 2,
              lj: 2,
              bm: 0,
              nm: "Stroke 1",
              mn: "ADBE Vector Graphic - Stroke",
              hd: false
            },
            {
              ty: "fl",
              c: { a: 0, k: [0.3137, 0.7569, 0.3294, 1], ix: 4 },
              o: {
                a: 1,
                k: [
                  {
                    i: { x: [0], y: [1] },
                    o: { x: [0.333], y: [0] },
                    t: 22,
                    s: [0]
                  },
                  { t: 24, s: [100] }
                ],
                ix: 5
              },
              r: 1,
              bm: 0,
              nm: "Fill 1",
              mn: "ADBE Vector Graphic - Fill",
              hd: false
            },
            {
              ty: "tr",
              p: { a: 0, k: [-7.627, -7.691], ix: 2 },
              a: { a: 0, k: [0, 0], ix: 1 },
              s: { a: 0, k: [100, 100], ix: 3 },
              r: { a: 0, k: 0, ix: 6 },
              o: { a: 0, k: 100, ix: 7 },
              sk: { a: 0, k: 0, ix: 4 },
              sa: { a: 0, k: 0, ix: 5 },
              nm: "Transform"
            }
          ],
          nm: "Ellipse 1",
          np: 4,
          cix: 2,
          bm: 0,
          ix: 1,
          mn: "ADBE Vector Group",
          hd: false
        }
      ],
      ip: 0,
      op: 720,
      st: 0,
      bm: 0
    },
    {
      ddd: 0,
      ind: 3,
      ty: 4,
      nm: "Line",
      sr: 1,
      ks: {
        o: {
          a: 1,
          k: [
            { i: { x: [0.667], y: [1] }, o: { x: [0.333], y: [0] }, t: 28, s: [0] },
            {
              i: { x: [0.667], y: [1] },
              o: { x: [0.333], y: [0] },
              t: 39,
              s: [100]
            },
            { t: 50, s: [0] }
          ],
          ix: 11
        },
        r: { a: 0, k: 0, ix: 10 },
        p: { a: 0, k: [260, 260, 0], ix: 2, l: 2 },
        a: { a: 0, k: [298, 298, 0], ix: 1, l: 2 },
        s: {
          a: 1,
          k: [
            {
              i: { x: [0, 0, 0.667], y: [1, 1, 1] },
              o: { x: [0.333, 0.333, 0.333], y: [0, 0, 0] },
              t: 28,
              s: [46, 46, 100]
            },
            { t: 50, s: [100, 100, 100] }
          ],
          ix: 6,
          l: 2
        }
      },
      ao: 0,
      shapes: [
        {
          ty: "gr",
          it: [
            {
              ind: 0,
              ty: "sh",
              ix: 1,
              ks: {
                a: 0,
                k: {
                  i: [
                    [-120.208, 0],
                    [0, -120.208],
                    [120.207, 0],
                    [0, 120.208]
                  ],
                  o: [
                    [120.207, 0],
                    [0, 120.208],
                    [-120.208, 0],
                    [0, -120.208]
                  ],
                  v: [
                    [0, -217.655],
                    [217.655, 0],
                    [0, 217.655],
                    [-217.655, 0]
                  ],
                  c: true
                },
                ix: 2
              },
              nm: "Path 1",
              mn: "ADBE Vector Shape - Group",
              hd: false
            },
            {
              ty: "st",
              c: { a: 0, k: [0.6516, 0.8284, 0.6575, 1], ix: 3 },
              o: { a: 0, k: 100, ix: 4 },
              w: { a: 0, k: 2, ix: 5 },
              lc: 1,
              lj: 1,
              ml: 10,
              bm: 0,
              nm: "Stroke 1",
              mn: "ADBE Vector Graphic - Stroke",
              hd: false
            },
            {
              ty: "tr",
              p: { a: 0, k: [297.587, 298.119], ix: 2 },
              a: { a: 0, k: [0, 0], ix: 1 },
              s: { a: 0, k: [100, 100], ix: 3 },
              r: { a: 0, k: 0, ix: 6 },
              o: { a: 0, k: 100, ix: 7 },
              sk: { a: 0, k: 0, ix: 4 },
              sa: { a: 0, k: 0, ix: 5 },
              nm: "Transform"
            }
          ],
          nm: "Group 1",
          np: 2,
          cix: 2,
          bm: 0,
          ix: 1,
          mn: "ADBE Vector Group",
          hd: false
        }
      ],
      ip: 28,
      op: 720,
      st: 0,
      bm: 0
    },
    {
      ddd: 0,
      ind: 4,
      ty: 4,
      nm: "Shadow",
      sr: 1,
      ks: {
        o: {
          a: 1,
          k: [
            { i: { x: [0.667], y: [1] }, o: { x: [0.333], y: [0] }, t: 22, s: [0] },
            {
              i: { x: [0.667], y: [1] },
              o: { x: [0.333], y: [0] },
              t: 33,
              s: [100]
            },
            { t: 44, s: [0] }
          ],
          ix: 11
        },
        r: { a: 0, k: 0, ix: 10 },
        p: { a: 0, k: [260, 260, 0], ix: 2, l: 2 },
        a: { a: 0, k: [298, 298, 0], ix: 1, l: 2 },
        s: {
          a: 1,
          k: [
            {
              i: { x: [0, 0, 0.667], y: [1, 1, 1] },
              o: { x: [0.333, 0.333, 0.333], y: [0, 0, 0] },
              t: 22,
              s: [60, 60, 100]
            },
            { t: 44, s: [100, 100, 100] }
          ],
          ix: 6,
          l: 2
        }
      },
      ao: 0,
      shapes: [
        {
          ty: "gr",
          it: [
            {
              ind: 0,
              ty: "sh",
              ix: 1,
              ks: {
                a: 0,
                k: {
                  i: [
                    [-94.797, 0],
                    [0, -94.797],
                    [94.797, 0],
                    [0, 94.798]
                  ],
                  o: [
                    [94.797, 0],
                    [0, 94.798],
                    [-94.797, 0],
                    [0, -94.797]
                  ],
                  v: [
                    [0, -171.646],
                    [171.646, 0],
                    [0, 171.646],
                    [-171.646, 0]
                  ],
                  c: true
                },
                ix: 2
              },
              nm: "Path 1",
              mn: "ADBE Vector Shape - Group",
              hd: false
            },
            {
              ty: "fl",
              c: { a: 0, k: [0.8936, 0.9464, 0.8954, 1], ix: 4 },
              o: { a: 0, k: 100, ix: 5 },
              r: 1,
              bm: 0,
              nm: "Fill 1",
              mn: "ADBE Vector Graphic - Fill",
              hd: false
            },
            {
              ty: "tr",
              p: { a: 0, k: [297.587, 298.119], ix: 2 },
              a: { a: 0, k: [0, 0], ix: 1 },
              s: { a: 0, k: [100, 100], ix: 3 },
              r: { a: 0, k: 0, ix: 6 },
              o: { a: 0, k: 100, ix: 7 },
              sk: { a: 0, k: 0, ix: 4 },
              sa: { a: 0, k: 0, ix: 5 },
              nm: "Transform"
            }
          ],
          nm: "Group 1",
          np: 2,
          cix: 2,
          bm: 0,
          ix: 1,
          mn: "ADBE Vector Group",
          hd: false
        }
      ],
      ip: 22,
      op: 720,
      st: 0,
      bm: 0
    }
  ],
  markers: []
};
var x_animation_default = {
  v: "5.7.11",
  fr: 30,
  ip: 0,
  op: 60,
  w: 512,
  h: 512,
  nm: "Bouncy Fail",
  ddd: 0,
  assets: [],
  layers: [
    {
      ddd: 0,
      ind: 1,
      ty: 4,
      nm: "X line 2",
      sr: 1,
      ks: {
        o: { a: 0, k: 100, ix: 11 },
        r: { a: 0, k: 90, ix: 10 },
        p: { a: 0, k: [256, 256, 0], ix: 2, l: 2 },
        a: { a: 0, k: [41, -3, 0], ix: 1, l: 2 },
        s: { a: 0, k: [100, 100, 100], ix: 6, l: 2 }
      },
      ao: 0,
      shapes: [
        {
          ty: "gr",
          it: [
            {
              ind: 0,
              ty: "sh",
              ix: 1,
              ks: {
                a: 0,
                k: {
                  i: [
                    [112, -74],
                    [-30, 68]
                  ],
                  o: [
                    [112, -74],
                    [-30, 68]
                  ],
                  v: [
                    [112, -74],
                    [-30, 68]
                  ],
                  c: false
                },
                ix: 2
              },
              nm: "Path 1",
              mn: "ADBE Vector Shape - Group",
              hd: false,
              _render: true
            },
            {
              ty: "st",
              c: { a: 0, k: [1, 1, 1, 1], ix: 3 },
              o: { a: 0, k: 100, ix: 4 },
              w: { a: 0, k: 40, ix: 5 },
              lc: 2,
              lj: 2,
              bm: 0,
              nm: "Stroke 1",
              mn: "ADBE Vector Graphic - Stroke",
              hd: false,
              _render: true
            },
            {
              ty: "fl",
              c: { a: 0, k: [1, 0.5412, 0.4902, 1], ix: 4 },
              o: { a: 0, k: 100, ix: 5 },
              r: 1,
              bm: 0,
              nm: "Fill 1",
              mn: "ADBE Vector Graphic - Fill",
              hd: false,
              _render: true
            },
            {
              ty: "tr",
              p: { a: 0, k: [0, 0], ix: 2 },
              a: { a: 0, k: [0, 0], ix: 1 },
              s: { a: 0, k: [100, 100], ix: 3 },
              r: { a: 0, k: 0, ix: 6 },
              o: { a: 0, k: 100, ix: 7 },
              sk: { a: 0, k: 0, ix: 4 },
              sa: { a: 0, k: 0, ix: 5 },
              nm: "Transform",
              _render: true
            }
          ],
          nm: "Shape 1",
          np: 3,
          cix: 2,
          bm: 0,
          ix: 1,
          mn: "ADBE Vector Group",
          hd: false,
          _render: true
        },
        {
          ty: "tm",
          s: {
            a: 1,
            k: [
              {
                i: { x: [0.667], y: [1] },
                o: { x: [0.333], y: [0] },
                t: 26,
                s: [100]
              },
              { t: 40, s: [0] }
            ],
            ix: 1
          },
          e: { a: 0, k: 100, ix: 2 },
          o: { a: 0, k: 0, ix: 3 },
          m: 1,
          ix: 2,
          nm: "Trim Paths 1",
          mn: "ADBE Vector Filter - Trim",
          hd: false,
          _render: true
        }
      ],
      ip: 26,
      op: 60,
      st: 0,
      bm: 0,
      completed: true
    },
    {
      ddd: 0,
      ind: 2,
      ty: 4,
      nm: "X line 1",
      sr: 1,
      ks: {
        o: { a: 0, k: 100, ix: 11 },
        r: { a: 0, k: 0, ix: 10 },
        p: { a: 0, k: [256, 256, 0], ix: 2, l: 2 },
        a: { a: 0, k: [41, -3, 0], ix: 1, l: 2 },
        s: { a: 0, k: [100, 100, 100], ix: 6, l: 2 }
      },
      ao: 0,
      shapes: [
        {
          ty: "gr",
          it: [
            {
              ind: 0,
              ty: "sh",
              ix: 1,
              ks: {
                a: 0,
                k: {
                  i: [
                    [112, -74],
                    [-30, 68]
                  ],
                  o: [
                    [112, -74],
                    [-30, 68]
                  ],
                  v: [
                    [112, -74],
                    [-30, 68]
                  ],
                  c: false
                },
                ix: 2
              },
              nm: "Path 1",
              mn: "ADBE Vector Shape - Group",
              hd: false,
              _render: true
            },
            {
              ty: "st",
              c: { a: 0, k: [1, 1, 1, 1], ix: 3 },
              o: { a: 0, k: 100, ix: 4 },
              w: { a: 0, k: 40, ix: 5 },
              lc: 2,
              lj: 2,
              bm: 0,
              nm: "Stroke 1",
              mn: "ADBE Vector Graphic - Stroke",
              hd: false,
              _render: true
            },
            {
              ty: "fl",
              c: { a: 0, k: [1, 0.5412, 0.4902, 1], ix: 4 },
              o: { a: 0, k: 100, ix: 5 },
              r: 1,
              bm: 0,
              nm: "Fill 1",
              mn: "ADBE Vector Graphic - Fill",
              hd: false,
              _render: true
            },
            {
              ty: "tr",
              p: { a: 0, k: [0, 0], ix: 2 },
              a: { a: 0, k: [0, 0], ix: 1 },
              s: { a: 0, k: [100, 100], ix: 3 },
              r: { a: 0, k: 0, ix: 6 },
              o: { a: 0, k: 100, ix: 7 },
              sk: { a: 0, k: 0, ix: 4 },
              sa: { a: 0, k: 0, ix: 5 },
              nm: "Transform",
              _render: true
            }
          ],
          nm: "Shape 1",
          np: 3,
          cix: 2,
          bm: 0,
          ix: 1,
          mn: "ADBE Vector Group",
          hd: false,
          _render: true
        },
        {
          ty: "tm",
          s: { a: 0, k: 0, ix: 1 },
          e: {
            a: 1,
            k: [
              {
                i: { x: [0.667], y: [1] },
                o: { x: [0.333], y: [0] },
                t: 26,
                s: [0]
              },
              { t: 40, s: [100] }
            ],
            ix: 2
          },
          o: { a: 0, k: 0, ix: 3 },
          m: 1,
          ix: 2,
          nm: "Trim Paths 1",
          mn: "ADBE Vector Filter - Trim",
          hd: false,
          _render: true
        }
      ],
      ip: 26,
      op: 60,
      st: 0,
      bm: 0,
      completed: true
    },
    {
      ddd: 0,
      ind: 4,
      ty: 4,
      nm: "Circle 2",
      sr: 1,
      ks: {
        o: {
          a: 0,
          k: 100,
          ix: 11,
          x: "var $bm_rt;\nvar opacityInertialBounce, opacityBounceBack, n, n, t, t, v, amp, freq, decay, v, amp, freq, decay, e, g, nMax, e, g, nMax, n, n, t, v, vl, vu, vu, tCur, segDur, tNext, nb, delta;\nopacityInertialBounce = effect('Bounce & Drop - ukramedia.com')(44);\nopacityBounceBack = effect('Bounce & Drop - ukramedia.com')(45);\ntry {\n    if (opacityInertialBounce == 1) {\n        $bm_rt = n = 0;\n        if (numKeys > 0) {\n            $bm_rt = n = nearestKey(time).index;\n            if (key(n).time > time) {\n                n--;\n            }\n        }\n        if (n == 0) {\n            $bm_rt = t = 0;\n        } else {\n            $bm_rt = t = $bm_sub(time, key(n).time);\n        }\n        if (effect('Bounce & Drop - ukramedia.com')(58) == 1) {\n            if (n > 0 && t < 1) {\n                v = velocityAtTime($bm_sub(key(n).time, $bm_div(thisComp.frameDuration, 10)));\n                amp = effect('Bounce & Drop - ukramedia.com')(59);\n                freq = effect('Bounce & Drop - ukramedia.com')(60);\n                decay = effect('Bounce & Drop - ukramedia.com')(61);\n                $bm_rt = $bm_sum(value, $bm_div($bm_mul($bm_mul(v, amp), Math.sin($bm_mul($bm_mul($bm_mul(freq, t), 2), Math.PI))), Math.exp($bm_mul(decay, t))));\n            } else {\n                $bm_rt = value;\n            }\n        } else {\n            if (n > 0 && t < 1) {\n                v = velocityAtTime($bm_sub(key(n).time, $bm_div(thisComp.frameDuration, 10)));\n                amp = effect('Bounce & Drop - ukramedia.com')(47);\n                freq = effect('Bounce & Drop - ukramedia.com')(48);\n                decay = effect('Bounce & Drop - ukramedia.com')(49);\n                $bm_rt = $bm_sum(value, $bm_div($bm_mul($bm_mul(v, amp), Math.sin($bm_mul($bm_mul($bm_mul(freq, t), 2), Math.PI))), Math.exp($bm_mul(decay, t))));\n            } else {\n                $bm_rt = value;\n            }\n        }\n    } else if (opacityBounceBack == 1) {\n        if (effect('Bounce & Drop - ukramedia.com')(64) == 1) {\n            e = effect('Bounce & Drop - ukramedia.com')(65);\n            g = effect('Bounce & Drop - ukramedia.com')(66);\n            nMax = effect('Bounce & Drop - ukramedia.com')(67);\n        } else {\n            e = effect('Bounce & Drop - ukramedia.com')(52);\n            g = effect('Bounce & Drop - ukramedia.com')(53);\n            nMax = effect('Bounce & Drop - ukramedia.com')(54);\n        }\n        $bm_rt = n = 0;\n        if (numKeys > 0) {\n            $bm_rt = n = nearestKey(time).index;\n            if (key(n).time > time)\n                n--;\n        }\n        if (n > 0) {\n            t = $bm_sub(time, key(n).time);\n            v = $bm_mul($bm_neg(velocityAtTime($bm_sub(key(n).time, 0.001))), e);\n            vl = length(v);\n            if ($bm_isInstanceOfArray(value)) {\n                vu = vl > 0 ? normalize(v) : [\n                    0,\n                    0,\n                    0\n                ];\n            } else {\n                vu = v < 0 ? -1 : 1;\n            }\n            tCur = 0;\n            segDur = $bm_div($bm_mul(2, vl), g);\n            tNext = segDur;\n            nb = 1;\n            while (tNext < t && nb <= nMax) {\n                vl *= e;\n                segDur *= e;\n                tCur = tNext;\n                tNext = $bm_sum(tNext, segDur);\n                nb++;\n            }\n            if (nb <= nMax) {\n                delta = $bm_sub(t, tCur);\n                $bm_rt = $bm_sum(value, $bm_mul($bm_mul(vu, delta), $bm_sub(vl, $bm_div($bm_mul(g, delta), 2))));\n            } else {\n                $bm_rt = value;\n            }\n        } else\n            $bm_rt = value;\n    } else {\n        $bm_rt = value;\n    }\n} catch (err) {\n    $bm_rt = value;\n}"
        },
        r: {
          a: 0,
          k: 0,
          ix: 10,
          x: "var $bm_rt;\nvar rotationInertialBounce, rotationBounceBack, n, n, t, t, v, amp, freq, decay, v, amp, freq, decay, e, g, nMax, e, g, nMax, n, n, t, v, vl, vu, vu, tCur, segDur, tNext, nb, delta;\nrotationInertialBounce = effect('Bounce & Drop - ukramedia.com')(30);\nrotationBounceBack = effect('Bounce & Drop - ukramedia.com')(31);\ntry {\n    if (rotationInertialBounce == 1) {\n        $bm_rt = n = 0;\n        if (numKeys > 0) {\n            $bm_rt = n = nearestKey(time).index;\n            if (key(n).time > time) {\n                n--;\n            }\n        }\n        if (n == 0) {\n            $bm_rt = t = 0;\n        } else {\n            $bm_rt = t = $bm_sub(time, key(n).time);\n        }\n        if (effect('Bounce & Drop - ukramedia.com')(58) == 1) {\n            if (n > 0 && t < 1) {\n                v = velocityAtTime($bm_sub(key(n).time, $bm_div(thisComp.frameDuration, 10)));\n                amp = effect('Bounce & Drop - ukramedia.com')(59);\n                freq = effect('Bounce & Drop - ukramedia.com')(60);\n                decay = effect('Bounce & Drop - ukramedia.com')(61);\n                $bm_rt = $bm_sum(value, $bm_div($bm_mul($bm_mul(v, amp), Math.sin($bm_mul($bm_mul($bm_mul(freq, t), 2), Math.PI))), Math.exp($bm_mul(decay, t))));\n            } else {\n                $bm_rt = value;\n            }\n        } else {\n            if (n > 0 && t < 1) {\n                v = velocityAtTime($bm_sub(key(n).time, $bm_div(thisComp.frameDuration, 10)));\n                amp = effect('Bounce & Drop - ukramedia.com')(33);\n                freq = effect('Bounce & Drop - ukramedia.com')(34);\n                decay = effect('Bounce & Drop - ukramedia.com')(35);\n                $bm_rt = $bm_sum(value, $bm_div($bm_mul($bm_mul(v, amp), Math.sin($bm_mul($bm_mul($bm_mul(freq, t), 2), Math.PI))), Math.exp($bm_mul(decay, t))));\n            } else {\n                $bm_rt = value;\n            }\n        }\n    } else if (rotationBounceBack == 1) {\n        if (effect('Bounce & Drop - ukramedia.com')(64) == 1) {\n            e = effect('Bounce & Drop - ukramedia.com')(65);\n            g = effect('Bounce & Drop - ukramedia.com')(66);\n            nMax = effect('Bounce & Drop - ukramedia.com')(67);\n        } else {\n            e = effect('Bounce & Drop - ukramedia.com')(38);\n            g = effect('Bounce & Drop - ukramedia.com')(39);\n            nMax = effect('Bounce & Drop - ukramedia.com')(40);\n        }\n        $bm_rt = n = 0;\n        if (numKeys > 0) {\n            $bm_rt = n = nearestKey(time).index;\n            if (key(n).time > time)\n                n--;\n        }\n        if (n > 0) {\n            t = $bm_sub(time, key(n).time);\n            v = $bm_mul($bm_neg(velocityAtTime($bm_sub(key(n).time, 0.001))), e);\n            vl = length(v);\n            if ($bm_isInstanceOfArray(value)) {\n                vu = vl > 0 ? normalize(v) : [\n                    0,\n                    0,\n                    0\n                ];\n            } else {\n                vu = v < 0 ? -1 : 1;\n            }\n            tCur = 0;\n            segDur = $bm_div($bm_mul(2, vl), g);\n            tNext = segDur;\n            nb = 1;\n            while (tNext < t && nb <= nMax) {\n                vl *= e;\n                segDur *= e;\n                tCur = tNext;\n                tNext = $bm_sum(tNext, segDur);\n                nb++;\n            }\n            if (nb <= nMax) {\n                delta = $bm_sub(t, tCur);\n                $bm_rt = $bm_sum(value, $bm_mul($bm_mul(vu, delta), $bm_sub(vl, $bm_div($bm_mul(g, delta), 2))));\n            } else {\n                $bm_rt = value;\n            }\n        } else\n            $bm_rt = value;\n    } else {\n        $bm_rt = value;\n    }\n} catch (err) {\n    $bm_rt = value;\n}"
        },
        p: {
          a: 0,
          k: [256, 256, 0],
          ix: 2,
          l: 2,
          x: "var $bm_rt;\nvar positionInertialBounce, positionBounceBack, n, n, t, t, v, amp, freq, decay, v, amp, freq, decay, e, g, nMax, e, g, nMax, n, n, t, v, vl, vu, vu, tCur, segDur, tNext, nb, delta;\npositionInertialBounce = effect('Bounce & Drop - ukramedia.com')(2);\npositionBounceBack = effect('Bounce & Drop - ukramedia.com')(3);\ntry {\n    if (positionInertialBounce == 1) {\n        $bm_rt = n = 0;\n        if (numKeys > 0) {\n            $bm_rt = n = nearestKey(time).index;\n            if (key(n).time > time) {\n                n--;\n            }\n        }\n        if (n == 0) {\n            $bm_rt = t = 0;\n        } else {\n            $bm_rt = t = $bm_sub(time, key(n).time);\n        }\n        if (effect('Bounce & Drop - ukramedia.com')(58) == 1) {\n            if (n > 0 && t < 1) {\n                v = velocityAtTime($bm_sub(key(n).time, $bm_div(thisComp.frameDuration, 10)));\n                amp = effect('Bounce & Drop - ukramedia.com')(59);\n                freq = effect('Bounce & Drop - ukramedia.com')(60);\n                decay = effect('Bounce & Drop - ukramedia.com')(61);\n                $bm_rt = $bm_sum(value, $bm_div($bm_mul($bm_mul(v, amp), Math.sin($bm_mul($bm_mul($bm_mul(freq, t), 2), Math.PI))), Math.exp($bm_mul(decay, t))));\n            } else {\n                $bm_rt = value;\n            }\n        } else {\n            if (n > 0 && t < 1) {\n                v = velocityAtTime($bm_sub(key(n).time, $bm_div(thisComp.frameDuration, 10)));\n                amp = effect('Bounce & Drop - ukramedia.com')(5);\n                freq = effect('Bounce & Drop - ukramedia.com')(6);\n                decay = effect('Bounce & Drop - ukramedia.com')(7);\n                $bm_rt = $bm_sum(value, $bm_div($bm_mul($bm_mul(v, amp), Math.sin($bm_mul($bm_mul($bm_mul(freq, t), 2), Math.PI))), Math.exp($bm_mul(decay, t))));\n            } else {\n                $bm_rt = value;\n            }\n        }\n    } else if (positionBounceBack == 1) {\n        if (effect('Bounce & Drop - ukramedia.com')(64) == 1) {\n            e = effect('Bounce & Drop - ukramedia.com')(65);\n            g = effect('Bounce & Drop - ukramedia.com')(66);\n            nMax = effect('Bounce & Drop - ukramedia.com')(67);\n        } else {\n            e = effect('Bounce & Drop - ukramedia.com')(10);\n            g = effect('Bounce & Drop - ukramedia.com')(11);\n            nMax = effect('Bounce & Drop - ukramedia.com')(12);\n        }\n        $bm_rt = n = 0;\n        if (numKeys > 0) {\n            $bm_rt = n = nearestKey(time).index;\n            if (key(n).time > time)\n                n--;\n        }\n        if (n > 0) {\n            t = $bm_sub(time, key(n).time);\n            v = $bm_mul($bm_neg(velocityAtTime($bm_sub(key(n).time, 0.001))), e);\n            vl = length(v);\n            if ($bm_isInstanceOfArray(value)) {\n                vu = vl > 0 ? normalize(v) : [\n                    0,\n                    0,\n                    0\n                ];\n            } else {\n                vu = v < 0 ? -1 : 1;\n            }\n            tCur = 0;\n            segDur = $bm_div($bm_mul(2, vl), g);\n            tNext = segDur;\n            nb = 1;\n            while (tNext < t && nb <= nMax) {\n                vl *= e;\n                segDur *= e;\n                tCur = tNext;\n                tNext = $bm_sum(tNext, segDur);\n                nb++;\n            }\n            if (nb <= nMax) {\n                delta = $bm_sub(t, tCur);\n                $bm_rt = $bm_sum(value, $bm_mul($bm_mul(vu, delta), $bm_sub(vl, $bm_div($bm_mul(g, delta), 2))));\n            } else {\n                $bm_rt = value;\n            }\n        } else\n            $bm_rt = value;\n    } else {\n        $bm_rt = value;\n    }\n} catch (err) {\n    $bm_rt = value;\n}"
        },
        a: { a: 0, k: [140.061, 140.061, 0], ix: 1, l: 2 },
        s: {
          a: 1,
          k: [
            {
              i: { x: [0.667, 0.667, 0.667], y: [1, 1, 1] },
              o: { x: [0.167, 0.167, 0.167], y: [0.167, 0.167, 1.01] },
              t: 10,
              s: [0, 0, 100]
            },
            { t: 20, s: [140, 140, 100] }
          ],
          ix: 6,
          l: 2,
          x: "var $bm_rt;\nvar scaleInertialBounce, scaleBounceBack, n, n, t, t, v, amp, freq, decay, v, amp, freq, decay, e, g, nMax, e, g, nMax, n, n, t, v, vl, vu, vu, tCur, segDur, tNext, nb, delta;\nscaleInertialBounce = effect('Bounce & Drop - ukramedia.com')(16);\nscaleBounceBack = effect('Bounce & Drop - ukramedia.com')(17);\ntry {\n    if (scaleInertialBounce == 1) {\n        $bm_rt = n = 0;\n        if (numKeys > 0) {\n            $bm_rt = n = nearestKey(time).index;\n            if (key(n).time > time) {\n                n--;\n            }\n        }\n        if (n == 0) {\n            $bm_rt = t = 0;\n        } else {\n            $bm_rt = t = $bm_sub(time, key(n).time);\n        }\n        if (effect('Bounce & Drop - ukramedia.com')(58) == 1) {\n            if (n > 0 && t < 1) {\n                v = velocityAtTime($bm_sub(key(n).time, $bm_div(thisComp.frameDuration, 10)));\n                amp = effect('Bounce & Drop - ukramedia.com')(59);\n                freq = effect('Bounce & Drop - ukramedia.com')(60);\n                decay = effect('Bounce & Drop - ukramedia.com')(61);\n                $bm_rt = $bm_sum(value, $bm_div($bm_mul($bm_mul(v, amp), Math.sin($bm_mul($bm_mul($bm_mul(freq, t), 2), Math.PI))), Math.exp($bm_mul(decay, t))));\n            } else {\n                $bm_rt = value;\n            }\n        } else {\n            if (n > 0 && t < 1) {\n                v = velocityAtTime($bm_sub(key(n).time, $bm_div(thisComp.frameDuration, 10)));\n                amp = effect('Bounce & Drop - ukramedia.com')(19);\n                freq = effect('Bounce & Drop - ukramedia.com')(20);\n                decay = effect('Bounce & Drop - ukramedia.com')(21);\n                $bm_rt = $bm_sum(value, $bm_div($bm_mul($bm_mul(v, amp), Math.sin($bm_mul($bm_mul($bm_mul(freq, t), 2), Math.PI))), Math.exp($bm_mul(decay, t))));\n            } else {\n                $bm_rt = value;\n            }\n        }\n    } else if (scaleBounceBack == 1) {\n        if (effect('Bounce & Drop - ukramedia.com')(64) == 1) {\n            e = effect('Bounce & Drop - ukramedia.com')(65);\n            g = effect('Bounce & Drop - ukramedia.com')(66);\n            nMax = effect('Bounce & Drop - ukramedia.com')(67);\n        } else {\n            e = effect('Bounce & Drop - ukramedia.com')(24);\n            g = effect('Bounce & Drop - ukramedia.com')(25);\n            nMax = effect('Bounce & Drop - ukramedia.com')(26);\n        }\n        $bm_rt = n = 0;\n        if (numKeys > 0) {\n            $bm_rt = n = nearestKey(time).index;\n            if (key(n).time > time)\n                n--;\n        }\n        if (n > 0) {\n            t = $bm_sub(time, key(n).time);\n            v = $bm_mul($bm_neg(velocityAtTime($bm_sub(key(n).time, 0.001))), e);\n            vl = length(v);\n            if ($bm_isInstanceOfArray(value)) {\n                vu = vl > 0 ? normalize(v) : [\n                    0,\n                    0,\n                    0\n                ];\n            } else {\n                vu = v < 0 ? -1 : 1;\n            }\n            tCur = 0;\n            segDur = $bm_div($bm_mul(2, vl), g);\n            tNext = segDur;\n            nb = 1;\n            while (tNext < t && nb <= nMax) {\n                vl *= e;\n                segDur *= e;\n                tCur = tNext;\n                tNext = $bm_sum(tNext, segDur);\n                nb++;\n            }\n            if (nb <= nMax) {\n                delta = $bm_sub(t, tCur);\n                $bm_rt = $bm_sum(value, $bm_mul($bm_mul(vu, delta), $bm_sub(vl, $bm_div($bm_mul(g, delta), 2))));\n            } else {\n                $bm_rt = value;\n            }\n        } else\n            $bm_rt = value;\n    } else {\n        $bm_rt = value;\n    }\n} catch (err) {\n    $bm_rt = value;\n}"
        }
      },
      ao: 0,
      ef: [
        {
          ty: 5,
          nm: "Bounce & Drop - ukramedia.com",
          np: 70,
          mn: "Pseudo/animationControl",
          ix: 1,
          en: 1,
          ef: [
            { ty: 6, nm: "Position", mn: "Pseudo/animationControl-0001", ix: 1, v: 0 },
            {
              ty: 7,
              nm: "Enable Inertial Bounce",
              mn: "Pseudo/animationControl-0002",
              ix: 2,
              v: { a: 0, k: 0, ix: 2 }
            },
            {
              ty: 7,
              nm: "Enable Bounce Back",
              mn: "Pseudo/animationControl-0003",
              ix: 3,
              v: { a: 0, k: 0, ix: 3 }
            },
            {
              ty: 6,
              nm: "Inertial Bounce Options",
              mn: "Pseudo/animationControl-0004",
              ix: 4,
              v: 0
            },
            {
              ty: 0,
              nm: "Amplitude",
              mn: "Pseudo/animationControl-0005",
              ix: 5,
              v: { a: 0, k: 0.05, ix: 5 }
            },
            {
              ty: 0,
              nm: "Frequency",
              mn: "Pseudo/animationControl-0006",
              ix: 6,
              v: { a: 0, k: 4, ix: 6 }
            },
            {
              ty: 0,
              nm: "Decay",
              mn: "Pseudo/animationControl-0007",
              ix: 7,
              v: { a: 0, k: 8, ix: 7 }
            },
            { ty: 6, nm: "", mn: "Pseudo/animationControl-0008", ix: 8, v: 0 },
            {
              ty: 6,
              nm: "Bounce Back Options",
              mn: "Pseudo/animationControl-0009",
              ix: 9,
              v: 0
            },
            {
              ty: 0,
              nm: "Elasticity",
              mn: "Pseudo/animationControl-0010",
              ix: 10,
              v: { a: 0, k: 0.7, ix: 10 }
            },
            {
              ty: 0,
              nm: "Gravity",
              mn: "Pseudo/animationControl-0011",
              ix: 11,
              v: { a: 0, k: 5e3, ix: 11 }
            },
            {
              ty: 0,
              nm: "nMax",
              mn: "Pseudo/animationControl-0012",
              ix: 12,
              v: { a: 0, k: 9, ix: 12 }
            },
            { ty: 6, nm: "", mn: "Pseudo/animationControl-0013", ix: 13, v: 0 },
            { ty: 6, nm: "", mn: "Pseudo/animationControl-0014", ix: 14, v: 0 },
            { ty: 6, nm: "Scale", mn: "Pseudo/animationControl-0015", ix: 15, v: 0 },
            {
              ty: 7,
              nm: "Enable Inertial Bounce",
              mn: "Pseudo/animationControl-0016",
              ix: 16,
              v: { a: 0, k: 1, ix: 16 }
            },
            {
              ty: 7,
              nm: "Enable Bounce Back",
              mn: "Pseudo/animationControl-0017",
              ix: 17,
              v: { a: 0, k: 0, ix: 17 }
            },
            {
              ty: 6,
              nm: "Inertial Bounce Options",
              mn: "Pseudo/animationControl-0018",
              ix: 18,
              v: 0
            },
            {
              ty: 0,
              nm: "Amplitude",
              mn: "Pseudo/animationControl-0019",
              ix: 19,
              v: { a: 0, k: 0.8, ix: 19 }
            },
            {
              ty: 0,
              nm: "Frequency",
              mn: "Pseudo/animationControl-0020",
              ix: 20,
              v: { a: 0, k: 4, ix: 20 }
            },
            {
              ty: 0,
              nm: "Decay",
              mn: "Pseudo/animationControl-0021",
              ix: 21,
              v: { a: 0, k: 8, ix: 21 }
            },
            { ty: 6, nm: "", mn: "Pseudo/animationControl-0022", ix: 22, v: 0 },
            {
              ty: 6,
              nm: "Bounce Back Options",
              mn: "Pseudo/animationControl-0023",
              ix: 23,
              v: 0
            },
            {
              ty: 0,
              nm: "Elasticity",
              mn: "Pseudo/animationControl-0024",
              ix: 24,
              v: { a: 0, k: 0.7, ix: 24 }
            },
            {
              ty: 0,
              nm: "Gravity",
              mn: "Pseudo/animationControl-0025",
              ix: 25,
              v: { a: 0, k: 5e3, ix: 25 }
            },
            {
              ty: 0,
              nm: "nMax",
              mn: "Pseudo/animationControl-0026",
              ix: 26,
              v: { a: 0, k: 9, ix: 26 }
            },
            { ty: 6, nm: "", mn: "Pseudo/animationControl-0027", ix: 27, v: 0 },
            { ty: 6, nm: "", mn: "Pseudo/animationControl-0028", ix: 28, v: 0 },
            { ty: 6, nm: "Rotation", mn: "Pseudo/animationControl-0029", ix: 29, v: 0 },
            {
              ty: 7,
              nm: "Enable Inertial Bounce",
              mn: "Pseudo/animationControl-0030",
              ix: 30,
              v: { a: 0, k: 0, ix: 30 }
            },
            {
              ty: 7,
              nm: "Enable Bounce Back",
              mn: "Pseudo/animationControl-0031",
              ix: 31,
              v: { a: 0, k: 0, ix: 31 }
            },
            {
              ty: 6,
              nm: "Inertial Bounce Options",
              mn: "Pseudo/animationControl-0032",
              ix: 32,
              v: 0
            },
            {
              ty: 0,
              nm: "Amplitude",
              mn: "Pseudo/animationControl-0033",
              ix: 33,
              v: { a: 0, k: 0.05, ix: 33 }
            },
            {
              ty: 0,
              nm: "Frequency",
              mn: "Pseudo/animationControl-0034",
              ix: 34,
              v: { a: 0, k: 4, ix: 34 }
            },
            {
              ty: 0,
              nm: "Decay",
              mn: "Pseudo/animationControl-0035",
              ix: 35,
              v: { a: 0, k: 8, ix: 35 }
            },
            { ty: 6, nm: "", mn: "Pseudo/animationControl-0036", ix: 36, v: 0 },
            {
              ty: 6,
              nm: "Bounce Back Options",
              mn: "Pseudo/animationControl-0037",
              ix: 37,
              v: 0
            },
            {
              ty: 0,
              nm: "Elasticity",
              mn: "Pseudo/animationControl-0038",
              ix: 38,
              v: { a: 0, k: 0.7, ix: 38 }
            },
            {
              ty: 0,
              nm: "Gravity",
              mn: "Pseudo/animationControl-0039",
              ix: 39,
              v: { a: 0, k: 5e3, ix: 39 }
            },
            {
              ty: 0,
              nm: "nMax",
              mn: "Pseudo/animationControl-0040",
              ix: 40,
              v: { a: 0, k: 9, ix: 40 }
            },
            { ty: 6, nm: "", mn: "Pseudo/animationControl-0041", ix: 41, v: 0 },
            { ty: 6, nm: "", mn: "Pseudo/animationControl-0042", ix: 42, v: 0 },
            { ty: 6, nm: "Opacity", mn: "Pseudo/animationControl-0043", ix: 43, v: 0 },
            {
              ty: 7,
              nm: "Enable Inertial Bounce",
              mn: "Pseudo/animationControl-0044",
              ix: 44,
              v: { a: 0, k: 0, ix: 44 }
            },
            {
              ty: 7,
              nm: "Enable Bounce Back",
              mn: "Pseudo/animationControl-0045",
              ix: 45,
              v: { a: 0, k: 0, ix: 45 }
            },
            {
              ty: 6,
              nm: "Inertial Bounce Options",
              mn: "Pseudo/animationControl-0046",
              ix: 46,
              v: 0
            },
            {
              ty: 0,
              nm: "Amplitude",
              mn: "Pseudo/animationControl-0047",
              ix: 47,
              v: { a: 0, k: 0.05, ix: 47 }
            },
            {
              ty: 0,
              nm: "Frequency",
              mn: "Pseudo/animationControl-0048",
              ix: 48,
              v: { a: 0, k: 4, ix: 48 }
            },
            {
              ty: 0,
              nm: "Decay",
              mn: "Pseudo/animationControl-0049",
              ix: 49,
              v: { a: 0, k: 8, ix: 49 }
            },
            { ty: 6, nm: "", mn: "Pseudo/animationControl-0050", ix: 50, v: 0 },
            {
              ty: 6,
              nm: "Bounce Back Options",
              mn: "Pseudo/animationControl-0051",
              ix: 51,
              v: 0
            },
            {
              ty: 0,
              nm: "Elasticity",
              mn: "Pseudo/animationControl-0052",
              ix: 52,
              v: { a: 0, k: 0.7, ix: 52 }
            },
            {
              ty: 0,
              nm: "Gravity",
              mn: "Pseudo/animationControl-0053",
              ix: 53,
              v: { a: 0, k: 5e3, ix: 53 }
            },
            {
              ty: 0,
              nm: "nMax",
              mn: "Pseudo/animationControl-0054",
              ix: 54,
              v: { a: 0, k: 9, ix: 54 }
            },
            { ty: 6, nm: "", mn: "Pseudo/animationControl-0055", ix: 55, v: 0 },
            { ty: 6, nm: "", mn: "Pseudo/animationControl-0056", ix: 56, v: 0 },
            {
              ty: 6,
              nm: "Global Inertial Bounce Options",
              mn: "Pseudo/animationControl-0057",
              ix: 57,
              v: 0
            },
            {
              ty: 7,
              nm: "Enable Global Inertial Bounce",
              mn: "Pseudo/animationControl-0058",
              ix: 58,
              v: { a: 0, k: 0, ix: 58 }
            },
            {
              ty: 0,
              nm: "Amplitude",
              mn: "Pseudo/animationControl-0059",
              ix: 59,
              v: { a: 0, k: 0.05, ix: 59 }
            },
            {
              ty: 0,
              nm: "Frequency",
              mn: "Pseudo/animationControl-0060",
              ix: 60,
              v: { a: 0, k: 4, ix: 60 }
            },
            {
              ty: 0,
              nm: "Decay",
              mn: "Pseudo/animationControl-0061",
              ix: 61,
              v: { a: 0, k: 8, ix: 61 }
            },
            { ty: 6, nm: "", mn: "Pseudo/animationControl-0062", ix: 62, v: 0 },
            {
              ty: 6,
              nm: "Global Bounce Back Options",
              mn: "Pseudo/animationControl-0063",
              ix: 63,
              v: 0
            },
            {
              ty: 7,
              nm: "Enable Global Bounce Back",
              mn: "Pseudo/animationControl-0064",
              ix: 64,
              v: { a: 0, k: 0, ix: 64 }
            },
            {
              ty: 0,
              nm: "Elasticity",
              mn: "Pseudo/animationControl-0065",
              ix: 65,
              v: { a: 0, k: 0.7, ix: 65 }
            },
            {
              ty: 0,
              nm: "Gravity",
              mn: "Pseudo/animationControl-0066",
              ix: 66,
              v: { a: 0, k: 5e3, ix: 66 }
            },
            {
              ty: 0,
              nm: "nMax",
              mn: "Pseudo/animationControl-0067",
              ix: 67,
              v: { a: 0, k: 9, ix: 67 }
            },
            { ty: 6, nm: "", mn: "Pseudo/animationControl-0068", ix: 68, v: 0 }
          ]
        }
      ],
      shapes: [
        {
          ty: "gr",
          it: [
            {
              ind: 0,
              ty: "sh",
              ix: 1,
              ks: {
                a: 0,
                k: {
                  i: [
                    [139.811, -77.215],
                    [77.216, 139.811],
                    [-139.811, 77.215],
                    [-77.215, -139.811]
                  ],
                  o: [
                    [139.811, 77.215],
                    [-77.215, 139.811],
                    [-139.811, -77.215],
                    [77.216, -139.811]
                  ],
                  v: [
                    [139.811, 0],
                    [0, 139.811],
                    [-139.811, 0],
                    [0, -139.811]
                  ],
                  c: true
                },
                ix: 2
              },
              nm: "Path 1",
              mn: "ADBE Vector Shape - Group",
              hd: false,
              _render: true
            },
            {
              ty: "fl",
              c: { a: 0, k: [1, 0.5412, 0.4902, 1], ix: 4 },
              o: { a: 0, k: 100, ix: 5 },
              r: 1,
              bm: 0,
              nm: "Fill 1",
              mn: "ADBE Vector Graphic - Fill",
              hd: false,
              _render: true
            },
            {
              ty: "tr",
              p: { a: 0, k: [140.061, 140.061], ix: 2 },
              a: { a: 0, k: [0, 0], ix: 1 },
              s: { a: 0, k: [100, 100], ix: 3 },
              r: { a: 0, k: 0, ix: 6 },
              o: { a: 0, k: 100, ix: 7 },
              sk: { a: 0, k: 0, ix: 4 },
              sa: { a: 0, k: 0, ix: 5 },
              nm: "Transform",
              _render: true
            }
          ],
          nm: "Group 1",
          np: 2,
          cix: 2,
          bm: 0,
          ix: 1,
          mn: "ADBE Vector Group",
          hd: false,
          _render: true
        }
      ],
      ip: 10,
      op: 360,
      st: 0,
      bm: 0,
      completed: true
    },
    {
      ddd: 0,
      ind: 5,
      ty: 4,
      nm: "Circle 1",
      sr: 1,
      ks: {
        o: {
          a: 1,
          k: [
            {
              i: { x: [0.667], y: [1] },
              o: { x: [0.167], y: [0.167] },
              t: 41.25,
              s: [50]
            },
            { t: 55, s: [0] }
          ],
          ix: 11,
          x: "var $bm_rt;\nvar opacityInertialBounce, opacityBounceBack, n, n, t, t, v, amp, freq, decay, v, amp, freq, decay, e, g, nMax, e, g, nMax, n, n, t, v, vl, vu, vu, tCur, segDur, tNext, nb, delta;\nopacityInertialBounce = effect('Bounce & Drop - ukramedia.com')(44);\nopacityBounceBack = effect('Bounce & Drop - ukramedia.com')(45);\ntry {\n    if (opacityInertialBounce == 1) {\n        $bm_rt = n = 0;\n        if (numKeys > 0) {\n            $bm_rt = n = nearestKey(time).index;\n            if (key(n).time > time) {\n                n--;\n            }\n        }\n        if (n == 0) {\n            $bm_rt = t = 0;\n        } else {\n            $bm_rt = t = $bm_sub(time, key(n).time);\n        }\n        if (effect('Bounce & Drop - ukramedia.com')(58) == 1) {\n            if (n > 0 && t < 1) {\n                v = velocityAtTime($bm_sub(key(n).time, $bm_div(thisComp.frameDuration, 10)));\n                amp = effect('Bounce & Drop - ukramedia.com')(59);\n                freq = effect('Bounce & Drop - ukramedia.com')(60);\n                decay = effect('Bounce & Drop - ukramedia.com')(61);\n                $bm_rt = $bm_sum(value, $bm_div($bm_mul($bm_mul(v, amp), Math.sin($bm_mul($bm_mul($bm_mul(freq, t), 2), Math.PI))), Math.exp($bm_mul(decay, t))));\n            } else {\n                $bm_rt = value;\n            }\n        } else {\n            if (n > 0 && t < 1) {\n                v = velocityAtTime($bm_sub(key(n).time, $bm_div(thisComp.frameDuration, 10)));\n                amp = effect('Bounce & Drop - ukramedia.com')(47);\n                freq = effect('Bounce & Drop - ukramedia.com')(48);\n                decay = effect('Bounce & Drop - ukramedia.com')(49);\n                $bm_rt = $bm_sum(value, $bm_div($bm_mul($bm_mul(v, amp), Math.sin($bm_mul($bm_mul($bm_mul(freq, t), 2), Math.PI))), Math.exp($bm_mul(decay, t))));\n            } else {\n                $bm_rt = value;\n            }\n        }\n    } else if (opacityBounceBack == 1) {\n        if (effect('Bounce & Drop - ukramedia.com')(64) == 1) {\n            e = effect('Bounce & Drop - ukramedia.com')(65);\n            g = effect('Bounce & Drop - ukramedia.com')(66);\n            nMax = effect('Bounce & Drop - ukramedia.com')(67);\n        } else {\n            e = effect('Bounce & Drop - ukramedia.com')(52);\n            g = effect('Bounce & Drop - ukramedia.com')(53);\n            nMax = effect('Bounce & Drop - ukramedia.com')(54);\n        }\n        $bm_rt = n = 0;\n        if (numKeys > 0) {\n            $bm_rt = n = nearestKey(time).index;\n            if (key(n).time > time)\n                n--;\n        }\n        if (n > 0) {\n            t = $bm_sub(time, key(n).time);\n            v = $bm_mul($bm_neg(velocityAtTime($bm_sub(key(n).time, 0.001))), e);\n            vl = length(v);\n            if ($bm_isInstanceOfArray(value)) {\n                vu = vl > 0 ? normalize(v) : [\n                    0,\n                    0,\n                    0\n                ];\n            } else {\n                vu = v < 0 ? -1 : 1;\n            }\n            tCur = 0;\n            segDur = $bm_div($bm_mul(2, vl), g);\n            tNext = segDur;\n            nb = 1;\n            while (tNext < t && nb <= nMax) {\n                vl *= e;\n                segDur *= e;\n                tCur = tNext;\n                tNext = $bm_sum(tNext, segDur);\n                nb++;\n            }\n            if (nb <= nMax) {\n                delta = $bm_sub(t, tCur);\n                $bm_rt = $bm_sum(value, $bm_mul($bm_mul(vu, delta), $bm_sub(vl, $bm_div($bm_mul(g, delta), 2))));\n            } else {\n                $bm_rt = value;\n            }\n        } else\n            $bm_rt = value;\n    } else {\n        $bm_rt = value;\n    }\n} catch (err) {\n    $bm_rt = value;\n}"
        },
        r: {
          a: 0,
          k: 0,
          ix: 10,
          x: "var $bm_rt;\nvar rotationInertialBounce, rotationBounceBack, n, n, t, t, v, amp, freq, decay, v, amp, freq, decay, e, g, nMax, e, g, nMax, n, n, t, v, vl, vu, vu, tCur, segDur, tNext, nb, delta;\nrotationInertialBounce = effect('Bounce & Drop - ukramedia.com')(30);\nrotationBounceBack = effect('Bounce & Drop - ukramedia.com')(31);\ntry {\n    if (rotationInertialBounce == 1) {\n        $bm_rt = n = 0;\n        if (numKeys > 0) {\n            $bm_rt = n = nearestKey(time).index;\n            if (key(n).time > time) {\n                n--;\n            }\n        }\n        if (n == 0) {\n            $bm_rt = t = 0;\n        } else {\n            $bm_rt = t = $bm_sub(time, key(n).time);\n        }\n        if (effect('Bounce & Drop - ukramedia.com')(58) == 1) {\n            if (n > 0 && t < 1) {\n                v = velocityAtTime($bm_sub(key(n).time, $bm_div(thisComp.frameDuration, 10)));\n                amp = effect('Bounce & Drop - ukramedia.com')(59);\n                freq = effect('Bounce & Drop - ukramedia.com')(60);\n                decay = effect('Bounce & Drop - ukramedia.com')(61);\n                $bm_rt = $bm_sum(value, $bm_div($bm_mul($bm_mul(v, amp), Math.sin($bm_mul($bm_mul($bm_mul(freq, t), 2), Math.PI))), Math.exp($bm_mul(decay, t))));\n            } else {\n                $bm_rt = value;\n            }\n        } else {\n            if (n > 0 && t < 1) {\n                v = velocityAtTime($bm_sub(key(n).time, $bm_div(thisComp.frameDuration, 10)));\n                amp = effect('Bounce & Drop - ukramedia.com')(33);\n                freq = effect('Bounce & Drop - ukramedia.com')(34);\n                decay = effect('Bounce & Drop - ukramedia.com')(35);\n                $bm_rt = $bm_sum(value, $bm_div($bm_mul($bm_mul(v, amp), Math.sin($bm_mul($bm_mul($bm_mul(freq, t), 2), Math.PI))), Math.exp($bm_mul(decay, t))));\n            } else {\n                $bm_rt = value;\n            }\n        }\n    } else if (rotationBounceBack == 1) {\n        if (effect('Bounce & Drop - ukramedia.com')(64) == 1) {\n            e = effect('Bounce & Drop - ukramedia.com')(65);\n            g = effect('Bounce & Drop - ukramedia.com')(66);\n            nMax = effect('Bounce & Drop - ukramedia.com')(67);\n        } else {\n            e = effect('Bounce & Drop - ukramedia.com')(38);\n            g = effect('Bounce & Drop - ukramedia.com')(39);\n            nMax = effect('Bounce & Drop - ukramedia.com')(40);\n        }\n        $bm_rt = n = 0;\n        if (numKeys > 0) {\n            $bm_rt = n = nearestKey(time).index;\n            if (key(n).time > time)\n                n--;\n        }\n        if (n > 0) {\n            t = $bm_sub(time, key(n).time);\n            v = $bm_mul($bm_neg(velocityAtTime($bm_sub(key(n).time, 0.001))), e);\n            vl = length(v);\n            if ($bm_isInstanceOfArray(value)) {\n                vu = vl > 0 ? normalize(v) : [\n                    0,\n                    0,\n                    0\n                ];\n            } else {\n                vu = v < 0 ? -1 : 1;\n            }\n            tCur = 0;\n            segDur = $bm_div($bm_mul(2, vl), g);\n            tNext = segDur;\n            nb = 1;\n            while (tNext < t && nb <= nMax) {\n                vl *= e;\n                segDur *= e;\n                tCur = tNext;\n                tNext = $bm_sum(tNext, segDur);\n                nb++;\n            }\n            if (nb <= nMax) {\n                delta = $bm_sub(t, tCur);\n                $bm_rt = $bm_sum(value, $bm_mul($bm_mul(vu, delta), $bm_sub(vl, $bm_div($bm_mul(g, delta), 2))));\n            } else {\n                $bm_rt = value;\n            }\n        } else\n            $bm_rt = value;\n    } else {\n        $bm_rt = value;\n    }\n} catch (err) {\n    $bm_rt = value;\n}"
        },
        p: {
          a: 0,
          k: [256, 256, 0],
          ix: 2,
          l: 2,
          x: "var $bm_rt;\nvar positionInertialBounce, positionBounceBack, n, n, t, t, v, amp, freq, decay, v, amp, freq, decay, e, g, nMax, e, g, nMax, n, n, t, v, vl, vu, vu, tCur, segDur, tNext, nb, delta;\npositionInertialBounce = effect('Bounce & Drop - ukramedia.com')(2);\npositionBounceBack = effect('Bounce & Drop - ukramedia.com')(3);\ntry {\n    if (positionInertialBounce == 1) {\n        $bm_rt = n = 0;\n        if (numKeys > 0) {\n            $bm_rt = n = nearestKey(time).index;\n            if (key(n).time > time) {\n                n--;\n            }\n        }\n        if (n == 0) {\n            $bm_rt = t = 0;\n        } else {\n            $bm_rt = t = $bm_sub(time, key(n).time);\n        }\n        if (effect('Bounce & Drop - ukramedia.com')(58) == 1) {\n            if (n > 0 && t < 1) {\n                v = velocityAtTime($bm_sub(key(n).time, $bm_div(thisComp.frameDuration, 10)));\n                amp = effect('Bounce & Drop - ukramedia.com')(59);\n                freq = effect('Bounce & Drop - ukramedia.com')(60);\n                decay = effect('Bounce & Drop - ukramedia.com')(61);\n                $bm_rt = $bm_sum(value, $bm_div($bm_mul($bm_mul(v, amp), Math.sin($bm_mul($bm_mul($bm_mul(freq, t), 2), Math.PI))), Math.exp($bm_mul(decay, t))));\n            } else {\n                $bm_rt = value;\n            }\n        } else {\n            if (n > 0 && t < 1) {\n                v = velocityAtTime($bm_sub(key(n).time, $bm_div(thisComp.frameDuration, 10)));\n                amp = effect('Bounce & Drop - ukramedia.com')(5);\n                freq = effect('Bounce & Drop - ukramedia.com')(6);\n                decay = effect('Bounce & Drop - ukramedia.com')(7);\n                $bm_rt = $bm_sum(value, $bm_div($bm_mul($bm_mul(v, amp), Math.sin($bm_mul($bm_mul($bm_mul(freq, t), 2), Math.PI))), Math.exp($bm_mul(decay, t))));\n            } else {\n                $bm_rt = value;\n            }\n        }\n    } else if (positionBounceBack == 1) {\n        if (effect('Bounce & Drop - ukramedia.com')(64) == 1) {\n            e = effect('Bounce & Drop - ukramedia.com')(65);\n            g = effect('Bounce & Drop - ukramedia.com')(66);\n            nMax = effect('Bounce & Drop - ukramedia.com')(67);\n        } else {\n            e = effect('Bounce & Drop - ukramedia.com')(10);\n            g = effect('Bounce & Drop - ukramedia.com')(11);\n            nMax = effect('Bounce & Drop - ukramedia.com')(12);\n        }\n        $bm_rt = n = 0;\n        if (numKeys > 0) {\n            $bm_rt = n = nearestKey(time).index;\n            if (key(n).time > time)\n                n--;\n        }\n        if (n > 0) {\n            t = $bm_sub(time, key(n).time);\n            v = $bm_mul($bm_neg(velocityAtTime($bm_sub(key(n).time, 0.001))), e);\n            vl = length(v);\n            if ($bm_isInstanceOfArray(value)) {\n                vu = vl > 0 ? normalize(v) : [\n                    0,\n                    0,\n                    0\n                ];\n            } else {\n                vu = v < 0 ? -1 : 1;\n            }\n            tCur = 0;\n            segDur = $bm_div($bm_mul(2, vl), g);\n            tNext = segDur;\n            nb = 1;\n            while (tNext < t && nb <= nMax) {\n                vl *= e;\n                segDur *= e;\n                tCur = tNext;\n                tNext = $bm_sum(tNext, segDur);\n                nb++;\n            }\n            if (nb <= nMax) {\n                delta = $bm_sub(t, tCur);\n                $bm_rt = $bm_sum(value, $bm_mul($bm_mul(vu, delta), $bm_sub(vl, $bm_div($bm_mul(g, delta), 2))));\n            } else {\n                $bm_rt = value;\n            }\n        } else\n            $bm_rt = value;\n    } else {\n        $bm_rt = value;\n    }\n} catch (err) {\n    $bm_rt = value;\n}"
        },
        a: { a: 0, k: [140.061, 140.061, 0], ix: 1, l: 2 },
        s: {
          a: 1,
          k: [
            {
              i: { x: [0.667, 0.667, 0.667], y: [1, 1, 1] },
              o: { x: [0.167, 0.167, 0.167], y: [0.167, 0.167, 16.794] },
              t: 0,
              s: [0, 0, 100]
            },
            {
              i: { x: [0.667, 0.667, 0.667], y: [1, 1, 1] },
              o: { x: [0.167, 0.167, 0.167], y: [0.167, 0.167, -0.38] },
              t: 10,
              s: [132, 132, 100]
            },
            {
              i: { x: [0.667, 0.667, 0.667], y: [1, 1, 1] },
              o: { x: [0.167, 0.167, 0.167], y: [0.167, 0.167, -0.21] },
              t: 35,
              s: [130, 130, 100]
            },
            { t: 55, s: [175, 175, 100] }
          ],
          ix: 6,
          l: 2,
          x: "var $bm_rt;\nvar scaleInertialBounce, scaleBounceBack, n, n, t, t, v, amp, freq, decay, v, amp, freq, decay, e, g, nMax, e, g, nMax, n, n, t, v, vl, vu, vu, tCur, segDur, tNext, nb, delta;\nscaleInertialBounce = effect('Bounce & Drop - ukramedia.com')(16);\nscaleBounceBack = effect('Bounce & Drop - ukramedia.com')(17);\ntry {\n    if (scaleInertialBounce == 1) {\n        $bm_rt = n = 0;\n        if (numKeys > 0) {\n            $bm_rt = n = nearestKey(time).index;\n            if (key(n).time > time) {\n                n--;\n            }\n        }\n        if (n == 0) {\n            $bm_rt = t = 0;\n        } else {\n            $bm_rt = t = $bm_sub(time, key(n).time);\n        }\n        if (effect('Bounce & Drop - ukramedia.com')(58) == 1) {\n            if (n > 0 && t < 1) {\n                v = velocityAtTime($bm_sub(key(n).time, $bm_div(thisComp.frameDuration, 10)));\n                amp = effect('Bounce & Drop - ukramedia.com')(59);\n                freq = effect('Bounce & Drop - ukramedia.com')(60);\n                decay = effect('Bounce & Drop - ukramedia.com')(61);\n                $bm_rt = $bm_sum(value, $bm_div($bm_mul($bm_mul(v, amp), Math.sin($bm_mul($bm_mul($bm_mul(freq, t), 2), Math.PI))), Math.exp($bm_mul(decay, t))));\n            } else {\n                $bm_rt = value;\n            }\n        } else {\n            if (n > 0 && t < 1) {\n                v = velocityAtTime($bm_sub(key(n).time, $bm_div(thisComp.frameDuration, 10)));\n                amp = effect('Bounce & Drop - ukramedia.com')(19);\n                freq = effect('Bounce & Drop - ukramedia.com')(20);\n                decay = effect('Bounce & Drop - ukramedia.com')(21);\n                $bm_rt = $bm_sum(value, $bm_div($bm_mul($bm_mul(v, amp), Math.sin($bm_mul($bm_mul($bm_mul(freq, t), 2), Math.PI))), Math.exp($bm_mul(decay, t))));\n            } else {\n                $bm_rt = value;\n            }\n        }\n    } else if (scaleBounceBack == 1) {\n        if (effect('Bounce & Drop - ukramedia.com')(64) == 1) {\n            e = effect('Bounce & Drop - ukramedia.com')(65);\n            g = effect('Bounce & Drop - ukramedia.com')(66);\n            nMax = effect('Bounce & Drop - ukramedia.com')(67);\n        } else {\n            e = effect('Bounce & Drop - ukramedia.com')(24);\n            g = effect('Bounce & Drop - ukramedia.com')(25);\n            nMax = effect('Bounce & Drop - ukramedia.com')(26);\n        }\n        $bm_rt = n = 0;\n        if (numKeys > 0) {\n            $bm_rt = n = nearestKey(time).index;\n            if (key(n).time > time)\n                n--;\n        }\n        if (n > 0) {\n            t = $bm_sub(time, key(n).time);\n            v = $bm_mul($bm_neg(velocityAtTime($bm_sub(key(n).time, 0.001))), e);\n            vl = length(v);\n            if ($bm_isInstanceOfArray(value)) {\n                vu = vl > 0 ? normalize(v) : [\n                    0,\n                    0,\n                    0\n                ];\n            } else {\n                vu = v < 0 ? -1 : 1;\n            }\n            tCur = 0;\n            segDur = $bm_div($bm_mul(2, vl), g);\n            tNext = segDur;\n            nb = 1;\n            while (tNext < t && nb <= nMax) {\n                vl *= e;\n                segDur *= e;\n                tCur = tNext;\n                tNext = $bm_sum(tNext, segDur);\n                nb++;\n            }\n            if (nb <= nMax) {\n                delta = $bm_sub(t, tCur);\n                $bm_rt = $bm_sum(value, $bm_mul($bm_mul(vu, delta), $bm_sub(vl, $bm_div($bm_mul(g, delta), 2))));\n            } else {\n                $bm_rt = value;\n            }\n        } else\n            $bm_rt = value;\n    } else {\n        $bm_rt = value;\n    }\n} catch (err) {\n    $bm_rt = value;\n}"
        }
      },
      ao: 0,
      ef: [
        {
          ty: 5,
          nm: "Bounce & Drop - ukramedia.com",
          np: 70,
          mn: "Pseudo/animationControl",
          ix: 1,
          en: 1,
          ef: [
            { ty: 6, nm: "Position", mn: "Pseudo/animationControl-0001", ix: 1, v: 0 },
            {
              ty: 7,
              nm: "Enable Inertial Bounce",
              mn: "Pseudo/animationControl-0002",
              ix: 2,
              v: { a: 0, k: 0, ix: 2 }
            },
            {
              ty: 7,
              nm: "Enable Bounce Back",
              mn: "Pseudo/animationControl-0003",
              ix: 3,
              v: { a: 0, k: 0, ix: 3 }
            },
            {
              ty: 6,
              nm: "Inertial Bounce Options",
              mn: "Pseudo/animationControl-0004",
              ix: 4,
              v: 0
            },
            {
              ty: 0,
              nm: "Amplitude",
              mn: "Pseudo/animationControl-0005",
              ix: 5,
              v: { a: 0, k: 0.05, ix: 5 }
            },
            {
              ty: 0,
              nm: "Frequency",
              mn: "Pseudo/animationControl-0006",
              ix: 6,
              v: { a: 0, k: 4, ix: 6 }
            },
            {
              ty: 0,
              nm: "Decay",
              mn: "Pseudo/animationControl-0007",
              ix: 7,
              v: { a: 0, k: 8, ix: 7 }
            },
            { ty: 6, nm: "", mn: "Pseudo/animationControl-0008", ix: 8, v: 0 },
            {
              ty: 6,
              nm: "Bounce Back Options",
              mn: "Pseudo/animationControl-0009",
              ix: 9,
              v: 0
            },
            {
              ty: 0,
              nm: "Elasticity",
              mn: "Pseudo/animationControl-0010",
              ix: 10,
              v: { a: 0, k: 0.7, ix: 10 }
            },
            {
              ty: 0,
              nm: "Gravity",
              mn: "Pseudo/animationControl-0011",
              ix: 11,
              v: { a: 0, k: 5e3, ix: 11 }
            },
            {
              ty: 0,
              nm: "nMax",
              mn: "Pseudo/animationControl-0012",
              ix: 12,
              v: { a: 0, k: 9, ix: 12 }
            },
            { ty: 6, nm: "", mn: "Pseudo/animationControl-0013", ix: 13, v: 0 },
            { ty: 6, nm: "", mn: "Pseudo/animationControl-0014", ix: 14, v: 0 },
            { ty: 6, nm: "Scale", mn: "Pseudo/animationControl-0015", ix: 15, v: 0 },
            {
              ty: 7,
              nm: "Enable Inertial Bounce",
              mn: "Pseudo/animationControl-0016",
              ix: 16,
              v: { a: 0, k: 1, ix: 16 }
            },
            {
              ty: 7,
              nm: "Enable Bounce Back",
              mn: "Pseudo/animationControl-0017",
              ix: 17,
              v: { a: 0, k: 0, ix: 17 }
            },
            {
              ty: 6,
              nm: "Inertial Bounce Options",
              mn: "Pseudo/animationControl-0018",
              ix: 18,
              v: 0
            },
            {
              ty: 0,
              nm: "Amplitude",
              mn: "Pseudo/animationControl-0019",
              ix: 19,
              v: { a: 0, k: 0.8, ix: 19 }
            },
            {
              ty: 0,
              nm: "Frequency",
              mn: "Pseudo/animationControl-0020",
              ix: 20,
              v: { a: 0, k: 4, ix: 20 }
            },
            {
              ty: 0,
              nm: "Decay",
              mn: "Pseudo/animationControl-0021",
              ix: 21,
              v: { a: 0, k: 8, ix: 21 }
            },
            { ty: 6, nm: "", mn: "Pseudo/animationControl-0022", ix: 22, v: 0 },
            {
              ty: 6,
              nm: "Bounce Back Options",
              mn: "Pseudo/animationControl-0023",
              ix: 23,
              v: 0
            },
            {
              ty: 0,
              nm: "Elasticity",
              mn: "Pseudo/animationControl-0024",
              ix: 24,
              v: { a: 0, k: 0.7, ix: 24 }
            },
            {
              ty: 0,
              nm: "Gravity",
              mn: "Pseudo/animationControl-0025",
              ix: 25,
              v: { a: 0, k: 5e3, ix: 25 }
            },
            {
              ty: 0,
              nm: "nMax",
              mn: "Pseudo/animationControl-0026",
              ix: 26,
              v: { a: 0, k: 9, ix: 26 }
            },
            { ty: 6, nm: "", mn: "Pseudo/animationControl-0027", ix: 27, v: 0 },
            { ty: 6, nm: "", mn: "Pseudo/animationControl-0028", ix: 28, v: 0 },
            { ty: 6, nm: "Rotation", mn: "Pseudo/animationControl-0029", ix: 29, v: 0 },
            {
              ty: 7,
              nm: "Enable Inertial Bounce",
              mn: "Pseudo/animationControl-0030",
              ix: 30,
              v: { a: 0, k: 0, ix: 30 }
            },
            {
              ty: 7,
              nm: "Enable Bounce Back",
              mn: "Pseudo/animationControl-0031",
              ix: 31,
              v: { a: 0, k: 0, ix: 31 }
            },
            {
              ty: 6,
              nm: "Inertial Bounce Options",
              mn: "Pseudo/animationControl-0032",
              ix: 32,
              v: 0
            },
            {
              ty: 0,
              nm: "Amplitude",
              mn: "Pseudo/animationControl-0033",
              ix: 33,
              v: { a: 0, k: 0.05, ix: 33 }
            },
            {
              ty: 0,
              nm: "Frequency",
              mn: "Pseudo/animationControl-0034",
              ix: 34,
              v: { a: 0, k: 4, ix: 34 }
            },
            {
              ty: 0,
              nm: "Decay",
              mn: "Pseudo/animationControl-0035",
              ix: 35,
              v: { a: 0, k: 8, ix: 35 }
            },
            { ty: 6, nm: "", mn: "Pseudo/animationControl-0036", ix: 36, v: 0 },
            {
              ty: 6,
              nm: "Bounce Back Options",
              mn: "Pseudo/animationControl-0037",
              ix: 37,
              v: 0
            },
            {
              ty: 0,
              nm: "Elasticity",
              mn: "Pseudo/animationControl-0038",
              ix: 38,
              v: { a: 0, k: 0.7, ix: 38 }
            },
            {
              ty: 0,
              nm: "Gravity",
              mn: "Pseudo/animationControl-0039",
              ix: 39,
              v: { a: 0, k: 5e3, ix: 39 }
            },
            {
              ty: 0,
              nm: "nMax",
              mn: "Pseudo/animationControl-0040",
              ix: 40,
              v: { a: 0, k: 9, ix: 40 }
            },
            { ty: 6, nm: "", mn: "Pseudo/animationControl-0041", ix: 41, v: 0 },
            { ty: 6, nm: "", mn: "Pseudo/animationControl-0042", ix: 42, v: 0 },
            { ty: 6, nm: "Opacity", mn: "Pseudo/animationControl-0043", ix: 43, v: 0 },
            {
              ty: 7,
              nm: "Enable Inertial Bounce",
              mn: "Pseudo/animationControl-0044",
              ix: 44,
              v: { a: 0, k: 0, ix: 44 }
            },
            {
              ty: 7,
              nm: "Enable Bounce Back",
              mn: "Pseudo/animationControl-0045",
              ix: 45,
              v: { a: 0, k: 0, ix: 45 }
            },
            {
              ty: 6,
              nm: "Inertial Bounce Options",
              mn: "Pseudo/animationControl-0046",
              ix: 46,
              v: 0
            },
            {
              ty: 0,
              nm: "Amplitude",
              mn: "Pseudo/animationControl-0047",
              ix: 47,
              v: { a: 0, k: 0.05, ix: 47 }
            },
            {
              ty: 0,
              nm: "Frequency",
              mn: "Pseudo/animationControl-0048",
              ix: 48,
              v: { a: 0, k: 4, ix: 48 }
            },
            {
              ty: 0,
              nm: "Decay",
              mn: "Pseudo/animationControl-0049",
              ix: 49,
              v: { a: 0, k: 8, ix: 49 }
            },
            { ty: 6, nm: "", mn: "Pseudo/animationControl-0050", ix: 50, v: 0 },
            {
              ty: 6,
              nm: "Bounce Back Options",
              mn: "Pseudo/animationControl-0051",
              ix: 51,
              v: 0
            },
            {
              ty: 0,
              nm: "Elasticity",
              mn: "Pseudo/animationControl-0052",
              ix: 52,
              v: { a: 0, k: 0.7, ix: 52 }
            },
            {
              ty: 0,
              nm: "Gravity",
              mn: "Pseudo/animationControl-0053",
              ix: 53,
              v: { a: 0, k: 5e3, ix: 53 }
            },
            {
              ty: 0,
              nm: "nMax",
              mn: "Pseudo/animationControl-0054",
              ix: 54,
              v: { a: 0, k: 9, ix: 54 }
            },
            { ty: 6, nm: "", mn: "Pseudo/animationControl-0055", ix: 55, v: 0 },
            { ty: 6, nm: "", mn: "Pseudo/animationControl-0056", ix: 56, v: 0 },
            {
              ty: 6,
              nm: "Global Inertial Bounce Options",
              mn: "Pseudo/animationControl-0057",
              ix: 57,
              v: 0
            },
            {
              ty: 7,
              nm: "Enable Global Inertial Bounce",
              mn: "Pseudo/animationControl-0058",
              ix: 58,
              v: { a: 0, k: 0, ix: 58 }
            },
            {
              ty: 0,
              nm: "Amplitude",
              mn: "Pseudo/animationControl-0059",
              ix: 59,
              v: { a: 0, k: 0.05, ix: 59 }
            },
            {
              ty: 0,
              nm: "Frequency",
              mn: "Pseudo/animationControl-0060",
              ix: 60,
              v: { a: 0, k: 4, ix: 60 }
            },
            {
              ty: 0,
              nm: "Decay",
              mn: "Pseudo/animationControl-0061",
              ix: 61,
              v: { a: 0, k: 8, ix: 61 }
            },
            { ty: 6, nm: "", mn: "Pseudo/animationControl-0062", ix: 62, v: 0 },
            {
              ty: 6,
              nm: "Global Bounce Back Options",
              mn: "Pseudo/animationControl-0063",
              ix: 63,
              v: 0
            },
            {
              ty: 7,
              nm: "Enable Global Bounce Back",
              mn: "Pseudo/animationControl-0064",
              ix: 64,
              v: { a: 0, k: 0, ix: 64 }
            },
            {
              ty: 0,
              nm: "Elasticity",
              mn: "Pseudo/animationControl-0065",
              ix: 65,
              v: { a: 0, k: 0.7, ix: 65 }
            },
            {
              ty: 0,
              nm: "Gravity",
              mn: "Pseudo/animationControl-0066",
              ix: 66,
              v: { a: 0, k: 5e3, ix: 66 }
            },
            {
              ty: 0,
              nm: "nMax",
              mn: "Pseudo/animationControl-0067",
              ix: 67,
              v: { a: 0, k: 9, ix: 67 }
            },
            { ty: 6, nm: "", mn: "Pseudo/animationControl-0068", ix: 68, v: 0 }
          ]
        }
      ],
      shapes: [
        {
          ty: "gr",
          it: [
            {
              ind: 0,
              ty: "sh",
              ix: 1,
              ks: {
                a: 0,
                k: {
                  i: [
                    [139.811, -77.215],
                    [77.216, 139.811],
                    [-139.811, 77.215],
                    [-77.215, -139.811]
                  ],
                  o: [
                    [139.811, 77.215],
                    [-77.215, 139.811],
                    [-139.811, -77.215],
                    [77.216, -139.811]
                  ],
                  v: [
                    [139.811, 0],
                    [0, 139.811],
                    [-139.811, 0],
                    [0, -139.811]
                  ],
                  c: true
                },
                ix: 2
              },
              nm: "Path 1",
              mn: "ADBE Vector Shape - Group",
              hd: false,
              _render: true
            },
            {
              ty: "fl",
              c: { a: 0, k: [1, 0.5412, 0.4902, 1], ix: 4 },
              o: { a: 0, k: 100, ix: 5 },
              r: 1,
              bm: 0,
              nm: "Fill 1",
              mn: "ADBE Vector Graphic - Fill",
              hd: false,
              _render: true
            },
            {
              ty: "tr",
              p: { a: 0, k: [140.061, 140.061], ix: 2 },
              a: { a: 0, k: [0, 0], ix: 1 },
              s: { a: 0, k: [100, 100], ix: 3 },
              r: { a: 0, k: 0, ix: 6 },
              o: { a: 0, k: 100, ix: 7 },
              sk: { a: 0, k: 0, ix: 4 },
              sa: { a: 0, k: 0, ix: 5 },
              nm: "Transform",
              _render: true
            }
          ],
          nm: "Group 1",
          np: 2,
          cix: 2,
          bm: 0,
          ix: 1,
          mn: "ADBE Vector Group",
          hd: false,
          _render: true
        }
      ],
      ip: 0,
      op: 360,
      st: 0,
      bm: 0,
      completed: true
    }
  ],
  markers: [],
  __complete: true
};
var SelfQRcodeWrapper = (props) => {
  const [isClient, setIsClient] = (0, import_react4.useState)(false);
  (0, import_react4.useEffect)(() => {
    setIsClient(true);
  }, []);
  if (!isClient) {
    return null;
  }
  return import_react4.default.createElement(SelfQRcode, { ...props });
};
var SelfQRcode = ({
  selfApp,
  onSuccess,
  onError,
  type = "websocket",
  websocketUrl = WS_DB_RELAYER,
  size = 300,
  darkMode = false
}) => {
  const [proofStep, setProofStep] = (0, import_react4.useState)(QRcodeSteps.WAITING_FOR_MOBILE);
  const [proofVerified, setProofVerified] = (0, import_react4.useState)(false);
  const [sessionId, setSessionId] = (0, import_react4.useState)("");
  const socketRef = (0, import_react4.useRef)(null);
  (0, import_react4.useEffect)(() => {
    setSessionId(v4_default());
  }, []);
  (0, import_react4.useEffect)(() => {
    if (sessionId && !socketRef.current) {
      console.log("[QRCode] Initializing new WebSocket connection");
      socketRef.current = initWebSocket(
        websocketUrl,
        {
          ...selfApp,
          sessionId
        },
        type,
        setProofStep,
        onSuccess,
        onError
      );
    }
    return () => {
      console.log("[QRCode] Cleaning up WebSocket connection");
      if (socketRef.current) {
        socketRef.current();
        socketRef.current = null;
      }
    };
  }, [sessionId, type, websocketUrl, onSuccess, selfApp]);
  if (!sessionId) {
    return null;
  }
  const renderProofStatus = () => import_react4.default.createElement("div", { style: containerStyle }, import_react4.default.createElement("div", { style: ledContainerStyle }, import_react4.default.createElement(LED_default, { connectionStatus: proofStep })), import_react4.default.createElement("div", { style: qrContainerStyle(size) }, (() => {
    switch (proofStep) {
      case QRcodeSteps.PROOF_GENERATION_STARTED:
      case QRcodeSteps.PROOF_GENERATED:
        return import_react4.default.createElement(BounceLoader_default, { loading: true, size: 200, color: "#94FBAB" });
      case QRcodeSteps.PROOF_GENERATION_FAILED:
        return import_react4.default.createElement(
          Lottie.default,
          {
            animationData: x_animation_default,
            style: { width: 200, height: 200 },
            onComplete: () => {
              setProofStep(QRcodeSteps.WAITING_FOR_MOBILE);
            },
            loop: false
          }
        );
      case QRcodeSteps.PROOF_VERIFIED:
        return import_react4.default.createElement(
          Lottie.default,
          {
            animationData: check_animation_default,
            style: { width: 200, height: 200 },
            onComplete: () => {
              setProofStep(QRcodeSteps.WAITING_FOR_MOBILE);
            },
            loop: false
          }
        );
      default:
        return import_react4.default.createElement(
          QRCodeSVG,
          {
            value: type === "websocket" ? `${REDIRECT_URL}?sessionId=${sessionId}` : getUniversalLink({
              ...selfApp,
              sessionId
            }),
            size,
            bgColor: darkMode ? "#000000" : "#ffffff",
            fgColor: darkMode ? "#ffffff" : "#000000"
          }
        );
    }
  })()));
  return import_react4.default.createElement("div", { style: containerStyle }, renderProofStatus());
};

// node_modules/@selfxyz/common/dist/esm/src/constants/countries.js
var countries = {
  AFGHANISTAN: "AFG",
  ALAND_ISLANDS: "ALA",
  ALBANIA: "ALB",
  ALGERIA: "DZA",
  AMERICAN_SAMOA: "ASM",
  ANDORRA: "AND",
  ANGOLA: "AGO",
  ANGUILLA: "AIA",
  ANTARCTICA: "ATA",
  ANTIGUA_AND_BARBUDA: "ATG",
  ARGENTINA: "ARG",
  ARMENIA: "ARM",
  ARUBA: "ABW",
  AUSTRALIA: "AUS",
  AUSTRIA: "AUT",
  AZERBAIJAN: "AZE",
  BAHAMAS: "BHS",
  BAHRAIN: "BHR",
  BANGLADESH: "BGD",
  BARBADOS: "BRB",
  BELARUS: "BLR",
  BELGIUM: "BEL",
  BELIZE: "BLZ",
  BENIN: "BEN",
  BERMUDA: "BMU",
  BHUTAN: "BTN",
  BOLIVIA: "BOL",
  BONAIRE_SINT_EUSTATIUS_AND_SABA: "BES",
  BOSNIA_AND_HERZEGOVINA: "BIH",
  BOTSWANA: "BWA",
  BOUVET_ISLAND: "BVT",
  BRAZIL: "BRA",
  BRITISH_INDIAN_OCEAN_TERRITORY: "IOT",
  BRUNEI: "BRN",
  BULGARIA: "BGR",
  BURKINA_FASO: "BFA",
  BURUNDI: "BDI",
  CAPE_VERDE: "CPV",
  CAMBODIA: "KHM",
  CAMEROON: "CMR",
  CANADA: "CAN",
  CAYMAN_ISLANDS: "CYM",
  CENTRAL_AFRICAN_REPUBLIC: "CAF",
  CHAD: "TCD",
  CHILE: "CHL",
  CHINA: "CHN",
  CHRISTMAS_ISLAND: "CXR",
  COCOS_ISLANDS: "CCK",
  COLOMBIA: "COL",
  COMOROS: "COM",
  CONGO: "COG",
  DR_CONGO: "COD",
  COOK_ISLANDS: "COK",
  COSTA_RICA: "CRI",
  IVORY_COAST: "CIV",
  CROATIA: "HRV",
  CUBA: "CUB",
  CURACAO: "CUW",
  CYPRUS: "CYP",
  CZECH_REPUBLIC: "CZE",
  DENMARK: "DNK",
  DJIBOUTI: "DJI",
  DOMINICA: "DMA",
  DOMINICAN_REPUBLIC: "DOM",
  ECUADOR: "ECU",
  EGYPT: "EGY",
  EL_SALVADOR: "SLV",
  EQUATORIAL_GUINEA: "GNQ",
  ERITREA: "ERI",
  ESTONIA: "EST",
  ESWATINI: "SWZ",
  ETHIOPIA: "ETH",
  FALKLAND_ISLANDS: "FLK",
  FAROE_ISLANDS: "FRO",
  FIJI: "FJI",
  FINLAND: "FIN",
  FRANCE: "FRA",
  FRENCH_GUIANA: "GUF",
  FRENCH_POLYNESIA: "PYF",
  FRENCH_SOUTHERN_TERRITORIES: "ATF",
  GABON: "GAB",
  GAMBIA: "GMB",
  GEORGIA: "GEO",
  GERMANY: "D<<",
  GHANA: "GHA",
  GIBRALTAR: "GIB",
  GREECE: "GRC",
  GREENLAND: "GRL",
  GRENADA: "GRD",
  GUADELOUPE: "GLP",
  GUAM: "GUM",
  GUATEMALA: "GTM",
  GUERNSEY: "GGY",
  GUINEA: "GIN",
  GUINEA_BISSAU: "GNB",
  GUYANA: "GUY",
  HAITI: "HTI",
  HEARD_ISLAND_AND_MCDONALD_ISLANDS: "HMD",
  VATICAN_CITY: "VAT",
  HONDURAS: "HND",
  HONG_KONG: "HKG",
  HUNGARY: "HUN",
  ICELAND: "ISL",
  INDIA: "IND",
  INDONESIA: "IDN",
  IRAN: "IRN",
  IRAQ: "IRQ",
  IRELAND: "IRL",
  ISLE_OF_MAN: "IMN",
  ISRAEL: "ISR",
  ITALY: "ITA",
  JAMAICA: "JAM",
  JAPAN: "JPN",
  JERSEY: "JEY",
  JORDAN: "JOR",
  KAZAKHSTAN: "KAZ",
  KENYA: "KEN",
  KIRIBATI: "KIR",
  NORTH_KOREA: "PRK",
  SOUTH_KOREA: "KOR",
  KUWAIT: "KWT",
  KYRGYZSTAN: "KGZ",
  LAOS: "LAO",
  LATVIA: "LVA",
  LEBANON: "LBN",
  LESOTHO: "LSO",
  LIBERIA: "LBR",
  LIBYA: "LBY",
  LIECHTENSTEIN: "LIE",
  LITHUANIA: "LTU",
  LUXEMBOURG: "LUX",
  MACAO: "MAC",
  MADAGASCAR: "MDG",
  MALAWI: "MWI",
  MALAYSIA: "MYS",
  MALDIVES: "MDV",
  MALI: "MLI",
  MALTA: "MLT",
  MARSHALL_ISLANDS: "MHL",
  MARTINIQUE: "MTQ",
  MAURITANIA: "MRT",
  MAURITIUS: "MUS",
  MAYOTTE: "MYT",
  MEXICO: "MEX",
  MICRONESIA: "FSM",
  MOLDOVA: "MDA",
  MONACO: "MCO",
  MONGOLIA: "MNG",
  MONTENEGRO: "MNE",
  MONTSERRAT: "MSR",
  MOROCCO: "MAR",
  MOZAMBIQUE: "MOZ",
  MYANMAR: "MMR",
  NAMIBIA: "NAM",
  NAURU: "NRU",
  NEPAL: "NPL",
  NETHERLANDS: "NLD",
  NEW_CALEDONIA: "NCL",
  NEW_ZEALAND: "NZL",
  NICARAGUA: "NIC",
  NIGER: "NER",
  NIGERIA: "NGA",
  NIUE: "NIU",
  NORFOLK_ISLAND: "NFK",
  NORTH_MACEDONIA: "MKD",
  NORTHERN_MARIANA_ISLANDS: "MNP",
  NORWAY: "NOR",
  OMAN: "OMN",
  PAKISTAN: "PAK",
  PALAU: "PLW",
  PALESTINE: "PSE",
  PANAMA: "PAN",
  PAPUA_NEW_GUINEA: "PNG",
  PARAGUAY: "PRY",
  PERU: "PER",
  PHILIPPINES: "PHL",
  PITCAIRN: "PCN",
  POLAND: "POL",
  PORTUGAL: "PRT",
  PUERTO_RICO: "PRI",
  QATAR: "QAT",
  REUNION: "REU",
  ROMANIA: "ROU",
  RUSSIA: "RUS",
  RWANDA: "RWA",
  SAINT_BARTHELEMY: "BLM",
  SAINT_HELENA_ASCENSION_AND_TRISTAN_DA_CUNHA: "SHN",
  SAINT_KITTS_AND_NEVIS: "KNA",
  SAINT_LUCIA: "LCA",
  SAINT_MARTIN: "MAF",
  SAINT_PIERRE_AND_MIQUELON: "SPM",
  SAINT_VINCENT_AND_THE_GRENADINES: "VCT",
  SAMOA: "WSM",
  SAN_MARINO: "SMR",
  SAO_TOME_AND_PRINCIPE: "STP",
  SAUDI_ARABIA: "SAU",
  SENEGAL: "SEN",
  SERBIA: "SRB",
  SEYCHELLES: "SYC",
  SIERRA_LEONE: "SLE",
  SINGAPORE: "SGP",
  SINT_MAARTEN: "SXM",
  SLOVAKIA: "SVK",
  SLOVENIA: "SVN",
  SOLOMON_ISLANDS: "SLB",
  SOMALIA: "SOM",
  SOUTH_AFRICA: "ZAF",
  SOUTH_GEORGIA_AND_THE_SOUTH_SANDWICH_ISLANDS: "SGS",
  SOUTH_SUDAN: "SSD",
  SPAIN: "ESP",
  SRI_LANKA: "LKA",
  SUDAN: "SDN",
  SURINAME: "SUR",
  SVALBARD_AND_JAN_MAYEN: "SJM",
  SWEDEN: "SWE",
  SWITZERLAND: "CHE",
  SYRIAN_ARAB_REPUBLIC: "SYR",
  TAIWAN: "TWN",
  TAJIKISTAN: "TJK",
  TANZANIA: "TZA",
  THAILAND: "THA",
  TIMOR_LESTE: "TLS",
  TOGO: "TGO",
  TOKELAU: "TKL",
  TONGA: "TON",
  TRINIDAD_AND_TOBAGO: "TTO",
  TUNISIA: "TUN",
  TURKEY: "TUR",
  TURKMENISTAN: "TKM",
  TURKS_AND_CAICOS_ISLANDS: "TCA",
  TUVALU: "TUV",
  UGANDA: "UGA",
  UKRAINE: "UKR",
  UNITED_ARAB_EMIRATES: "ARE",
  UNITED_KINGDOM: "GBR",
  UNITED_STATES: "USA",
  UNITED_STATES_MINOR_OUTLYING_ISLANDS: "UMI",
  URUGUAY: "URY",
  UZBEKISTAN: "UZB",
  VANUATU: "VUT",
  VENEZUELA: "VEN",
  VIET_NAM: "VNM",
  VIRGIN_ISLANDS_BRITISH: "VGB",
  VIRGIN_ISLANDS_US: "VIR",
  WALLIS_AND_FUTUNA: "WLF",
  WESTERN_SAHARA: "ESH",
  YEMEN: "YEM",
  ZAMBIA: "ZMB",
  ZIMBABWE: "ZWE",
  EUROPEAN_UNION: "EUE",
  UNITED_NATIONS: "UNO",
  COUNCIL_OF_EUROPE: "XCE",
  INTERPOL: "XPO",
  SMOM: "XOM"
};
export {
  SelfAppBuilder,
  SelfQRcode,
  SelfQRcodeWrapper,
  countries
};
/*! Bundled license information:

lottie-web/build/player/lottie.js:
  (*!
   Transformation Matrix v2.0
   (c) Epistemex 2014-2015
   www.epistemex.com
   By Ken Fyrstenberg
   Contributions by leeoniya.
   License: MIT, header required.
   *)

js-sha256/src/sha256.js:
  (**
   * [js-sha256]{@link https://github.com/emn178/js-sha256}
   *
   * @version 0.11.1
   * @author Chen, Yi-Cyuan [emn178@gmail.com]
   * @copyright Chen, Yi-Cyuan 2014-2025
   * @license MIT
   *)

js-sha1/src/sha1.js:
  (*
   * [js-sha1]{@link https://github.com/emn178/js-sha1}
   *
   * @version 0.7.0
   * @author Chen, Yi-Cyuan [emn178@gmail.com]
   * @copyright Chen, Yi-Cyuan 2014-2024
   * @license MIT
   *)

js-sha512/src/sha512.js:
  (*
   * [js-sha512]{@link https://github.com/emn178/js-sha512}
   *
   * @version 0.9.0
   * @author Chen, Yi-Cyuan [emn178@gmail.com]
   * @copyright Chen, Yi-Cyuan 2014-2024
   * @license MIT
   *)

lottie-react/build/index.es.js:
  (*! goToAndStop must be relative to the start of the current segment *)

qrcode.react/lib/esm/index.js:
  (**
   * @license QR Code generator library (TypeScript)
   * Copyright (c) Project Nayuki.
   * SPDX-License-Identifier: MIT
   *)
  (**
   * @license qrcode.react
   * Copyright (c) Paul O'Shannessy
   * SPDX-License-Identifier: ISC
   *)
*/
//# sourceMappingURL=@selfxyz_qrcode.js.map

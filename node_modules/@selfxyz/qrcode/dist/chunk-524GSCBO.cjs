"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }

var _chunkJJXEZUAKcjs = require('./chunk-JJXEZUAK.cjs');

// utils/websocket.ts
var _socketioclient = require('socket.io-client'); var _socketioclient2 = _interopRequireDefault(_socketioclient);
console.log("[WebSocket] Initializing websocket module.");
var validateWebSocketUrl = (websocketUrl) => {
  if (websocketUrl.includes("localhost") || websocketUrl.includes("127.0.0.1")) {
    throw new Error("localhost websocket URLs are not allowed");
  }
};
var newSocket = (websocketUrl, sessionId) => {
  const fullUrl = `${websocketUrl}/websocket`;
  console.log(
    `[WebSocket] Creating new socket. URL: ${fullUrl}, sessionId: ${sessionId}`
  );
  return _socketioclient2.default.call(void 0, fullUrl, {
    path: "/",
    query: { sessionId, clientType: "web" },
    transports: ["websocket"]
  });
};
var handleWebSocketMessage = (socket, sessionId, selfApp, type, setProofStep, onSuccess, onError) => async (data) => {
  console.log(
    "[WebSocket] Received mobile status:",
    data.status,
    "for session:",
    sessionId
  );
  switch (data.status) {
    case "mobile_connected":
      console.log(
        "[WebSocket] Mobile device connected. Emitting self_app event with payload:",
        selfApp
      );
      setProofStep(_chunkJJXEZUAKcjs.QRcodeSteps.MOBILE_CONNECTED);
      if (type === "websocket") {
        socket.emit("self_app", { ...selfApp, sessionId });
      }
      break;
    case "mobile_disconnected":
      console.log("[WebSocket] Mobile device disconnected.");
      setProofStep(_chunkJJXEZUAKcjs.QRcodeSteps.WAITING_FOR_MOBILE);
      break;
    case "proof_generation_started":
      console.log("[WebSocket] Proof generation started.");
      setProofStep(_chunkJJXEZUAKcjs.QRcodeSteps.PROOF_GENERATION_STARTED);
      break;
    case "proof_generated":
      console.log("[WebSocket] Proof generated.");
      setProofStep(_chunkJJXEZUAKcjs.QRcodeSteps.PROOF_GENERATED);
      break;
    case "proof_generation_failed":
      console.log("[WebSocket] Proof generation failed.");
      setProofStep(_chunkJJXEZUAKcjs.QRcodeSteps.PROOF_GENERATION_FAILED);
      onError(data);
      break;
    case "proof_verified":
      console.log("[WebSocket] Proof verified.");
      console.log("ws data", data);
      setProofStep(_chunkJJXEZUAKcjs.QRcodeSteps.PROOF_VERIFIED);
      onSuccess();
      break;
    default:
      console.log("[WebSocket] Unhandled mobile status:", data.status);
      break;
  }
};
function initWebSocket(websocketUrl, selfApp, type, setProofStep, onSuccess, onError) {
  validateWebSocketUrl(websocketUrl);
  const sessionId = selfApp.sessionId;
  console.log(
    `[WebSocket] Initializing WebSocket connection for sessionId: ${sessionId}`
  );
  const socket = newSocket(websocketUrl, sessionId);
  socket.on("connect", () => {
    console.log(
      `[WebSocket] Connected with id: ${socket.id}, transport: ${socket.io.engine.transport.name}`
    );
  });
  socket.on("connect_error", (error) => {
    console.error("[WebSocket] Connection error:", error);
  });
  socket.on("mobile_status", (data) => {
    console.log("[WebSocket] Raw mobile_status event received:", data);
    handleWebSocketMessage(
      socket,
      sessionId,
      selfApp,
      type,
      setProofStep,
      onSuccess,
      onError
    )(data);
  });
  socket.on("disconnect", (reason) => {
    console.log(
      `[WebSocket] Disconnected. Reason: ${reason}, Last transport: ${_optionalChain([socket, 'access', _ => _.io, 'access', _2 => _2.engine, 'access', _3 => _3.transport, 'optionalAccess', _4 => _4.name])}`
    );
  });
  return () => {
    console.log(
      `[WebSocket] Cleaning up connection for sessionId: ${sessionId}`
    );
    if (socket) {
      socket.disconnect();
    }
  };
}



exports.initWebSocket = initWebSocket;

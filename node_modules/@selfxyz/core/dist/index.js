// src/SelfBackendVerifier.ts
import { ethers as ethers2 } from "ethers";
import { hashEndpointWithScope } from "@selfxyz/common/utils/scope";

// src/typechain-types/factories/IdentityVerificationHubImpl__factory.ts
import { Contract, Interface } from "ethers";
var _abi = [
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "attestationId",
        type: "bytes32"
      }
    ],
    name: "discloseVerifier",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "attestationId",
        type: "bytes32"
      }
    ],
    name: "registry",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];
var IdentityVerificationHubImpl__factory = class {
  static createInterface() {
    return new Interface(_abi);
  }
  static connect(address, runner) {
    return new Contract(
      address,
      _abi,
      runner
    );
  }
};
IdentityVerificationHubImpl__factory.abi = _abi;

// src/typechain-types/factories/Registry__factory.ts
import { Contract as Contract2, Interface as Interface2 } from "ethers";
var _abi2 = [
  {
    inputs: [
      {
        internalType: "uint256",
        name: "root",
        type: "uint256"
      }
    ],
    name: "checkIdentityCommitmentRoot",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];
var Registry__factory = class {
  static createInterface() {
    return new Interface2(_abi2);
  }
  static connect(address, runner) {
    return new Contract2(address, _abi2, runner);
  }
};
Registry__factory.abi = _abi2;

// src/typechain-types/factories/Verifier__factory.ts
import { Contract as Contract3, Interface as Interface3 } from "ethers";
var _abi3 = [
  {
    inputs: [
      {
        internalType: "uint256[2]",
        name: "a",
        type: "uint256[2]"
      },
      {
        internalType: "uint256[2][2]",
        name: "b",
        type: "uint256[2][2]"
      },
      {
        internalType: "uint256[2]",
        name: "c",
        type: "uint256[2]"
      },
      {
        internalType: "uint256[21]",
        name: "pubSignals",
        type: "uint256[21]"
      }
    ],
    name: "verifyProof",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];
var Verifier__factory = class {
  static createInterface() {
    return new Interface3(_abi3);
  }
  static connect(address, runner) {
    return new Contract3(address, _abi3, runner);
  }
};
Verifier__factory.abi = _abi3;

// src/utils/constants.ts
var discloseIndices = {
  1: {
    revealedDataPackedIndex: 0,
    forbiddenCountriesListPackedIndex: 3,
    nullifierIndex: 7,
    attestationIdIndex: 8,
    merkleRootIndex: 9,
    currentDateIndex: 10,
    namedobSmtRootIndex: 17,
    nameyobSmtRootIndex: 18,
    scopeIndex: 19,
    userIdentifierIndex: 20,
    passportNoSmtRootIndex: 16
  },
  2: {
    revealedDataPackedIndex: 0,
    forbiddenCountriesListPackedIndex: 4,
    nullifierIndex: 8,
    attestationIdIndex: 9,
    merkleRootIndex: 10,
    currentDateIndex: 11,
    namedobSmtRootIndex: 17,
    nameyobSmtRootIndex: 18,
    scopeIndex: 19,
    userIdentifierIndex: 20,
    passportNoSmtRootIndex: 99
  }
};
var revealedDataIndices = {
  1: {
    issuingStateStart: 2,
    issuingStateEnd: 4,
    nameStart: 5,
    nameEnd: 43,
    idNumberStart: 44,
    idNumberEnd: 52,
    nationalityStart: 54,
    nationalityEnd: 56,
    dateOfBirthStart: 57,
    dateOfBirthEnd: 62,
    genderStart: 64,
    genderEnd: 64,
    expiryDateStart: 65,
    expiryDateEnd: 70,
    olderThanStart: 88,
    olderThanEnd: 89,
    ofacStart: 90,
    ofacEnd: 92
  },
  2: {
    issuingStateStart: 2,
    issuingStateEnd: 4,
    nameStart: 60,
    nameEnd: 89,
    idNumberStart: 5,
    idNumberEnd: 13,
    nationalityStart: 45,
    nationalityEnd: 47,
    dateOfBirthStart: 30,
    dateOfBirthEnd: 35,
    genderStart: 37,
    genderEnd: 37,
    expiryDateStart: 38,
    expiryDateEnd: 43,
    olderThanStart: 90,
    olderThanEnd: 91,
    ofacStart: 92,
    ofacEnd: 93
  }
};
var allIdEntries = Object.keys(discloseIndices).map(
  (id) => [Number(id), true]
);
var AllIds = new Map(allIdEntries);

// src/utils/proof.ts
function getRevealedDataPublicSignalsLength(attestationId) {
  switch (attestationId) {
    case 1:
      return 93 / 31;
    case 2:
      return Math.ceil(94 / 31);
    default:
      throw new Error(`Invalid attestation ID: ${attestationId}`);
  }
}
var bytesCount = {
  1: [31, 31, 31],
  2: [31, 31, 31, 1]
};
function getRevealedDataBytes(attestationId, publicSignals) {
  let bytes = [];
  for (let i = 0; i < getRevealedDataPublicSignalsLength(attestationId); i++) {
    let publicSignal = BigInt(
      publicSignals[discloseIndices[attestationId].revealedDataPackedIndex + i]
    );
    for (let j = 0; j < bytesCount[attestationId][i]; j++) {
      bytes.push(Number(publicSignal & 0xffn));
      publicSignal = publicSignal >> 8n;
    }
  }
  return bytes;
}

// src/utils/id.ts
var formatRevealedDataPacked = (attestationId, publicSignals) => {
  const revealedDataPacked = getRevealedDataBytes(attestationId, publicSignals);
  const revealedDataPackedString = Buffer.from(revealedDataPacked);
  const nullifier = publicSignals[discloseIndices[attestationId].nullifierIndex];
  const forbiddenCountriesListPacked = publicSignals.slice(
    discloseIndices[attestationId].forbiddenCountriesListPackedIndex,
    discloseIndices[attestationId].forbiddenCountriesListPackedIndex + 3
  );
  const issuingState = revealedDataPackedString.subarray(
    revealedDataIndices[attestationId].issuingStateStart,
    revealedDataIndices[attestationId].issuingStateEnd + 1
  ).toString("utf-8");
  const name = revealedDataPackedString.subarray(
    revealedDataIndices[attestationId].nameStart,
    revealedDataIndices[attestationId].nameEnd + 1
  ).toString("utf-8").replace(/([A-Z])<+([A-Z])/g, "$1 $2").replace(/</g, "").trim();
  const idNumber = revealedDataPackedString.subarray(
    revealedDataIndices[attestationId].idNumberStart,
    revealedDataIndices[attestationId].idNumberEnd + 1
  ).toString("utf-8");
  const nationality = revealedDataPackedString.subarray(
    revealedDataIndices[attestationId].nationalityStart,
    revealedDataIndices[attestationId].nationalityEnd + 1
  ).toString("utf-8");
  const dateOfBirth = revealedDataPackedString.subarray(
    revealedDataIndices[attestationId].dateOfBirthStart,
    revealedDataIndices[attestationId].dateOfBirthEnd + 1
  ).toString("utf-8");
  const gender = revealedDataPackedString.subarray(
    revealedDataIndices[attestationId].genderStart,
    revealedDataIndices[attestationId].genderEnd + 1
  ).toString("utf-8");
  const expiryDate = revealedDataPackedString.subarray(
    revealedDataIndices[attestationId].expiryDateStart,
    revealedDataIndices[attestationId].expiryDateEnd + 1
  ).toString("utf-8");
  const olderThan = Buffer.from(
    revealedDataPackedString.subarray(
      revealedDataIndices[attestationId].olderThanStart,
      revealedDataIndices[attestationId].olderThanEnd + 1
    )
  ).toString("utf-8");
  const ofac = Array.from(
    revealedDataPackedString.subarray(
      revealedDataIndices[attestationId].ofacStart,
      revealedDataIndices[attestationId].ofacEnd + 1
    )
  ).map(Boolean);
  return {
    nullifier: nullifier.toString(),
    forbiddenCountriesListPacked,
    issuingState,
    name,
    idNumber,
    nationality,
    dateOfBirth,
    gender,
    expiryDate,
    minimumAge: olderThan,
    ofac
  };
};

// src/utils/hash.ts
import { ethers } from "ethers";
function calculateUserIdentifierHash(userContextData) {
  const sha256Hash = ethers.sha256(userContextData);
  const ripemdHash = ethers.ripemd160(sha256Hash);
  return ripemdHash.toString().padStart(40, "0");
}

// src/SelfBackendVerifier.ts
import { castToUserIdentifier } from "@selfxyz/common/utils/circuits/uuid";

// src/errors.ts
var ConfigMismatchError = class _ConfigMismatchError extends Error {
  constructor(issues) {
    const message = issues.map((issue) => `[${issue.type}]: ${issue.message}`).join("\n");
    super(message);
    this.name = "ConfigMismatchError";
    this.issues = issues;
    Object.setPrototypeOf(this, _ConfigMismatchError.prototype);
  }
  static single(type, message) {
    return new _ConfigMismatchError([{ type, message }]);
  }
};

// src/utils/utils.ts
import { unpackReveal } from "@selfxyz/common/utils/circuits/formatOutputs";
function trimu0000(unpackedReveal) {
  return unpackedReveal.filter((value) => value !== "\0");
}
function unpackForbiddenCountriesList(forbiddenCountriesList_packed) {
  const trimmed = trimu0000(unpackReveal(forbiddenCountriesList_packed, "id"));
  const countries2 = [];
  for (let i = 0; i < trimmed.length; i += 3) {
    const countryCode = trimmed.slice(i, i + 3).join("");
    if (countryCode.length === 3) {
      countries2.push(countryCode);
    }
  }
  return countries2;
}

// src/SelfBackendVerifier.ts
var CELO_MAINNET_RPC_URL = "https://forno.celo.org";
var CELO_TESTNET_RPC_URL = "https://alfajores-forno.celo-testnet.org";
var IDENTITY_VERIFICATION_HUB_ADDRESS = "0xe57F4773bd9c9d8b6Cd70431117d353298B9f5BF";
var IDENTITY_VERIFICATION_HUB_ADDRESS_STAGING = "0x68c931C9a534D37aa78094877F46fE46a49F1A51";
var SelfBackendVerifier = class {
  constructor(scope, endpoint, mockPassport = false, allowedIds, configStorage, userIdentifierType) {
    const rpcUrl = mockPassport ? CELO_TESTNET_RPC_URL : CELO_MAINNET_RPC_URL;
    const provider = new ethers2.JsonRpcProvider(rpcUrl);
    const identityVerificationHubAddress = mockPassport ? IDENTITY_VERIFICATION_HUB_ADDRESS_STAGING : IDENTITY_VERIFICATION_HUB_ADDRESS;
    this.identityVerificationHubContract = IdentityVerificationHubImpl__factory.connect(
      identityVerificationHubAddress,
      provider
    );
    this.provider = provider;
    this.scope = hashEndpointWithScope(endpoint, scope);
    this.allowedIds = allowedIds;
    this.configStorage = configStorage;
    this.userIdentifierType = userIdentifierType;
  }
  async verify(attestationId, proof, pubSignals, userContextData) {
    const allowedId = this.allowedIds.get(attestationId);
    let issues = [];
    if (!allowedId) {
      issues.push({
        type: "InvalidId" /* InvalidId */,
        message: "Attestation ID is not allowed, received: " + attestationId
      });
    }
    const publicSignals = pubSignals.map(String).map((x) => /[a-f]/g.test(x) && x.length > 0 ? "0x" + x : x);
    const userContextHashInCircuit = BigInt(
      publicSignals[discloseIndices[attestationId].userIdentifierIndex]
    );
    const userContextHash = BigInt(
      calculateUserIdentifierHash(Buffer.from(userContextData, "hex"))
    );
    if (userContextHashInCircuit !== userContextHash) {
      issues.push({
        type: "InvalidUserContextHash" /* InvalidUserContextHash */,
        message: "User context hash does not match with the one in the circuit\nCircuit: " + userContextHashInCircuit + "\nUser context hash: " + userContextHash
      });
    }
    const isValidScope = this.scope === publicSignals[discloseIndices[attestationId].scopeIndex];
    if (!isValidScope) {
      issues.push({
        type: "InvalidScope" /* InvalidScope */,
        message: "Scope does not match with the one in the circuit\nCircuit: " + publicSignals[discloseIndices[attestationId].scopeIndex] + "\nScope: " + this.scope
      });
    }
    try {
      const registryAddress = await this.identityVerificationHubContract.registry(
        "0x" + attestationId.toString(16).padStart(64, "0")
      );
      if (registryAddress === "0x0000000000000000000000000000000000000000") {
        throw new Error("Registry contract not found");
      }
      const registryContract = Registry__factory.connect(registryAddress, this.provider);
      const currentRoot = await registryContract.checkIdentityCommitmentRoot(
        publicSignals[discloseIndices[attestationId].merkleRootIndex]
      );
      if (!currentRoot) {
        issues.push({
          type: "InvalidRoot" /* InvalidRoot */,
          message: "Onchain root does not exist, received: " + publicSignals[discloseIndices[attestationId].merkleRootIndex]
        });
      }
    } catch (error) {
      throw new Error("Registry contract not found");
    }
    const isValidAttestationId = attestationId.toString() === publicSignals[discloseIndices[attestationId].attestationIdIndex];
    if (!isValidAttestationId) {
      issues.push({
        type: "InvalidAttestationId" /* InvalidAttestationId */,
        message: "Attestation ID does not match with the one in the circuit"
      });
    }
    const userIdentifier = castToUserIdentifier(
      BigInt("0x" + userContextData.slice(64, 128)),
      this.userIdentifierType
    );
    const userDefinedData = userContextData.slice(128);
    const configId = await this.configStorage.getActionId(userIdentifier, userDefinedData);
    if (!configId) {
      issues.push({
        type: "ConfigNotFound" /* ConfigNotFound */,
        message: "Config Id not found"
      });
    }
    let verificationConfig;
    try {
      verificationConfig = await this.configStorage.getConfig(configId);
    } catch (error) {
      issues.push({
        type: "ConfigNotFound" /* ConfigNotFound */,
        message: `Config not found for ${configId}`
      });
    } finally {
      if (!verificationConfig) {
        issues.push({
          type: "ConfigNotFound" /* ConfigNotFound */,
          message: `Config not found for ${configId}`
        });
        throw new ConfigMismatchError(issues);
      }
    }
    const forbiddenCountriesList = unpackForbiddenCountriesList(
      [0, 1, 2, 3].map(
        (x) => publicSignals[discloseIndices[attestationId].forbiddenCountriesListPackedIndex + x]
      )
    );
    const forbiddenCountriesListVerificationConfig = verificationConfig.excludedCountries;
    const isForbiddenCountryListValid = forbiddenCountriesListVerificationConfig.every(
      (country) => forbiddenCountriesList.includes(country)
    );
    if (!isForbiddenCountryListValid) {
      issues.push({
        type: "InvalidForbiddenCountriesList" /* InvalidForbiddenCountriesList */,
        message: "Forbidden countries list in config does not match with the one in the circuit\nCircuit: " + forbiddenCountriesList.join(", ") + "\nConfig: " + forbiddenCountriesListVerificationConfig.join(", ")
      });
    }
    const genericDiscloseOutput = formatRevealedDataPacked(attestationId, publicSignals);
    const isMinimumAgeValid = verificationConfig.minimumAge !== void 0 ? verificationConfig.minimumAge === Number.parseInt(genericDiscloseOutput.minimumAge, 10) || genericDiscloseOutput.minimumAge === "00" : true;
    if (!isMinimumAgeValid) {
      issues.push({
        type: "InvalidMinimumAge" /* InvalidMinimumAge */,
        message: "Minimum age in config does not match with the one in the circuit\nCircuit: " + genericDiscloseOutput.minimumAge + "\nConfig: " + verificationConfig.minimumAge
      });
    }
    const circuitTimestampYy = [
      2,
      0,
      publicSignals[discloseIndices[attestationId].currentDateIndex],
      publicSignals[discloseIndices[attestationId].currentDateIndex + 1]
    ];
    const circuitTimestampMm = [
      publicSignals[discloseIndices[attestationId].currentDateIndex + 2],
      publicSignals[discloseIndices[attestationId].currentDateIndex + 3]
    ];
    const circuitTimestampDd = [
      publicSignals[discloseIndices[attestationId].currentDateIndex + 4],
      publicSignals[discloseIndices[attestationId].currentDateIndex + 5]
    ];
    const circuitTimestamp = new Date(
      Number(circuitTimestampYy.join("")),
      Number(circuitTimestampMm.join("")) - 1,
      Number(circuitTimestampDd.join(""))
    );
    const currentTimestamp = /* @__PURE__ */ new Date();
    const oneDayAhead = new Date(currentTimestamp.getTime() + 24 * 60 * 60 * 1e3);
    if (circuitTimestamp > oneDayAhead) {
      issues.push({
        type: "InvalidTimestamp" /* InvalidTimestamp */,
        message: "Circuit timestamp is in the future"
      });
    }
    const oneDayAgo = new Date(currentTimestamp.getTime() - 24 * 60 * 60 * 1e3);
    if (circuitTimestamp < oneDayAgo) {
      issues.push({
        type: "InvalidTimestamp" /* InvalidTimestamp */,
        message: "Circuit timestamp is too old"
      });
    }
    if (!verificationConfig.ofac && genericDiscloseOutput.ofac[0]) {
      issues.push({
        type: "InvalidOfac" /* InvalidOfac */,
        message: "Passport number OFAC check is not allowed"
      });
    }
    if (!verificationConfig.ofac && genericDiscloseOutput.ofac[1]) {
      issues.push({
        type: "InvalidOfac" /* InvalidOfac */,
        message: "Name and DOB OFAC check is not allowed"
      });
    }
    if (!verificationConfig.ofac && genericDiscloseOutput.ofac[2]) {
      issues.push({
        type: "InvalidOfac" /* InvalidOfac */,
        message: "Name and YOB OFAC check is not allowed"
      });
    }
    if (issues.length > 0) {
      throw new ConfigMismatchError(issues);
    }
    let verifierContract;
    try {
      const verifierAddress = await this.identityVerificationHubContract.discloseVerifier(
        "0x" + attestationId.toString(16).padStart(64, "0")
      );
      if (verifierAddress === "0x0000000000000000000000000000000000000000") {
        throw new Error("Verifier contract not found");
      }
      verifierContract = Verifier__factory.connect(verifierAddress, this.provider);
    } catch (error) {
      throw new Error("Verifier contract not found");
    }
    let isValid = false;
    try {
      isValid = await verifierContract.verifyProof(
        proof.a,
        [
          [proof.b[0][1], proof.b[0][0]],
          [proof.b[1][1], proof.b[1][0]]
        ],
        proof.c,
        publicSignals
      );
    } catch (error) {
      isValid = false;
    }
    return {
      attestationId,
      isValidDetails: {
        isValid,
        isMinimumAgeValid: verificationConfig.minimumAge !== void 0 ? verificationConfig.minimumAge <= Number.parseInt(genericDiscloseOutput.minimumAge, 10) : true,
        isOfacValid: verificationConfig.ofac !== void 0 && verificationConfig.ofac ? genericDiscloseOutput.ofac.every(
          (enabled, index) => enabled ? genericDiscloseOutput.ofac[index] : true
        ) : true
      },
      forbiddenCountriesList,
      discloseOutput: genericDiscloseOutput,
      userData: {
        userIdentifier,
        userDefinedData
      }
    };
  }
};

// index.ts
import { countryCodes } from "@selfxyz/common/constants/constants";
import { getUniversalLink } from "@selfxyz/common/utils/appType";
import { countries } from "@selfxyz/common";

// src/store/DefaultConfigStore.ts
var DefaultConfigStore = class {
  constructor(config) {
    this.config = config;
  }
  async getConfig(_id) {
    return this.config;
  }
  async setConfig(_id, config) {
    this.config = config;
    return true;
  }
  async getActionId(_userIdentifier, _data) {
    return "random-id";
  }
};

// src/store/InMemoryConfigStore.ts
var InMemoryConfigStore = class {
  constructor(getActionIdFunc) {
    this.configs = /* @__PURE__ */ new Map();
    this.getActionIdFunc = getActionIdFunc;
  }
  async getActionId(userIdentifier, userDefinedData) {
    return this.getActionIdFunc(userIdentifier, userDefinedData);
  }
  async setConfig(configId, config) {
    const existed = this.configs.has(configId);
    this.configs.set(configId, config);
    return !existed;
  }
  async getConfig(configId) {
    return this.configs.get(configId);
  }
};
export {
  AllIds,
  DefaultConfigStore,
  InMemoryConfigStore,
  SelfBackendVerifier,
  countries,
  countryCodes,
  getUniversalLink
};
//# sourceMappingURL=index.js.map
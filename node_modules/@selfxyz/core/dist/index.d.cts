import { Country3LetterCode } from '@selfxyz/common';
export { countries } from '@selfxyz/common';
import { BigNumberish, DeferredTopicFilter, EventFragment, EventLog, TransactionRequest, Typed, ContractTransactionResponse, FunctionFragment, ContractTransaction, BaseContract, ContractRunner, Interface, BytesLike, Result, Listener, ContractMethod, ethers } from 'ethers';
import { UserIdType } from '@selfxyz/common/utils/circuits/uuid';
export { countryCodes } from '@selfxyz/common/constants/constants';
export { getUniversalLink } from '@selfxyz/common/utils/appType';

declare const discloseIndices: {
    readonly 1: {
        readonly revealedDataPackedIndex: 0;
        readonly forbiddenCountriesListPackedIndex: 3;
        readonly nullifierIndex: 7;
        readonly attestationIdIndex: 8;
        readonly merkleRootIndex: 9;
        readonly currentDateIndex: 10;
        readonly namedobSmtRootIndex: 17;
        readonly nameyobSmtRootIndex: 18;
        readonly scopeIndex: 19;
        readonly userIdentifierIndex: 20;
        readonly passportNoSmtRootIndex: 16;
    };
    readonly 2: {
        readonly revealedDataPackedIndex: 0;
        readonly forbiddenCountriesListPackedIndex: 4;
        readonly nullifierIndex: 8;
        readonly attestationIdIndex: 9;
        readonly merkleRootIndex: 10;
        readonly currentDateIndex: 11;
        readonly namedobSmtRootIndex: 17;
        readonly nameyobSmtRootIndex: 18;
        readonly scopeIndex: 19;
        readonly userIdentifierIndex: 20;
        readonly passportNoSmtRootIndex: 99;
    };
};
declare const AllIds: Map<1 | 2, boolean>;

type VcAndDiscloseProof = {
    a: [BigNumberish, BigNumberish];
    b: [[BigNumberish, BigNumberish], [BigNumberish, BigNumberish]];
    c: [BigNumberish, BigNumberish];
};
type VerificationConfig = {
    minimumAge?: number;
    excludedCountries?: Country3LetterCode[];
    ofac?: boolean;
};
type VerificationResult = {
    attestationId: AttestationId;
    isValidDetails: {
        isValid: boolean;
        isMinimumAgeValid: boolean;
        isOfacValid: boolean;
    };
    forbiddenCountriesList: string[];
    discloseOutput: GenericDiscloseOutput;
    userData: {
        userIdentifier: string;
        userDefinedData: string;
    };
};
type GenericDiscloseOutput = {
    nullifier: string;
    forbiddenCountriesListPacked: string[];
    issuingState: string;
    name: string;
    idNumber: string;
    nationality: string;
    dateOfBirth: string;
    gender: string;
    expiryDate: string;
    minimumAge: string;
    ofac: boolean[];
};
type AttestationId = keyof typeof discloseIndices;

interface TypedDeferredTopicFilter<_TCEvent extends TypedContractEvent> extends DeferredTopicFilter {
}
interface TypedContractEvent<InputTuple extends Array<any> = any, OutputTuple extends Array<any> = any, OutputObject = any> {
    (...args: Partial<InputTuple>): TypedDeferredTopicFilter<TypedContractEvent<InputTuple, OutputTuple, OutputObject>>;
    name: string;
    fragment: EventFragment;
    getFragment(...args: Partial<InputTuple>): EventFragment;
}
type __TypechainAOutputTuple<T> = T extends TypedContractEvent<infer _U, infer W> ? W : never;
type __TypechainOutputObject<T> = T extends TypedContractEvent<infer _U, infer _W, infer V> ? V : never;
interface TypedEventLog<TCEvent extends TypedContractEvent> extends Omit<EventLog, "args"> {
    args: __TypechainAOutputTuple<TCEvent> & __TypechainOutputObject<TCEvent>;
}
type TypedListener<TCEvent extends TypedContractEvent> = (...listenerArg: [
    ...__TypechainAOutputTuple<TCEvent>,
    TypedEventLog<TCEvent>,
    ...undefined[]
]) => void;
type StateMutability = "nonpayable" | "payable" | "view";
type BaseOverrides = Omit<TransactionRequest, "to" | "data">;
type NonPayableOverrides = Omit<BaseOverrides, "value" | "blockTag" | "enableCcipRead">;
type PayableOverrides = Omit<BaseOverrides, "blockTag" | "enableCcipRead">;
type ViewOverrides = Omit<TransactionRequest, "to" | "data">;
type Overrides<S extends StateMutability> = S extends "nonpayable" ? NonPayableOverrides : S extends "payable" ? PayableOverrides : ViewOverrides;
type PostfixOverrides<A extends Array<any>, S extends StateMutability> = A | [...A, Overrides<S>];
type ContractMethodArgs<A extends Array<any>, S extends StateMutability> = PostfixOverrides<{
    [I in keyof A]-?: A[I] | Typed;
}, S>;
type DefaultReturnType<R> = R extends Array<any> ? R[0] : R;
interface TypedContractMethod<A extends Array<any> = Array<any>, R = any, S extends StateMutability = "payable"> {
    (...args: ContractMethodArgs<A, S>): S extends "view" ? Promise<DefaultReturnType<R>> : Promise<ContractTransactionResponse>;
    name: string;
    fragment: FunctionFragment;
    getFragment(...args: ContractMethodArgs<A, S>): FunctionFragment;
    populateTransaction(...args: ContractMethodArgs<A, S>): Promise<ContractTransaction>;
    staticCall(...args: ContractMethodArgs<A, "view">): Promise<DefaultReturnType<R>>;
    send(...args: ContractMethodArgs<A, S>): Promise<ContractTransactionResponse>;
    estimateGas(...args: ContractMethodArgs<A, S>): Promise<bigint>;
    staticCallResult(...args: ContractMethodArgs<A, "view">): Promise<R>;
}

interface IdentityVerificationHubImplInterface extends Interface {
    getFunction(nameOrSignature: "discloseVerifier" | "registry"): FunctionFragment;
    encodeFunctionData(functionFragment: "discloseVerifier", values: [BytesLike]): string;
    encodeFunctionData(functionFragment: "registry", values: [BytesLike]): string;
    decodeFunctionResult(functionFragment: "discloseVerifier", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "registry", data: BytesLike): Result;
}
interface IdentityVerificationHubImpl extends BaseContract {
    connect(runner?: ContractRunner | null): IdentityVerificationHubImpl;
    waitForDeployment(): Promise<this>;
    interface: IdentityVerificationHubImplInterface;
    queryFilter<TCEvent extends TypedContractEvent>(event: TCEvent, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TypedEventLog<TCEvent>>>;
    queryFilter<TCEvent extends TypedContractEvent>(filter: TypedDeferredTopicFilter<TCEvent>, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TypedEventLog<TCEvent>>>;
    on<TCEvent extends TypedContractEvent>(event: TCEvent, listener: TypedListener<TCEvent>): Promise<this>;
    on<TCEvent extends TypedContractEvent>(filter: TypedDeferredTopicFilter<TCEvent>, listener: TypedListener<TCEvent>): Promise<this>;
    once<TCEvent extends TypedContractEvent>(event: TCEvent, listener: TypedListener<TCEvent>): Promise<this>;
    once<TCEvent extends TypedContractEvent>(filter: TypedDeferredTopicFilter<TCEvent>, listener: TypedListener<TCEvent>): Promise<this>;
    listeners<TCEvent extends TypedContractEvent>(event: TCEvent): Promise<Array<TypedListener<TCEvent>>>;
    listeners(eventName?: string): Promise<Array<Listener>>;
    removeAllListeners<TCEvent extends TypedContractEvent>(event?: TCEvent): Promise<this>;
    discloseVerifier: TypedContractMethod<[
        attestationId: BytesLike
    ], [
        string
    ], "view">;
    registry: TypedContractMethod<[attestationId: BytesLike], [string], "view">;
    getFunction<T extends ContractMethod = ContractMethod>(key: string | FunctionFragment): T;
    getFunction(nameOrSignature: "discloseVerifier"): TypedContractMethod<[attestationId: BytesLike], [string], "view">;
    getFunction(nameOrSignature: "registry"): TypedContractMethod<[attestationId: BytesLike], [string], "view">;
    filters: {};
}

interface IConfigStorage {
    /**
     * Get the verification config for a given id
     * @param id - An identifiier associated with the verification config
     * @returns The verification config
     */
    getConfig(id: string): Promise<VerificationConfig>;
    /**
     * Set the verification config for a given id
     * @param id - An identifiier associated with the verification config
     * @param config - The verification config
     * @returns True if a config was replaced, false if a new config was set
     */
    setConfig(id: string, config: VerificationConfig): Promise<boolean>;
    /**
     * Get the action id for given user defined data passed in the frontend
     * @param data - The user defined data passed in the frontend
     * @returns The action id
     */
    getActionId(userIdentifier: string, data: string): Promise<string>;
}

declare class SelfBackendVerifier {
    protected scope: string;
    protected identityVerificationHubContract: IdentityVerificationHubImpl;
    protected configStorage: IConfigStorage;
    protected provider: ethers.JsonRpcProvider;
    protected allowedIds: Map<AttestationId, boolean>;
    protected userIdentifierType: UserIdType;
    constructor(scope: string, endpoint: string, mockPassport: boolean, allowedIds: Map<AttestationId, boolean>, configStorage: IConfigStorage, userIdentifierType: UserIdType);
    verify(attestationId: AttestationId, proof: VcAndDiscloseProof, pubSignals: BigNumberish[], userContextData: string): Promise<{
        attestationId: 1 | 2;
        isValidDetails: {
            isValid: boolean;
            isMinimumAgeValid: boolean;
            isOfacValid: boolean;
        };
        forbiddenCountriesList: string[];
        discloseOutput: GenericDiscloseOutput;
        userData: {
            userIdentifier: string;
            userDefinedData: string;
        };
    }>;
}

declare class DefaultConfigStore implements IConfigStorage {
    private config;
    constructor(config: VerificationConfig);
    getConfig(_id: string): Promise<VerificationConfig>;
    setConfig(_id: string, config: VerificationConfig): Promise<boolean>;
    getActionId(_userIdentifier: string, _data: string): Promise<string>;
}

declare class InMemoryConfigStore implements IConfigStorage {
    private configs;
    private getActionIdFunc;
    constructor(getActionIdFunc: IConfigStorage['getActionId']);
    getActionId(userIdentifier: string, userDefinedData: string): Promise<string>;
    setConfig(configId: string, config: VerificationConfig): Promise<boolean>;
    getConfig(configId: string): Promise<VerificationConfig>;
}

export { AllIds, type AttestationId, DefaultConfigStore, type IConfigStorage, InMemoryConfigStore, SelfBackendVerifier, type VerificationConfig, type VerificationResult };

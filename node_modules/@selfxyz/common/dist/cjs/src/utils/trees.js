"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getLeaf = getLeaf;
exports.getLeafDscTreeFromDscCertificateMetadata = getLeafDscTreeFromDscCertificateMetadata;
exports.getLeafDscTreeFromParsedDsc = getLeafDscTreeFromParsedDsc;
exports.getLeafDscTree = getLeafDscTree;
exports.getLeafCscaTree = getLeafCscaTree;
exports.getDscTreeInclusionProof = getDscTreeInclusionProof;
exports.getCscaTreeInclusionProof = getCscaTreeInclusionProof;
exports.getCscaTreeRoot = getCscaTreeRoot;
exports.formatRoot = formatRoot;
exports.generateSMTProof = generateSMTProof;
exports.generateMerkleProof = generateMerkleProof;
exports.buildSMT = buildSMT;
exports.getCountryLeaf = getCountryLeaf;
exports.getPassportNumberAndNationalityLeaf = getPassportNumberAndNationalityLeaf;
exports.getNameDobLeaf = getNameDobLeaf;
exports.getNameYobLeaf = getNameYobLeaf;
exports.getNameLeaf = getNameLeaf;
exports.getDobLeaf = getDobLeaf;
const zk_kit_imt_1 = require("@openpassport/zk-kit-imt");
const zk_kit_lean_imt_1 = require("@openpassport/zk-kit-lean-imt");
const zk_kit_smt_1 = require("@openpassport/zk-kit-smt");
const i18n_iso_countries_1 = __importDefault(require("i18n-iso-countries"));
// @ts-ignore
const en_json_1 = __importDefault(require("i18n-iso-countries/langs/en.json"));
const poseidon_lite_1 = require("poseidon-lite");
const parseCertificateSimple_js_1 = require("./certificate_parsing/parseCertificateSimple.js");
const constants_js_1 = require("../constants/constants.js");
const constants_js_2 = require("../constants/constants.js");
const uuid_js_1 = require("./circuits/uuid.js");
const hash_js_1 = require("./hash.js");
const passport_js_1 = require("./passports/passport.js");
const parseDscCertificateData_js_1 = require("./passports/passport_parsing/parseDscCertificateData.js");
// SideEffect here
i18n_iso_countries_1.default.registerLocale(en_json_1.default);
/** get leaf for DSC and CSCA Trees */
function getLeaf(parsed, type) {
    if (type === 'dsc') {
        // for now, we pad it for sha
        const tbsArray = Object.keys(parsed.tbsBytes).map((key) => parsed.tbsBytes[key]);
        const [paddedTbsBytes, tbsBytesPaddedLength] = (0, passport_js_1.pad)(parsed.hashAlgorithm)(tbsArray, constants_js_2.max_dsc_bytes);
        const dsc_hash = (0, hash_js_1.packBytesAndPoseidon)(Array.from(paddedTbsBytes));
        return (0, poseidon_lite_1.poseidon2)([dsc_hash, tbsArray.length]).toString();
    }
    else {
        const tbsBytesArray = Array.from(parsed.tbsBytes);
        const paddedTbsBytesArray = tbsBytesArray.concat(new Array(constants_js_1.max_csca_bytes - tbsBytesArray.length).fill(0));
        const csca_hash = (0, hash_js_1.packBytesAndPoseidon)(paddedTbsBytesArray);
        return (0, poseidon_lite_1.poseidon2)([csca_hash, tbsBytesArray.length]).toString();
    }
}
function getLeafDscTreeFromDscCertificateMetadata(dscParsed, dscMetaData) {
    // TODO: WRONG  change this function using raw dsc and hashfunctions from passportMetadata
    const cscaParsed = (0, parseCertificateSimple_js_1.parseCertificateSimple)(dscMetaData.csca);
    return getLeafDscTree(dscParsed, cscaParsed);
}
function getLeafDscTreeFromParsedDsc(dscParsed) {
    return getLeafDscTreeFromDscCertificateMetadata(dscParsed, (0, parseDscCertificateData_js_1.parseDscCertificateData)(dscParsed));
}
function getLeafDscTree(dsc_parsed, csca_parsed) {
    const dscLeaf = getLeaf(dsc_parsed, 'dsc');
    const cscaLeaf = getLeaf(csca_parsed, 'csca');
    return (0, poseidon_lite_1.poseidon2)([dscLeaf, cscaLeaf]).toString();
}
function getLeafCscaTree(csca_parsed) {
    return getLeaf(csca_parsed, 'csca');
}
function getDscTreeInclusionProof(leaf, serialized_dsc_tree) {
    const hashFunction = (a, b) => (0, poseidon_lite_1.poseidon2)([a, b]);
    const tree = zk_kit_lean_imt_1.LeanIMT.import(hashFunction, serialized_dsc_tree);
    const index = tree.indexOf(BigInt(leaf));
    if (index === -1) {
        throw new Error('Your public key was not found in the registry');
    }
    const { siblings, path, leaf_depth } = generateMerkleProof(tree, index, constants_js_1.DSC_TREE_DEPTH);
    return [tree.root, path, siblings, leaf_depth];
}
function getCscaTreeInclusionProof(leaf, _serialized_csca_tree) {
    let tree = new zk_kit_imt_1.IMT(poseidon_lite_1.poseidon2, constants_js_1.CSCA_TREE_DEPTH, 0, 2);
    tree.setNodes(_serialized_csca_tree);
    const index = tree.indexOf(leaf);
    if (index === -1) {
        throw new Error('Your public key was not found in the registry');
    }
    const proof = tree.createProof(index);
    return [
        tree.root,
        proof.pathIndices.map((index) => index.toString()),
        proof.siblings.flat().map((sibling) => sibling.toString()),
    ];
}
function getCscaTreeRoot(serialized_csca_tree) {
    let tree = new zk_kit_imt_1.IMT(poseidon_lite_1.poseidon2, constants_js_1.CSCA_TREE_DEPTH, 0, 2);
    tree.setNodes(serialized_csca_tree);
    return tree.root;
}
function formatRoot(root) {
    let rootHex = BigInt(root).toString(16);
    return rootHex.length % 2 === 0 ? '0x' + rootHex : '0x0' + rootHex;
}
function generateSMTProof(smt, leaf) {
    const { entry, matchingEntry, siblings, root, membership } = smt.createProof(leaf);
    const leaf_depth = siblings.length;
    let closestleaf;
    if (!matchingEntry) {
        // we got the 0 leaf or membership
        // then check if entry[1] exists
        if (!entry[1]) {
            // non membership proof
            closestleaf = BigInt(0); // 0 leaf
        }
        else {
            closestleaf = BigInt(entry[0]); // leaf itself (memb proof)
        }
    }
    else {
        // non membership proof
        closestleaf = BigInt(matchingEntry[0]); // actual closest
    }
    // PATH, SIBLINGS manipulation as per binary tree in the circuit
    siblings.reverse();
    while (siblings.length < constants_js_1.OFAC_TREE_LEVELS)
        siblings.push(BigInt(0));
    // ----- Useful for debugging hence leaving as comments -----
    // const binary = entry[0].toString(2)
    // const bits = binary.slice(-leaf_depth);
    // let indices = bits.padEnd(256, "0").split("").map(Number)
    // const pathToMatch = num2Bits(256,BigInt(entry[0]))
    // while(indices.length < 256) indices.push(0);
    // // CALCULATED ROOT FOR TESTING
    // // closestleaf, leaf_depth, siblings, indices, root : needed
    // let calculatedNode = poseidon3([closestleaf,1,1]);
    // console.log("Initial node while calculating",calculatedNode)
    // console.log(smt.verifyProof(smt.createProof(leaf)))
    // for (let i= 0; i < leaf_depth ; i++) {
    //   const childNodes: any = indices[i] ? [siblings[i], calculatedNode] : [calculatedNode, siblings[i]]
    //   console.log(indices[i],childNodes)
    //   calculatedNode = poseidon2(childNodes)
    // }
    // console.log("Actual node", root)
    // console.log("calculated node", calculatedNode)
    // -----------------------------------------------------------
    return {
        root,
        leaf_depth,
        closestleaf,
        siblings,
    };
}
function generateMerkleProof(imt, _index, maxleaf_depth) {
    const { siblings: siblings, index } = imt.generateProof(_index);
    const leaf_depth = siblings.length;
    // The index must be converted to a list of indices, 1 for each tree level.
    // The circuit tree leaf_depth is 20, so the number of siblings must be 20, even if
    // the tree leaf_depth is actually 3. The missing siblings can be set to 0, as they
    // won't be used to calculate the root in the circuit.
    const path = [];
    for (let i = 0; i < maxleaf_depth; i += 1) {
        path.push((index >> i) & 1);
        if (siblings[i] === undefined) {
            siblings[i] = BigInt(0);
        }
    }
    return { siblings, path, leaf_depth };
}
// SMT trees for 3 levels of matching :
// 1. Passport Number and Nationality tree : level 3 (Absolute Match)
// 2. Name and date of birth combo tree : level 2 (High Probability Match)
// 3. Name and year of birth combo tree : level 1 (Partial Match)
// NEW: ID card specific trees
function buildSMT(field, treetype) {
    let count = 0;
    let startTime = performance.now();
    const hash2 = (childNodes) => childNodes.length === 2 ? (0, poseidon_lite_1.poseidon2)(childNodes) : (0, poseidon_lite_1.poseidon3)(childNodes);
    const tree = new zk_kit_smt_1.SMT(hash2, true);
    for (let i = 0; i < field.length; i++) {
        const entry = field[i];
        // Optimization: Log progress less frequently
        if (i !== 0 && i % 100 === 0) {
            console.log('Processing', treetype, 'number', i, 'out of', field.length);
        }
        let leaf = BigInt(0);
        // Determine document type based on treetype for name processing
        let docType = 'passport'; // Default to passport
        if (treetype.endsWith('_id_card')) {
            docType = 'id_card';
        }
        if (treetype == 'passport_no_and_nationality') {
            leaf = processPassportNoAndNationality(entry.Pass_No, entry.Pass_Country, i);
        }
        else if (treetype == 'name_and_dob') {
            leaf = processNameAndDob(entry, i, 'passport'); // Explicitly passport
        }
        else if (treetype == 'name_and_yob') {
            leaf = processNameAndYob(entry, i, 'passport'); // Explicitly passport
        }
        else if (treetype == 'name_and_dob_id_card') {
            // New ID card type
            leaf = processNameAndDob(entry, i, 'id_card');
        }
        else if (treetype == 'name_and_yob_id_card') {
            // New ID card type
            leaf = processNameAndYob(entry, i, 'id_card');
        }
        else if (treetype == 'country') {
            const keys = Object.keys(entry);
            leaf = processCountry(keys[0], entry[keys[0]], i);
        }
        if (leaf == BigInt(0)) {
            // Skip entries that couldn't be processed (e.g., missing data)
            continue;
        }
        // Check for duplicates *after* processing, as different inputs might yield the same hash
        if (tree.createProof(leaf).membership) {
            // console.log('Duplicate leaf generated, skipping entry:', i, entry); // Optional: log duplicates
            continue;
        }
        count += 1;
        tree.add(leaf, BigInt(1));
    }
    console.log('Total', treetype, 'entries added:', count, 'out of', field.length);
    console.log(treetype, 'tree built in', (performance.now() - startTime).toFixed(2), 'ms');
    return [count, performance.now() - startTime, tree];
}
function processPassportNoAndNationality(passno, nationality, index) {
    if (passno.length > 9) {
        console.log('passport number length is greater than 9:', index, passno);
    }
    else if (passno.length < 9) {
        while (passno.length != 9) {
            passno += '<';
        }
    }
    const countryCode = getCountryCode(nationality);
    if (!countryCode) {
        console.log('Error getting country code', index, nationality);
        return BigInt(0);
    }
    console.log('nationality and countryCode', nationality, countryCode);
    const leaf = getPassportNumberAndNationalityLeaf((0, uuid_js_1.stringToAsciiBigIntArray)(passno), (0, uuid_js_1.stringToAsciiBigIntArray)(countryCode), index);
    if (!leaf) {
        console.log('Error creating leaf value', index, passno, nationality);
        return BigInt(0);
    }
    return leaf;
}
// this is a temporary workaround for some of the country name,
// will be removed once we parse the OFAC list better, starting from the XML file.
const normalizeCountryName = (country) => {
    const mapping = {
        palestinian: 'Palestine',
        'korea, north': 'North Korea',
        'korea, south': 'Korea, Republic of',
        'united kingdom': 'United Kingdom',
        syria: 'Syrian Arab Republic',
        burma: 'Myanmar',
        'cabo verde': 'Cape Verde',
        'congo, democratic republic of the': 'Democratic Republic of the Congo',
        macau: 'Macao',
    };
    return mapping[country.toLowerCase()] || country;
};
const getCountryCode = (countryName) => {
    return i18n_iso_countries_1.default.getAlpha3Code(normalizeCountryName(countryName), 'en');
};
function generateSmallKey(input) {
    return input % (BigInt(1) << BigInt(constants_js_1.OFAC_TREE_LEVELS));
}
function processNameAndDob(entry, i, docType) {
    const firstName = entry.First_Name;
    const lastName = entry.Last_Name;
    const day = entry.day;
    const month = entry.month;
    const year = entry.year;
    if (day == null || month == null || year == null || !firstName || !lastName) {
        // Added checks for name presence
        // console.log('Name or DOB data missing for name_and_dob', i, entry); // Optional: log missing data
        return BigInt(0);
    }
    const targetLength = docType === 'passport' ? 39 : 30;
    const nameHash = processName(firstName, lastName, targetLength, i);
    if (nameHash === BigInt(0))
        return BigInt(0); // Propagate error
    const dobHash = processDob(day, month, year, i);
    if (dobHash === BigInt(0))
        return BigInt(0); // Propagate error
    return generateSmallKey((0, poseidon_lite_1.poseidon2)([dobHash, nameHash]));
}
function processNameAndYob(entry, i, docType) {
    const firstName = entry.First_Name;
    const lastName = entry.Last_Name;
    const year = entry.year;
    if (year == null || !firstName || !lastName) {
        // Added checks for name presence
        // console.log('Name or YOB data missing for name_and_yob', i, entry); // Optional: log missing data
        return BigInt(0);
    }
    const targetLength = docType === 'passport' ? 39 : 30;
    const nameHash = processName(firstName, lastName, targetLength, i);
    if (nameHash === BigInt(0))
        return BigInt(0); // Propagate error
    const yearHash = processYear(year, i);
    if (yearHash === BigInt(0))
        return BigInt(0); // Propagate error
    return generateSmallKey((0, poseidon_lite_1.poseidon2)([yearHash, nameHash]));
}
function processYear(year, i) {
    if (!year || typeof year !== 'string' || year.length < 2) {
        // console.log('Invalid year format for processYear', i, year); // Optional: log error
        return BigInt(0);
    }
    const yearSuffix = year.slice(-2);
    const yearArr = (0, uuid_js_1.stringToAsciiBigIntArray)(yearSuffix);
    return getYearLeaf(yearArr);
}
function getYearLeaf(yearArr) {
    if (yearArr.length !== 2) {
        // console.log('Invalid year array length for getYearLeaf', yearArr); // Optional: log error
        return BigInt(0);
    }
    try {
        return (0, poseidon_lite_1.poseidon2)(yearArr);
    }
    catch (err) {
        // console.log('err : Year hash', err, yearArr); // Optional: log error
        return BigInt(0);
    }
}
function processName(firstName, lastName, targetLength, i) {
    // LASTNAME<<FIRSTNAME<MIDDLENAME<<<...
    // Ensure names are strings before processing
    const cleanFirstName = typeof firstName === 'string'
        ? firstName.replace(/'/g, '').replace(/\./g, '').replace(/[- ]/g, '<')
        : '';
    const cleanLastName = typeof lastName === 'string'
        ? lastName.replace(/'/g, '').replace(/[- ]/g, '<').replace(/\./g, '')
        : '';
    // Handle cases where one name might be missing
    let arr = (cleanLastName ? cleanLastName + '<<' : '') + cleanFirstName;
    if (arr.length === 0) {
        // console.log('Cannot process empty name string', i); // Optional: log error
        return BigInt(0);
    }
    // Pad or truncate to target length
    if (arr.length > targetLength) {
        arr = arr.substring(0, targetLength);
    }
    else {
        while (arr.length < targetLength) {
            arr += '<';
        }
    }
    console.log('arr', arr, 'arr.length', arr.length);
    let nameArr = (0, uuid_js_1.stringToAsciiBigIntArray)(arr);
    // getNameLeaf will select the correct Poseidon hash based on nameArr.length
    return getNameLeaf(nameArr, i);
}
function processDob(day, month, year, i) {
    // YYMMDD
    const monthMap = {
        jan: '01',
        feb: '02',
        mar: '03',
        apr: '04',
        may: '05',
        jun: '06',
        jul: '07',
        aug: '08',
        sep: '09',
        oct: '10',
        nov: '11',
        dec: '12',
    };
    const lowerMonth = typeof month === 'string' ? month.toLowerCase() : '';
    const mappedMonth = monthMap[lowerMonth];
    if (!mappedMonth ||
        !day ||
        typeof day !== 'string' ||
        day.length !== 2 ||
        !year ||
        typeof year !== 'string' ||
        year.length < 2) {
        // console.log('Invalid DOB component format for processDob', i, {day, month, year}); // Optional: log error
        return BigInt(0);
    }
    const yearSuffix = year.slice(-2);
    const dob = yearSuffix + mappedMonth + day;
    let arr = (0, uuid_js_1.stringToAsciiBigIntArray)(dob);
    return getDobLeaf(arr, i);
}
function processCountry(country1, country2, i) {
    let arr = (0, uuid_js_1.stringToAsciiBigIntArray)(country1);
    let arr2 = (0, uuid_js_1.stringToAsciiBigIntArray)(country2);
    const leaf = getCountryLeaf(arr, arr2, i);
    if (!leaf) {
        console.log('Error creating leaf value', i, country1, country2);
        return BigInt(0);
    }
    return leaf;
}
function getCountryLeaf(country_by, country_to, i) {
    if (country_by.length !== 3 || country_to.length !== 3) {
        console.log('parsed passport length is not 3:', i, country_to, country_by);
        return;
    }
    try {
        const country = country_by.concat(country_to);
        return (0, poseidon_lite_1.poseidon6)(country);
    }
    catch (err) {
        console.log('err : sanc_country hash', err, i, country_by, country_to);
    }
}
function getPassportNumberAndNationalityLeaf(passport, nationality, i) {
    if (passport.length !== 9) {
        console.log('parsed passport length is not 9:', i, passport);
        return;
    }
    if (nationality.length !== 3) {
        console.log('parsed nationality length is not 3:', i, nationality);
        return;
    }
    try {
        const fullHash = (0, poseidon_lite_1.poseidon12)(passport.concat(nationality));
        return generateSmallKey(fullHash);
    }
    catch (err) {
        console.log('err : passport', err, i, passport);
    }
}
function getNameDobLeaf(nameMrz, dobMrz, i) {
    return generateSmallKey((0, poseidon_lite_1.poseidon2)([getDobLeaf(dobMrz), getNameLeaf(nameMrz)]));
}
function getNameYobLeaf(nameMrz, yobMrz, i) {
    return generateSmallKey((0, poseidon_lite_1.poseidon2)([getYearLeaf(yobMrz), getNameLeaf(nameMrz)]));
}
function getNameLeaf(nameMrz, i) {
    let middleChunks = [];
    let chunks = [];
    try {
        // Add try-catch block
        if (nameMrz.length == 39) {
            // passport
            chunks.push(nameMrz.slice(0, 13), nameMrz.slice(13, 26), nameMrz.slice(26, 39));
            for (const chunk of chunks) {
                if (chunk.length !== 13)
                    throw new Error(`Invalid chunk length for Poseidon13: ${chunk.length}`);
                middleChunks.push((0, poseidon_lite_1.poseidon13)(chunk));
            }
        }
        else if (nameMrz.length == 30) {
            // id_card
            chunks.push(nameMrz.slice(0, 10), nameMrz.slice(10, 20), nameMrz.slice(20, 30)); // Corrected comment: 30/3 for poseidon10
            for (const chunk of chunks) {
                if (chunk.length !== 10)
                    throw new Error(`Invalid chunk length for Poseidon10: ${chunk.length}`);
                middleChunks.push((0, poseidon_lite_1.poseidon10)(chunk));
            }
        }
        else {
            throw new Error(`Unsupported name MRZ length: ${nameMrz.length}`); // Handle unexpected lengths
        }
        if (middleChunks.length !== 3)
            throw new Error(`Invalid number of middle chunks: ${middleChunks.length}`);
        return (0, poseidon_lite_1.poseidon3)(middleChunks);
    }
    catch (err) {
        console.error('Error in getNameLeaf:', err, 'Index:', i, 'MRZ Length:', nameMrz.length); // Use console.error for errors
        // console.log('MRZ data:', nameMrz); // Optional: log failing data
        return BigInt(0); // Return 0 on error
    }
}
function getDobLeaf(dobMrz, i) {
    if (dobMrz.length !== 6) {
        // console.log('parsed dob length is not 6:', i, dobMrz); // Corrected length check message
        return BigInt(0); // Return 0 for invalid length
    }
    try {
        return (0, poseidon_lite_1.poseidon6)(dobMrz);
    }
    catch (err) {
        console.error('Error in getDobLeaf:', err, 'Index:', i, 'DOB MRZ:', dobMrz); // Use console.error
        return BigInt(0); // Return 0 on error
    }
}

"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.genMockPassportData = genMockPassportData;
exports.genAndInitMockPassportData = genAndInitMockPassportData;
const asn1 = __importStar(require("asn1js"));
const elliptic_1 = __importDefault(require("elliptic"));
const forge = __importStar(require("node-forge"));
const curves_js_1 = require("../certificate_parsing/curves.js");
const parseCertificateSimple_js_1 = require("../certificate_parsing/parseCertificateSimple.js");
const hash_js_1 = require("../hash.js");
const format_js_1 = require("./format.js");
const passport_js_1 = require("./passport.js");
const getMockDSC_js_1 = __importDefault(require("./getMockDSC.js"));
function generateRandomBytes(length) {
    // Generate numbers between -128 and 127 to match the existing signed byte format
    return Array.from({ length }, () => Math.floor(Math.random() * 256) - 128);
}
function generateDataGroupHashes(mrzHash, hashLen) {
    // Generate hashes for DGs 2-15 (excluding some DGs that aren't typically used)
    const dataGroups = [
        [1, mrzHash], // DG1 must be the MRZ hash
        [2, generateRandomBytes(hashLen)],
        [3, generateRandomBytes(hashLen)],
        [4, generateRandomBytes(hashLen)],
        [5, generateRandomBytes(hashLen)],
        [7, generateRandomBytes(hashLen)],
        [8, generateRandomBytes(hashLen)],
        // [11, generateRandomBytes(hashLen)],
        // [12, generateRandomBytes(hashLen)],
        // [14, generateRandomBytes(hashLen)],
        [15, generateRandomBytes(hashLen)],
    ];
    return dataGroups;
}
function genMockPassportData(dgHashAlgo, eContentHashAlgo, signatureType, nationality, birthDate, expiryDate, passportNumber = '15AA81234', lastName = 'DUPONT', firstName = 'ALPHONSE HUGHUES ALBERT') {
    if (birthDate.length !== 6 || expiryDate.length !== 6) {
        throw new Error('birthdate and expiry date have to be in the "YYMMDD" format');
    }
    // Prepare last name: Convert to uppercase, remove invalid characters, split by spaces, and join with '<'
    const lastNameParts = lastName
        .toUpperCase()
        .replace(/[^A-Z< ]/g, '')
        .split(' ');
    const formattedLastName = lastNameParts.join('<');
    // Prepare first name: Convert to uppercase, remove invalid characters, split by spaces, and join with '<'
    const firstNameParts = firstName
        .toUpperCase()
        .replace(/[^A-Z< ]/g, '')
        .split(' ');
    const formattedFirstName = firstNameParts.join('<');
    // Build the first line of MRZ
    let mrzLine1 = `P<${nationality}${formattedLastName}<<${formattedFirstName}`;
    // Pad the first line with '<' to make it exactly 44 characters
    mrzLine1 = mrzLine1.padEnd(44, '<');
    if (mrzLine1.length > 44) {
        throw new Error('First line of MRZ exceeds 44 characters');
    }
    // Build the second line of MRZ
    const mrzLine2 = `${passportNumber}4${nationality}${birthDate}1M${expiryDate}5<<<<<<<<<<<<<<02`;
    // Combine both lines to form the MRZ
    const mrz = mrzLine1 + mrzLine2;
    // Validate the MRZ length
    if (mrz.length !== 88) {
        throw new Error(`MRZ must be 88 characters long, got ${mrz.length}`);
    }
    const { privateKeyPem, dsc } = (0, getMockDSC_js_1.default)(signatureType);
    // Generate MRZ hash first
    const mrzHash = (0, hash_js_1.hash)(dgHashAlgo, (0, format_js_1.formatMrz)(mrz));
    // Generate random hashes for other DGs, passing mrzHash for DG1
    const dataGroupHashes = generateDataGroupHashes(mrzHash, (0, hash_js_1.getHashLen)(dgHashAlgo));
    const eContent = (0, format_js_1.formatAndConcatenateDataHashes)(dataGroupHashes, 63);
    const signedAttr = (0, format_js_1.generateSignedAttr)((0, hash_js_1.hash)(eContentHashAlgo, eContent));
    const hashAlgo = signatureType.split('_')[1];
    const signature = sign(privateKeyPem, dsc, hashAlgo, signedAttr);
    const signatureBytes = Array.from(signature, (byte) => (byte < 128 ? byte : byte - 256));
    return {
        dsc: dsc,
        mrz: mrz,
        dg2Hash: dataGroupHashes.find(([dgNum]) => dgNum === 2)?.[1] || [],
        eContent: eContent,
        signedAttr: signedAttr,
        encryptedDigest: signatureBytes,
        documentType: 'mock_passport',
        documentCategory: 'passport',
        mock: true,
    };
}
function genAndInitMockPassportData(dgHashAlgo, eContentHashAlgo, signatureType, nationality, birthDate, expiryDate, passportNumber = '15AA81234', lastName = 'DUPONT', firstName = 'ALPHONSE HUGHUES ALBERT') {
    return (0, passport_js_1.initPassportDataParsing)(genMockPassportData(dgHashAlgo, eContentHashAlgo, signatureType, nationality, birthDate, expiryDate, passportNumber, lastName, firstName));
}
function sign(privateKeyPem, dsc, hashAlgorithm, eContent) {
    const actualForge = forge.pki ? forge : forge.default;
    const { signatureAlgorithm, publicKeyDetails } = (0, parseCertificateSimple_js_1.parseCertificateSimple)(dsc);
    if (signatureAlgorithm === 'rsapss') {
        const privateKey = actualForge.pki.privateKeyFromPem(privateKeyPem);
        const md = actualForge.md[hashAlgorithm].create();
        md.update(actualForge.util.binary.raw.encode(new Uint8Array(eContent)));
        const pss = actualForge.pss.create({
            md: actualForge.md[hashAlgorithm].create(),
            mgf: actualForge.mgf.mgf1.create(actualForge.md[hashAlgorithm].create()),
            saltLength: parseInt(publicKeyDetails.saltLength),
        });
        const signatureBytes = privateKey.sign(md, pss);
        return Array.from(signatureBytes, (c) => c.charCodeAt(0));
    }
    else if (signatureAlgorithm === 'ecdsa') {
        const curve = publicKeyDetails.curve;
        let curveForElliptic = (0, curves_js_1.getCurveForElliptic)(curve);
        const ec = new elliptic_1.default.ec(curveForElliptic);
        const privateKeyDer = Buffer.from(privateKeyPem.replace(/-----BEGIN EC PRIVATE KEY-----|\n|-----END EC PRIVATE KEY-----/g, ''), 'base64');
        const asn1Data = asn1.fromBER(privateKeyDer);
        const privateKeyBuffer = asn1Data.result.valueBlock.value[1].valueBlock.valueHexView;
        const keyPair = ec.keyFromPrivate(privateKeyBuffer);
        const msgHash = (0, hash_js_1.hash)(hashAlgorithm, eContent, 'hex');
        const signature = keyPair.sign(msgHash, 'hex');
        // @ts-ignore-error this seems wrong
        const signatureBytes = Array.from(Buffer.from(signature.toDER(), 'hex'));
        return signatureBytes;
    }
    else {
        const privKey = actualForge.pki.privateKeyFromPem(privateKeyPem);
        const md = actualForge.md[hashAlgorithm].create();
        md.update(actualForge.util.binary.raw.encode(new Uint8Array(eContent)));
        const forgeSignature = privKey.sign(md);
        return Array.from(forgeSignature, (c) => c.charCodeAt(0));
    }
}

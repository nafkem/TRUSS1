"use strict";
// generate a mock id document
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateMockDSC = generateMockDSC;
exports.genMockIdDoc = genMockIdDoc;
exports.genMockIdDocAndInitDataParsing = genMockIdDocAndInitDataParsing;
const constants_js_1 = require("../../constants/constants.js");
const countries_js_1 = require("../../constants/countries.js");
const dg1_js_1 = require("./dg1.js");
const hash_js_1 = require("../hash.js");
const format_js_1 = require("./format.js");
const node_forge_1 = __importDefault(require("node-forge"));
const elliptic_1 = __importDefault(require("elliptic"));
const getMockDSC_js_1 = __importDefault(require("./getMockDSC.js"));
const parseCertificateSimple_js_1 = require("../certificate_parsing/parseCertificateSimple.js");
const curves_js_1 = require("../certificate_parsing/curves.js");
const asn1 = __importStar(require("asn1js"));
const passport_js_1 = require("./passport.js");
const defaultIdDocInput = {
    idType: 'mock_passport',
    dgHashAlgo: 'sha256',
    eContentHashAlgo: 'sha256',
    signatureType: 'rsa_sha256_65537_2048',
    nationality: countries_js_1.countries.UNITED_STATES,
    birthDate: '900101',
    expiryDate: '300101',
    passportNumber: '123456789',
    lastName: 'DOE',
    firstName: 'JOHN',
    sex: 'M',
};
async function generateMockDSC(signatureType) {
    const response = await fetch(`${constants_js_1.API_URL_STAGING}/api/v2/generate-dsc`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ signatureType }),
    });
    if (!response.ok) {
        throw new Error(`Failed to generate DSC: ${response.status} ${response.statusText}`);
    }
    const data = await response.json();
    if (!data || !data.data) {
        throw new Error('Missing data in server response');
    }
    if (typeof data.data.privateKeyPem !== 'string' || typeof data.data.dsc !== 'string') {
        throw new Error('Invalid DSC response format from server');
    }
    return { privateKeyPem: data.data.privateKeyPem, dsc: data.data.dsc };
}
function genMockIdDoc(userInput = {}, mockDSC) {
    const mergedInput = {
        ...defaultIdDocInput,
        ...userInput,
    };
    let privateKeyPem, dsc;
    if (mockDSC) {
        dsc = mockDSC.dsc;
        privateKeyPem = mockDSC.privateKeyPem;
    }
    else {
        ({ privateKeyPem, dsc } = (0, getMockDSC_js_1.default)(mergedInput.signatureType));
    }
    const dg1 = (0, dg1_js_1.genDG1)(mergedInput);
    const dg1_hash = (0, hash_js_1.hash)(mergedInput.dgHashAlgo, (0, format_js_1.formatMrz)(dg1));
    const dataGroupHashes = generateDataGroupHashes(dg1_hash, (0, hash_js_1.getHashLen)(mergedInput.dgHashAlgo));
    const eContent = (0, format_js_1.formatAndConcatenateDataHashes)(dataGroupHashes, 63);
    const eContentHash = (0, hash_js_1.hash)(mergedInput.eContentHashAlgo, eContent);
    const signedAttr = (0, format_js_1.generateSignedAttr)(eContentHash);
    const hashAlgo = mergedInput.signatureType.split('_')[1];
    const signature = sign(privateKeyPem, dsc, hashAlgo, signedAttr);
    const signatureBytes = Array.from(signature, (byte) => (byte < 128 ? byte : byte - 256));
    return {
        dsc: dsc,
        mrz: dg1,
        dg2Hash: dataGroupHashes.find(([dgNum]) => dgNum === 2)?.[1] || [],
        eContent: eContent,
        signedAttr: signedAttr,
        encryptedDigest: signatureBytes,
        documentType: mergedInput.idType,
        documentCategory: mergedInput.idType === 'mock_passport' ? 'passport' : 'id_card',
        mock: true,
    };
}
function genMockIdDocAndInitDataParsing(userInput = {}) {
    return (0, passport_js_1.initPassportDataParsing)({
        ...genMockIdDoc(userInput),
    });
}
function generateRandomBytes(length) {
    // Generate numbers between -128 and 127 to match the existing signed byte format
    return Array.from({ length }, () => Math.floor(Math.random() * 256) - 128);
}
function generateDataGroupHashes(mrzHash, hashLen) {
    // Generate hashes for DGs 2-15 (excluding some DGs that aren't typically used)
    const dataGroups = [
        [1, mrzHash], // DG1 must be the MRZ hash
        [2, generateRandomBytes(hashLen)],
        [3, generateRandomBytes(hashLen)],
        [4, generateRandomBytes(hashLen)],
        [5, generateRandomBytes(hashLen)],
        [7, generateRandomBytes(hashLen)],
        [8, generateRandomBytes(hashLen)],
        // [11, generateRandomBytes(hashLen)],
        // [12, generateRandomBytes(hashLen)],
        // [14, generateRandomBytes(hashLen)],
        [15, generateRandomBytes(hashLen)],
    ];
    return dataGroups;
}
function sign(privateKeyPem, dsc, hashAlgorithm, eContent) {
    const { signatureAlgorithm, publicKeyDetails } = (0, parseCertificateSimple_js_1.parseCertificateSimple)(dsc);
    if (signatureAlgorithm === 'rsapss') {
        const privateKey = node_forge_1.default.pki.privateKeyFromPem(privateKeyPem);
        const md = node_forge_1.default.md[hashAlgorithm].create();
        md.update(node_forge_1.default.util.binary.raw.encode(new Uint8Array(eContent)));
        const pss = node_forge_1.default.pss.create({
            md: node_forge_1.default.md[hashAlgorithm].create(),
            mgf: node_forge_1.default.mgf.mgf1.create(node_forge_1.default.md[hashAlgorithm].create()),
            saltLength: parseInt(publicKeyDetails.saltLength),
        });
        const signatureBytes = privateKey.sign(md, pss);
        return Array.from(signatureBytes, (c) => c.charCodeAt(0));
    }
    else if (signatureAlgorithm === 'ecdsa') {
        const curve = publicKeyDetails.curve;
        let curveForElliptic = (0, curves_js_1.getCurveForElliptic)(curve);
        const ec = new elliptic_1.default.ec(curveForElliptic);
        const privateKeyDer = Buffer.from(privateKeyPem.replace(/-----BEGIN EC PRIVATE KEY-----|\n|-----END EC PRIVATE KEY-----/g, ''), 'base64');
        const asn1Data = asn1.fromBER(privateKeyDer);
        const privateKeyBuffer = asn1Data.result.valueBlock.value[1].valueBlock.valueHexView;
        const keyPair = ec.keyFromPrivate(privateKeyBuffer);
        const msgHash = (0, hash_js_1.hash)(hashAlgorithm, eContent, 'hex');
        const signature = keyPair.sign(msgHash, 'hex');
        // @ts-ignore-error toDer gives number[] what is fine for Buffer.from
        const signatureBytes = Array.from(Buffer.from(signature.toDER(), 'hex'));
        return signatureBytes;
    }
    else {
        const privKey = node_forge_1.default.pki.privateKeyFromPem(privateKeyPem);
        const md = node_forge_1.default.md[hashAlgorithm].create();
        md.update(node_forge_1.default.util.binary.raw.encode(new Uint8Array(eContent)));
        const forgeSignature = privKey.sign(md);
        return Array.from(forgeSignature, (c) => c.charCodeAt(0));
    }
}
